
obj/net/ns:     file format elf32-i386


Disassembly of section .text:

00800020 <_start>:
// starts us running when we are initially loaded into a new environment.
.text
.globl _start
_start:
	// See if we were started with arguments on the stack
	cmpl $USTACKTOP, %esp
  800020:	81 fc 00 e0 bf ee    	cmp    $0xeebfe000,%esp
	jne args_exist
  800026:	75 04                	jne    80002c <args_exist>

	// If not, push dummy argc/argv arguments.
	// This happens when we are loaded by the kernel,
	// because the kernel does not know about passing arguments.
	pushl $0
  800028:	6a 00                	push   $0x0
	pushl $0
  80002a:	6a 00                	push   $0x0

0080002c <args_exist>:

args_exist:
	call libmain
  80002c:	e8 e8 ef 00 00       	call   80f019 <libmain>
1:	jmp 1b
  800031:	eb fe                	jmp    800031 <args_exist+0x5>
  800033:	66 90                	xchg   %ax,%ax
  800035:	66 90                	xchg   %ax,%ax
  800037:	66 90                	xchg   %ax,%ax
  800039:	66 90                	xchg   %ax,%ax
  80003b:	66 90                	xchg   %ax,%ax
  80003d:	66 90                	xchg   %ax,%ax
  80003f:	90                   	nop

00800040 <tcpip_init_done>:
		panic("cannot create timer thread: %s", e2s(r));
}

static void
tcpip_init_done(void *arg)
{
  800040:	55                   	push   %ebp
  800041:	89 e5                	mov    %esp,%ebp
  800043:	83 ec 18             	sub    $0x18,%esp
  800046:	8b 45 08             	mov    0x8(%ebp),%eax
	uint32_t *done = arg;
	*done = 1;
  800049:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
	thread_wakeup(done);
  80004f:	89 04 24             	mov    %eax,(%esp)
  800052:	e8 58 ae 00 00       	call   80aeaf <thread_wakeup>
}
  800057:	c9                   	leave  
  800058:	c3                   	ret    

00800059 <start_timer>:
	}
}

static void
start_timer(struct timer_thread *t, void (*func)(void), const char *name, int msec)
{
  800059:	55                   	push   %ebp
  80005a:	89 e5                	mov    %esp,%ebp
  80005c:	53                   	push   %ebx
  80005d:	83 ec 14             	sub    $0x14,%esp
	t->msec = msec;
  800060:	8b 5d 08             	mov    0x8(%ebp),%ebx
  800063:	89 18                	mov    %ebx,(%eax)
	t->func = func;
  800065:	89 50 04             	mov    %edx,0x4(%eax)
	t->name = name;
  800068:	89 48 08             	mov    %ecx,0x8(%eax)
	int r = thread_create(0, name, &net_timer, (uint32_t)t);
  80006b:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80006f:	c7 44 24 08 b9 00 80 	movl   $0x8000b9,0x8(%esp)
  800076:	00 
  800077:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  80007b:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  800082:	e8 96 ae 00 00       	call   80af1d <thread_create>
	if (r < 0)
  800087:	85 c0                	test   %eax,%eax
  800089:	79 28                	jns    8000b3 <start_timer+0x5a>
		panic("cannot create timer thread: %s", e2s(r));
  80008b:	89 04 24             	mov    %eax,(%esp)
  80008e:	e8 ed b1 00 00       	call   80b280 <e2s>
  800093:	89 44 24 0c          	mov    %eax,0xc(%esp)
  800097:	c7 44 24 08 c0 1b 81 	movl   $0x811bc0,0x8(%esp)
  80009e:	00 
  80009f:	c7 44 24 04 7a 00 00 	movl   $0x7a,0x4(%esp)
  8000a6:	00 
  8000a7:	c7 04 24 f5 1c 81 00 	movl   $0x811cf5,(%esp)
  8000ae:	e8 c7 ef 00 00       	call   80f07a <_panic>
}
  8000b3:	83 c4 14             	add    $0x14,%esp
  8000b6:	5b                   	pop    %ebx
  8000b7:	5d                   	pop    %ebp
  8000b8:	c3                   	ret    

008000b9 <net_timer>:
	netif_set_up(nif);
}

static void __attribute__((noreturn))
net_timer(uint32_t arg)
{
  8000b9:	55                   	push   %ebp
  8000ba:	89 e5                	mov    %esp,%ebp
  8000bc:	56                   	push   %esi
  8000bd:	53                   	push   %ebx
  8000be:	83 ec 10             	sub    $0x10,%esp
	struct timer_thread *t = (struct timer_thread *) arg;
  8000c1:	8b 5d 08             	mov    0x8(%ebp),%ebx

	for (;;) {
		uint32_t cur = sys_time_msec();
  8000c4:	e8 52 fd 00 00       	call   80fe1b <sys_time_msec>
  8000c9:	89 c6                	mov    %eax,%esi

		lwip_core_lock();
  8000cb:	e8 97 ad 00 00       	call   80ae67 <lwip_core_lock>
		t->func();
  8000d0:	ff 53 04             	call   *0x4(%ebx)
		lwip_core_unlock();
  8000d3:	e8 94 ad 00 00       	call   80ae6c <lwip_core_unlock>

		thread_wait(0, 0, cur + t->msec);
  8000d8:	03 33                	add    (%ebx),%esi
  8000da:	89 74 24 08          	mov    %esi,0x8(%esp)
  8000de:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8000e5:	00 
  8000e6:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8000ed:	e8 f7 af 00 00       	call   80b0e9 <thread_wait>
  8000f2:	eb d0                	jmp    8000c4 <net_timer+0xb>

008000f4 <serve_thread>:
	uint32_t whom;
	union Nsipc *req;
};

static void
serve_thread(uint32_t a) {
  8000f4:	55                   	push   %ebp
  8000f5:	89 e5                	mov    %esp,%ebp
  8000f7:	57                   	push   %edi
  8000f8:	56                   	push   %esi
  8000f9:	53                   	push   %ebx
  8000fa:	81 ec 8c 00 00 00    	sub    $0x8c,%esp
  800100:	8b 5d 08             	mov    0x8(%ebp),%ebx
	struct st_args *args = (struct st_args *)a;
	union Nsipc *req = args->req;
  800103:	8b 73 08             	mov    0x8(%ebx),%esi
	int r;

	switch (args->reqno) {
  800106:	83 3b 0a             	cmpl   $0xa,(%ebx)
  800109:	0f 87 3a 01 00 00    	ja     800249 <serve_thread+0x155>
  80010f:	8b 03                	mov    (%ebx),%eax
  800111:	ff 24 85 a0 1d 81 00 	jmp    *0x811da0(,%eax,4)
	case NSREQ_ACCEPT:
	{
		struct Nsret_accept ret;
		ret.ret_addrlen = req->accept.req_addrlen;
  800118:	8b 46 04             	mov    0x4(%esi),%eax
  80011b:	89 45 94             	mov    %eax,-0x6c(%ebp)
		r = lwip_accept(req->accept.req_s, &ret.ret_addr,
  80011e:	8d 45 94             	lea    -0x6c(%ebp),%eax
  800121:	89 44 24 08          	mov    %eax,0x8(%esp)
  800125:	8d 45 84             	lea    -0x7c(%ebp),%eax
  800128:	89 44 24 04          	mov    %eax,0x4(%esp)
  80012c:	8b 06                	mov    (%esi),%eax
  80012e:	89 04 24             	mov    %eax,(%esp)
  800131:	e8 2c 0f 00 00       	call   801062 <lwip_accept>
  800136:	89 c7                	mov    %eax,%edi
				&ret.ret_addrlen);
		memmove(req, &ret, sizeof ret);
  800138:	c7 44 24 08 14 00 00 	movl   $0x14,0x8(%esp)
  80013f:	00 
  800140:	8d 45 84             	lea    -0x7c(%ebp),%eax
  800143:	89 44 24 04          	mov    %eax,0x4(%esp)
  800147:	89 34 24             	mov    %esi,(%esp)
  80014a:	e8 e5 f7 00 00       	call   80f934 <memmove>
  80014f:	e9 13 01 00 00       	jmp    800267 <serve_thread+0x173>
		break;
	}
	case NSREQ_BIND:
		r = lwip_bind(req->bind.req_s, &req->bind.req_name,
  800154:	8b 46 14             	mov    0x14(%esi),%eax
  800157:	89 44 24 08          	mov    %eax,0x8(%esp)
  80015b:	8d 46 04             	lea    0x4(%esi),%eax
  80015e:	89 44 24 04          	mov    %eax,0x4(%esp)
  800162:	8b 06                	mov    (%esi),%eax
  800164:	89 04 24             	mov    %eax,(%esp)
  800167:	e8 bc 10 00 00       	call   801228 <lwip_bind>
  80016c:	89 c7                	mov    %eax,%edi
			      req->bind.req_namelen);
		break;
  80016e:	e9 f4 00 00 00       	jmp    800267 <serve_thread+0x173>
	case NSREQ_SHUTDOWN:
		r = lwip_shutdown(req->shutdown.req_s, req->shutdown.req_how);
  800173:	8b 46 04             	mov    0x4(%esi),%eax
  800176:	89 44 24 04          	mov    %eax,0x4(%esp)
  80017a:	8b 06                	mov    (%esi),%eax
  80017c:	89 04 24             	mov    %eax,(%esp)
  80017f:	e8 9c 1c 00 00       	call   801e20 <lwip_shutdown>
  800184:	89 c7                	mov    %eax,%edi
		break;
  800186:	e9 dc 00 00 00       	jmp    800267 <serve_thread+0x173>
	case NSREQ_CLOSE:
		r = lwip_close(req->close.req_s);
  80018b:	8b 06                	mov    (%esi),%eax
  80018d:	89 04 24             	mov    %eax,(%esp)
  800190:	e8 50 11 00 00       	call   8012e5 <lwip_close>
  800195:	89 c7                	mov    %eax,%edi
		break;
  800197:	e9 cb 00 00 00       	jmp    800267 <serve_thread+0x173>
	case NSREQ_CONNECT:
		r = lwip_connect(req->connect.req_s, &req->connect.req_name,
  80019c:	8b 46 14             	mov    0x14(%esi),%eax
  80019f:	89 44 24 08          	mov    %eax,0x8(%esp)
  8001a3:	8d 46 04             	lea    0x4(%esi),%eax
  8001a6:	89 44 24 04          	mov    %eax,0x4(%esp)
  8001aa:	8b 06                	mov    (%esi),%eax
  8001ac:	89 04 24             	mov    %eax,(%esp)
  8001af:	e8 af 11 00 00       	call   801363 <lwip_connect>
  8001b4:	89 c7                	mov    %eax,%edi
				 req->connect.req_namelen);
		break;
  8001b6:	e9 ac 00 00 00       	jmp    800267 <serve_thread+0x173>
	case NSREQ_LISTEN:
		r = lwip_listen(req->listen.req_s, req->listen.req_backlog);
  8001bb:	8b 46 04             	mov    0x4(%esi),%eax
  8001be:	89 44 24 04          	mov    %eax,0x4(%esp)
  8001c2:	8b 06                	mov    (%esi),%eax
  8001c4:	89 04 24             	mov    %eax,(%esp)
  8001c7:	e8 54 12 00 00       	call   801420 <lwip_listen>
  8001cc:	89 c7                	mov    %eax,%edi
		break;
  8001ce:	e9 94 00 00 00       	jmp    800267 <serve_thread+0x173>
	case NSREQ_RECV:
		// Note that we read the request fields before we
		// overwrite it with the response data.
		r = lwip_recv(req->recv.req_s, req->recvRet.ret_buf,
  8001d3:	8b 46 08             	mov    0x8(%esi),%eax
  8001d6:	89 44 24 0c          	mov    %eax,0xc(%esp)
  8001da:	8b 46 04             	mov    0x4(%esi),%eax
  8001dd:	89 44 24 08          	mov    %eax,0x8(%esp)
  8001e1:	89 74 24 04          	mov    %esi,0x4(%esp)
  8001e5:	8b 06                	mov    (%esi),%eax
  8001e7:	89 04 24             	mov    %eax,(%esp)
  8001ea:	e8 36 15 00 00       	call   801725 <lwip_recv>
  8001ef:	89 c7                	mov    %eax,%edi
			      req->recv.req_len, req->recv.req_flags);
		break;
  8001f1:	eb 74                	jmp    800267 <serve_thread+0x173>
	case NSREQ_SEND:
		r = lwip_send(req->send.req_s, &req->send.req_buf,
  8001f3:	8b 46 08             	mov    0x8(%esi),%eax
  8001f6:	89 44 24 0c          	mov    %eax,0xc(%esp)
  8001fa:	8b 46 04             	mov    0x4(%esi),%eax
  8001fd:	89 44 24 08          	mov    %eax,0x8(%esp)
  800201:	8d 46 0c             	lea    0xc(%esi),%eax
  800204:	89 44 24 04          	mov    %eax,0x4(%esp)
  800208:	8b 06                	mov    (%esi),%eax
  80020a:	89 04 24             	mov    %eax,(%esp)
  80020d:	e8 ab 16 00 00       	call   8018bd <lwip_send>
  800212:	89 c7                	mov    %eax,%edi
			      req->send.req_size, req->send.req_flags);
		break;
  800214:	eb 51                	jmp    800267 <serve_thread+0x173>
	case NSREQ_SOCKET:
		r = lwip_socket(req->socket.req_domain, req->socket.req_type,
  800216:	8b 46 08             	mov    0x8(%esi),%eax
  800219:	89 44 24 08          	mov    %eax,0x8(%esp)
  80021d:	8b 46 04             	mov    0x4(%esi),%eax
  800220:	89 44 24 04          	mov    %eax,0x4(%esp)
  800224:	8b 06                	mov    (%esi),%eax
  800226:	89 04 24             	mov    %eax,(%esp)
  800229:	e8 42 17 00 00       	call   801970 <lwip_socket>
  80022e:	89 c7                	mov    %eax,%edi
				req->socket.req_protocol);
		break;
  800230:	eb 35                	jmp    800267 <serve_thread+0x173>
	case NSREQ_INPUT:
		jif_input(&nif, (void *)&req->pkt);
  800232:	89 74 24 04          	mov    %esi,0x4(%esp)
  800236:	c7 04 24 20 c2 b3 00 	movl   $0xb3c220,(%esp)
  80023d:	e8 74 b1 00 00       	call   80b3b6 <jif_input>
		r = 0;
  800242:	bf 00 00 00 00       	mov    $0x0,%edi
		break;
  800247:	eb 4c                	jmp    800295 <serve_thread+0x1a1>
	default:
		cprintf("Invalid request code %d from %08x\n", args->whom, args->req);
  800249:	89 74 24 08          	mov    %esi,0x8(%esp)
  80024d:	8b 43 04             	mov    0x4(%ebx),%eax
  800250:	89 44 24 04          	mov    %eax,0x4(%esp)
  800254:	c7 04 24 e0 1b 81 00 	movl   $0x811be0,(%esp)
  80025b:	e8 13 ef 00 00       	call   80f173 <cprintf>
		r = -E_INVAL;
  800260:	bf fd ff ff ff       	mov    $0xfffffffd,%edi
		break;
  800265:	eb 2e                	jmp    800295 <serve_thread+0x1a1>
	}

	if (r == -1) {
  800267:	83 ff ff             	cmp    $0xffffffff,%edi
  80026a:	75 29                	jne    800295 <serve_thread+0x1a1>
		char buf[100];
		snprintf(buf, sizeof buf, "ns req type %d", args->reqno);
  80026c:	8b 03                	mov    (%ebx),%eax
  80026e:	89 44 24 0c          	mov    %eax,0xc(%esp)
  800272:	c7 44 24 08 00 1d 81 	movl   $0x811d00,0x8(%esp)
  800279:	00 
  80027a:	c7 44 24 04 64 00 00 	movl   $0x64,0x4(%esp)
  800281:	00 
  800282:	8d 75 84             	lea    -0x7c(%ebp),%esi
  800285:	89 34 24             	mov    %esi,(%esp)
  800288:	e8 9d f4 00 00       	call   80f72a <snprintf>
		perror(buf);
  80028d:	89 34 24             	mov    %esi,(%esp)
  800290:	e8 c0 af 00 00       	call   80b255 <perror>
	}

	if (args->reqno != NSREQ_INPUT)
  800295:	83 3b 0a             	cmpl   $0xa,(%ebx)
  800298:	74 1f                	je     8002b9 <serve_thread+0x1c5>
		ipc_send(args->whom, r, 0, 0);
  80029a:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  8002a1:	00 
  8002a2:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8002a9:	00 
  8002aa:	89 7c 24 04          	mov    %edi,0x4(%esp)
  8002ae:	8b 43 04             	mov    0x4(%ebx),%eax
  8002b1:	89 04 24             	mov    %eax,(%esp)
  8002b4:	e8 b1 ff 00 00       	call   81026a <ipc_send>

	put_buffer(args->req);
  8002b9:	8b 43 08             	mov    0x8(%ebx),%eax
	return va;
}

static void
put_buffer(void *va) {
	int i = ((uint32_t)va - REQVA) / PGSIZE;
  8002bc:	8d 90 00 50 01 f0    	lea    -0xffeb000(%eax),%edx
  8002c2:	c1 ea 0c             	shr    $0xc,%edx
	buse[i] = 0;
  8002c5:	c6 82 00 60 81 00 00 	movb   $0x0,0x816000(%edx)

	if (args->reqno != NSREQ_INPUT)
		ipc_send(args->whom, r, 0, 0);

	put_buffer(args->req);
	sys_page_unmap(0, (void*) args->req);
  8002cc:	89 44 24 04          	mov    %eax,0x4(%esp)
  8002d0:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8002d7:	e8 7e f9 00 00       	call   80fc5a <sys_page_unmap>
	free(args);
  8002dc:	89 1c 24             	mov    %ebx,(%esp)
  8002df:	e8 bc 0d 01 00       	call   8110a0 <free>
}
  8002e4:	81 c4 8c 00 00 00    	add    $0x8c,%esp
  8002ea:	5b                   	pop    %ebx
  8002eb:	5e                   	pop    %esi
  8002ec:	5f                   	pop    %edi
  8002ed:	5d                   	pop    %ebp
  8002ee:	c3                   	ret    

008002ef <serve_init>:
	thread_wakeup(done);
}

void
serve_init(uint32_t ipaddr, uint32_t netmask, uint32_t gw)
{
  8002ef:	55                   	push   %ebp
  8002f0:	89 e5                	mov    %esp,%ebp
  8002f2:	56                   	push   %esi
  8002f3:	53                   	push   %ebx
  8002f4:	83 ec 30             	sub    $0x30,%esp
  8002f7:	8b 75 08             	mov    0x8(%ebp),%esi
	int r;
	lwip_core_lock();
  8002fa:	e8 68 ab 00 00       	call   80ae67 <lwip_core_lock>

	uint32_t done = 0;
  8002ff:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	tcpip_init(&tcpip_init_done, &done);
  800306:	8d 5d f4             	lea    -0xc(%ebp),%ebx
  800309:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80030d:	c7 04 24 40 00 80 00 	movl   $0x800040,(%esp)
  800314:	e8 67 24 00 00       	call   802780 <tcpip_init>
	lwip_core_unlock();
  800319:	e8 4e ab 00 00       	call   80ae6c <lwip_core_unlock>
	thread_wait(&done, 0, (uint32_t)~0);
  80031e:	c7 44 24 08 ff ff ff 	movl   $0xffffffff,0x8(%esp)
  800325:	ff 
  800326:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80032d:	00 
  80032e:	89 1c 24             	mov    %ebx,(%esp)
  800331:	e8 b3 ad 00 00       	call   80b0e9 <thread_wait>
	lwip_core_lock();
  800336:	e8 2c ab 00 00       	call   80ae67 <lwip_core_lock>
static void
lwip_init(struct netif *nif, void *if_state,
	  uint32_t init_addr, uint32_t init_mask, uint32_t init_gw)
{
	struct ip_addr ipaddr, netmask, gateway;
	ipaddr.addr  = init_addr;
  80033b:	89 75 e8             	mov    %esi,-0x18(%ebp)
	netmask.addr = init_mask;
  80033e:	8b 45 0c             	mov    0xc(%ebp),%eax
  800341:	89 45 ec             	mov    %eax,-0x14(%ebp)
	gateway.addr = init_gw;
  800344:	8b 45 10             	mov    0x10(%ebp),%eax
  800347:	89 45 f0             	mov    %eax,-0x10(%ebp)

	if (0 == netif_add(nif, &ipaddr, &netmask, &gateway,
  80034a:	c7 44 24 18 40 6b 80 	movl   $0x806b40,0x18(%esp)
  800351:	00 
  800352:	c7 44 24 14 be b4 80 	movl   $0x80b4be,0x14(%esp)
  800359:	00 
  80035a:	c7 44 24 10 14 60 81 	movl   $0x816014,0x10(%esp)
  800361:	00 
  800362:	8d 45 f0             	lea    -0x10(%ebp),%eax
  800365:	89 44 24 0c          	mov    %eax,0xc(%esp)
  800369:	8d 45 ec             	lea    -0x14(%ebp),%eax
  80036c:	89 44 24 08          	mov    %eax,0x8(%esp)
  800370:	8d 45 e8             	lea    -0x18(%ebp),%eax
  800373:	89 44 24 04          	mov    %eax,0x4(%esp)
  800377:	c7 04 24 20 c2 b3 00 	movl   $0xb3c220,(%esp)
  80037e:	e8 5e 48 00 00       	call   804be1 <netif_add>
  800383:	85 c0                	test   %eax,%eax
  800385:	75 1c                	jne    8003a3 <serve_init+0xb4>
			   if_state,
			   jif_init,
			   ip_input))
		panic("lwip_init: error in netif_add\n");
  800387:	c7 44 24 08 04 1c 81 	movl   $0x811c04,0x8(%esp)
  80038e:	00 
  80038f:	c7 44 24 04 5c 00 00 	movl   $0x5c,0x4(%esp)
  800396:	00 
  800397:	c7 04 24 f5 1c 81 00 	movl   $0x811cf5,(%esp)
  80039e:	e8 d7 ec 00 00       	call   80f07a <_panic>

	netif_set_default(nif);
  8003a3:	c7 04 24 20 c2 b3 00 	movl   $0xb3c220,(%esp)
  8003aa:	e8 f4 48 00 00       	call   804ca3 <netif_set_default>
	netif_set_up(nif);
  8003af:	c7 04 24 20 c2 b3 00 	movl   $0xb3c220,(%esp)
  8003b6:	e8 f5 48 00 00       	call   804cb0 <netif_set_up>
	thread_wait(&done, 0, (uint32_t)~0);
	lwip_core_lock();

	lwip_init(&nif, &output_envid, ipaddr, netmask, gw);

	start_timer(&t_arp, &etharp_tmr, "arp timer", ARP_TMR_INTERVAL);
  8003bb:	c7 04 24 88 13 00 00 	movl   $0x1388,(%esp)
  8003c2:	b9 0f 1d 81 00       	mov    $0x811d0f,%ecx
  8003c7:	ba e0 9c 80 00       	mov    $0x809ce0,%edx
  8003cc:	b8 38 60 81 00       	mov    $0x816038,%eax
  8003d1:	e8 83 fc ff ff       	call   800059 <start_timer>
	start_timer(&t_tcpf, &tcp_fasttmr, "tcp f timer", TCP_FAST_INTERVAL);
  8003d6:	c7 04 24 fa 00 00 00 	movl   $0xfa,(%esp)
  8003dd:	b9 19 1d 81 00       	mov    $0x811d19,%ecx
  8003e2:	ba 4f 5d 80 00       	mov    $0x805d4f,%edx
  8003e7:	b8 2c 60 81 00       	mov    $0x81602c,%eax
  8003ec:	e8 68 fc ff ff       	call   800059 <start_timer>
	start_timer(&t_tcps, &tcp_slowtmr, "tcp s timer", TCP_SLOW_INTERVAL);
  8003f1:	c7 04 24 f4 01 00 00 	movl   $0x1f4,(%esp)
  8003f8:	b9 25 1d 81 00       	mov    $0x811d25,%ecx
  8003fd:	ba ed 62 80 00       	mov    $0x8062ed,%edx
  800402:	b8 20 60 81 00       	mov    $0x816020,%eax
  800407:	e8 4d fc ff ff       	call   800059 <start_timer>

	struct in_addr ia = {ipaddr};
	cprintf("ns: %02x:%02x:%02x:%02x:%02x:%02x"
  80040c:	89 34 24             	mov    %esi,(%esp)
  80040f:	e8 ac 78 00 00       	call   807cc0 <inet_ntoa>
  800414:	89 44 24 1c          	mov    %eax,0x1c(%esp)
  800418:	0f b6 05 4a c2 b3 00 	movzbl 0xb3c24a,%eax
  80041f:	89 44 24 18          	mov    %eax,0x18(%esp)
  800423:	0f b6 05 49 c2 b3 00 	movzbl 0xb3c249,%eax
  80042a:	89 44 24 14          	mov    %eax,0x14(%esp)
  80042e:	0f b6 05 48 c2 b3 00 	movzbl 0xb3c248,%eax
  800435:	89 44 24 10          	mov    %eax,0x10(%esp)
  800439:	0f b6 05 47 c2 b3 00 	movzbl 0xb3c247,%eax
  800440:	89 44 24 0c          	mov    %eax,0xc(%esp)
  800444:	0f b6 05 46 c2 b3 00 	movzbl 0xb3c246,%eax
  80044b:	89 44 24 08          	mov    %eax,0x8(%esp)
  80044f:	0f b6 05 45 c2 b3 00 	movzbl 0xb3c245,%eax
  800456:	89 44 24 04          	mov    %eax,0x4(%esp)
  80045a:	c7 04 24 24 1c 81 00 	movl   $0x811c24,(%esp)
  800461:	e8 0d ed 00 00       	call   80f173 <cprintf>
		" bound to static IP %s\n",
		nif.hwaddr[0], nif.hwaddr[1], nif.hwaddr[2],
		nif.hwaddr[3], nif.hwaddr[4], nif.hwaddr[5],
		inet_ntoa(ia));

	lwip_core_unlock();
  800466:	e8 01 aa 00 00       	call   80ae6c <lwip_core_unlock>

	cprintf("NS: TCP/IP initialized.\n");
  80046b:	c7 04 24 31 1d 81 00 	movl   $0x811d31,(%esp)
  800472:	e8 fc ec 00 00       	call   80f173 <cprintf>
}
  800477:	83 c4 30             	add    $0x30,%esp
  80047a:	5b                   	pop    %ebx
  80047b:	5e                   	pop    %esi
  80047c:	5d                   	pop    %ebp
  80047d:	c3                   	ret    

0080047e <serve>:
	sys_page_unmap(0, (void*) args->req);
	free(args);
}

void
serve(void) {
  80047e:	55                   	push   %ebp
  80047f:	89 e5                	mov    %esp,%ebp
  800481:	57                   	push   %edi
  800482:	56                   	push   %esi
  800483:	53                   	push   %ebx
  800484:	83 ec 3c             	sub    $0x3c,%esp

	while (1) {
		// ipc_recv will block the entire process, so we flush
		// all pending work from other threads.  We limit the
		// number of yields in case there's a rogue thread.
		for (i = 0; thread_wakeups_pending() && i < 32; ++i)
  800487:	bb 00 00 00 00       	mov    $0x0,%ebx
			thread_yield();

		perm = 0;
		va = get_buffer();
		reqno = ipc_recv((int32_t *) &whom, (void *) va, &perm);
  80048c:	8d 7d e0             	lea    -0x20(%ebp),%edi
  80048f:	eb 08                	jmp    800499 <serve+0x1b>
	while (1) {
		// ipc_recv will block the entire process, so we flush
		// all pending work from other threads.  We limit the
		// number of yields in case there's a rogue thread.
		for (i = 0; thread_wakeups_pending() && i < 32; ++i)
			thread_yield();
  800491:	e8 d3 ab 00 00       	call   80b069 <thread_yield>

	while (1) {
		// ipc_recv will block the entire process, so we flush
		// all pending work from other threads.  We limit the
		// number of yields in case there's a rogue thread.
		for (i = 0; thread_wakeups_pending() && i < 32; ++i)
  800496:	83 c3 01             	add    $0x1,%ebx
  800499:	e8 30 aa 00 00       	call   80aece <thread_wakeups_pending>
  80049e:	85 c0                	test   %eax,%eax
  8004a0:	74 05                	je     8004a7 <serve+0x29>
  8004a2:	83 fb 1f             	cmp    $0x1f,%ebx
  8004a5:	7e ea                	jle    800491 <serve+0x13>
			thread_yield();

		perm = 0;
  8004a7:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
static void *
get_buffer(void) {
	void *va;

	int i;
	for (i = 0; i < QUEUE_SIZE; i++)
  8004ae:	b8 00 00 00 00       	mov    $0x0,%eax
		if (!buse[i]) break;
  8004b3:	80 b8 00 60 81 00 00 	cmpb   $0x0,0x816000(%eax)
  8004ba:	74 0a                	je     8004c6 <serve+0x48>
static void *
get_buffer(void) {
	void *va;

	int i;
	for (i = 0; i < QUEUE_SIZE; i++)
  8004bc:	83 c0 01             	add    $0x1,%eax
  8004bf:	83 f8 14             	cmp    $0x14,%eax
  8004c2:	75 ef                	jne    8004b3 <serve+0x35>
  8004c4:	eb 05                	jmp    8004cb <serve+0x4d>
		if (!buse[i]) break;

	if (i == QUEUE_SIZE) {
  8004c6:	83 f8 14             	cmp    $0x14,%eax
  8004c9:	75 1c                	jne    8004e7 <serve+0x69>
		panic("NS: buffer overflow");
  8004cb:	c7 44 24 08 4a 1d 81 	movl   $0x811d4a,0x8(%esp)
  8004d2:	00 
  8004d3:	c7 44 24 04 3f 00 00 	movl   $0x3f,0x4(%esp)
  8004da:	00 
  8004db:	c7 04 24 f5 1c 81 00 	movl   $0x811cf5,(%esp)
  8004e2:	e8 93 eb 00 00       	call   80f07a <_panic>
		return 0;
	}

	va = (void *)(REQVA + i * PGSIZE);
  8004e7:	8d 98 eb ff 00 00    	lea    0xffeb(%eax),%ebx
  8004ed:	c1 e3 0c             	shl    $0xc,%ebx
	buse[i] = 1;
  8004f0:	c6 80 00 60 81 00 01 	movb   $0x1,0x816000(%eax)
		for (i = 0; thread_wakeups_pending() && i < 32; ++i)
			thread_yield();

		perm = 0;
		va = get_buffer();
		reqno = ipc_recv((int32_t *) &whom, (void *) va, &perm);
  8004f7:	89 7c 24 08          	mov    %edi,0x8(%esp)
  8004fb:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8004ff:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  800502:	89 04 24             	mov    %eax,(%esp)
  800505:	e8 e6 fc 00 00       	call   8101f0 <ipc_recv>
  80050a:	89 c6                	mov    %eax,%esi
		if (debug) {
			cprintf("ns req %d from %08x\n", reqno, whom);
		}

		// first take care of requests that do not contain an argument page
		if (reqno == NSREQ_TIMER) {
  80050c:	83 f8 0c             	cmp    $0xc,%eax
  80050f:	75 70                	jne    800581 <serve+0x103>
			process_timer(whom);
  800511:	8b 75 e4             	mov    -0x1c(%ebp),%esi

static void
process_timer(envid_t envid) {
	uint32_t start, now, to;

	if (envid != timer_envid) {
  800514:	3b 35 1c 60 81 00    	cmp    0x81601c,%esi
  80051a:	74 12                	je     80052e <serve+0xb0>
		cprintf("NS: received timer interrupt from envid %x not timer env\n", envid);
  80051c:	89 74 24 04          	mov    %esi,0x4(%esp)
  800520:	c7 04 24 60 1c 81 00 	movl   $0x811c60,(%esp)
  800527:	e8 47 ec 00 00       	call   80f173 <cprintf>
  80052c:	eb 39                	jmp    800567 <serve+0xe9>
		return;
	}

	start = sys_time_msec();
  80052e:	e8 e8 f8 00 00       	call   80fe1b <sys_time_msec>
  800533:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	thread_yield();
  800536:	e8 2e ab 00 00       	call   80b069 <thread_yield>
	now = sys_time_msec();
  80053b:	e8 db f8 00 00       	call   80fe1b <sys_time_msec>

	to = TIMER_INTERVAL - (now - start);
	ipc_send(envid, to, 0, 0);
  800540:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  800547:	00 
  800548:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80054f:	00 

	start = sys_time_msec();
	thread_yield();
	now = sys_time_msec();

	to = TIMER_INTERVAL - (now - start);
  800550:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  800553:	81 c2 fa 00 00 00    	add    $0xfa,%edx
  800559:	29 c2                	sub    %eax,%edx
	ipc_send(envid, to, 0, 0);
  80055b:	89 54 24 04          	mov    %edx,0x4(%esp)
  80055f:	89 34 24             	mov    %esi,(%esp)
  800562:	e8 03 fd 00 00       	call   81026a <ipc_send>
	return va;
}

static void
put_buffer(void *va) {
	int i = ((uint32_t)va - REQVA) / PGSIZE;
  800567:	81 eb 00 b0 fe 0f    	sub    $0xffeb000,%ebx
  80056d:	c1 eb 0c             	shr    $0xc,%ebx
	buse[i] = 0;
  800570:	c6 83 00 60 81 00 00 	movb   $0x0,0x816000(%ebx)

	while (1) {
		// ipc_recv will block the entire process, so we flush
		// all pending work from other threads.  We limit the
		// number of yields in case there's a rogue thread.
		for (i = 0; thread_wakeups_pending() && i < 32; ++i)
  800577:	bb 00 00 00 00       	mov    $0x0,%ebx

		// first take care of requests that do not contain an argument page
		if (reqno == NSREQ_TIMER) {
			process_timer(whom);
			put_buffer(va);
			continue;
  80057c:	e9 18 ff ff ff       	jmp    800499 <serve+0x1b>
		}

		// All remaining requests must contain an argument page
		if (!(perm & PTE_P)) {
  800581:	f6 45 e0 01          	testb  $0x1,-0x20(%ebp)
  800585:	75 1d                	jne    8005a4 <serve+0x126>
			cprintf("Invalid request from %08x: no argument page\n", whom);
  800587:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80058a:	89 44 24 04          	mov    %eax,0x4(%esp)
  80058e:	c7 04 24 9c 1c 81 00 	movl   $0x811c9c,(%esp)
  800595:	e8 d9 eb 00 00       	call   80f173 <cprintf>

	while (1) {
		// ipc_recv will block the entire process, so we flush
		// all pending work from other threads.  We limit the
		// number of yields in case there's a rogue thread.
		for (i = 0; thread_wakeups_pending() && i < 32; ++i)
  80059a:	bb 00 00 00 00       	mov    $0x0,%ebx
		}

		// All remaining requests must contain an argument page
		if (!(perm & PTE_P)) {
			cprintf("Invalid request from %08x: no argument page\n", whom);
			continue; // just leave it hanging...
  80059f:	e9 f5 fe ff ff       	jmp    800499 <serve+0x1b>
		}

		// Since some lwIP socket calls will block, create a thread and
		// process the rest of the request in the thread.
		struct st_args *args = malloc(sizeof(struct st_args));
  8005a4:	c7 04 24 0c 00 00 00 	movl   $0xc,(%esp)
  8005ab:	e8 c2 0b 01 00       	call   811172 <malloc>
		if (!args)
  8005b0:	85 c0                	test   %eax,%eax
  8005b2:	75 1c                	jne    8005d0 <serve+0x152>
			panic("could not allocate thread args structure");
  8005b4:	c7 44 24 08 cc 1c 81 	movl   $0x811ccc,0x8(%esp)
  8005bb:	00 
  8005bc:	c7 44 24 04 27 01 00 	movl   $0x127,0x4(%esp)
  8005c3:	00 
  8005c4:	c7 04 24 f5 1c 81 00 	movl   $0x811cf5,(%esp)
  8005cb:	e8 aa ea 00 00       	call   80f07a <_panic>

		args->reqno = reqno;
  8005d0:	89 30                	mov    %esi,(%eax)
		args->whom = whom;
  8005d2:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  8005d5:	89 50 04             	mov    %edx,0x4(%eax)
		args->req = va;
  8005d8:	89 58 08             	mov    %ebx,0x8(%eax)

		thread_create(0, "serve_thread", serve_thread, (uint32_t)args);
  8005db:	89 44 24 0c          	mov    %eax,0xc(%esp)
  8005df:	c7 44 24 08 f4 00 80 	movl   $0x8000f4,0x8(%esp)
  8005e6:	00 
  8005e7:	c7 44 24 04 5e 1d 81 	movl   $0x811d5e,0x4(%esp)
  8005ee:	00 
  8005ef:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8005f6:	e8 22 a9 00 00       	call   80af1d <thread_create>
		thread_yield(); // let the thread created run
  8005fb:	e8 69 aa 00 00       	call   80b069 <thread_yield>

	while (1) {
		// ipc_recv will block the entire process, so we flush
		// all pending work from other threads.  We limit the
		// number of yields in case there's a rogue thread.
		for (i = 0; thread_wakeups_pending() && i < 32; ++i)
  800600:	bb 00 00 00 00       	mov    $0x0,%ebx
  800605:	e9 8f fe ff ff       	jmp    800499 <serve+0x1b>

0080060a <tmain>:
		thread_yield(); // let the thread created run
	}
}

static void
tmain(uint32_t arg) {
  80060a:	55                   	push   %ebp
  80060b:	89 e5                	mov    %esp,%ebp
  80060d:	56                   	push   %esi
  80060e:	53                   	push   %ebx
  80060f:	83 ec 10             	sub    $0x10,%esp
	serve_init(inet_addr(IP),
  800612:	c7 04 24 6b 1d 81 00 	movl   $0x811d6b,(%esp)
  800619:	e8 87 79 00 00       	call   807fa5 <inet_addr>
  80061e:	89 c6                	mov    %eax,%esi
  800620:	c7 04 24 74 1d 81 00 	movl   $0x811d74,(%esp)
  800627:	e8 79 79 00 00       	call   807fa5 <inet_addr>
  80062c:	89 c3                	mov    %eax,%ebx
  80062e:	c7 04 24 82 1d 81 00 	movl   $0x811d82,(%esp)
  800635:	e8 6b 79 00 00       	call   807fa5 <inet_addr>
  80063a:	89 74 24 08          	mov    %esi,0x8(%esp)
  80063e:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  800642:	89 04 24             	mov    %eax,(%esp)
  800645:	e8 a5 fc ff ff       	call   8002ef <serve_init>
		   inet_addr(MASK),
		   inet_addr(DEFAULT));
	serve();
  80064a:	e8 2f fe ff ff       	call   80047e <serve>

0080064f <umain>:
}

void
umain(int argc, char **argv)
{
  80064f:	55                   	push   %ebp
  800650:	89 e5                	mov    %esp,%ebp
  800652:	53                   	push   %ebx
  800653:	83 ec 14             	sub    $0x14,%esp
	envid_t ns_envid = sys_getenvid();
  800656:	e8 1a f5 00 00       	call   80fb75 <sys_getenvid>
  80065b:	89 c3                	mov    %eax,%ebx

	binaryname = "ns";
  80065d:	c7 05 e8 52 81 00 e5 	movl   $0x8146e5,0x8152e8
  800664:	46 81 00 

	// fork off the timer thread which will send us periodic messages
	timer_envid = fork();
  800667:	e8 78 f9 00 00       	call   80ffe4 <fork>
  80066c:	a3 1c 60 81 00       	mov    %eax,0x81601c
	if (timer_envid < 0)
  800671:	85 c0                	test   %eax,%eax
  800673:	79 1c                	jns    800691 <umain+0x42>
		panic("error forking");
  800675:	c7 44 24 08 8c 1d 81 	movl   $0x811d8c,0x8(%esp)
  80067c:	00 
  80067d:	c7 44 24 04 44 01 00 	movl   $0x144,0x4(%esp)
  800684:	00 
  800685:	c7 04 24 f5 1c 81 00 	movl   $0x811cf5,(%esp)
  80068c:	e8 e9 e9 00 00       	call   80f07a <_panic>
	else if (timer_envid == 0) {
  800691:	85 c0                	test   %eax,%eax
  800693:	75 15                	jne    8006aa <umain+0x5b>
		timer(ns_envid, TIMER_INTERVAL);
  800695:	c7 44 24 04 fa 00 00 	movl   $0xfa,0x4(%esp)
  80069c:	00 
  80069d:	89 1c 24             	mov    %ebx,(%esp)
  8006a0:	e8 ab 00 00 00       	call   800750 <timer>
		return;
  8006a5:	e9 9e 00 00 00       	jmp    800748 <umain+0xf9>
	}

	// fork off the input thread which will poll the NIC driver for input
	// packets
	input_envid = fork();
  8006aa:	e8 35 f9 00 00       	call   80ffe4 <fork>
  8006af:	a3 18 60 81 00       	mov    %eax,0x816018
	if (input_envid < 0)
  8006b4:	85 c0                	test   %eax,%eax
  8006b6:	79 1c                	jns    8006d4 <umain+0x85>
		panic("error forking");
  8006b8:	c7 44 24 08 8c 1d 81 	movl   $0x811d8c,0x8(%esp)
  8006bf:	00 
  8006c0:	c7 44 24 04 4e 01 00 	movl   $0x14e,0x4(%esp)
  8006c7:	00 
  8006c8:	c7 04 24 f5 1c 81 00 	movl   $0x811cf5,(%esp)
  8006cf:	e8 a6 e9 00 00       	call   80f07a <_panic>
	else if (input_envid == 0) {
  8006d4:	85 c0                	test   %eax,%eax
  8006d6:	75 0a                	jne    8006e2 <umain+0x93>
		input(ns_envid);
  8006d8:	89 1c 24             	mov    %ebx,(%esp)
  8006db:	e8 40 01 00 00       	call   800820 <input>
		return;
  8006e0:	eb 66                	jmp    800748 <umain+0xf9>
	}

	// fork off the output thread that will send the packets to the NIC
	// driver
	output_envid = fork();
  8006e2:	e8 fd f8 00 00       	call   80ffe4 <fork>
  8006e7:	a3 14 60 81 00       	mov    %eax,0x816014
	if (output_envid < 0)
  8006ec:	85 c0                	test   %eax,%eax
  8006ee:	79 1c                	jns    80070c <umain+0xbd>
		panic("error forking");
  8006f0:	c7 44 24 08 8c 1d 81 	movl   $0x811d8c,0x8(%esp)
  8006f7:	00 
  8006f8:	c7 44 24 04 58 01 00 	movl   $0x158,0x4(%esp)
  8006ff:	00 
  800700:	c7 04 24 f5 1c 81 00 	movl   $0x811cf5,(%esp)
  800707:	e8 6e e9 00 00       	call   80f07a <_panic>
	else if (output_envid == 0) {
  80070c:	85 c0                	test   %eax,%eax
  80070e:	75 0a                	jne    80071a <umain+0xcb>
		output(ns_envid);
  800710:	89 1c 24             	mov    %ebx,(%esp)
  800713:	e8 a8 01 00 00       	call   8008c0 <output>
		return;
  800718:	eb 2e                	jmp    800748 <umain+0xf9>
	}

	// lwIP requires a user threading library; start the library and jump
	// into a thread to continue initialization.
	thread_init();
  80071a:	e8 61 a7 00 00       	call   80ae80 <thread_init>
	thread_create(0, "main", tmain, 0);
  80071f:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  800726:	00 
  800727:	c7 44 24 08 0a 06 80 	movl   $0x80060a,0x8(%esp)
  80072e:	00 
  80072f:	c7 44 24 04 9a 1d 81 	movl   $0x811d9a,0x4(%esp)
  800736:	00 
  800737:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80073e:	e8 da a7 00 00       	call   80af1d <thread_create>
	thread_yield();
  800743:	e8 21 a9 00 00       	call   80b069 <thread_yield>
	// never coming here!
}
  800748:	83 c4 14             	add    $0x14,%esp
  80074b:	5b                   	pop    %ebx
  80074c:	5d                   	pop    %ebp
  80074d:	c3                   	ret    
  80074e:	66 90                	xchg   %ax,%ax

00800750 <timer>:
#include "ns.h"

void
timer(envid_t ns_envid, uint32_t initial_to) {
  800750:	55                   	push   %ebp
  800751:	89 e5                	mov    %esp,%ebp
  800753:	57                   	push   %edi
  800754:	56                   	push   %esi
  800755:	53                   	push   %ebx
  800756:	83 ec 2c             	sub    $0x2c,%esp
  800759:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int r;
	uint32_t stop = sys_time_msec() + initial_to;
  80075c:	e8 ba f6 00 00       	call   80fe1b <sys_time_msec>
  800761:	03 45 0c             	add    0xc(%ebp),%eax
  800764:	89 c6                	mov    %eax,%esi

	binaryname = "ns_timer";
  800766:	c7 05 e8 52 81 00 cc 	movl   $0x811dcc,0x8152e8
  80076d:	1d 81 00 

		ipc_send(ns_envid, NSREQ_TIMER, 0, 0);

		while (1) {
			uint32_t to, whom;
			to = ipc_recv((int32_t *) &whom, 0, 0);
  800770:	8d 7d e4             	lea    -0x1c(%ebp),%edi
  800773:	eb 05                	jmp    80077a <timer+0x2a>

	binaryname = "ns_timer";

	while (1) {
		while((r = sys_time_msec()) < stop && r >= 0) {
			sys_yield();
  800775:	e8 1a f4 00 00       	call   80fb94 <sys_yield>
	uint32_t stop = sys_time_msec() + initial_to;

	binaryname = "ns_timer";

	while (1) {
		while((r = sys_time_msec()) < stop && r >= 0) {
  80077a:	e8 9c f6 00 00       	call   80fe1b <sys_time_msec>
  80077f:	39 c6                	cmp    %eax,%esi
  800781:	76 06                	jbe    800789 <timer+0x39>
  800783:	85 c0                	test   %eax,%eax
  800785:	79 ee                	jns    800775 <timer+0x25>
  800787:	eb 09                	jmp    800792 <timer+0x42>
			sys_yield();
		}
		if (r < 0)
  800789:	85 c0                	test   %eax,%eax
  80078b:	90                   	nop
  80078c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  800790:	79 20                	jns    8007b2 <timer+0x62>
			panic("sys_time_msec: %e", r);
  800792:	89 44 24 0c          	mov    %eax,0xc(%esp)
  800796:	c7 44 24 08 d5 1d 81 	movl   $0x811dd5,0x8(%esp)
  80079d:	00 
  80079e:	c7 44 24 04 0f 00 00 	movl   $0xf,0x4(%esp)
  8007a5:	00 
  8007a6:	c7 04 24 e7 1d 81 00 	movl   $0x811de7,(%esp)
  8007ad:	e8 c8 e8 00 00       	call   80f07a <_panic>

		ipc_send(ns_envid, NSREQ_TIMER, 0, 0);
  8007b2:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  8007b9:	00 
  8007ba:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8007c1:	00 
  8007c2:	c7 44 24 04 0c 00 00 	movl   $0xc,0x4(%esp)
  8007c9:	00 
  8007ca:	89 1c 24             	mov    %ebx,(%esp)
  8007cd:	e8 98 fa 00 00       	call   81026a <ipc_send>

		while (1) {
			uint32_t to, whom;
			to = ipc_recv((int32_t *) &whom, 0, 0);
  8007d2:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8007d9:	00 
  8007da:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8007e1:	00 
  8007e2:	89 3c 24             	mov    %edi,(%esp)
  8007e5:	e8 06 fa 00 00       	call   8101f0 <ipc_recv>
  8007ea:	89 c6                	mov    %eax,%esi

			if (whom != ns_envid) {
  8007ec:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8007ef:	39 c3                	cmp    %eax,%ebx
  8007f1:	74 12                	je     800805 <timer+0xb5>
				cprintf("NS TIMER: timer thread got IPC message from env %x not NS\n", whom);
  8007f3:	89 44 24 04          	mov    %eax,0x4(%esp)
  8007f7:	c7 04 24 f4 1d 81 00 	movl   $0x811df4,(%esp)
  8007fe:	e8 70 e9 00 00       	call   80f173 <cprintf>
  800803:	eb cd                	jmp    8007d2 <timer+0x82>
				continue;
			}

			stop = sys_time_msec() + to;
  800805:	e8 11 f6 00 00       	call   80fe1b <sys_time_msec>
  80080a:	01 c6                	add    %eax,%esi
  80080c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  800810:	e9 65 ff ff ff       	jmp    80077a <timer+0x2a>
  800815:	66 90                	xchg   %ax,%ax
  800817:	66 90                	xchg   %ax,%ax
  800819:	66 90                	xchg   %ax,%ax
  80081b:	66 90                	xchg   %ax,%ax
  80081d:	66 90                	xchg   %ax,%ax
  80081f:	90                   	nop

00800820 <input>:

extern union Nsipc nsipcbuf;

void
input(envid_t ns_envid)
{
  800820:	55                   	push   %ebp
  800821:	89 e5                	mov    %esp,%ebp
  800823:	57                   	push   %edi
  800824:	56                   	push   %esi
  800825:	53                   	push   %ebx
  800826:	83 ec 2c             	sub    $0x2c,%esp
  800829:	8b 7d 08             	mov    0x8(%ebp),%edi
	binaryname = "ns_input";
  80082c:	c7 05 e8 52 81 00 2f 	movl   $0x811e2f,0x8152e8
  800833:	1e 81 00 
	while(true) {
		//sys_yield();
		//continue;

		while(true) {
			if(sys_try_recv_packet(&packet, &size) == 0)  break;
  800836:	8d 75 e0             	lea    -0x20(%ebp),%esi
  800839:	8d 5d e4             	lea    -0x1c(%ebp),%ebx
  80083c:	89 74 24 04          	mov    %esi,0x4(%esp)
  800840:	89 1c 24             	mov    %ebx,(%esp)
  800843:	e8 45 f6 00 00       	call   80fe8d <sys_try_recv_packet>
  800848:	85 c0                	test   %eax,%eax
  80084a:	74 07                	je     800853 <input+0x33>
			sys_yield();
  80084c:	e8 43 f3 00 00       	call   80fb94 <sys_yield>
		}
  800851:	eb e9                	jmp    80083c <input+0x1c>

		sys_page_alloc(0, &nsipcbuf, PTE_U|PTE_W|PTE_P);
  800853:	c7 44 24 08 07 00 00 	movl   $0x7,0x8(%esp)
  80085a:	00 
  80085b:	c7 44 24 04 00 e0 b3 	movl   $0xb3e000,0x4(%esp)
  800862:	00 
  800863:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80086a:	e8 44 f3 00 00       	call   80fbb3 <sys_page_alloc>
		memcpy(nsipcbuf.pkt.jp_data, packet, size);
  80086f:	8b 45 e0             	mov    -0x20(%ebp),%eax
  800872:	89 44 24 08          	mov    %eax,0x8(%esp)
  800876:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800879:	89 44 24 04          	mov    %eax,0x4(%esp)
  80087d:	c7 04 24 04 e0 b3 00 	movl   $0xb3e004,(%esp)
  800884:	e8 13 f1 00 00       	call   80f99c <memcpy>
		nsipcbuf.pkt.jp_len = size;
  800889:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80088c:	a3 00 e0 b3 00       	mov    %eax,0xb3e000

		ipc_send(ns_envid, NSREQ_INPUT, &nsipcbuf, PTE_U|PTE_W|PTE_P);
  800891:	c7 44 24 0c 07 00 00 	movl   $0x7,0xc(%esp)
  800898:	00 
  800899:	c7 44 24 08 00 e0 b3 	movl   $0xb3e000,0x8(%esp)
  8008a0:	00 
  8008a1:	c7 44 24 04 0a 00 00 	movl   $0xa,0x4(%esp)
  8008a8:	00 
  8008a9:	89 3c 24             	mov    %edi,(%esp)
  8008ac:	e8 b9 f9 00 00       	call   81026a <ipc_send>
	}
  8008b1:	eb 89                	jmp    80083c <input+0x1c>
  8008b3:	66 90                	xchg   %ax,%ax
  8008b5:	66 90                	xchg   %ax,%ax
  8008b7:	66 90                	xchg   %ax,%ax
  8008b9:	66 90                	xchg   %ax,%ax
  8008bb:	66 90                	xchg   %ax,%ax
  8008bd:	66 90                	xchg   %ax,%ax
  8008bf:	90                   	nop

008008c0 <output>:

extern union Nsipc nsipcbuf;

void
output(envid_t ns_envid)
{
  8008c0:	55                   	push   %ebp
  8008c1:	89 e5                	mov    %esp,%ebp
  8008c3:	57                   	push   %edi
  8008c4:	56                   	push   %esi
  8008c5:	53                   	push   %ebx
  8008c6:	83 ec 2c             	sub    $0x2c,%esp
	binaryname = "ns_output";
  8008c9:	c7 05 e8 52 81 00 38 	movl   $0x811e38,0x8152e8
  8008d0:	1e 81 00 
	envid_t srcenv;
	int perm;
	int i;

	while(true) {
		ipc_recv(&srcenv, &nsipcbuf, &perm);
  8008d3:	8d 7d e0             	lea    -0x20(%ebp),%edi
  8008d6:	8d 75 e4             	lea    -0x1c(%ebp),%esi
  8008d9:	89 7c 24 08          	mov    %edi,0x8(%esp)
  8008dd:	c7 44 24 04 00 e0 b3 	movl   $0xb3e000,0x4(%esp)
  8008e4:	00 
  8008e5:	89 34 24             	mov    %esi,(%esp)
  8008e8:	e8 03 f9 00 00       	call   8101f0 <ipc_recv>

		if(srcenv != ns_envid) continue;
  8008ed:	8b 45 08             	mov    0x8(%ebp),%eax
  8008f0:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
  8008f3:	75 e4                	jne    8008d9 <output+0x19>
  8008f5:	bb 00 00 00 00       	mov    $0x0,%ebx

		for(i = 0; i < 50; i++) {
			if(sys_try_send_packet(nsipcbuf.pkt.jp_data, nsipcbuf.pkt.jp_len) == 0) break;
  8008fa:	a1 00 e0 b3 00       	mov    0xb3e000,%eax
  8008ff:	89 44 24 04          	mov    %eax,0x4(%esp)
  800903:	c7 04 24 04 e0 b3 00 	movl   $0xb3e004,(%esp)
  80090a:	e8 2b f5 00 00       	call   80fe3a <sys_try_send_packet>
  80090f:	85 c0                	test   %eax,%eax
  800911:	74 0f                	je     800922 <output+0x62>
			sys_yield();
  800913:	e8 7c f2 00 00       	call   80fb94 <sys_yield>
	while(true) {
		ipc_recv(&srcenv, &nsipcbuf, &perm);

		if(srcenv != ns_envid) continue;

		for(i = 0; i < 50; i++) {
  800918:	83 c3 01             	add    $0x1,%ebx
  80091b:	83 fb 32             	cmp    $0x32,%ebx
  80091e:	75 da                	jne    8008fa <output+0x3a>
  800920:	eb 05                	jmp    800927 <output+0x67>
			if(sys_try_send_packet(nsipcbuf.pkt.jp_data, nsipcbuf.pkt.jp_len) == 0) break;
			sys_yield();
		}

		if(i == 50) {
  800922:	83 fb 32             	cmp    $0x32,%ebx
  800925:	75 b2                	jne    8008d9 <output+0x19>
			cprintf("Packet failed to send after 50 tries\n");
  800927:	c7 04 24 44 1e 81 00 	movl   $0x811e44,(%esp)
  80092e:	e8 40 e8 00 00       	call   80f173 <cprintf>
  800933:	eb a4                	jmp    8008d9 <output+0x19>
  800935:	66 90                	xchg   %ax,%ax
  800937:	66 90                	xchg   %ax,%ax
  800939:	66 90                	xchg   %ax,%ax
  80093b:	66 90                	xchg   %ax,%ax
  80093d:	66 90                	xchg   %ax,%ax
  80093f:	90                   	nop

00800940 <get_socket>:
 * @param s externally used socket index
 * @return struct lwip_socket for the socket or NULL if not found
 */
static struct lwip_socket *
get_socket(int s)
{
  800940:	55                   	push   %ebp
  800941:	89 e5                	mov    %esp,%ebp
  struct lwip_socket *sock;

  if ((s < 0) || (s >= NUM_SOCKETS)) {
  800943:	83 f8 1f             	cmp    $0x1f,%eax
  800946:	76 11                	jbe    800959 <get_socket+0x19>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("get_socket(%d): invalid\n", s));
    set_errno(EBADF);
  800948:	c7 05 00 c2 b3 00 09 	movl   $0x9,0xb3c200
  80094f:	00 00 00 
    return NULL;
  800952:	b8 00 00 00 00       	mov    $0x0,%eax
  800957:	eb 24                	jmp    80097d <get_socket+0x3d>
  }

  sock = &sockets[s];
  800959:	8d 14 80             	lea    (%eax,%eax,4),%edx
  80095c:	c1 e2 02             	shl    $0x2,%edx
  80095f:	8d 82 80 60 81 00    	lea    0x816080(%edx),%eax

  if (!sock->conn) {
  800965:	83 ba 80 60 81 00 00 	cmpl   $0x0,0x816080(%edx)
  80096c:	75 0f                	jne    80097d <get_socket+0x3d>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("get_socket(%d): not active\n", s));
    set_errno(EBADF);
  80096e:	c7 05 00 c2 b3 00 09 	movl   $0x9,0xb3c200
  800975:	00 00 00 
    return NULL;
  800978:	b8 00 00 00 00       	mov    $0x0,%eax
  }

  return sock;
}
  80097d:	5d                   	pop    %ebp
  80097e:	c3                   	ret    

0080097f <lwip_selscan>:
 * @param exceptset not yet implemented
 * @return number of sockets that had events (read+write)
 */
static int
lwip_selscan(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset)
{
  80097f:	55                   	push   %ebp
  800980:	89 e5                	mov    %esp,%ebp
  800982:	57                   	push   %edi
  800983:	56                   	push   %esi
  800984:	53                   	push   %ebx
  800985:	83 ec 3c             	sub    $0x3c,%esp
  800988:	89 45 d0             	mov    %eax,-0x30(%ebp)
  80098b:	89 55 cc             	mov    %edx,-0x34(%ebp)
  80098e:	89 4d c8             	mov    %ecx,-0x38(%ebp)
  int i, nready = 0;
  fd_set lreadset, lwriteset, lexceptset;
  struct lwip_socket *p_sock;
  
  FD_ZERO(&lreadset);
  800991:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  800998:	00 
  800999:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8009a0:	00 
  8009a1:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  8009a4:	89 04 24             	mov    %eax,(%esp)
  8009a7:	e8 3b ef 00 00       	call   80f8e7 <memset>
  FD_ZERO(&lwriteset);
  8009ac:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  8009b3:	00 
  8009b4:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8009bb:	00 
  8009bc:	8d 45 e0             	lea    -0x20(%ebp),%eax
  8009bf:	89 04 24             	mov    %eax,(%esp)
  8009c2:	e8 20 ef 00 00       	call   80f8e7 <memset>
  FD_ZERO(&lexceptset);
  8009c7:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  8009ce:	00 
  8009cf:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8009d6:	00 
  8009d7:	8d 45 dc             	lea    -0x24(%ebp),%eax
  8009da:	89 04 24             	mov    %eax,(%esp)
  8009dd:	e8 05 ef 00 00       	call   80f8e7 <memset>
 * @return number of sockets that had events (read+write)
 */
static int
lwip_selscan(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset)
{
  int i, nready = 0;
  8009e2:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
  FD_ZERO(&lwriteset);
  FD_ZERO(&lexceptset);
  
  /* Go through each socket in each list to count number of sockets which
  currently match */
  for(i = 0; i < maxfdp1; i++) {
  8009e9:	bf 00 00 00 00       	mov    $0x0,%edi
  8009ee:	e9 80 00 00 00       	jmp    800a73 <lwip_selscan+0xf4>
    if (FD_ISSET(i, readset)) {
  8009f3:	8d 5f 07             	lea    0x7(%edi),%ebx
  8009f6:	85 ff                	test   %edi,%edi
  8009f8:	0f 49 df             	cmovns %edi,%ebx
  8009fb:	c1 fb 03             	sar    $0x3,%ebx
  8009fe:	89 5d d4             	mov    %ebx,-0x2c(%ebp)
  800a01:	89 fe                	mov    %edi,%esi
  800a03:	83 e6 07             	and    $0x7,%esi
  800a06:	8b 45 cc             	mov    -0x34(%ebp),%eax
  800a09:	0f b6 04 18          	movzbl (%eax,%ebx,1),%eax
  800a0d:	0f a3 f0             	bt     %esi,%eax
  800a10:	73 2c                	jae    800a3e <lwip_selscan+0xbf>
      /* See if netconn of this socket is ready for read */
      p_sock = get_socket(i);
  800a12:	89 f8                	mov    %edi,%eax
  800a14:	e8 27 ff ff ff       	call   800940 <get_socket>
      if (p_sock && (p_sock->lastdata || p_sock->rcvevent)) {
  800a19:	85 c0                	test   %eax,%eax
  800a1b:	74 21                	je     800a3e <lwip_selscan+0xbf>
  800a1d:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
  800a21:	75 07                	jne    800a2a <lwip_selscan+0xab>
  800a23:	66 83 78 0a 00       	cmpw   $0x0,0xa(%eax)
  800a28:	74 14                	je     800a3e <lwip_selscan+0xbf>
        FD_SET(i, &lreadset);
  800a2a:	b8 01 00 00 00       	mov    $0x1,%eax
  800a2f:	89 f1                	mov    %esi,%ecx
  800a31:	d3 e0                	shl    %cl,%eax
  800a33:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  800a36:	08 44 15 e4          	or     %al,-0x1c(%ebp,%edx,1)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for reading\n", i));
        nready++;
  800a3a:	83 45 c4 01          	addl   $0x1,-0x3c(%ebp)
      }
    }
    if (FD_ISSET(i, writeset)) {
  800a3e:	8b 45 c8             	mov    -0x38(%ebp),%eax
  800a41:	0f b6 04 18          	movzbl (%eax,%ebx,1),%eax
  800a45:	0f a3 f0             	bt     %esi,%eax
  800a48:	73 26                	jae    800a70 <lwip_selscan+0xf1>
      /* See if netconn of this socket is ready for write */
      p_sock = get_socket(i);
  800a4a:	89 f8                	mov    %edi,%eax
  800a4c:	e8 ef fe ff ff       	call   800940 <get_socket>
      if (p_sock && p_sock->sendevent) {
  800a51:	85 c0                	test   %eax,%eax
  800a53:	74 1b                	je     800a70 <lwip_selscan+0xf1>
  800a55:	66 83 78 0c 00       	cmpw   $0x0,0xc(%eax)
  800a5a:	74 14                	je     800a70 <lwip_selscan+0xf1>
        FD_SET(i, &lwriteset);
  800a5c:	b8 01 00 00 00       	mov    $0x1,%eax
  800a61:	89 f1                	mov    %esi,%ecx
  800a63:	d3 e0                	shl    %cl,%eax
  800a65:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  800a68:	08 44 15 e0          	or     %al,-0x20(%ebp,%edx,1)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for writing\n", i));
        nready++;
  800a6c:	83 45 c4 01          	addl   $0x1,-0x3c(%ebp)
  FD_ZERO(&lwriteset);
  FD_ZERO(&lexceptset);
  
  /* Go through each socket in each list to count number of sockets which
  currently match */
  for(i = 0; i < maxfdp1; i++) {
  800a70:	83 c7 01             	add    $0x1,%edi
  800a73:	3b 7d d0             	cmp    -0x30(%ebp),%edi
  800a76:	0f 8c 77 ff ff ff    	jl     8009f3 <lwip_selscan+0x74>
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for writing\n", i));
        nready++;
      }
    }
  }
  *readset = lreadset;
  800a7c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800a7f:	8b 55 cc             	mov    -0x34(%ebp),%edx
  800a82:	89 02                	mov    %eax,(%edx)
  *writeset = lwriteset;
  800a84:	8b 45 e0             	mov    -0x20(%ebp),%eax
  800a87:	8b 4d c8             	mov    -0x38(%ebp),%ecx
  800a8a:	89 01                	mov    %eax,(%ecx)
  FD_ZERO(exceptset);
  800a8c:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  800a93:	00 
  800a94:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  800a9b:	00 
  800a9c:	8b 45 08             	mov    0x8(%ebp),%eax
  800a9f:	89 04 24             	mov    %eax,(%esp)
  800aa2:	e8 40 ee 00 00       	call   80f8e7 <memset>
  
  return nready;
}
  800aa7:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  800aaa:	83 c4 3c             	add    $0x3c,%esp
  800aad:	5b                   	pop    %ebx
  800aae:	5e                   	pop    %esi
  800aaf:	5f                   	pop    %edi
  800ab0:	5d                   	pop    %ebp
  800ab1:	c3                   	ret    

00800ab2 <lwip_getaddrname>:
  return lwip_close(s); /* XXX temporary hack until proper implementation */
}

static int
lwip_getaddrname(int s, struct sockaddr *name, socklen_t *namelen, u8_t local)
{
  800ab2:	55                   	push   %ebp
  800ab3:	89 e5                	mov    %esp,%ebp
  800ab5:	57                   	push   %edi
  800ab6:	56                   	push   %esi
  800ab7:	53                   	push   %ebx
  800ab8:	83 ec 4c             	sub    $0x4c,%esp
  800abb:	89 d7                	mov    %edx,%edi
  800abd:	89 ce                	mov    %ecx,%esi
  800abf:	8b 55 08             	mov    0x8(%ebp),%edx
  800ac2:	89 55 c4             	mov    %edx,-0x3c(%ebp)
  struct lwip_socket *sock;
  struct sockaddr_in sin;
  struct ip_addr naddr;

  sock = get_socket(s);
  800ac5:	e8 76 fe ff ff       	call   800940 <get_socket>
  800aca:	89 c3                	mov    %eax,%ebx
  if (!sock)
  800acc:	85 c0                	test   %eax,%eax
  800ace:	0f 84 91 00 00 00    	je     800b65 <lwip_getaddrname+0xb3>
    return -1;

  memset(&sin, 0, sizeof(sin));
  800ad4:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%esp)
  800adb:	00 
  800adc:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  800ae3:	00 
  800ae4:	8d 45 d8             	lea    -0x28(%ebp),%eax
  800ae7:	89 04 24             	mov    %eax,(%esp)
  800aea:	e8 f8 ed 00 00       	call   80f8e7 <memset>
  sin.sin_len = sizeof(sin);
  800aef:	c6 45 d8 10          	movb   $0x10,-0x28(%ebp)
  sin.sin_family = AF_INET;
  800af3:	c6 45 d9 02          	movb   $0x2,-0x27(%ebp)

  /* get the IP address and port */
  netconn_getaddr(sock->conn, &naddr, &sin.sin_port, local);
  800af7:	0f b6 45 c4          	movzbl -0x3c(%ebp),%eax
  800afb:	89 44 24 0c          	mov    %eax,0xc(%esp)
  800aff:	8d 45 da             	lea    -0x26(%ebp),%eax
  800b02:	89 44 24 08          	mov    %eax,0x8(%esp)
  800b06:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  800b09:	89 44 24 04          	mov    %eax,0x4(%esp)
  800b0d:	8b 03                	mov    (%ebx),%eax
  800b0f:	89 04 24             	mov    %eax,(%esp)
  800b12:	e8 d6 ab 00 00       	call   80b6ed <netconn_getaddr>

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getaddrname(%d, addr=", s));
  //ip_addr_debug_print(SOCKETS_DEBUG, &naddr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%d)\n", sin.sin_port));

  sin.sin_port = htons(sin.sin_port);
  800b17:	0f b7 45 da          	movzwl -0x26(%ebp),%eax
  800b1b:	89 04 24             	mov    %eax,(%esp)
  800b1e:	e8 53 72 00 00       	call   807d76 <htons>
  800b23:	66 89 45 da          	mov    %ax,-0x26(%ebp)
  sin.sin_addr.s_addr = naddr.addr;
  800b27:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  800b2a:	89 45 dc             	mov    %eax,-0x24(%ebp)

  if (*namelen > sizeof(sin))
  800b2d:	83 3e 10             	cmpl   $0x10,(%esi)
  800b30:	76 06                	jbe    800b38 <lwip_getaddrname+0x86>
    *namelen = sizeof(sin);
  800b32:	c7 06 10 00 00 00    	movl   $0x10,(%esi)

  SMEMCPY(name, &sin, *namelen);
  800b38:	8b 06                	mov    (%esi),%eax
  800b3a:	89 44 24 08          	mov    %eax,0x8(%esp)
  800b3e:	8d 45 d8             	lea    -0x28(%ebp),%eax
  800b41:	89 44 24 04          	mov    %eax,0x4(%esp)
  800b45:	89 3c 24             	mov    %edi,(%esp)
  800b48:	e8 4f ee 00 00       	call   80f99c <memcpy>
  sock_set_errno(sock, 0);
  800b4d:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  800b54:	c7 05 00 c2 b3 00 00 	movl   $0x0,0xb3c200
  800b5b:	00 00 00 
  return 0;
  800b5e:	b8 00 00 00 00       	mov    $0x0,%eax
  800b63:	eb 05                	jmp    800b6a <lwip_getaddrname+0xb8>
  struct sockaddr_in sin;
  struct ip_addr naddr;

  sock = get_socket(s);
  if (!sock)
    return -1;
  800b65:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    *namelen = sizeof(sin);

  SMEMCPY(name, &sin, *namelen);
  sock_set_errno(sock, 0);
  return 0;
}
  800b6a:	83 c4 4c             	add    $0x4c,%esp
  800b6d:	5b                   	pop    %ebx
  800b6e:	5e                   	pop    %esi
  800b6f:	5f                   	pop    %edi
  800b70:	5d                   	pop    %ebp
  800b71:	c3                   	ret    

00800b72 <event_callback>:
 * Callback registered in the netconn layer for each socket-netconn.
 * Processes recvevent (data available) and wakes up tasks waiting for select.
 */
static void
event_callback(struct netconn *conn, enum netconn_evt evt, u16_t len)
{
  800b72:	55                   	push   %ebp
  800b73:	89 e5                	mov    %esp,%ebp
  800b75:	57                   	push   %edi
  800b76:	56                   	push   %esi
  800b77:	53                   	push   %ebx
  800b78:	83 ec 1c             	sub    $0x1c,%esp
  800b7b:	8b 7d 08             	mov    0x8(%ebp),%edi
  800b7e:	8b 75 0c             	mov    0xc(%ebp),%esi
  struct lwip_select_cb *scb;

  LWIP_UNUSED_ARG(len);

  /* Get socket */
  if (conn) {
  800b81:	85 ff                	test   %edi,%edi
  800b83:	0f 84 6a 01 00 00    	je     800cf3 <event_callback+0x181>
    s = conn->socket;
  800b89:	8b 5f 1c             	mov    0x1c(%edi),%ebx
    if (s < 0) {
  800b8c:	85 db                	test   %ebx,%ebx
  800b8e:	79 3d                	jns    800bcd <event_callback+0x5b>
      /* Data comes in right away after an accept, even though
       * the server task might not have created a new socket yet.
       * Just count down (or up) if that's the case and we
       * will use the data later. Note that only receive events
       * can happen before the new socket is set up. */
      sys_sem_wait(socksem);
  800b90:	a1 64 60 81 00       	mov    0x816064,%eax
  800b95:	89 04 24             	mov    %eax,(%esp)
  800b98:	e8 8b 4b 00 00       	call   805728 <sys_sem_wait>
      if (conn->socket < 0) {
  800b9d:	8b 47 1c             	mov    0x1c(%edi),%eax
  800ba0:	85 c0                	test   %eax,%eax
  800ba2:	79 1c                	jns    800bc0 <event_callback+0x4e>
        if (evt == NETCONN_EVT_RCVPLUS) {
  800ba4:	85 f6                	test   %esi,%esi
  800ba6:	75 06                	jne    800bae <event_callback+0x3c>
          conn->socket--;
  800ba8:	83 e8 01             	sub    $0x1,%eax
  800bab:	89 47 1c             	mov    %eax,0x1c(%edi)
        }
        sys_sem_signal(socksem);
  800bae:	a1 64 60 81 00       	mov    0x816064,%eax
  800bb3:	89 04 24             	mov    %eax,(%esp)
  800bb6:	e8 45 9d 00 00       	call   80a900 <sys_sem_signal>
        return;
  800bbb:	e9 33 01 00 00       	jmp    800cf3 <event_callback+0x181>
      }
      sys_sem_signal(socksem);
  800bc0:	a1 64 60 81 00       	mov    0x816064,%eax
  800bc5:	89 04 24             	mov    %eax,(%esp)
  800bc8:	e8 33 9d 00 00       	call   80a900 <sys_sem_signal>
    }

    sock = get_socket(s);
  800bcd:	89 d8                	mov    %ebx,%eax
  800bcf:	e8 6c fd ff ff       	call   800940 <get_socket>
  800bd4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if (!sock) {
  800bd7:	85 c0                	test   %eax,%eax
  800bd9:	0f 84 14 01 00 00    	je     800cf3 <event_callback+0x181>
    }
  } else {
    return;
  }

  sys_sem_wait(selectsem);
  800bdf:	a1 60 60 81 00       	mov    0x816060,%eax
  800be4:	89 04 24             	mov    %eax,(%esp)
  800be7:	e8 3c 4b 00 00       	call   805728 <sys_sem_wait>
  /* Set event as required */
  switch (evt) {
  800bec:	83 fe 01             	cmp    $0x1,%esi
  800bef:	74 1d                	je     800c0e <event_callback+0x9c>
  800bf1:	83 fe 01             	cmp    $0x1,%esi
  800bf4:	72 0e                	jb     800c04 <event_callback+0x92>
  800bf6:	83 fe 02             	cmp    $0x2,%esi
  800bf9:	74 1d                	je     800c18 <event_callback+0xa6>
  800bfb:	83 fe 03             	cmp    $0x3,%esi
  800bfe:	66 90                	xchg   %ax,%ax
  800c00:	74 21                	je     800c23 <event_callback+0xb1>
  800c02:	eb 2a                	jmp    800c2e <event_callback+0xbc>
    case NETCONN_EVT_RCVPLUS:
      sock->rcvevent++;
  800c04:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800c07:	66 83 40 0a 01       	addw   $0x1,0xa(%eax)
      break;
  800c0c:	eb 3c                	jmp    800c4a <event_callback+0xd8>
    case NETCONN_EVT_RCVMINUS:
      sock->rcvevent--;
  800c0e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800c11:	66 83 68 0a 01       	subw   $0x1,0xa(%eax)
      break;
  800c16:	eb 32                	jmp    800c4a <event_callback+0xd8>
    case NETCONN_EVT_SENDPLUS:
      sock->sendevent = 1;
  800c18:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800c1b:	66 c7 40 0c 01 00    	movw   $0x1,0xc(%eax)
      break;
  800c21:	eb 27                	jmp    800c4a <event_callback+0xd8>
    case NETCONN_EVT_SENDMINUS:
      sock->sendevent = 0;
  800c23:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800c26:	66 c7 40 0c 00 00    	movw   $0x0,0xc(%eax)
      break;
  800c2c:	eb 1c                	jmp    800c4a <event_callback+0xd8>
    default:
      LWIP_ASSERT("unknown event", 0);
  800c2e:	c7 44 24 08 6a 1e 81 	movl   $0x811e6a,0x8(%esp)
  800c35:	00 
  800c36:	c7 44 24 04 17 04 00 	movl   $0x417,0x4(%esp)
  800c3d:	00 
  800c3e:	c7 04 24 78 1e 81 00 	movl   $0x811e78,(%esp)
  800c45:	e8 30 e4 00 00       	call   80f07a <_panic>
      break;
  }
  sys_sem_signal(selectsem);
  800c4a:	a1 60 60 81 00       	mov    0x816060,%eax
  800c4f:	89 04 24             	mov    %eax,(%esp)
  800c52:	e8 a9 9c 00 00       	call   80a900 <sys_sem_signal>
  while (1) {
    sys_sem_wait(selectsem);
    for (scb = select_cb_list; scb; scb = scb->next) {
      if (scb->sem_signalled == 0) {
        /* Test this select call for our socket */
        if (scb->readset && FD_ISSET(s, scb->readset))
  800c57:	8d 7b 07             	lea    0x7(%ebx),%edi
  800c5a:	85 db                	test   %ebx,%ebx
  800c5c:	0f 49 fb             	cmovns %ebx,%edi
  800c5f:	c1 ff 03             	sar    $0x3,%edi
  800c62:	89 d9                	mov    %ebx,%ecx
  800c64:	83 e1 07             	and    $0x7,%ecx
  800c67:	b8 01 00 00 00       	mov    $0x1,%eax
  800c6c:	d3 e0                	shl    %cl,%eax
  800c6e:	89 c6                	mov    %eax,%esi
     signalling for the select. This means we need to go through the list
     multiple times ONLY IF a select was actually waiting. We go through
     the list the number of waiting select calls + 1. This list is
     expected to be small. */
  while (1) {
    sys_sem_wait(selectsem);
  800c70:	a1 60 60 81 00       	mov    0x816060,%eax
  800c75:	89 04 24             	mov    %eax,(%esp)
  800c78:	e8 ab 4a 00 00       	call   805728 <sys_sem_wait>
    for (scb = select_cb_list; scb; scb = scb->next) {
  800c7d:	8b 1d 68 60 81 00    	mov    0x816068,%ebx
  800c83:	eb 3a                	jmp    800cbf <event_callback+0x14d>
      if (scb->sem_signalled == 0) {
  800c85:	83 7b 10 00          	cmpl   $0x0,0x10(%ebx)
  800c89:	75 32                	jne    800cbd <event_callback+0x14b>
        /* Test this select call for our socket */
        if (scb->readset && FD_ISSET(s, scb->readset))
  800c8b:	8b 43 04             	mov    0x4(%ebx),%eax
  800c8e:	85 c0                	test   %eax,%eax
  800c90:	74 12                	je     800ca4 <event_callback+0x132>
  800c92:	0f b6 04 38          	movzbl (%eax,%edi,1),%eax
  800c96:	85 f0                	test   %esi,%eax
  800c98:	74 0a                	je     800ca4 <event_callback+0x132>
          if (sock->rcvevent)
  800c9a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800c9d:	66 83 78 0a 00       	cmpw   $0x0,0xa(%eax)
  800ca2:	75 21                	jne    800cc5 <event_callback+0x153>
            break;
        if (scb->writeset && FD_ISSET(s, scb->writeset))
  800ca4:	8b 43 08             	mov    0x8(%ebx),%eax
  800ca7:	85 c0                	test   %eax,%eax
  800ca9:	74 12                	je     800cbd <event_callback+0x14b>
  800cab:	0f b6 04 38          	movzbl (%eax,%edi,1),%eax
  800caf:	85 f0                	test   %esi,%eax
  800cb1:	74 0a                	je     800cbd <event_callback+0x14b>
          if (sock->sendevent)
  800cb3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800cb6:	66 83 78 0c 00       	cmpw   $0x0,0xc(%eax)
  800cbb:	75 08                	jne    800cc5 <event_callback+0x153>
     multiple times ONLY IF a select was actually waiting. We go through
     the list the number of waiting select calls + 1. This list is
     expected to be small. */
  while (1) {
    sys_sem_wait(selectsem);
    for (scb = select_cb_list; scb; scb = scb->next) {
  800cbd:	8b 1b                	mov    (%ebx),%ebx
  800cbf:	85 db                	test   %ebx,%ebx
  800cc1:	75 c2                	jne    800c85 <event_callback+0x113>
  800cc3:	eb 21                	jmp    800ce6 <event_callback+0x174>
          if (sock->sendevent)
            break;
      }
    }
    if (scb) {
      scb->sem_signalled = 1;
  800cc5:	c7 43 10 01 00 00 00 	movl   $0x1,0x10(%ebx)
      sys_sem_signal(selectsem);
  800ccc:	a1 60 60 81 00       	mov    0x816060,%eax
  800cd1:	89 04 24             	mov    %eax,(%esp)
  800cd4:	e8 27 9c 00 00       	call   80a900 <sys_sem_signal>
      sys_sem_signal(scb->sem);
  800cd9:	8b 43 14             	mov    0x14(%ebx),%eax
  800cdc:	89 04 24             	mov    %eax,(%esp)
  800cdf:	e8 1c 9c 00 00       	call   80a900 <sys_sem_signal>
    } else {
      sys_sem_signal(selectsem);
      break;
    }
  }
  800ce4:	eb 8a                	jmp    800c70 <event_callback+0xfe>
    if (scb) {
      scb->sem_signalled = 1;
      sys_sem_signal(selectsem);
      sys_sem_signal(scb->sem);
    } else {
      sys_sem_signal(selectsem);
  800ce6:	a1 60 60 81 00       	mov    0x816060,%eax
  800ceb:	89 04 24             	mov    %eax,(%esp)
  800cee:	e8 0d 9c 00 00       	call   80a900 <sys_sem_signal>
      break;
    }
  }
}
  800cf3:	83 c4 1c             	add    $0x1c,%esp
  800cf6:	5b                   	pop    %ebx
  800cf7:	5e                   	pop    %esi
  800cf8:	5f                   	pop    %edi
  800cf9:	5d                   	pop    %ebp
  800cfa:	c3                   	ret    

00800cfb <alloc_socket>:
 * @param newconn the netconn for which to allocate a socket
 * @return the index of the new socket; -1 on error
 */
static int
alloc_socket(struct netconn *newconn)
{
  800cfb:	55                   	push   %ebp
  800cfc:	89 e5                	mov    %esp,%ebp
  800cfe:	56                   	push   %esi
  800cff:	53                   	push   %ebx
  800d00:	83 ec 10             	sub    $0x10,%esp
  800d03:	89 c6                	mov    %eax,%esi
  int i;

  /* Protect socket array */
  sys_sem_wait(socksem);
  800d05:	a1 64 60 81 00       	mov    0x816064,%eax
  800d0a:	89 04 24             	mov    %eax,(%esp)
  800d0d:	e8 16 4a 00 00       	call   805728 <sys_sem_wait>
  800d12:	ba 80 60 81 00       	mov    $0x816080,%edx

  /* allocate a new socket identifier */
  for (i = 0; i < NUM_SOCKETS; ++i) {
  800d17:	bb 00 00 00 00       	mov    $0x0,%ebx
    if (!sockets[i].conn) {
  800d1c:	83 3a 00             	cmpl   $0x0,(%edx)
  800d1f:	75 5f                	jne    800d80 <alloc_socket+0x85>
      sockets[i].conn       = newconn;
  800d21:	8d 14 9d 00 00 00 00 	lea    0x0(,%ebx,4),%edx
  800d28:	8d 0c 1a             	lea    (%edx,%ebx,1),%ecx
  800d2b:	c1 e1 02             	shl    $0x2,%ecx
  800d2e:	89 b1 80 60 81 00    	mov    %esi,0x816080(%ecx)
      sockets[i].lastdata   = NULL;
  800d34:	c7 81 84 60 81 00 00 	movl   $0x0,0x816084(%ecx)
  800d3b:	00 00 00 
      sockets[i].lastoffset = 0;
  800d3e:	66 c7 81 88 60 81 00 	movw   $0x0,0x816088(%ecx)
  800d45:	00 00 
      sockets[i].rcvevent   = 0;
  800d47:	66 c7 81 8a 60 81 00 	movw   $0x0,0x81608a(%ecx)
  800d4e:	00 00 
      sockets[i].sendevent  = 1; /* TCP send buf is empty */
  800d50:	66 c7 81 8c 60 81 00 	movw   $0x1,0x81608c(%ecx)
  800d57:	01 00 
      sockets[i].flags      = 0;
  800d59:	66 c7 81 8e 60 81 00 	movw   $0x0,0x81608e(%ecx)
  800d60:	00 00 
      sockets[i].err        = 0;
  800d62:	01 da                	add    %ebx,%edx
  800d64:	c7 04 95 90 60 81 00 	movl   $0x0,0x816090(,%edx,4)
  800d6b:	00 00 00 00 
      sys_sem_signal(socksem);
  800d6f:	a1 64 60 81 00       	mov    0x816064,%eax
  800d74:	89 04 24             	mov    %eax,(%esp)
  800d77:	e8 84 9b 00 00       	call   80a900 <sys_sem_signal>
      return i;
  800d7c:	89 d8                	mov    %ebx,%eax
  800d7e:	eb 1d                	jmp    800d9d <alloc_socket+0xa2>

  /* Protect socket array */
  sys_sem_wait(socksem);

  /* allocate a new socket identifier */
  for (i = 0; i < NUM_SOCKETS; ++i) {
  800d80:	83 c3 01             	add    $0x1,%ebx
  800d83:	83 c2 14             	add    $0x14,%edx
  800d86:	83 fb 20             	cmp    $0x20,%ebx
  800d89:	75 91                	jne    800d1c <alloc_socket+0x21>
      sockets[i].err        = 0;
      sys_sem_signal(socksem);
      return i;
    }
  }
  sys_sem_signal(socksem);
  800d8b:	a1 64 60 81 00       	mov    0x816064,%eax
  800d90:	89 04 24             	mov    %eax,(%esp)
  800d93:	e8 68 9b 00 00       	call   80a900 <sys_sem_signal>
  return -1;
  800d98:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  800d9d:	83 c4 10             	add    $0x10,%esp
  800da0:	5b                   	pop    %ebx
  800da1:	5e                   	pop    %esi
  800da2:	5d                   	pop    %ebp
  800da3:	c3                   	ret    

00800da4 <lwip_getsockopt_internal>:
  return err ? -1 : 0;
}

static void
lwip_getsockopt_internal(void *arg)
{
  800da4:	55                   	push   %ebp
  800da5:	89 e5                	mov    %esp,%ebp
  800da7:	53                   	push   %ebx
  800da8:	83 ec 14             	sub    $0x14,%esp
  800dab:	8b 45 08             	mov    0x8(%ebp),%eax
#endif /* LWIP_DEBUG */
  int level, optname;
  void *optval;
  struct lwip_setgetsockopt_data *data;

  LWIP_ASSERT("arg != NULL", arg != NULL);
  800dae:	85 c0                	test   %eax,%eax
  800db0:	75 1c                	jne    800dce <lwip_getsockopt_internal+0x2a>
  800db2:	c7 44 24 08 8f 1e 81 	movl   $0x811e8f,0x8(%esp)
  800db9:	00 
  800dba:	c7 44 24 04 38 05 00 	movl   $0x538,0x4(%esp)
  800dc1:	00 
  800dc2:	c7 04 24 78 1e 81 00 	movl   $0x811e78,(%esp)
  800dc9:	e8 ac e2 00 00       	call   80f07a <_panic>

  data = (struct lwip_setgetsockopt_data*)arg;
  sock = data->sock;
  800dce:	8b 08                	mov    (%eax),%ecx
#ifdef LWIP_DEBUG
  s = data->s;
#endif /* LWIP_DEBUG */
  level = data->level;
  optname = data->optname;
  800dd0:	8b 50 0c             	mov    0xc(%eax),%edx
  optval = data->optval;
  800dd3:	8b 58 10             	mov    0x10(%eax),%ebx

  switch (level) {
  800dd6:	8b 40 08             	mov    0x8(%eax),%eax
  800dd9:	83 f8 06             	cmp    $0x6,%eax
  800ddc:	0f 84 0a 01 00 00    	je     800eec <lwip_getsockopt_internal+0x148>
  800de2:	3d ff 0f 00 00       	cmp    $0xfff,%eax
  800de7:	74 0d                	je     800df6 <lwip_getsockopt_internal+0x52>
  800de9:	85 c0                	test   %eax,%eax
  800deb:	0f 85 27 01 00 00    	jne    800f18 <lwip_getsockopt_internal+0x174>
  800df1:	e9 d2 00 00 00       	jmp    800ec8 <lwip_getsockopt_internal+0x124>
   
/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
  800df6:	83 fa 20             	cmp    $0x20,%edx
  800df9:	74 39                	je     800e34 <lwip_getsockopt_internal+0x90>
  800dfb:	83 fa 20             	cmp    $0x20,%edx
  800dfe:	66 90                	xchg   %ax,%ax
  800e00:	7f 10                	jg     800e12 <lwip_getsockopt_internal+0x6e>
  800e02:	83 fa 02             	cmp    $0x2,%edx
  800e05:	74 2d                	je     800e34 <lwip_getsockopt_internal+0x90>
  800e07:	83 fa 08             	cmp    $0x8,%edx
  800e0a:	0f 85 08 01 00 00    	jne    800f18 <lwip_getsockopt_internal+0x174>
  800e10:	eb 22                	jmp    800e34 <lwip_getsockopt_internal+0x90>
  800e12:	81 fa 08 10 00 00    	cmp    $0x1008,%edx
  800e18:	74 2c                	je     800e46 <lwip_getsockopt_internal+0xa2>
  800e1a:	81 fa 0a 10 00 00    	cmp    $0x100a,%edx
  800e20:	0f 84 92 00 00 00    	je     800eb8 <lwip_getsockopt_internal+0x114>
  800e26:	81 fa 07 10 00 00    	cmp    $0x1007,%edx
  800e2c:	0f 85 e6 00 00 00    	jne    800f18 <lwip_getsockopt_internal+0x174>
  800e32:	eb 4f                	jmp    800e83 <lwip_getsockopt_internal+0xdf>
#if SO_REUSE
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    /*case SO_USELOOPBACK: UNIMPL */
      *(int*)optval = sock->conn->pcb.ip->so_options & optname;
  800e34:	8b 01                	mov    (%ecx),%eax
  800e36:	8b 40 08             	mov    0x8(%eax),%eax
  800e39:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  800e3d:	21 c2                	and    %eax,%edx
  800e3f:	89 13                	mov    %edx,(%ebx)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, optname=0x%x, ..) = %s\n",
                                  s, optname, (*(int*)optval?"on":"off")));
      break;
  800e41:	e9 d2 00 00 00       	jmp    800f18 <lwip_getsockopt_internal+0x174>

    case SO_TYPE:
      switch (NETCONNTYPE_GROUP(sock->conn->type)) {
  800e46:	8b 01                	mov    (%ecx),%eax
  800e48:	8b 10                	mov    (%eax),%edx
  800e4a:	89 d0                	mov    %edx,%eax
  800e4c:	25 f0 00 00 00       	and    $0xf0,%eax
  800e51:	83 f8 20             	cmp    $0x20,%eax
  800e54:	74 22                	je     800e78 <lwip_getsockopt_internal+0xd4>
  800e56:	83 f8 40             	cmp    $0x40,%eax
  800e59:	74 12                	je     800e6d <lwip_getsockopt_internal+0xc9>
  800e5b:	83 f8 10             	cmp    $0x10,%eax
        break;
      case NETCONN_UDP:
        *(int*)optval = SOCK_DGRAM;
        break;
      default: /* unrecognized socket type */
        *(int*)optval = sock->conn->type;
  800e5e:	b8 01 00 00 00       	mov    $0x1,%eax
  800e63:	0f 44 d0             	cmove  %eax,%edx
  800e66:	89 13                	mov    %edx,(%ebx)
  800e68:	e9 ab 00 00 00       	jmp    800f18 <lwip_getsockopt_internal+0x174>
      break;

    case SO_TYPE:
      switch (NETCONNTYPE_GROUP(sock->conn->type)) {
      case NETCONN_RAW:
        *(int*)optval = SOCK_RAW;
  800e6d:	c7 03 03 00 00 00    	movl   $0x3,(%ebx)
        break;
  800e73:	e9 a0 00 00 00       	jmp    800f18 <lwip_getsockopt_internal+0x174>
      case NETCONN_TCP:
        *(int*)optval = SOCK_STREAM;
        break;
      case NETCONN_UDP:
        *(int*)optval = SOCK_DGRAM;
  800e78:	c7 03 02 00 00 00    	movl   $0x2,(%ebx)
        break;
  800e7e:	e9 95 00 00 00       	jmp    800f18 <lwip_getsockopt_internal+0x174>
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, SO_TYPE) = %d\n",
                  s, *(int *)optval));
      break;

    case SO_ERROR:
      if (sock->err == 0) {
  800e83:	83 79 10 00          	cmpl   $0x0,0x10(%ecx)
  800e87:	75 21                	jne    800eaa <lwip_getsockopt_internal+0x106>
        sock_set_errno(sock, err_to_errno(sock->conn->err));
  800e89:	8b 01                	mov    (%ecx),%eax
  800e8b:	0f be 50 0c          	movsbl 0xc(%eax),%edx
  800e8f:	f7 da                	neg    %edx
  800e91:	b8 05 00 00 00       	mov    $0x5,%eax
  800e96:	83 fa 0e             	cmp    $0xe,%edx
  800e99:	77 07                	ja     800ea2 <lwip_getsockopt_internal+0xfe>
  800e9b:	8b 04 95 40 1f 81 00 	mov    0x811f40(,%edx,4),%eax
  800ea2:	89 41 10             	mov    %eax,0x10(%ecx)
  800ea5:	a3 00 c2 b3 00       	mov    %eax,0xb3c200
      } 
      *(int *)optval = sock->err;
  800eaa:	8b 41 10             	mov    0x10(%ecx),%eax
  800ead:	89 03                	mov    %eax,(%ebx)
      sock->err = 0;
  800eaf:	c7 41 10 00 00 00 00 	movl   $0x0,0x10(%ecx)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, SO_ERROR) = %d\n",
                  s, *(int *)optval));
      break;
  800eb6:	eb 60                	jmp    800f18 <lwip_getsockopt_internal+0x174>
      *(int *)optval = sock->conn->recv_bufsize;
      break;
#endif /* LWIP_SO_RCVBUF */
#if LWIP_UDP
    case SO_NO_CHECK:
      *(int*)optval = (udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_NOCHKSUM) ? 1 : 0;
  800eb8:	8b 01                	mov    (%ecx),%eax
  800eba:	8b 40 08             	mov    0x8(%eax),%eax
  800ebd:	0f b6 40 10          	movzbl 0x10(%eax),%eax
  800ec1:	83 e0 01             	and    $0x1,%eax
  800ec4:	89 03                	mov    %eax,(%ebx)
      break;
  800ec6:	eb 50                	jmp    800f18 <lwip_getsockopt_internal+0x174>
    }  /* switch (optname) */
    break;

/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
  800ec8:	83 fa 01             	cmp    $0x1,%edx
  800ecb:	74 12                	je     800edf <lwip_getsockopt_internal+0x13b>
  800ecd:	83 fa 02             	cmp    $0x2,%edx
  800ed0:	75 46                	jne    800f18 <lwip_getsockopt_internal+0x174>
    case IP_TTL:
      *(int*)optval = sock->conn->pcb.ip->ttl;
  800ed2:	8b 01                	mov    (%ecx),%eax
  800ed4:	8b 40 08             	mov    0x8(%eax),%eax
  800ed7:	0f b6 40 0b          	movzbl 0xb(%eax),%eax
  800edb:	89 03                	mov    %eax,(%ebx)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, IP_TTL) = %d\n",
                  s, *(int *)optval));
      break;
  800edd:	eb 39                	jmp    800f18 <lwip_getsockopt_internal+0x174>
    case IP_TOS:
      *(int*)optval = sock->conn->pcb.ip->tos;
  800edf:	8b 01                	mov    (%ecx),%eax
  800ee1:	8b 40 08             	mov    0x8(%eax),%eax
  800ee4:	0f b6 40 0a          	movzbl 0xa(%eax),%eax
  800ee8:	89 03                	mov    %eax,(%ebx)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, IP_TOS) = %d\n",
                  s, *(int *)optval));
      break;
  800eea:	eb 2c                	jmp    800f18 <lwip_getsockopt_internal+0x174>
    break;

#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    switch (optname) {
  800eec:	83 fa 01             	cmp    $0x1,%edx
  800eef:	74 07                	je     800ef8 <lwip_getsockopt_internal+0x154>
  800ef1:	83 fa 02             	cmp    $0x2,%edx
  800ef4:	74 15                	je     800f0b <lwip_getsockopt_internal+0x167>
  800ef6:	eb 20                	jmp    800f18 <lwip_getsockopt_internal+0x174>
    case TCP_NODELAY:
      *(int*)optval = (sock->conn->pcb.tcp->flags & TF_NODELAY);
  800ef8:	8b 01                	mov    (%ecx),%eax
  800efa:	8b 40 08             	mov    0x8(%eax),%eax
  800efd:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  800f01:	83 e0 40             	and    $0x40,%eax
  800f04:	0f b6 c0             	movzbl %al,%eax
  800f07:	89 03                	mov    %eax,(%ebx)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_TCP, TCP_NODELAY) = %s\n",
                  s, (*(int*)optval)?"on":"off") );
      break;
  800f09:	eb 0d                	jmp    800f18 <lwip_getsockopt_internal+0x174>
    case TCP_KEEPALIVE:
      *(int*)optval = (int)sock->conn->pcb.tcp->keep_idle;
  800f0b:	8b 01                	mov    (%ecx),%eax
  800f0d:	8b 40 08             	mov    0x8(%eax),%eax
  800f10:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
  800f16:	89 03                	mov    %eax,(%ebx)
      break;
    }  /* switch (optname) */
    break;
#endif /* LWIP_UDP */
  } /* switch (level) */
  sys_sem_signal(sock->conn->op_completed);
  800f18:	8b 01                	mov    (%ecx),%eax
  800f1a:	8b 40 10             	mov    0x10(%eax),%eax
  800f1d:	89 04 24             	mov    %eax,(%esp)
  800f20:	e8 db 99 00 00       	call   80a900 <sys_sem_signal>
}
  800f25:	83 c4 14             	add    $0x14,%esp
  800f28:	5b                   	pop    %ebx
  800f29:	5d                   	pop    %ebp
  800f2a:	c3                   	ret    

00800f2b <lwip_setsockopt_internal>:
  return err ? -1 : 0;
}

static void
lwip_setsockopt_internal(void *arg)
{
  800f2b:	55                   	push   %ebp
  800f2c:	89 e5                	mov    %esp,%ebp
  800f2e:	53                   	push   %ebx
  800f2f:	83 ec 14             	sub    $0x14,%esp
  800f32:	8b 45 08             	mov    0x8(%ebp),%eax
#endif /* LWIP_DEBUG */
  int level, optname;
  const void *optval;
  struct lwip_setgetsockopt_data *data;

  LWIP_ASSERT("arg != NULL", arg != NULL);
  800f35:	85 c0                	test   %eax,%eax
  800f37:	75 1c                	jne    800f55 <lwip_setsockopt_internal+0x2a>
  800f39:	c7 44 24 08 8f 1e 81 	movl   $0x811e8f,0x8(%esp)
  800f40:	00 
  800f41:	c7 44 24 04 ae 06 00 	movl   $0x6ae,0x4(%esp)
  800f48:	00 
  800f49:	c7 04 24 78 1e 81 00 	movl   $0x811e78,(%esp)
  800f50:	e8 25 e1 00 00       	call   80f07a <_panic>

  data = (struct lwip_setgetsockopt_data*)arg;
  sock = data->sock;
  800f55:	8b 10                	mov    (%eax),%edx
#ifdef LWIP_DEBUG
  s = data->s;
#endif /* LWIP_DEBUG */
  level = data->level;
  optname = data->optname;
  800f57:	8b 48 0c             	mov    0xc(%eax),%ecx
  optval = data->optval;
  800f5a:	8b 58 10             	mov    0x10(%eax),%ebx

  switch (level) {
  800f5d:	8b 40 08             	mov    0x8(%eax),%eax
  800f60:	83 f8 06             	cmp    $0x6,%eax
  800f63:	0f 84 87 00 00 00    	je     800ff0 <lwip_setsockopt_internal+0xc5>
  800f69:	3d ff 0f 00 00       	cmp    $0xfff,%eax
  800f6e:	74 0a                	je     800f7a <lwip_setsockopt_internal+0x4f>
  800f70:	85 c0                	test   %eax,%eax
  800f72:	0f 85 ad 00 00 00    	jne    801025 <lwip_setsockopt_internal+0xfa>
  800f78:	eb 54                	jmp    800fce <lwip_setsockopt_internal+0xa3>

/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
  800f7a:	83 f9 20             	cmp    $0x20,%ecx
  800f7d:	8d 76 00             	lea    0x0(%esi),%esi
  800f80:	74 11                	je     800f93 <lwip_setsockopt_internal+0x68>
  800f82:	81 f9 0a 10 00 00    	cmp    $0x100a,%ecx
  800f88:	74 29                	je     800fb3 <lwip_setsockopt_internal+0x88>
  800f8a:	83 f9 08             	cmp    $0x8,%ecx
  800f8d:	0f 85 92 00 00 00    	jne    801025 <lwip_setsockopt_internal+0xfa>
#if SO_REUSE
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    /* UNIMPL case SO_USELOOPBACK: */
      if (*(int*)optval) {
  800f93:	83 3b 00             	cmpl   $0x0,(%ebx)
  800f96:	74 0e                	je     800fa6 <lwip_setsockopt_internal+0x7b>
        sock->conn->pcb.ip->so_options |= optname;
  800f98:	8b 02                	mov    (%edx),%eax
  800f9a:	8b 40 08             	mov    0x8(%eax),%eax
  800f9d:	66 09 48 08          	or     %cx,0x8(%eax)
  800fa1:	e9 7f 00 00 00       	jmp    801025 <lwip_setsockopt_internal+0xfa>
      } else {
        sock->conn->pcb.ip->so_options &= ~optname;
  800fa6:	8b 02                	mov    (%edx),%eax
  800fa8:	8b 40 08             	mov    0x8(%eax),%eax
  800fab:	f7 d1                	not    %ecx
  800fad:	66 21 48 08          	and    %cx,0x8(%eax)
  800fb1:	eb 72                	jmp    801025 <lwip_setsockopt_internal+0xfa>
      sock->conn->recv_bufsize = ( *(int*)optval );
      break;
#endif /* LWIP_SO_RCVBUF */
#if LWIP_UDP
    case SO_NO_CHECK:
      if (*(int*)optval) {
  800fb3:	83 3b 00             	cmpl   $0x0,(%ebx)
  800fb6:	74 0b                	je     800fc3 <lwip_setsockopt_internal+0x98>
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) | UDP_FLAGS_NOCHKSUM);
  800fb8:	8b 02                	mov    (%edx),%eax
  800fba:	8b 40 08             	mov    0x8(%eax),%eax
  800fbd:	80 48 10 01          	orb    $0x1,0x10(%eax)
  800fc1:	eb 62                	jmp    801025 <lwip_setsockopt_internal+0xfa>
      } else {
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) & ~UDP_FLAGS_NOCHKSUM);
  800fc3:	8b 02                	mov    (%edx),%eax
  800fc5:	8b 40 08             	mov    0x8(%eax),%eax
  800fc8:	80 60 10 fe          	andb   $0xfe,0x10(%eax)
  800fcc:	eb 57                	jmp    801025 <lwip_setsockopt_internal+0xfa>
    }  /* switch (optname) */
    break;

/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
  800fce:	83 f9 01             	cmp    $0x1,%ecx
  800fd1:	74 11                	je     800fe4 <lwip_setsockopt_internal+0xb9>
  800fd3:	83 f9 02             	cmp    $0x2,%ecx
  800fd6:	75 4d                	jne    801025 <lwip_setsockopt_internal+0xfa>
    case IP_TTL:
      sock->conn->pcb.ip->ttl = (u8_t)(*(int*)optval);
  800fd8:	8b 02                	mov    (%edx),%eax
  800fda:	8b 40 08             	mov    0x8(%eax),%eax
  800fdd:	8b 0b                	mov    (%ebx),%ecx
  800fdf:	88 48 0b             	mov    %cl,0xb(%eax)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IP, IP_TTL, ..) -> %u\n",
                  s, sock->conn->pcb.ip->ttl));
      break;
  800fe2:	eb 41                	jmp    801025 <lwip_setsockopt_internal+0xfa>
    case IP_TOS:
      sock->conn->pcb.ip->tos = (u8_t)(*(int*)optval);
  800fe4:	8b 02                	mov    (%edx),%eax
  800fe6:	8b 40 08             	mov    0x8(%eax),%eax
  800fe9:	8b 0b                	mov    (%ebx),%ecx
  800feb:	88 48 0a             	mov    %cl,0xa(%eax)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IP, IP_TOS, ..)-> %u\n",
                  s, sock->conn->pcb.ip->tos));
      break;
  800fee:	eb 35                	jmp    801025 <lwip_setsockopt_internal+0xfa>
    break;

#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    switch (optname) {
  800ff0:	83 f9 01             	cmp    $0x1,%ecx
  800ff3:	74 07                	je     800ffc <lwip_setsockopt_internal+0xd1>
  800ff5:	83 f9 02             	cmp    $0x2,%ecx
  800ff8:	74 1e                	je     801018 <lwip_setsockopt_internal+0xed>
  800ffa:	eb 29                	jmp    801025 <lwip_setsockopt_internal+0xfa>
    case TCP_NODELAY:
      if (*(int*)optval) {
  800ffc:	83 3b 00             	cmpl   $0x0,(%ebx)
  800fff:	90                   	nop
  801000:	74 0b                	je     80100d <lwip_setsockopt_internal+0xe2>
        sock->conn->pcb.tcp->flags |= TF_NODELAY;
  801002:	8b 02                	mov    (%edx),%eax
  801004:	8b 40 08             	mov    0x8(%eax),%eax
  801007:	80 48 20 40          	orb    $0x40,0x20(%eax)
  80100b:	eb 18                	jmp    801025 <lwip_setsockopt_internal+0xfa>
      } else {
        sock->conn->pcb.tcp->flags &= ~TF_NODELAY;
  80100d:	8b 02                	mov    (%edx),%eax
  80100f:	8b 40 08             	mov    0x8(%eax),%eax
  801012:	80 60 20 bf          	andb   $0xbf,0x20(%eax)
  801016:	eb 0d                	jmp    801025 <lwip_setsockopt_internal+0xfa>
      }
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, TCP_NODELAY) -> %s\n",
                  s, (*(int *)optval)?"on":"off") );
      break;
    case TCP_KEEPALIVE:
      sock->conn->pcb.tcp->keep_idle = (u32_t)(*(int*)optval);
  801018:	8b 02                	mov    (%edx),%eax
  80101a:	8b 40 08             	mov    0x8(%eax),%eax
  80101d:	8b 0b                	mov    (%ebx),%ecx
  80101f:	89 88 9c 00 00 00    	mov    %ecx,0x9c(%eax)
      break;
    }  /* switch (optname) */
    break;
#endif /* LWIP_UDP */
  }  /* switch (level) */
  sys_sem_signal(sock->conn->op_completed);
  801025:	8b 02                	mov    (%edx),%eax
  801027:	8b 40 10             	mov    0x10(%eax),%eax
  80102a:	89 04 24             	mov    %eax,(%esp)
  80102d:	e8 ce 98 00 00       	call   80a900 <sys_sem_signal>
}
  801032:	83 c4 14             	add    $0x14,%esp
  801035:	5b                   	pop    %ebx
  801036:	5d                   	pop    %ebp
  801037:	c3                   	ret    

00801038 <lwip_socket_init>:
 * Initialize this module. This function has to be called before any other
 * functions in this module!
 */
void
lwip_socket_init(void)
{
  801038:	55                   	push   %ebp
  801039:	89 e5                	mov    %esp,%ebp
  80103b:	83 ec 18             	sub    $0x18,%esp
  socksem   = sys_sem_new(1);
  80103e:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  801045:	e8 d4 95 00 00       	call   80a61e <sys_sem_new>
  80104a:	a3 64 60 81 00       	mov    %eax,0x816064
  selectsem = sys_sem_new(1);
  80104f:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  801056:	e8 c3 95 00 00       	call   80a61e <sys_sem_new>
  80105b:	a3 60 60 81 00       	mov    %eax,0x816060
}
  801060:	c9                   	leave  
  801061:	c3                   	ret    

00801062 <lwip_accept>:
 * Exceptions are documented!
 */

int
lwip_accept(int s, struct sockaddr *addr, socklen_t *addrlen)
{
  801062:	55                   	push   %ebp
  801063:	89 e5                	mov    %esp,%ebp
  801065:	57                   	push   %edi
  801066:	56                   	push   %esi
  801067:	53                   	push   %ebx
  801068:	83 ec 4c             	sub    $0x4c,%esp
  80106b:	8b 75 10             	mov    0x10(%ebp),%esi
  int newsock;
  struct sockaddr_in sin;
  err_t err;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d)...\n", s));
  sock = get_socket(s);
  80106e:	8b 45 08             	mov    0x8(%ebp),%eax
  801071:	e8 ca f8 ff ff       	call   800940 <get_socket>
  801076:	89 c7                	mov    %eax,%edi
  if (!sock)
  801078:	85 c0                	test   %eax,%eax
  80107a:	0f 84 9b 01 00 00    	je     80121b <lwip_accept+0x1b9>
    return -1;

  newconn = netconn_accept(sock->conn);
  801080:	8b 00                	mov    (%eax),%eax
  801082:	89 04 24             	mov    %eax,(%esp)
  801085:	e8 3c a8 00 00       	call   80b8c6 <netconn_accept>
  80108a:	89 c3                	mov    %eax,%ebx
  if (!newconn) {
  80108c:	85 c0                	test   %eax,%eax
  80108e:	75 2b                	jne    8010bb <lwip_accept+0x59>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d) failed, err=%d\n", s, sock->conn->err));
    sock_set_errno(sock, err_to_errno(sock->conn->err));
  801090:	8b 07                	mov    (%edi),%eax
  801092:	0f be 50 0c          	movsbl 0xc(%eax),%edx
  801096:	f7 da                	neg    %edx
  801098:	b8 05 00 00 00       	mov    $0x5,%eax
  80109d:	83 fa 0e             	cmp    $0xe,%edx
  8010a0:	77 07                	ja     8010a9 <lwip_accept+0x47>
  8010a2:	8b 04 95 40 1f 81 00 	mov    0x811f40(,%edx,4),%eax
  8010a9:	89 47 10             	mov    %eax,0x10(%edi)
  8010ac:	a3 00 c2 b3 00       	mov    %eax,0xb3c200
    return -1;
  8010b1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8010b6:	e9 65 01 00 00       	jmp    801220 <lwip_accept+0x1be>
  }

  /* get the IP address and port of the remote host */
  err = netconn_peer(newconn, &naddr, &port);
  8010bb:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  8010c2:	00 
  8010c3:	8d 45 e2             	lea    -0x1e(%ebp),%eax
  8010c6:	89 44 24 08          	mov    %eax,0x8(%esp)
  8010ca:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  8010cd:	89 44 24 04          	mov    %eax,0x4(%esp)
  8010d1:	89 1c 24             	mov    %ebx,(%esp)
  8010d4:	e8 14 a6 00 00       	call   80b6ed <netconn_getaddr>
  8010d9:	88 45 c4             	mov    %al,-0x3c(%ebp)
  if (err != ERR_OK) {
  8010dc:	84 c0                	test   %al,%al
  8010de:	74 31                	je     801111 <lwip_accept+0xaf>
    netconn_delete(newconn);
  8010e0:	89 1c 24             	mov    %ebx,(%esp)
  8010e3:	e8 9b a5 00 00       	call   80b683 <netconn_delete>
    sock_set_errno(sock, err_to_errno(err));
  8010e8:	0f be 55 c4          	movsbl -0x3c(%ebp),%edx
  8010ec:	f7 da                	neg    %edx
  8010ee:	b8 05 00 00 00       	mov    $0x5,%eax
  8010f3:	83 fa 0e             	cmp    $0xe,%edx
  8010f6:	77 07                	ja     8010ff <lwip_accept+0x9d>
  8010f8:	8b 04 95 40 1f 81 00 	mov    0x811f40(,%edx,4),%eax
  8010ff:	89 47 10             	mov    %eax,0x10(%edi)
  801102:	a3 00 c2 b3 00       	mov    %eax,0xb3c200
    return -1;
  801107:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80110c:	e9 0f 01 00 00       	jmp    801220 <lwip_accept+0x1be>
  }

  memset(&sin, 0, sizeof(sin));
  801111:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%esp)
  801118:	00 
  801119:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  801120:	00 
  801121:	8d 45 d0             	lea    -0x30(%ebp),%eax
  801124:	89 04 24             	mov    %eax,(%esp)
  801127:	e8 bb e7 00 00       	call   80f8e7 <memset>
  sin.sin_len = sizeof(sin);
  80112c:	c6 45 d0 10          	movb   $0x10,-0x30(%ebp)
  sin.sin_family = AF_INET;
  801130:	c6 45 d1 02          	movb   $0x2,-0x2f(%ebp)
  sin.sin_port = htons(port);
  801134:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  801138:	89 04 24             	mov    %eax,(%esp)
  80113b:	e8 36 6c 00 00       	call   807d76 <htons>
  801140:	66 89 45 d2          	mov    %ax,-0x2e(%ebp)
  sin.sin_addr.s_addr = naddr.addr;
  801144:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  801147:	89 45 d4             	mov    %eax,-0x2c(%ebp)

  if (*addrlen > sizeof(sin))
  80114a:	83 3e 10             	cmpl   $0x10,(%esi)
  80114d:	76 06                	jbe    801155 <lwip_accept+0xf3>
    *addrlen = sizeof(sin);
  80114f:	c7 06 10 00 00 00    	movl   $0x10,(%esi)

  SMEMCPY(addr, &sin, *addrlen);
  801155:	8b 06                	mov    (%esi),%eax
  801157:	89 44 24 08          	mov    %eax,0x8(%esp)
  80115b:	8d 45 d0             	lea    -0x30(%ebp),%eax
  80115e:	89 44 24 04          	mov    %eax,0x4(%esp)
  801162:	8b 45 0c             	mov    0xc(%ebp),%eax
  801165:	89 04 24             	mov    %eax,(%esp)
  801168:	e8 2f e8 00 00       	call   80f99c <memcpy>

  newsock = alloc_socket(newconn);
  80116d:	89 d8                	mov    %ebx,%eax
  80116f:	e8 87 fb ff ff       	call   800cfb <alloc_socket>
  801174:	89 c6                	mov    %eax,%esi
  if (newsock == -1) {
  801176:	83 f8 ff             	cmp    $0xffffffff,%eax
  801179:	75 23                	jne    80119e <lwip_accept+0x13c>
    netconn_delete(newconn);
  80117b:	89 1c 24             	mov    %ebx,(%esp)
  80117e:	e8 00 a5 00 00       	call   80b683 <netconn_delete>
    sock_set_errno(sock, ENFILE);
  801183:	c7 47 10 17 00 00 00 	movl   $0x17,0x10(%edi)
  80118a:	c7 05 00 c2 b3 00 17 	movl   $0x17,0xb3c200
  801191:	00 00 00 
    return -1;
  801194:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801199:	e9 82 00 00 00       	jmp    801220 <lwip_accept+0x1be>
  }
  LWIP_ASSERT("invalid socket index", (newsock >= 0) && (newsock < NUM_SOCKETS));
  80119e:	83 f8 1f             	cmp    $0x1f,%eax
  8011a1:	76 1c                	jbe    8011bf <lwip_accept+0x15d>
  8011a3:	c7 44 24 08 9b 1e 81 	movl   $0x811e9b,0x8(%esp)
  8011aa:	00 
  8011ab:	c7 44 24 04 25 01 00 	movl   $0x125,0x4(%esp)
  8011b2:	00 
  8011b3:	c7 04 24 78 1e 81 00 	movl   $0x811e78,(%esp)
  8011ba:	e8 bb de 00 00       	call   80f07a <_panic>
  newconn->callback = event_callback;
  8011bf:	c7 43 2c 72 0b 80 00 	movl   $0x800b72,0x2c(%ebx)
  nsock = &sockets[newsock];
  8011c6:	8d 04 80             	lea    (%eax,%eax,4),%eax
  8011c9:	8d 04 85 80 60 81 00 	lea    0x816080(,%eax,4),%eax
  8011d0:	89 45 c4             	mov    %eax,-0x3c(%ebp)
  LWIP_ASSERT("invalid socket pointer", nsock != NULL);

  sys_sem_wait(socksem);
  8011d3:	a1 64 60 81 00       	mov    0x816064,%eax
  8011d8:	89 04 24             	mov    %eax,(%esp)
  8011db:	e8 48 45 00 00       	call   805728 <sys_sem_wait>
  /* See event_callback: If data comes in right away after an accept, even
   * though the server task might not have created a new socket yet.
   * In that case, newconn->socket is counted down (newconn->socket--),
   * so nsock->rcvevent is >= 1 here!
   */
  nsock->rcvevent += -1 - newconn->socket;
  8011e0:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
  8011e3:	0f b7 41 0a          	movzwl 0xa(%ecx),%eax
  8011e7:	66 89 45 c4          	mov    %ax,-0x3c(%ebp)
  8011eb:	83 e8 01             	sub    $0x1,%eax
  8011ee:	66 2b 43 1c          	sub    0x1c(%ebx),%ax
  8011f2:	66 89 41 0a          	mov    %ax,0xa(%ecx)
  newconn->socket = newsock;
  8011f6:	89 73 1c             	mov    %esi,0x1c(%ebx)
  sys_sem_signal(socksem);
  8011f9:	a1 64 60 81 00       	mov    0x816064,%eax
  8011fe:	89 04 24             	mov    %eax,(%esp)
  801201:	e8 fa 96 00 00       	call   80a900 <sys_sem_signal>

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d) returning new sock=%d addr=", s, newsock));
  //ip_addr_debug_print(SOCKETS_DEBUG, &naddr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u\n", port));

  sock_set_errno(sock, 0);
  801206:	c7 47 10 00 00 00 00 	movl   $0x0,0x10(%edi)
  80120d:	c7 05 00 c2 b3 00 00 	movl   $0x0,0xb3c200
  801214:	00 00 00 
  return newsock;
  801217:	89 f0                	mov    %esi,%eax
  801219:	eb 05                	jmp    801220 <lwip_accept+0x1be>
  err_t err;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d)...\n", s));
  sock = get_socket(s);
  if (!sock)
    return -1;
  80121b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  //ip_addr_debug_print(SOCKETS_DEBUG, &naddr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u\n", port));

  sock_set_errno(sock, 0);
  return newsock;
}
  801220:	83 c4 4c             	add    $0x4c,%esp
  801223:	5b                   	pop    %ebx
  801224:	5e                   	pop    %esi
  801225:	5f                   	pop    %edi
  801226:	5d                   	pop    %ebp
  801227:	c3                   	ret    

00801228 <lwip_bind>:

int
lwip_bind(int s, struct sockaddr *name, socklen_t namelen)
{
  801228:	55                   	push   %ebp
  801229:	89 e5                	mov    %esp,%ebp
  80122b:	56                   	push   %esi
  80122c:	53                   	push   %ebx
  80122d:	83 ec 20             	sub    $0x20,%esp
  801230:	8b 75 0c             	mov    0xc(%ebp),%esi
  struct lwip_socket *sock;
  struct ip_addr local_addr;
  u16_t local_port;
  err_t err;

  sock = get_socket(s);
  801233:	8b 45 08             	mov    0x8(%ebp),%eax
  801236:	e8 05 f7 ff ff       	call   800940 <get_socket>
  80123b:	89 c3                	mov    %eax,%ebx
  if (!sock)
  80123d:	85 c0                	test   %eax,%eax
  80123f:	0f 84 94 00 00 00    	je     8012d9 <lwip_bind+0xb1>
    return -1;

  LWIP_ERROR("lwip_bind: invalid address", ((namelen == sizeof(struct sockaddr_in)) &&
  801245:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
  801249:	75 06                	jne    801251 <lwip_bind+0x29>
  80124b:	80 7e 01 02          	cmpb   $0x2,0x1(%esi)
  80124f:	74 1c                	je     80126d <lwip_bind+0x45>
  801251:	c7 44 24 08 b0 1e 81 	movl   $0x811eb0,0x8(%esp)
  801258:	00 
  801259:	c7 44 24 04 4a 01 00 	movl   $0x14a,0x4(%esp)
  801260:	00 
  801261:	c7 04 24 78 1e 81 00 	movl   $0x811e78,(%esp)
  801268:	e8 0d de 00 00       	call   80f07a <_panic>
             ((((struct sockaddr_in *)name)->sin_family) == AF_INET)),
             sock_set_errno(sock, err_to_errno(ERR_ARG)); return -1;);

  local_addr.addr = ((struct sockaddr_in *)name)->sin_addr.s_addr;
  80126d:	8b 46 04             	mov    0x4(%esi),%eax
  801270:	89 45 f4             	mov    %eax,-0xc(%ebp)

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d, addr=", s));
  //ip_addr_debug_print(SOCKETS_DEBUG, &local_addr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u)\n", ntohs(local_port)));

  err = netconn_bind(sock->conn, &local_addr, ntohs(local_port));
  801273:	0f b7 46 02          	movzwl 0x2(%esi),%eax
  801277:	89 04 24             	mov    %eax,(%esp)
  80127a:	e8 04 6b 00 00       	call   807d83 <ntohs>
  80127f:	0f b7 c0             	movzwl %ax,%eax
  801282:	89 44 24 08          	mov    %eax,0x8(%esp)
  801286:	8d 45 f4             	lea    -0xc(%ebp),%eax
  801289:	89 44 24 04          	mov    %eax,0x4(%esp)
  80128d:	8b 03                	mov    (%ebx),%eax
  80128f:	89 04 24             	mov    %eax,(%esp)
  801292:	e8 f1 a4 00 00       	call   80b788 <netconn_bind>

  if (err != ERR_OK) {
  801297:	84 c0                	test   %al,%al
  801299:	74 26                	je     8012c1 <lwip_bind+0x99>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d) failed, err=%d\n", s, err));
    sock_set_errno(sock, err_to_errno(err));
  80129b:	0f be c0             	movsbl %al,%eax
  80129e:	f7 d8                	neg    %eax
  8012a0:	ba 05 00 00 00       	mov    $0x5,%edx
  8012a5:	83 f8 0e             	cmp    $0xe,%eax
  8012a8:	77 07                	ja     8012b1 <lwip_bind+0x89>
  8012aa:	8b 14 85 40 1f 81 00 	mov    0x811f40(,%eax,4),%edx
  8012b1:	89 53 10             	mov    %edx,0x10(%ebx)
  8012b4:	89 15 00 c2 b3 00    	mov    %edx,0xb3c200
    return -1;
  8012ba:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8012bf:	eb 1d                	jmp    8012de <lwip_bind+0xb6>
  }

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d) succeeded\n", s));
  sock_set_errno(sock, 0);
  8012c1:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  8012c8:	c7 05 00 c2 b3 00 00 	movl   $0x0,0xb3c200
  8012cf:	00 00 00 
  return 0;
  8012d2:	b8 00 00 00 00       	mov    $0x0,%eax
  8012d7:	eb 05                	jmp    8012de <lwip_bind+0xb6>
  u16_t local_port;
  err_t err;

  sock = get_socket(s);
  if (!sock)
    return -1;
  8012d9:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  }

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d) succeeded\n", s));
  sock_set_errno(sock, 0);
  return 0;
}
  8012de:	83 c4 20             	add    $0x20,%esp
  8012e1:	5b                   	pop    %ebx
  8012e2:	5e                   	pop    %esi
  8012e3:	5d                   	pop    %ebp
  8012e4:	c3                   	ret    

008012e5 <lwip_close>:

int
lwip_close(int s)
{
  8012e5:	55                   	push   %ebp
  8012e6:	89 e5                	mov    %esp,%ebp
  8012e8:	53                   	push   %ebx
  8012e9:	83 ec 14             	sub    $0x14,%esp
  struct lwip_socket *sock;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_close(%d)\n", s));

  sock = get_socket(s);
  8012ec:	8b 45 08             	mov    0x8(%ebp),%eax
  8012ef:	e8 4c f6 ff ff       	call   800940 <get_socket>
  8012f4:	89 c3                	mov    %eax,%ebx
  if (!sock) {
  8012f6:	85 c0                	test   %eax,%eax
  8012f8:	74 5e                	je     801358 <lwip_close+0x73>
    return -1;
  }

  netconn_delete(sock->conn);
  8012fa:	8b 00                	mov    (%eax),%eax
  8012fc:	89 04 24             	mov    %eax,(%esp)
  8012ff:	e8 7f a3 00 00       	call   80b683 <netconn_delete>

  sys_sem_wait(socksem);
  801304:	a1 64 60 81 00       	mov    0x816064,%eax
  801309:	89 04 24             	mov    %eax,(%esp)
  80130c:	e8 17 44 00 00       	call   805728 <sys_sem_wait>
  if (sock->lastdata) {
  801311:	8b 43 04             	mov    0x4(%ebx),%eax
  801314:	85 c0                	test   %eax,%eax
  801316:	74 08                	je     801320 <lwip_close+0x3b>
    netbuf_delete(sock->lastdata);
  801318:	89 04 24             	mov    %eax,(%esp)
  80131b:	e8 2c 15 00 00       	call   80284c <netbuf_delete>
  }
  sock->lastdata   = NULL;
  801320:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  sock->lastoffset = 0;
  801327:	66 c7 43 08 00 00    	movw   $0x0,0x8(%ebx)
  sock->conn       = NULL;
  80132d:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
  sock_set_errno(sock, 0);
  801333:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  80133a:	c7 05 00 c2 b3 00 00 	movl   $0x0,0xb3c200
  801341:	00 00 00 
  sys_sem_signal(socksem);
  801344:	a1 64 60 81 00       	mov    0x816064,%eax
  801349:	89 04 24             	mov    %eax,(%esp)
  80134c:	e8 af 95 00 00       	call   80a900 <sys_sem_signal>
  return 0;
  801351:	b8 00 00 00 00       	mov    $0x0,%eax
  801356:	eb 05                	jmp    80135d <lwip_close+0x78>

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_close(%d)\n", s));

  sock = get_socket(s);
  if (!sock) {
    return -1;
  801358:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  sock->lastoffset = 0;
  sock->conn       = NULL;
  sock_set_errno(sock, 0);
  sys_sem_signal(socksem);
  return 0;
}
  80135d:	83 c4 14             	add    $0x14,%esp
  801360:	5b                   	pop    %ebx
  801361:	5d                   	pop    %ebp
  801362:	c3                   	ret    

00801363 <lwip_connect>:

int
lwip_connect(int s, const struct sockaddr *name, socklen_t namelen)
{
  801363:	55                   	push   %ebp
  801364:	89 e5                	mov    %esp,%ebp
  801366:	56                   	push   %esi
  801367:	53                   	push   %ebx
  801368:	83 ec 20             	sub    $0x20,%esp
  80136b:	8b 75 0c             	mov    0xc(%ebp),%esi
  struct lwip_socket *sock;
  err_t err;

  sock = get_socket(s);
  80136e:	8b 45 08             	mov    0x8(%ebp),%eax
  801371:	e8 ca f5 ff ff       	call   800940 <get_socket>
  801376:	89 c3                	mov    %eax,%ebx
  if (!sock)
  801378:	85 c0                	test   %eax,%eax
  80137a:	0f 84 94 00 00 00    	je     801414 <lwip_connect+0xb1>
    return -1;

  LWIP_ERROR("lwip_connect: invalid address", ((namelen == sizeof(struct sockaddr_in)) &&
  801380:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
  801384:	75 06                	jne    80138c <lwip_connect+0x29>
  801386:	80 7e 01 02          	cmpb   $0x2,0x1(%esi)
  80138a:	74 1c                	je     8013a8 <lwip_connect+0x45>
  80138c:	c7 44 24 08 cb 1e 81 	movl   $0x811ecb,0x8(%esp)
  801393:	00 
  801394:	c7 44 24 04 86 01 00 	movl   $0x186,0x4(%esp)
  80139b:	00 
  80139c:	c7 04 24 78 1e 81 00 	movl   $0x811e78,(%esp)
  8013a3:	e8 d2 dc 00 00       	call   80f07a <_panic>
    err = netconn_disconnect(sock->conn);
  } else {
    struct ip_addr remote_addr;
    u16_t remote_port;

    remote_addr.addr = ((struct sockaddr_in *)name)->sin_addr.s_addr;
  8013a8:	8b 46 04             	mov    0x4(%esi),%eax
  8013ab:	89 45 f4             	mov    %eax,-0xc(%ebp)

    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d, addr=", s));
    //ip_addr_debug_print(SOCKETS_DEBUG, &remote_addr);
    LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u)\n", ntohs(remote_port)));

    err = netconn_connect(sock->conn, &remote_addr, ntohs(remote_port));
  8013ae:	0f b7 46 02          	movzwl 0x2(%esi),%eax
  8013b2:	89 04 24             	mov    %eax,(%esp)
  8013b5:	e8 c9 69 00 00       	call   807d83 <ntohs>
  8013ba:	0f b7 c0             	movzwl %ax,%eax
  8013bd:	89 44 24 08          	mov    %eax,0x8(%esp)
  8013c1:	8d 45 f4             	lea    -0xc(%ebp),%eax
  8013c4:	89 44 24 04          	mov    %eax,0x4(%esp)
  8013c8:	8b 03                	mov    (%ebx),%eax
  8013ca:	89 04 24             	mov    %eax,(%esp)
  8013cd:	e8 0c a4 00 00       	call   80b7de <netconn_connect>
  }

  if (err != ERR_OK) {
  8013d2:	84 c0                	test   %al,%al
  8013d4:	74 26                	je     8013fc <lwip_connect+0x99>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d) failed, err=%d\n", s, err));
    sock_set_errno(sock, err_to_errno(err));
  8013d6:	0f be c0             	movsbl %al,%eax
  8013d9:	f7 d8                	neg    %eax
  8013db:	ba 05 00 00 00       	mov    $0x5,%edx
  8013e0:	83 f8 0e             	cmp    $0xe,%eax
  8013e3:	77 07                	ja     8013ec <lwip_connect+0x89>
  8013e5:	8b 14 85 40 1f 81 00 	mov    0x811f40(,%eax,4),%edx
  8013ec:	89 53 10             	mov    %edx,0x10(%ebx)
  8013ef:	89 15 00 c2 b3 00    	mov    %edx,0xb3c200
    return -1;
  8013f5:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8013fa:	eb 1d                	jmp    801419 <lwip_connect+0xb6>
  }

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d) succeeded\n", s));
  sock_set_errno(sock, 0);
  8013fc:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  801403:	c7 05 00 c2 b3 00 00 	movl   $0x0,0xb3c200
  80140a:	00 00 00 
  return 0;
  80140d:	b8 00 00 00 00       	mov    $0x0,%eax
  801412:	eb 05                	jmp    801419 <lwip_connect+0xb6>
  struct lwip_socket *sock;
  err_t err;

  sock = get_socket(s);
  if (!sock)
    return -1;
  801414:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  }

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d) succeeded\n", s));
  sock_set_errno(sock, 0);
  return 0;
}
  801419:	83 c4 20             	add    $0x20,%esp
  80141c:	5b                   	pop    %ebx
  80141d:	5e                   	pop    %esi
  80141e:	5d                   	pop    %ebp
  80141f:	c3                   	ret    

00801420 <lwip_listen>:
 * @param backlog (ATTENTION: need TCP_LISTEN_BACKLOG=1)
 * @return 0 on success, non-zero on failure
 */
int
lwip_listen(int s, int backlog)
{
  801420:	55                   	push   %ebp
  801421:	89 e5                	mov    %esp,%ebp
  801423:	56                   	push   %esi
  801424:	53                   	push   %ebx
  801425:	83 ec 10             	sub    $0x10,%esp
  801428:	8b 75 0c             	mov    0xc(%ebp),%esi
  struct lwip_socket *sock;
  err_t err;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_listen(%d, backlog=%d)\n", s, backlog));

  sock = get_socket(s);
  80142b:	8b 45 08             	mov    0x8(%ebp),%eax
  80142e:	e8 0d f5 ff ff       	call   800940 <get_socket>
  801433:	89 c3                	mov    %eax,%ebx
  if (!sock)
  801435:	85 c0                	test   %eax,%eax
  801437:	74 68                	je     8014a1 <lwip_listen+0x81>
  801439:	85 f6                	test   %esi,%esi
  80143b:	b8 00 00 00 00       	mov    $0x0,%eax
  801440:	0f 48 f0             	cmovs  %eax,%esi
  801443:	81 fe ff 00 00 00    	cmp    $0xff,%esi
  801449:	b0 ff                	mov    $0xff,%al
  80144b:	0f 4e c6             	cmovle %esi,%eax
  }
  if (backlog > 0xff) {
    backlog = 0xff;
  }

  err = netconn_listen_with_backlog(sock->conn, backlog);
  80144e:	0f b6 f0             	movzbl %al,%esi
  801451:	89 74 24 04          	mov    %esi,0x4(%esp)
  801455:	8b 03                	mov    (%ebx),%eax
  801457:	89 04 24             	mov    %eax,(%esp)
  80145a:	e8 1e a4 00 00       	call   80b87d <netconn_listen_with_backlog>

  if (err != ERR_OK) {
  80145f:	84 c0                	test   %al,%al
  801461:	74 26                	je     801489 <lwip_listen+0x69>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_listen(%d) failed, err=%d\n", s, err));
    sock_set_errno(sock, err_to_errno(err));
  801463:	0f be c0             	movsbl %al,%eax
  801466:	f7 d8                	neg    %eax
  801468:	ba 05 00 00 00       	mov    $0x5,%edx
  80146d:	83 f8 0e             	cmp    $0xe,%eax
  801470:	77 07                	ja     801479 <lwip_listen+0x59>
  801472:	8b 14 85 40 1f 81 00 	mov    0x811f40(,%eax,4),%edx
  801479:	89 53 10             	mov    %edx,0x10(%ebx)
  80147c:	89 15 00 c2 b3 00    	mov    %edx,0xb3c200
    return -1;
  801482:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801487:	eb 1d                	jmp    8014a6 <lwip_listen+0x86>
  }

  sock_set_errno(sock, 0);
  801489:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  801490:	c7 05 00 c2 b3 00 00 	movl   $0x0,0xb3c200
  801497:	00 00 00 
  return 0;
  80149a:	b8 00 00 00 00       	mov    $0x0,%eax
  80149f:	eb 05                	jmp    8014a6 <lwip_listen+0x86>

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_listen(%d, backlog=%d)\n", s, backlog));

  sock = get_socket(s);
  if (!sock)
    return -1;
  8014a1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    return -1;
  }

  sock_set_errno(sock, 0);
  return 0;
}
  8014a6:	83 c4 10             	add    $0x10,%esp
  8014a9:	5b                   	pop    %ebx
  8014aa:	5e                   	pop    %esi
  8014ab:	5d                   	pop    %ebp
  8014ac:	c3                   	ret    

008014ad <lwip_recvfrom>:

int
lwip_recvfrom(int s, void *mem, int len, unsigned int flags,
        struct sockaddr *from, socklen_t *fromlen)
{
  8014ad:	55                   	push   %ebp
  8014ae:	89 e5                	mov    %esp,%ebp
  8014b0:	57                   	push   %edi
  8014b1:	56                   	push   %esi
  8014b2:	53                   	push   %ebx
  8014b3:	83 ec 5c             	sub    $0x5c,%esp
  8014b6:	8b 5d 14             	mov    0x14(%ebp),%ebx
  struct ip_addr     *addr;
  u16_t               port;
  u8_t                done = 0;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d, %p, %d, 0x%x, ..)\n", s, mem, len, flags));
  sock = get_socket(s);
  8014b9:	8b 45 08             	mov    0x8(%ebp),%eax
  8014bc:	e8 7f f4 ff ff       	call   800940 <get_socket>
  8014c1:	89 c7                	mov    %eax,%edi
  if (!sock)
  8014c3:	85 c0                	test   %eax,%eax
  8014c5:	0f 84 14 02 00 00    	je     8016df <lwip_recvfrom+0x232>
  8014cb:	66 c7 45 c4 00 00    	movw   $0x0,-0x3c(%ebp)
    /* Check if there is data left from the last recv operation. */
    if (sock->lastdata) {
      buf = sock->lastdata;
    } else {
      /* If this is non-blocking call, then check first */
      if (((flags & MSG_DONTWAIT) || (sock->flags & O_NONBLOCK)) && !sock->rcvevent) {
  8014d1:	89 d8                	mov    %ebx,%eax
  8014d3:	83 e0 08             	and    $0x8,%eax
  8014d6:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    } else {
      done = 1;
    }

    /* If we don't peek the incoming message... */
    if ((flags & MSG_PEEK)==0) {
  8014d9:	83 e3 01             	and    $0x1,%ebx
  8014dc:	89 5d b8             	mov    %ebx,-0x48(%ebp)
    return -1;

  do {
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: top while sock->lastdata=%p\n", (void*)sock->lastdata));
    /* Check if there is data left from the last recv operation. */
    if (sock->lastdata) {
  8014df:	8b 77 04             	mov    0x4(%edi),%esi
  8014e2:	85 f6                	test   %esi,%esi
  8014e4:	75 7d                	jne    801563 <lwip_recvfrom+0xb6>
      buf = sock->lastdata;
    } else {
      /* If this is non-blocking call, then check first */
      if (((flags & MSG_DONTWAIT) || (sock->flags & O_NONBLOCK)) && !sock->rcvevent) {
  8014e6:	83 7d b4 00          	cmpl   $0x0,-0x4c(%ebp)
  8014ea:	75 06                	jne    8014f2 <lwip_recvfrom+0x45>
  8014ec:	f6 47 0f 08          	testb  $0x8,0xf(%edi)
  8014f0:	74 22                	je     801514 <lwip_recvfrom+0x67>
  8014f2:	66 83 7f 0a 00       	cmpw   $0x0,0xa(%edi)
  8014f7:	75 1b                	jne    801514 <lwip_recvfrom+0x67>
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d): returning EWOULDBLOCK\n", s));
        sock_set_errno(sock, EWOULDBLOCK);
  8014f9:	c7 47 10 0b 00 00 00 	movl   $0xb,0x10(%edi)
  801500:	c7 05 00 c2 b3 00 0b 	movl   $0xb,0xb3c200
  801507:	00 00 00 
        return -1;
  80150a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80150f:	e9 d0 01 00 00       	jmp    8016e4 <lwip_recvfrom+0x237>
      }

      /* No data was left from the previous operation, so we try to get
      some from the network. */
      sock->lastdata = buf = netconn_recv(sock->conn);
  801514:	8b 07                	mov    (%edi),%eax
  801516:	89 04 24             	mov    %eax,(%esp)
  801519:	e8 32 a4 00 00       	call   80b950 <netconn_recv>
  80151e:	89 c6                	mov    %eax,%esi
  801520:	89 47 04             	mov    %eax,0x4(%edi)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: netconn_recv netbuf=%p\n", (void*)buf));

      if (!buf) {
  801523:	85 c0                	test   %eax,%eax
  801525:	75 3c                	jne    801563 <lwip_recvfrom+0xb6>
        /* We should really do some error checking here. */
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d): buf == NULL!\n", s));
        sock_set_errno(sock, (((sock->conn->pcb.ip!=NULL) && (sock->conn->err==ERR_OK))?ETIMEDOUT:err_to_errno(sock->conn->err)));
  801527:	8b 17                	mov    (%edi),%edx
  801529:	83 7a 08 00          	cmpl   $0x0,0x8(%edx)
  80152d:	74 0b                	je     80153a <lwip_recvfrom+0x8d>
  80152f:	b8 6e 00 00 00       	mov    $0x6e,%eax
  801534:	80 7a 0c 00          	cmpb   $0x0,0xc(%edx)
  801538:	74 17                	je     801551 <lwip_recvfrom+0xa4>
  80153a:	0f be 52 0c          	movsbl 0xc(%edx),%edx
  80153e:	f7 da                	neg    %edx
  801540:	b8 05 00 00 00       	mov    $0x5,%eax
  801545:	83 fa 0e             	cmp    $0xe,%edx
  801548:	77 07                	ja     801551 <lwip_recvfrom+0xa4>
  80154a:	8b 04 95 40 1f 81 00 	mov    0x811f40(,%edx,4),%eax
  801551:	89 47 10             	mov    %eax,0x10(%edi)
  801554:	a3 00 c2 b3 00       	mov    %eax,0xb3c200
        return 0;
  801559:	b8 00 00 00 00       	mov    $0x0,%eax
  80155e:	e9 81 01 00 00       	jmp    8016e4 <lwip_recvfrom+0x237>
      }
    }

    buflen = netbuf_len(buf);
  801563:	8b 06                	mov    (%esi),%eax
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: buflen=%d len=%d off=%d sock->lastoffset=%d\n", buflen, len, off, sock->lastoffset));

    buflen -= sock->lastoffset;
  801565:	0f b7 57 08          	movzwl 0x8(%edi),%edx
  801569:	0f b7 58 08          	movzwl 0x8(%eax),%ebx
  80156d:	29 d3                	sub    %edx,%ebx

    if (len > buflen) {
  80156f:	0f b7 cb             	movzwl %bx,%ecx
  801572:	89 4d bc             	mov    %ecx,-0x44(%ebp)
      copylen = buflen;
    } else {
      copylen = len;
  801575:	39 4d 10             	cmp    %ecx,0x10(%ebp)
  801578:	66 0f 4e 5d 10       	cmovle 0x10(%ebp),%bx
    }

    /* copy the contents of the received buffer into
    the supplied memory pointer mem */
    netbuf_copy_partial(buf, (u8_t*)mem + off, copylen, sock->lastoffset);
  80157d:	0f b7 cb             	movzwl %bx,%ecx
  801580:	89 4d c0             	mov    %ecx,-0x40(%ebp)
  801583:	0f b7 d2             	movzwl %dx,%edx
  801586:	89 54 24 0c          	mov    %edx,0xc(%esp)
  80158a:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  80158e:	0f b7 55 c4          	movzwl -0x3c(%ebp),%edx
  801592:	03 55 0c             	add    0xc(%ebp),%edx
  801595:	89 54 24 04          	mov    %edx,0x4(%esp)
  801599:	89 04 24             	mov    %eax,(%esp)
  80159c:	e8 fe 3f 00 00       	call   80559f <pbuf_copy_partial>

    off += copylen;
  8015a1:	66 01 5d c4          	add    %bx,-0x3c(%ebp)

    if (netconn_type(sock->conn) == NETCONN_TCP) {
  8015a5:	8b 07                	mov    (%edi),%eax
  8015a7:	89 04 24             	mov    %eax,(%esp)
  8015aa:	e8 11 a1 00 00       	call   80b6c0 <netconn_type>
      len -= copylen;
      if ( (len <= 0) || (buf->p->flags & PBUF_FLAG_PUSH) || !sock->rcvevent) {
        done = 1;
      }
    } else {
      done = 1;
  8015af:	c6 45 c7 01          	movb   $0x1,-0x39(%ebp)
    the supplied memory pointer mem */
    netbuf_copy_partial(buf, (u8_t*)mem + off, copylen, sock->lastoffset);

    off += copylen;

    if (netconn_type(sock->conn) == NETCONN_TCP) {
  8015b3:	83 f8 10             	cmp    $0x10,%eax
  8015b6:	75 1d                	jne    8015d5 <lwip_recvfrom+0x128>
      len -= copylen;
  8015b8:	8b 45 c0             	mov    -0x40(%ebp),%eax
  8015bb:	29 45 10             	sub    %eax,0x10(%ebp)
      if ( (len <= 0) || (buf->p->flags & PBUF_FLAG_PUSH) || !sock->rcvevent) {
  8015be:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  8015c2:	7e 11                	jle    8015d5 <lwip_recvfrom+0x128>
  8015c4:	8b 06                	mov    (%esi),%eax
  8015c6:	f6 40 0d 01          	testb  $0x1,0xd(%eax)
  8015ca:	75 09                	jne    8015d5 <lwip_recvfrom+0x128>
  8015cc:	66 83 7f 0a 00       	cmpw   $0x0,0xa(%edi)
  8015d1:	0f 94 45 c7          	sete   -0x39(%ebp)
    } else {
      done = 1;
    }

    /* If we don't peek the incoming message... */
    if ((flags & MSG_PEEK)==0) {
  8015d5:	83 7d b8 00          	cmpl   $0x0,-0x48(%ebp)
  8015d9:	75 39                	jne    801614 <lwip_recvfrom+0x167>
      /* If this is a TCP socket, check if there is data left in the
         buffer. If so, it should be saved in the sock structure for next
         time around. */
      if ((sock->conn->type == NETCONN_TCP) && (buflen - copylen > 0)) {
  8015db:	8b 07                	mov    (%edi),%eax
  8015dd:	83 38 10             	cmpl   $0x10,(%eax)
  8015e0:	75 13                	jne    8015f5 <lwip_recvfrom+0x148>
  8015e2:	8b 45 bc             	mov    -0x44(%ebp),%eax
  8015e5:	2b 45 c0             	sub    -0x40(%ebp),%eax
  8015e8:	85 c0                	test   %eax,%eax
  8015ea:	7e 09                	jle    8015f5 <lwip_recvfrom+0x148>
        sock->lastdata = buf;
  8015ec:	89 77 04             	mov    %esi,0x4(%edi)
        sock->lastoffset += copylen;
  8015ef:	66 01 5f 08          	add    %bx,0x8(%edi)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: lastdata now netbuf=%p\n", (void*)buf));
  8015f3:	eb 15                	jmp    80160a <lwip_recvfrom+0x15d>
      } else {
        sock->lastdata = NULL;
  8015f5:	c7 47 04 00 00 00 00 	movl   $0x0,0x4(%edi)
        sock->lastoffset = 0;
  8015fc:	66 c7 47 08 00 00    	movw   $0x0,0x8(%edi)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: deleting netbuf=%p\n", (void*)buf));
        netbuf_delete(buf);
  801602:	89 34 24             	mov    %esi,(%esp)
  801605:	e8 42 12 00 00       	call   80284c <netbuf_delete>
      }
    } else {
      done = 1;
    }
  } while (!done);
  80160a:	80 7d c7 00          	cmpb   $0x0,-0x39(%ebp)
  80160e:	0f 84 cb fe ff ff    	je     8014df <lwip_recvfrom+0x32>

  /* Check to see from where the data was.*/
  if (from && fromlen) {
  801614:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
  801618:	0f 84 aa 00 00 00    	je     8016c8 <lwip_recvfrom+0x21b>
  80161e:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  801622:	0f 84 a0 00 00 00    	je     8016c8 <lwip_recvfrom+0x21b>
    struct sockaddr_in sin;

    if (netconn_type(sock->conn) == NETCONN_TCP) {
  801628:	8b 07                	mov    (%edi),%eax
  80162a:	89 04 24             	mov    %eax,(%esp)
  80162d:	e8 8e a0 00 00       	call   80b6c0 <netconn_type>
  801632:	83 f8 10             	cmp    $0x10,%eax
  801635:	75 25                	jne    80165c <lwip_recvfrom+0x1af>
      addr = (struct ip_addr*)&(sin.sin_addr.s_addr);
      netconn_getaddr(sock->conn, addr, &port, 0);
  801637:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  80163e:	00 
  80163f:	8d 45 e6             	lea    -0x1a(%ebp),%eax
  801642:	89 44 24 08          	mov    %eax,0x8(%esp)
  801646:	8d 45 d8             	lea    -0x28(%ebp),%eax
  801649:	89 44 24 04          	mov    %eax,0x4(%esp)
  80164d:	8b 07                	mov    (%edi),%eax
  80164f:	89 04 24             	mov    %eax,(%esp)
  801652:	e8 96 a0 00 00       	call   80b6ed <netconn_getaddr>
  /* Check to see from where the data was.*/
  if (from && fromlen) {
    struct sockaddr_in sin;

    if (netconn_type(sock->conn) == NETCONN_TCP) {
      addr = (struct ip_addr*)&(sin.sin_addr.s_addr);
  801657:	8d 5d d8             	lea    -0x28(%ebp),%ebx
  80165a:	eb 0b                	jmp    801667 <lwip_recvfrom+0x1ba>
      netconn_getaddr(sock->conn, addr, &port, 0);
    } else {
      addr = netbuf_fromaddr(buf);
  80165c:	8b 5e 08             	mov    0x8(%esi),%ebx
      port = netbuf_fromport(buf);
  80165f:	0f b7 46 0c          	movzwl 0xc(%esi),%eax
  801663:	66 89 45 e6          	mov    %ax,-0x1a(%ebp)
    }

    memset(&sin, 0, sizeof(sin));
  801667:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%esp)
  80166e:	00 
  80166f:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  801676:	00 
  801677:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  80167a:	89 04 24             	mov    %eax,(%esp)
  80167d:	e8 65 e2 00 00       	call   80f8e7 <memset>
    sin.sin_len = sizeof(sin);
  801682:	c6 45 d4 10          	movb   $0x10,-0x2c(%ebp)
    sin.sin_family = AF_INET;
  801686:	c6 45 d5 02          	movb   $0x2,-0x2b(%ebp)
    sin.sin_port = htons(port);
  80168a:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  80168e:	89 04 24             	mov    %eax,(%esp)
  801691:	e8 e0 66 00 00       	call   807d76 <htons>
  801696:	66 89 45 d6          	mov    %ax,-0x2a(%ebp)
    sin.sin_addr.s_addr = addr->addr;
  80169a:	8b 03                	mov    (%ebx),%eax
  80169c:	89 45 d8             	mov    %eax,-0x28(%ebp)

    if (*fromlen > sizeof(sin))
  80169f:	8b 45 1c             	mov    0x1c(%ebp),%eax
  8016a2:	83 38 10             	cmpl   $0x10,(%eax)
  8016a5:	76 06                	jbe    8016ad <lwip_recvfrom+0x200>
      *fromlen = sizeof(sin);
  8016a7:	c7 00 10 00 00 00    	movl   $0x10,(%eax)

    SMEMCPY(from, &sin, *fromlen);
  8016ad:	8b 45 1c             	mov    0x1c(%ebp),%eax
  8016b0:	8b 00                	mov    (%eax),%eax
  8016b2:	89 44 24 08          	mov    %eax,0x8(%esp)
  8016b6:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  8016b9:	89 44 24 04          	mov    %eax,0x4(%esp)
  8016bd:	8b 45 18             	mov    0x18(%ebp),%eax
  8016c0:	89 04 24             	mov    %eax,(%esp)
  8016c3:	e8 d4 e2 00 00       	call   80f99c <memcpy>
    //ip_addr_debug_print(SOCKETS_DEBUG, addr);
    LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u len=%u\n", port, off));
#endif /*  SOCKETS_DEBUG */
  }

  sock_set_errno(sock, 0);
  8016c8:	c7 47 10 00 00 00 00 	movl   $0x0,0x10(%edi)
  8016cf:	c7 05 00 c2 b3 00 00 	movl   $0x0,0xb3c200
  8016d6:	00 00 00 
  return off;
  8016d9:	0f b7 45 c4          	movzwl -0x3c(%ebp),%eax
  8016dd:	eb 05                	jmp    8016e4 <lwip_recvfrom+0x237>
  u8_t                done = 0;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d, %p, %d, 0x%x, ..)\n", s, mem, len, flags));
  sock = get_socket(s);
  if (!sock)
    return -1;
  8016df:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
#endif /*  SOCKETS_DEBUG */
  }

  sock_set_errno(sock, 0);
  return off;
}
  8016e4:	83 c4 5c             	add    $0x5c,%esp
  8016e7:	5b                   	pop    %ebx
  8016e8:	5e                   	pop    %esi
  8016e9:	5f                   	pop    %edi
  8016ea:	5d                   	pop    %ebp
  8016eb:	c3                   	ret    

008016ec <lwip_read>:

int
lwip_read(int s, void *mem, int len)
{
  8016ec:	55                   	push   %ebp
  8016ed:	89 e5                	mov    %esp,%ebp
  8016ef:	83 ec 28             	sub    $0x28,%esp
  return lwip_recvfrom(s, mem, len, 0, NULL, NULL);
  8016f2:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
  8016f9:	00 
  8016fa:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  801701:	00 
  801702:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  801709:	00 
  80170a:	8b 45 10             	mov    0x10(%ebp),%eax
  80170d:	89 44 24 08          	mov    %eax,0x8(%esp)
  801711:	8b 45 0c             	mov    0xc(%ebp),%eax
  801714:	89 44 24 04          	mov    %eax,0x4(%esp)
  801718:	8b 45 08             	mov    0x8(%ebp),%eax
  80171b:	89 04 24             	mov    %eax,(%esp)
  80171e:	e8 8a fd ff ff       	call   8014ad <lwip_recvfrom>
}
  801723:	c9                   	leave  
  801724:	c3                   	ret    

00801725 <lwip_recv>:

int
lwip_recv(int s, void *mem, int len, unsigned int flags)
{
  801725:	55                   	push   %ebp
  801726:	89 e5                	mov    %esp,%ebp
  801728:	83 ec 28             	sub    $0x28,%esp
  return lwip_recvfrom(s, mem, len, flags, NULL, NULL);
  80172b:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
  801732:	00 
  801733:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  80173a:	00 
  80173b:	8b 45 14             	mov    0x14(%ebp),%eax
  80173e:	89 44 24 0c          	mov    %eax,0xc(%esp)
  801742:	8b 45 10             	mov    0x10(%ebp),%eax
  801745:	89 44 24 08          	mov    %eax,0x8(%esp)
  801749:	8b 45 0c             	mov    0xc(%ebp),%eax
  80174c:	89 44 24 04          	mov    %eax,0x4(%esp)
  801750:	8b 45 08             	mov    0x8(%ebp),%eax
  801753:	89 04 24             	mov    %eax,(%esp)
  801756:	e8 52 fd ff ff       	call   8014ad <lwip_recvfrom>
}
  80175b:	c9                   	leave  
  80175c:	c3                   	ret    

0080175d <lwip_sendto>:
}

int
lwip_sendto(int s, const void *data, int size, unsigned int flags,
       struct sockaddr *to, socklen_t tolen)
{
  80175d:	55                   	push   %ebp
  80175e:	89 e5                	mov    %esp,%ebp
  801760:	57                   	push   %edi
  801761:	56                   	push   %esi
  801762:	53                   	push   %ebx
  801763:	83 ec 3c             	sub    $0x3c,%esp
  801766:	8b 7d 10             	mov    0x10(%ebp),%edi
  801769:	8b 75 18             	mov    0x18(%ebp),%esi
#if !LWIP_TCPIP_CORE_LOCKING
  struct netbuf buf;
  u16_t remote_port;
#endif

  sock = get_socket(s);
  80176c:	8b 45 08             	mov    0x8(%ebp),%eax
  80176f:	e8 cc f1 ff ff       	call   800940 <get_socket>
  801774:	89 c3                	mov    %eax,%ebx
  if (!sock)
  801776:	85 c0                	test   %eax,%eax
  801778:	0f 84 32 01 00 00    	je     8018b0 <lwip_sendto+0x153>
    return -1;

  if (sock->conn->type==NETCONN_TCP) {
  80177e:	8b 00                	mov    (%eax),%eax
  801780:	83 38 10             	cmpl   $0x10,(%eax)
  801783:	75 22                	jne    8017a7 <lwip_sendto+0x4a>
#if LWIP_TCP
    return lwip_send(s, data, size, flags);
  801785:	8b 45 14             	mov    0x14(%ebp),%eax
  801788:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80178c:	89 7c 24 08          	mov    %edi,0x8(%esp)
  801790:	8b 45 0c             	mov    0xc(%ebp),%eax
  801793:	89 44 24 04          	mov    %eax,0x4(%esp)
  801797:	8b 45 08             	mov    0x8(%ebp),%eax
  80179a:	89 04 24             	mov    %eax,(%esp)
  80179d:	e8 1b 01 00 00       	call   8018bd <lwip_send>
  8017a2:	e9 0e 01 00 00       	jmp    8018b5 <lwip_sendto+0x158>
    sock_set_errno(sock, err_to_errno(ERR_ARG));
    return -1;
#endif /* LWIP_TCP */
  }

  LWIP_ASSERT("lwip_sendto: size must fit in u16_t",
  8017a7:	81 ff ff ff 00 00    	cmp    $0xffff,%edi
  8017ad:	76 1c                	jbe    8017cb <lwip_sendto+0x6e>
  8017af:	c7 44 24 08 08 1f 81 	movl   $0x811f08,0x8(%esp)
  8017b6:	00 
  8017b7:	c7 44 24 04 97 02 00 	movl   $0x297,0x4(%esp)
  8017be:	00 
  8017bf:	c7 04 24 78 1e 81 00 	movl   $0x811e78,(%esp)
  8017c6:	e8 af d8 00 00       	call   80f07a <_panic>
              ((size >= 0) && (size <= 0xffff)));
  LWIP_ERROR("lwip_sendto: invalid address", (((to == NULL) && (tolen == 0)) ||
  8017cb:	85 f6                	test   %esi,%esi
  8017cd:	0f 95 c0             	setne  %al
  8017d0:	75 06                	jne    8017d8 <lwip_sendto+0x7b>
  8017d2:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  8017d6:	74 28                	je     801800 <lwip_sendto+0xa3>
  8017d8:	83 7d 1c 10          	cmpl   $0x10,0x1c(%ebp)
  8017dc:	75 06                	jne    8017e4 <lwip_sendto+0x87>
  8017de:	80 7e 01 02          	cmpb   $0x2,0x1(%esi)
  8017e2:	74 1c                	je     801800 <lwip_sendto+0xa3>
  8017e4:	c7 44 24 08 e9 1e 81 	movl   $0x811ee9,0x8(%esp)
  8017eb:	00 
  8017ec:	c7 44 24 04 9b 02 00 	movl   $0x29b,0x4(%esp)
  8017f3:	00 
  8017f4:	c7 04 24 78 1e 81 00 	movl   $0x811e78,(%esp)
  8017fb:	e8 7a d8 00 00       	call   80f07a <_panic>
      pbuf_free(p);
    }
  }
#else
  /* initialize a buffer */
  buf.p = buf.ptr = NULL;
  801800:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
  801807:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
  if (to) {
  80180e:	84 c0                	test   %al,%al
  801810:	74 1e                	je     801830 <lwip_sendto+0xd3>
    remote_addr.addr = ((struct sockaddr_in *)to)->sin_addr.s_addr;
  801812:	8b 46 04             	mov    0x4(%esi),%eax
  801815:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    remote_port      = ntohs(((struct sockaddr_in *)to)->sin_port);
  801818:	0f b7 46 02          	movzwl 0x2(%esi),%eax
  80181c:	89 04 24             	mov    %eax,(%esp)
  80181f:	e8 5f 65 00 00       	call   807d83 <ntohs>
    buf.addr         = &remote_addr;
  801824:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  801827:	89 55 dc             	mov    %edx,-0x24(%ebp)
    buf.port         = remote_port;
  80182a:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
  80182e:	eb 14                	jmp    801844 <lwip_sendto+0xe7>
  } else {
    remote_addr.addr = 0;
  801830:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    remote_port      = 0;
    buf.addr         = NULL;
  801837:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
    buf.port         = 0;
  80183e:	66 c7 45 e0 00 00    	movw   $0x0,-0x20(%ebp)
              s, data, size, flags));
  //ip_addr_debug_print(SOCKETS_DEBUG, &remote_addr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u\n", remote_port));
    
  /* make the buffer point to the data that should be sent */
  if ((err = netbuf_ref(&buf, data, size)) == ERR_OK) {
  801844:	0f b7 c7             	movzwl %di,%eax
  801847:	89 44 24 08          	mov    %eax,0x8(%esp)
  80184b:	8b 45 0c             	mov    0xc(%ebp),%eax
  80184e:	89 44 24 04          	mov    %eax,0x4(%esp)
  801852:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  801855:	89 04 24             	mov    %eax,(%esp)
  801858:	e8 0c 11 00 00       	call   802969 <netbuf_ref>
  80185d:	0f be f0             	movsbl %al,%esi
  801860:	85 f6                	test   %esi,%esi
  801862:	75 14                	jne    801878 <lwip_sendto+0x11b>
    /* send the data */
    err = netconn_send(sock->conn, &buf);
  801864:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  801867:	89 44 24 04          	mov    %eax,0x4(%esp)
  80186b:	8b 03                	mov    (%ebx),%eax
  80186d:	89 04 24             	mov    %eax,(%esp)
  801870:	e8 80 a2 00 00       	call   80baf5 <netconn_send>
  801875:	0f be f0             	movsbl %al,%esi
  }

  /* deallocated the buffer */
  if (buf.p != NULL) {
  801878:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  80187b:	85 c0                	test   %eax,%eax
  80187d:	74 08                	je     801887 <lwip_sendto+0x12a>
    pbuf_free(buf.p);
  80187f:	89 04 24             	mov    %eax,(%esp)
  801882:	e8 6d 35 00 00       	call   804df4 <pbuf_free>
  }
#endif /* LWIP_TCPIP_CORE_LOCKING */
  sock_set_errno(sock, err_to_errno(err));
  801887:	89 f2                	mov    %esi,%edx
  801889:	f7 da                	neg    %edx
  80188b:	b8 05 00 00 00       	mov    $0x5,%eax
  801890:	83 fa 0e             	cmp    $0xe,%edx
  801893:	77 07                	ja     80189c <lwip_sendto+0x13f>
  801895:	8b 04 95 40 1f 81 00 	mov    0x811f40(,%edx,4),%eax
  80189c:	89 43 10             	mov    %eax,0x10(%ebx)
  80189f:	a3 00 c2 b3 00       	mov    %eax,0xb3c200
  return (err==ERR_OK?size:-1);
  8018a4:	85 f6                	test   %esi,%esi
  8018a6:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8018ab:	0f 44 c7             	cmove  %edi,%eax
  8018ae:	eb 05                	jmp    8018b5 <lwip_sendto+0x158>
  u16_t remote_port;
#endif

  sock = get_socket(s);
  if (!sock)
    return -1;
  8018b0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    pbuf_free(buf.p);
  }
#endif /* LWIP_TCPIP_CORE_LOCKING */
  sock_set_errno(sock, err_to_errno(err));
  return (err==ERR_OK?size:-1);
}
  8018b5:	83 c4 3c             	add    $0x3c,%esp
  8018b8:	5b                   	pop    %ebx
  8018b9:	5e                   	pop    %esi
  8018ba:	5f                   	pop    %edi
  8018bb:	5d                   	pop    %ebp
  8018bc:	c3                   	ret    

008018bd <lwip_send>:
  return lwip_recvfrom(s, mem, len, flags, NULL, NULL);
}

int
lwip_send(int s, const void *data, int size, unsigned int flags)
{
  8018bd:	55                   	push   %ebp
  8018be:	89 e5                	mov    %esp,%ebp
  8018c0:	57                   	push   %edi
  8018c1:	56                   	push   %esi
  8018c2:	53                   	push   %ebx
  8018c3:	83 ec 2c             	sub    $0x2c,%esp
  8018c6:	8b 7d 08             	mov    0x8(%ebp),%edi
  8018c9:	8b 75 10             	mov    0x10(%ebp),%esi
  err_t err;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_send(%d, data=%p, size=%d, flags=0x%x)\n",
                              s, data, size, flags));

  sock = get_socket(s);
  8018cc:	89 f8                	mov    %edi,%eax
  8018ce:	e8 6d f0 ff ff       	call   800940 <get_socket>
  8018d3:	89 c3                	mov    %eax,%ebx
  if (!sock)
  8018d5:	85 c0                	test   %eax,%eax
  8018d7:	0f 84 86 00 00 00    	je     801963 <lwip_send+0xa6>
    return -1;

  if (sock->conn->type!=NETCONN_TCP) {
  8018dd:	8b 00                	mov    (%eax),%eax
  8018df:	83 38 10             	cmpl   $0x10,(%eax)
  8018e2:	74 2c                	je     801910 <lwip_send+0x53>
#if (LWIP_UDP || LWIP_RAW)
    return lwip_sendto(s, data, size, flags, NULL, 0);
  8018e4:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
  8018eb:	00 
  8018ec:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  8018f3:	00 
  8018f4:	8b 45 14             	mov    0x14(%ebp),%eax
  8018f7:	89 44 24 0c          	mov    %eax,0xc(%esp)
  8018fb:	89 74 24 08          	mov    %esi,0x8(%esp)
  8018ff:	8b 45 0c             	mov    0xc(%ebp),%eax
  801902:	89 44 24 04          	mov    %eax,0x4(%esp)
  801906:	89 3c 24             	mov    %edi,(%esp)
  801909:	e8 4f fe ff ff       	call   80175d <lwip_sendto>
  80190e:	eb 58                	jmp    801968 <lwip_send+0xab>
    sock_set_errno(sock, err_to_errno(ERR_ARG));
    return -1;
#endif /* (LWIP_UDP || LWIP_RAW) */
  }

  err = netconn_write(sock->conn, data, size, NETCONN_COPY | ((flags & MSG_MORE)?NETCONN_MORE:0));
  801910:	8b 55 14             	mov    0x14(%ebp),%edx
  801913:	83 e2 10             	and    $0x10,%edx
  801916:	83 fa 01             	cmp    $0x1,%edx
  801919:	19 d2                	sbb    %edx,%edx
  80191b:	83 e2 fe             	and    $0xfffffffe,%edx
  80191e:	83 c2 03             	add    $0x3,%edx
  801921:	89 54 24 0c          	mov    %edx,0xc(%esp)
  801925:	89 74 24 08          	mov    %esi,0x8(%esp)
  801929:	8b 7d 0c             	mov    0xc(%ebp),%edi
  80192c:	89 7c 24 04          	mov    %edi,0x4(%esp)
  801930:	89 04 24             	mov    %eax,(%esp)
  801933:	e8 3e a2 00 00       	call   80bb76 <netconn_write>

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_send(%d) err=%d size=%d\n", s, err, size));
  sock_set_errno(sock, err_to_errno(err));
  801938:	0f be c8             	movsbl %al,%ecx
  80193b:	f7 d9                	neg    %ecx
  80193d:	ba 05 00 00 00       	mov    $0x5,%edx
  801942:	83 f9 0e             	cmp    $0xe,%ecx
  801945:	77 07                	ja     80194e <lwip_send+0x91>
  801947:	8b 14 8d 40 1f 81 00 	mov    0x811f40(,%ecx,4),%edx
  80194e:	89 53 10             	mov    %edx,0x10(%ebx)
  801951:	89 15 00 c2 b3 00    	mov    %edx,0xb3c200
  return (err==ERR_OK?size:-1);
  801957:	84 c0                	test   %al,%al
  801959:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80195e:	0f 44 c6             	cmove  %esi,%eax
  801961:	eb 05                	jmp    801968 <lwip_send+0xab>
  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_send(%d, data=%p, size=%d, flags=0x%x)\n",
                              s, data, size, flags));

  sock = get_socket(s);
  if (!sock)
    return -1;
  801963:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  err = netconn_write(sock->conn, data, size, NETCONN_COPY | ((flags & MSG_MORE)?NETCONN_MORE:0));

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_send(%d) err=%d size=%d\n", s, err, size));
  sock_set_errno(sock, err_to_errno(err));
  return (err==ERR_OK?size:-1);
}
  801968:	83 c4 2c             	add    $0x2c,%esp
  80196b:	5b                   	pop    %ebx
  80196c:	5e                   	pop    %esi
  80196d:	5f                   	pop    %edi
  80196e:	5d                   	pop    %ebp
  80196f:	c3                   	ret    

00801970 <lwip_socket>:
  return (err==ERR_OK?size:-1);
}

int
lwip_socket(int domain, int type, int protocol)
{
  801970:	55                   	push   %ebp
  801971:	89 e5                	mov    %esp,%ebp
  801973:	53                   	push   %ebx
  801974:	83 ec 14             	sub    $0x14,%esp
  801977:	8b 45 0c             	mov    0xc(%ebp),%eax
  int i;

  LWIP_UNUSED_ARG(domain);

  /* create a netconn */
  switch (type) {
  80197a:	83 f8 02             	cmp    $0x2,%eax
  80197d:	74 2c                	je     8019ab <lwip_socket+0x3b>
  80197f:	83 f8 03             	cmp    $0x3,%eax
  801982:	74 07                	je     80198b <lwip_socket+0x1b>
  801984:	83 f8 01             	cmp    $0x1,%eax
  801987:	75 6e                	jne    8019f7 <lwip_socket+0x87>
  801989:	eb 4c                	jmp    8019d7 <lwip_socket+0x67>
  case SOCK_RAW:
    conn = netconn_new_with_proto_and_callback(NETCONN_RAW, (u8_t)protocol, event_callback);
  80198b:	c7 44 24 08 72 0b 80 	movl   $0x800b72,0x8(%esp)
  801992:	00 
  801993:	0f b6 45 10          	movzbl 0x10(%ebp),%eax
  801997:	89 44 24 04          	mov    %eax,0x4(%esp)
  80199b:	c7 04 24 40 00 00 00 	movl   $0x40,(%esp)
  8019a2:	e8 d2 9b 00 00       	call   80b579 <netconn_new_with_proto_and_callback>
  8019a7:	89 c3                	mov    %eax,%ebx
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%s, SOCK_RAW, %d) = ",
                                 domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
    break;
  8019a9:	eb 5d                	jmp    801a08 <lwip_socket+0x98>
  case SOCK_DGRAM:
    conn = netconn_new_with_callback( (protocol == IPPROTO_UDPLITE) ?
  8019ab:	81 7d 10 88 00 00 00 	cmpl   $0x88,0x10(%ebp)
  8019b2:	0f 94 c0             	sete   %al
  8019b5:	0f b6 c0             	movzbl %al,%eax
  8019b8:	83 c0 20             	add    $0x20,%eax
  8019bb:	c7 44 24 08 72 0b 80 	movl   $0x800b72,0x8(%esp)
  8019c2:	00 
  8019c3:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8019ca:	00 
  8019cb:	89 04 24             	mov    %eax,(%esp)
  8019ce:	e8 a6 9b 00 00       	call   80b579 <netconn_new_with_proto_and_callback>
  8019d3:	89 c3                	mov    %eax,%ebx
                 NETCONN_UDPLITE : NETCONN_UDP, event_callback);
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%s, SOCK_DGRAM, %d) = ",
                                 domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
    break;
  8019d5:	eb 31                	jmp    801a08 <lwip_socket+0x98>
  case SOCK_STREAM:
    conn = netconn_new_with_callback(NETCONN_TCP, event_callback);
  8019d7:	c7 44 24 08 72 0b 80 	movl   $0x800b72,0x8(%esp)
  8019de:	00 
  8019df:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8019e6:	00 
  8019e7:	c7 04 24 10 00 00 00 	movl   $0x10,(%esp)
  8019ee:	e8 86 9b 00 00       	call   80b579 <netconn_new_with_proto_and_callback>
  8019f3:	89 c3                	mov    %eax,%ebx
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%s, SOCK_STREAM, %d) = ",
                                 domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
    break;
  8019f5:	eb 11                	jmp    801a08 <lwip_socket+0x98>
  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%d, %d/UNKNOWN, %d) = -1\n",
                                 domain, type, protocol));
    set_errno(EINVAL);
  8019f7:	c7 05 00 c2 b3 00 16 	movl   $0x16,0xb3c200
  8019fe:	00 00 00 
    return -1;
  801a01:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801a06:	eb 47                	jmp    801a4f <lwip_socket+0xdf>
  }

  if (!conn) {
  801a08:	85 db                	test   %ebx,%ebx
  801a0a:	75 11                	jne    801a1d <lwip_socket+0xad>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("-1 / ENOBUFS (could not create netconn)\n"));
    set_errno(ENOBUFS);
  801a0c:	c7 05 00 c2 b3 00 69 	movl   $0x69,0xb3c200
  801a13:	00 00 00 
    return -1;
  801a16:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801a1b:	eb 32                	jmp    801a4f <lwip_socket+0xdf>
  }

  i = alloc_socket(conn);
  801a1d:	89 d8                	mov    %ebx,%eax
  801a1f:	e8 d7 f2 ff ff       	call   800cfb <alloc_socket>

  if (i == -1) {
  801a24:	83 f8 ff             	cmp    $0xffffffff,%eax
  801a27:	75 19                	jne    801a42 <lwip_socket+0xd2>
    netconn_delete(conn);
  801a29:	89 1c 24             	mov    %ebx,(%esp)
  801a2c:	e8 52 9c 00 00       	call   80b683 <netconn_delete>
    set_errno(ENFILE);
  801a31:	c7 05 00 c2 b3 00 17 	movl   $0x17,0xb3c200
  801a38:	00 00 00 
    return -1;
  801a3b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801a40:	eb 0d                	jmp    801a4f <lwip_socket+0xdf>
  }
  conn->socket = i;
  801a42:	89 43 1c             	mov    %eax,0x1c(%ebx)
  LWIP_DEBUGF(SOCKETS_DEBUG, ("%d\n", i));
  set_errno(0);
  801a45:	c7 05 00 c2 b3 00 00 	movl   $0x0,0xb3c200
  801a4c:	00 00 00 
  return i;
}
  801a4f:	83 c4 14             	add    $0x14,%esp
  801a52:	5b                   	pop    %ebx
  801a53:	5d                   	pop    %ebp
  801a54:	c3                   	ret    

00801a55 <lwip_write>:

int
lwip_write(int s, const void *data, int size)
{
  801a55:	55                   	push   %ebp
  801a56:	89 e5                	mov    %esp,%ebp
  801a58:	83 ec 18             	sub    $0x18,%esp
  return lwip_send(s, data, size, 0);
  801a5b:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  801a62:	00 
  801a63:	8b 45 10             	mov    0x10(%ebp),%eax
  801a66:	89 44 24 08          	mov    %eax,0x8(%esp)
  801a6a:	8b 45 0c             	mov    0xc(%ebp),%eax
  801a6d:	89 44 24 04          	mov    %eax,0x4(%esp)
  801a71:	8b 45 08             	mov    0x8(%ebp),%eax
  801a74:	89 04 24             	mov    %eax,(%esp)
  801a77:	e8 41 fe ff ff       	call   8018bd <lwip_send>
}
  801a7c:	c9                   	leave  
  801a7d:	c3                   	ret    

00801a7e <lwip_select>:
 * Processing exceptset is not yet implemented.
 */
int
lwip_select(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset,
               struct timeval *timeout)
{
  801a7e:	55                   	push   %ebp
  801a7f:	89 e5                	mov    %esp,%ebp
  801a81:	57                   	push   %edi
  801a82:	56                   	push   %esi
  801a83:	53                   	push   %ebx
  801a84:	83 ec 4c             	sub    $0x4c,%esp
  801a87:	8b 75 0c             	mov    0xc(%ebp),%esi
  801a8a:	8b 5d 14             	mov    0x14(%ebp),%ebx

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select(%d, %p, %p, %p, tvsec=%ld tvusec=%ld)\n",
                  maxfdp1, (void *)readset, (void *) writeset, (void *) exceptset,
                  timeout ? timeout->tv_sec : -1L, timeout ? timeout->tv_usec : -1L));

  select_cb.next = 0;
  801a8d:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
  select_cb.readset = readset;
  801a94:	89 75 c8             	mov    %esi,-0x38(%ebp)
  select_cb.writeset = writeset;
  801a97:	8b 45 10             	mov    0x10(%ebp),%eax
  801a9a:	89 45 cc             	mov    %eax,-0x34(%ebp)
  select_cb.exceptset = exceptset;
  801a9d:	89 5d d0             	mov    %ebx,-0x30(%ebp)
  select_cb.sem_signalled = 0;
  801aa0:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)

  /* Protect ourselves searching through the list */
  sys_sem_wait(selectsem);
  801aa7:	a1 60 60 81 00       	mov    0x816060,%eax
  801aac:	89 04 24             	mov    %eax,(%esp)
  801aaf:	e8 74 3c 00 00       	call   805728 <sys_sem_wait>

  if (readset)
  801ab4:	85 f6                	test   %esi,%esi
  801ab6:	74 07                	je     801abf <lwip_select+0x41>
    lreadset = *readset;
  801ab8:	8b 06                	mov    (%esi),%eax
  801aba:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  801abd:	eb 1b                	jmp    801ada <lwip_select+0x5c>
  else
    FD_ZERO(&lreadset);
  801abf:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  801ac6:	00 
  801ac7:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  801ace:	00 
  801acf:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  801ad2:	89 04 24             	mov    %eax,(%esp)
  801ad5:	e8 0d de 00 00       	call   80f8e7 <memset>
  if (writeset)
  801ada:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  801ade:	74 0a                	je     801aea <lwip_select+0x6c>
    lwriteset = *writeset;
  801ae0:	8b 45 10             	mov    0x10(%ebp),%eax
  801ae3:	8b 00                	mov    (%eax),%eax
  801ae5:	89 45 e0             	mov    %eax,-0x20(%ebp)
  801ae8:	eb 1b                	jmp    801b05 <lwip_select+0x87>
  else
    FD_ZERO(&lwriteset);
  801aea:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  801af1:	00 
  801af2:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  801af9:	00 
  801afa:	8d 45 e0             	lea    -0x20(%ebp),%eax
  801afd:	89 04 24             	mov    %eax,(%esp)
  801b00:	e8 e2 dd 00 00       	call   80f8e7 <memset>
  if (exceptset)
  801b05:	85 db                	test   %ebx,%ebx
  801b07:	74 07                	je     801b10 <lwip_select+0x92>
    lexceptset = *exceptset;
  801b09:	8b 03                	mov    (%ebx),%eax
  801b0b:	89 45 dc             	mov    %eax,-0x24(%ebp)
  801b0e:	eb 1b                	jmp    801b2b <lwip_select+0xad>
  else
    FD_ZERO(&lexceptset);
  801b10:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  801b17:	00 
  801b18:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  801b1f:	00 
  801b20:	8d 45 dc             	lea    -0x24(%ebp),%eax
  801b23:	89 04 24             	mov    %eax,(%esp)
  801b26:	e8 bc dd 00 00       	call   80f8e7 <memset>

  /* Go through each socket in each list to count number of sockets which
     currently match */
  nready = lwip_selscan(maxfdp1, &lreadset, &lwriteset, &lexceptset);
  801b2b:	8d 45 dc             	lea    -0x24(%ebp),%eax
  801b2e:	89 04 24             	mov    %eax,(%esp)
  801b31:	8d 4d e0             	lea    -0x20(%ebp),%ecx
  801b34:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  801b37:	8b 45 08             	mov    0x8(%ebp),%eax
  801b3a:	e8 40 ee ff ff       	call   80097f <lwip_selscan>
  801b3f:	89 c7                	mov    %eax,%edi

  /* If we don't have any current events, then suspend if we are supposed to */
  if (!nready) {
  801b41:	85 c0                	test   %eax,%eax
  801b43:	0f 85 fd 01 00 00    	jne    801d46 <lwip_select+0x2c8>
    if (timeout && timeout->tv_sec == 0 && timeout->tv_usec == 0) {
  801b49:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
  801b4d:	0f 84 8f 02 00 00    	je     801de2 <lwip_select+0x364>
  801b53:	8b 45 18             	mov    0x18(%ebp),%eax
  801b56:	83 38 00             	cmpl   $0x0,(%eax)
  801b59:	0f 85 25 02 00 00    	jne    801d84 <lwip_select+0x306>
  801b5f:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
  801b63:	0f 85 1b 02 00 00    	jne    801d84 <lwip_select+0x306>
      sys_sem_signal(selectsem);
  801b69:	a1 60 60 81 00       	mov    0x816060,%eax
  801b6e:	89 04 24             	mov    %eax,(%esp)
  801b71:	e8 8a 8d 00 00       	call   80a900 <sys_sem_signal>
      if (readset)
  801b76:	85 f6                	test   %esi,%esi
  801b78:	74 18                	je     801b92 <lwip_select+0x114>
        FD_ZERO(readset);
  801b7a:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  801b81:	00 
  801b82:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  801b89:	00 
  801b8a:	89 34 24             	mov    %esi,(%esp)
  801b8d:	e8 55 dd 00 00       	call   80f8e7 <memset>
      if (writeset)
  801b92:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  801b96:	74 1b                	je     801bb3 <lwip_select+0x135>
        FD_ZERO(writeset);
  801b98:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  801b9f:	00 
  801ba0:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  801ba7:	00 
  801ba8:	8b 45 10             	mov    0x10(%ebp),%eax
  801bab:	89 04 24             	mov    %eax,(%esp)
  801bae:	e8 34 dd 00 00       	call   80f8e7 <memset>
      if (exceptset)
  801bb3:	85 db                	test   %ebx,%ebx
  801bb5:	74 18                	je     801bcf <lwip_select+0x151>
        FD_ZERO(exceptset);
  801bb7:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  801bbe:	00 
  801bbf:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  801bc6:	00 
  801bc7:	89 1c 24             	mov    %ebx,(%esp)
  801bca:	e8 18 dd 00 00       	call   80f8e7 <memset>
  
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: no timeout, returning 0\n"));
      set_errno(0);
  801bcf:	c7 05 00 c2 b3 00 00 	movl   $0x0,0xb3c200
  801bd6:	00 00 00 
  
      return 0;
  801bd9:	b8 00 00 00 00       	mov    $0x0,%eax
  801bde:	e9 35 02 00 00       	jmp    801e18 <lwip_select+0x39a>
      msectimeout =  ((timeout->tv_sec * 1000) + ((timeout->tv_usec + 500)/1000));
      if(msectimeout == 0)
        msectimeout = 1;
    }
    
    i = sys_sem_wait_timeout(select_cb.sem, msectimeout);
  801be3:	89 7c 24 04          	mov    %edi,0x4(%esp)
  801be7:	8b 45 d8             	mov    -0x28(%ebp),%eax
  801bea:	89 04 24             	mov    %eax,(%esp)
  801bed:	e8 08 3d 00 00       	call   8058fa <sys_sem_wait_timeout>
  801bf2:	89 c7                	mov    %eax,%edi
    
    /* Take us off the list */
    sys_sem_wait(selectsem);
  801bf4:	a1 60 60 81 00       	mov    0x816060,%eax
  801bf9:	89 04 24             	mov    %eax,(%esp)
  801bfc:	e8 27 3b 00 00       	call   805728 <sys_sem_wait>
    if (select_cb_list == &select_cb)
  801c01:	a1 68 60 81 00       	mov    0x816068,%eax
  801c06:	8d 55 c4             	lea    -0x3c(%ebp),%edx
      select_cb_list = select_cb.next;
    else
      for (p_selcb = select_cb_list; p_selcb; p_selcb = p_selcb->next) {
        if (p_selcb->next == &select_cb) {
  801c09:	89 d1                	mov    %edx,%ecx
    
    i = sys_sem_wait_timeout(select_cb.sem, msectimeout);
    
    /* Take us off the list */
    sys_sem_wait(selectsem);
    if (select_cb_list == &select_cb)
  801c0b:	39 d0                	cmp    %edx,%eax
  801c0d:	75 1b                	jne    801c2a <lwip_select+0x1ac>
      select_cb_list = select_cb.next;
  801c0f:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  801c12:	a3 68 60 81 00       	mov    %eax,0x816068
  801c17:	eb 15                	jmp    801c2e <lwip_select+0x1b0>
    else
      for (p_selcb = select_cb_list; p_selcb; p_selcb = p_selcb->next) {
        if (p_selcb->next == &select_cb) {
  801c19:	8b 10                	mov    (%eax),%edx
  801c1b:	39 ca                	cmp    %ecx,%edx
  801c1d:	74 04                	je     801c23 <lwip_select+0x1a5>
    /* Take us off the list */
    sys_sem_wait(selectsem);
    if (select_cb_list == &select_cb)
      select_cb_list = select_cb.next;
    else
      for (p_selcb = select_cb_list; p_selcb; p_selcb = p_selcb->next) {
  801c1f:	89 d0                	mov    %edx,%eax
  801c21:	eb 07                	jmp    801c2a <lwip_select+0x1ac>
        if (p_selcb->next == &select_cb) {
          p_selcb->next = select_cb.next;
  801c23:	8b 55 c4             	mov    -0x3c(%ebp),%edx
  801c26:	89 10                	mov    %edx,(%eax)
          break;
  801c28:	eb 04                	jmp    801c2e <lwip_select+0x1b0>
    /* Take us off the list */
    sys_sem_wait(selectsem);
    if (select_cb_list == &select_cb)
      select_cb_list = select_cb.next;
    else
      for (p_selcb = select_cb_list; p_selcb; p_selcb = p_selcb->next) {
  801c2a:	85 c0                	test   %eax,%eax
  801c2c:	75 eb                	jne    801c19 <lwip_select+0x19b>
          p_selcb->next = select_cb.next;
          break;
        }
      }
    
    sys_sem_signal(selectsem);
  801c2e:	a1 60 60 81 00       	mov    0x816060,%eax
  801c33:	89 04 24             	mov    %eax,(%esp)
  801c36:	e8 c5 8c 00 00       	call   80a900 <sys_sem_signal>
    
    sys_sem_free(select_cb.sem);
  801c3b:	8b 45 d8             	mov    -0x28(%ebp),%eax
  801c3e:	89 04 24             	mov    %eax,(%esp)
  801c41:	e8 61 8a 00 00       	call   80a6a7 <sys_sem_free>
    if (i == 0)  {
  801c46:	85 ff                	test   %edi,%edi
  801c48:	75 6d                	jne    801cb7 <lwip_select+0x239>
      /* Timeout */
      if (readset)
  801c4a:	85 f6                	test   %esi,%esi
  801c4c:	74 18                	je     801c66 <lwip_select+0x1e8>
        FD_ZERO(readset);
  801c4e:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  801c55:	00 
  801c56:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  801c5d:	00 
  801c5e:	89 34 24             	mov    %esi,(%esp)
  801c61:	e8 81 dc 00 00       	call   80f8e7 <memset>
      if (writeset)
  801c66:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  801c6a:	74 1b                	je     801c87 <lwip_select+0x209>
        FD_ZERO(writeset);
  801c6c:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  801c73:	00 
  801c74:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  801c7b:	00 
  801c7c:	8b 45 10             	mov    0x10(%ebp),%eax
  801c7f:	89 04 24             	mov    %eax,(%esp)
  801c82:	e8 60 dc 00 00       	call   80f8e7 <memset>
      if (exceptset)
  801c87:	85 db                	test   %ebx,%ebx
  801c89:	74 18                	je     801ca3 <lwip_select+0x225>
        FD_ZERO(exceptset);
  801c8b:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  801c92:	00 
  801c93:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  801c9a:	00 
  801c9b:	89 1c 24             	mov    %ebx,(%esp)
  801c9e:	e8 44 dc 00 00       	call   80f8e7 <memset>
  
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: timeout expired\n"));
      set_errno(0);
  801ca3:	c7 05 00 c2 b3 00 00 	movl   $0x0,0xb3c200
  801caa:	00 00 00 
  
      return 0;
  801cad:	b8 00 00 00 00       	mov    $0x0,%eax
  801cb2:	e9 61 01 00 00       	jmp    801e18 <lwip_select+0x39a>
    }
    
    if (readset)
  801cb7:	85 f6                	test   %esi,%esi
  801cb9:	74 07                	je     801cc2 <lwip_select+0x244>
      lreadset = *readset;
  801cbb:	8b 06                	mov    (%esi),%eax
  801cbd:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  801cc0:	eb 1b                	jmp    801cdd <lwip_select+0x25f>
    else
      FD_ZERO(&lreadset);
  801cc2:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  801cc9:	00 
  801cca:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  801cd1:	00 
  801cd2:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  801cd5:	89 04 24             	mov    %eax,(%esp)
  801cd8:	e8 0a dc 00 00       	call   80f8e7 <memset>
    if (writeset)
  801cdd:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  801ce1:	74 0a                	je     801ced <lwip_select+0x26f>
      lwriteset = *writeset;
  801ce3:	8b 45 10             	mov    0x10(%ebp),%eax
  801ce6:	8b 00                	mov    (%eax),%eax
  801ce8:	89 45 e0             	mov    %eax,-0x20(%ebp)
  801ceb:	eb 1b                	jmp    801d08 <lwip_select+0x28a>
    else
      FD_ZERO(&lwriteset);
  801ced:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  801cf4:	00 
  801cf5:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  801cfc:	00 
  801cfd:	8d 45 e0             	lea    -0x20(%ebp),%eax
  801d00:	89 04 24             	mov    %eax,(%esp)
  801d03:	e8 df db 00 00       	call   80f8e7 <memset>
    if (exceptset)
  801d08:	85 db                	test   %ebx,%ebx
  801d0a:	74 07                	je     801d13 <lwip_select+0x295>
      lexceptset = *exceptset;
  801d0c:	8b 03                	mov    (%ebx),%eax
  801d0e:	89 45 dc             	mov    %eax,-0x24(%ebp)
  801d11:	eb 1b                	jmp    801d2e <lwip_select+0x2b0>
    else
      FD_ZERO(&lexceptset);
  801d13:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  801d1a:	00 
  801d1b:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  801d22:	00 
  801d23:	8d 45 dc             	lea    -0x24(%ebp),%eax
  801d26:	89 04 24             	mov    %eax,(%esp)
  801d29:	e8 b9 db 00 00       	call   80f8e7 <memset>
    
    /* See what's set */
    nready = lwip_selscan(maxfdp1, &lreadset, &lwriteset, &lexceptset);
  801d2e:	8d 45 dc             	lea    -0x24(%ebp),%eax
  801d31:	89 04 24             	mov    %eax,(%esp)
  801d34:	8d 4d e0             	lea    -0x20(%ebp),%ecx
  801d37:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  801d3a:	8b 45 08             	mov    0x8(%ebp),%eax
  801d3d:	e8 3d ec ff ff       	call   80097f <lwip_selscan>
  801d42:	89 c7                	mov    %eax,%edi
  801d44:	eb 0d                	jmp    801d53 <lwip_select+0x2d5>
  } else
    sys_sem_signal(selectsem);
  801d46:	a1 60 60 81 00       	mov    0x816060,%eax
  801d4b:	89 04 24             	mov    %eax,(%esp)
  801d4e:	e8 ad 8b 00 00       	call   80a900 <sys_sem_signal>
  
  if (readset)
  801d53:	85 f6                	test   %esi,%esi
  801d55:	74 05                	je     801d5c <lwip_select+0x2de>
    *readset = lreadset;
  801d57:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  801d5a:	89 06                	mov    %eax,(%esi)
  if (writeset)
  801d5c:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  801d60:	74 08                	je     801d6a <lwip_select+0x2ec>
    *writeset = lwriteset;
  801d62:	8b 45 e0             	mov    -0x20(%ebp),%eax
  801d65:	8b 75 10             	mov    0x10(%ebp),%esi
  801d68:	89 06                	mov    %eax,(%esi)
  if (exceptset)
  801d6a:	85 db                	test   %ebx,%ebx
  801d6c:	74 05                	je     801d73 <lwip_select+0x2f5>
    *exceptset = lexceptset;
  801d6e:	8b 45 dc             	mov    -0x24(%ebp),%eax
  801d71:	89 03                	mov    %eax,(%ebx)
  
  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: nready=%d\n", nready));
  set_errno(0);
  801d73:	c7 05 00 c2 b3 00 00 	movl   $0x0,0xb3c200
  801d7a:	00 00 00 
  
  return nready;
  801d7d:	89 f8                	mov    %edi,%eax
  801d7f:	e9 94 00 00 00       	jmp    801e18 <lwip_select+0x39a>
    /* add our semaphore to list */
    /* We don't actually need any dynamic memory. Our entry on the
     * list is only valid while we are in this function, so it's ok
     * to use local variables */
    
    select_cb.sem = sys_sem_new(0);
  801d84:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  801d8b:	e8 8e 88 00 00       	call   80a61e <sys_sem_new>
  801d90:	89 45 d8             	mov    %eax,-0x28(%ebp)
    /* Note that we are still protected */
    /* Put this select_cb on top of list */
    select_cb.next = select_cb_list;
  801d93:	a1 68 60 81 00       	mov    0x816068,%eax
  801d98:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    select_cb_list = &select_cb;
  801d9b:	8d 45 c4             	lea    -0x3c(%ebp),%eax
  801d9e:	a3 68 60 81 00       	mov    %eax,0x816068
    
    /* Now we can safely unprotect */
    sys_sem_signal(selectsem);
  801da3:	a1 60 60 81 00       	mov    0x816060,%eax
  801da8:	89 04 24             	mov    %eax,(%esp)
  801dab:	e8 50 8b 00 00       	call   80a900 <sys_sem_signal>
    /* Now just wait to be woken */
    if (timeout == 0)
      /* Wait forever */
      msectimeout = 0;
    else {
      msectimeout =  ((timeout->tv_sec * 1000) + ((timeout->tv_usec + 500)/1000));
  801db0:	8b 45 18             	mov    0x18(%ebp),%eax
  801db3:	69 38 e8 03 00 00    	imul   $0x3e8,(%eax),%edi
  801db9:	8b 48 04             	mov    0x4(%eax),%ecx
  801dbc:	81 c1 f4 01 00 00    	add    $0x1f4,%ecx
  801dc2:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
  801dc7:	89 c8                	mov    %ecx,%eax
  801dc9:	f7 ea                	imul   %edx
  801dcb:	c1 fa 06             	sar    $0x6,%edx
  801dce:	c1 f9 1f             	sar    $0x1f,%ecx
  801dd1:	29 ca                	sub    %ecx,%edx
      if(msectimeout == 0)
  801dd3:	01 d7                	add    %edx,%edi
        msectimeout = 1;
  801dd5:	b8 01 00 00 00       	mov    $0x1,%eax
  801dda:	0f 44 f8             	cmove  %eax,%edi
  801ddd:	e9 01 fe ff ff       	jmp    801be3 <lwip_select+0x165>
    /* add our semaphore to list */
    /* We don't actually need any dynamic memory. Our entry on the
     * list is only valid while we are in this function, so it's ok
     * to use local variables */
    
    select_cb.sem = sys_sem_new(0);
  801de2:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  801de9:	e8 30 88 00 00       	call   80a61e <sys_sem_new>
  801dee:	89 45 d8             	mov    %eax,-0x28(%ebp)
    /* Note that we are still protected */
    /* Put this select_cb on top of list */
    select_cb.next = select_cb_list;
  801df1:	a1 68 60 81 00       	mov    0x816068,%eax
  801df6:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    select_cb_list = &select_cb;
  801df9:	8d 45 c4             	lea    -0x3c(%ebp),%eax
  801dfc:	a3 68 60 81 00       	mov    %eax,0x816068
    
    /* Now we can safely unprotect */
    sys_sem_signal(selectsem);
  801e01:	a1 60 60 81 00       	mov    0x816060,%eax
  801e06:	89 04 24             	mov    %eax,(%esp)
  801e09:	e8 f2 8a 00 00       	call   80a900 <sys_sem_signal>
    
    /* Now just wait to be woken */
    if (timeout == 0)
      /* Wait forever */
      msectimeout = 0;
  801e0e:	bf 00 00 00 00       	mov    $0x0,%edi
  801e13:	e9 cb fd ff ff       	jmp    801be3 <lwip_select+0x165>
  
  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: nready=%d\n", nready));
  set_errno(0);
  
  return nready;
}
  801e18:	83 c4 4c             	add    $0x4c,%esp
  801e1b:	5b                   	pop    %ebx
  801e1c:	5e                   	pop    %esi
  801e1d:	5f                   	pop    %edi
  801e1e:	5d                   	pop    %ebp
  801e1f:	c3                   	ret    

00801e20 <lwip_shutdown>:
 * Unimplemented: Close one end of a full-duplex connection.
 * Currently, the full connection is closed.
 */
int
lwip_shutdown(int s, int how)
{
  801e20:	55                   	push   %ebp
  801e21:	89 e5                	mov    %esp,%ebp
  801e23:	83 ec 18             	sub    $0x18,%esp
  LWIP_UNUSED_ARG(how);
  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_shutdown(%d, how=%d)\n", s, how));
  return lwip_close(s); /* XXX temporary hack until proper implementation */
  801e26:	8b 45 08             	mov    0x8(%ebp),%eax
  801e29:	89 04 24             	mov    %eax,(%esp)
  801e2c:	e8 b4 f4 ff ff       	call   8012e5 <lwip_close>
}
  801e31:	c9                   	leave  
  801e32:	c3                   	ret    

00801e33 <lwip_getpeername>:
  return 0;
}

int
lwip_getpeername(int s, struct sockaddr *name, socklen_t *namelen)
{
  801e33:	55                   	push   %ebp
  801e34:	89 e5                	mov    %esp,%ebp
  801e36:	83 ec 18             	sub    $0x18,%esp
  return lwip_getaddrname(s, name, namelen, 0);
  801e39:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  801e40:	8b 4d 10             	mov    0x10(%ebp),%ecx
  801e43:	8b 55 0c             	mov    0xc(%ebp),%edx
  801e46:	8b 45 08             	mov    0x8(%ebp),%eax
  801e49:	e8 64 ec ff ff       	call   800ab2 <lwip_getaddrname>
}
  801e4e:	c9                   	leave  
  801e4f:	c3                   	ret    

00801e50 <lwip_getsockname>:

int
lwip_getsockname(int s, struct sockaddr *name, socklen_t *namelen)
{
  801e50:	55                   	push   %ebp
  801e51:	89 e5                	mov    %esp,%ebp
  801e53:	83 ec 18             	sub    $0x18,%esp
  return lwip_getaddrname(s, name, namelen, 1);
  801e56:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  801e5d:	8b 4d 10             	mov    0x10(%ebp),%ecx
  801e60:	8b 55 0c             	mov    0xc(%ebp),%edx
  801e63:	8b 45 08             	mov    0x8(%ebp),%eax
  801e66:	e8 47 ec ff ff       	call   800ab2 <lwip_getaddrname>
}
  801e6b:	c9                   	leave  
  801e6c:	c3                   	ret    

00801e6d <lwip_getsockopt>:

int
lwip_getsockopt(int s, int level, int optname, void *optval, socklen_t *optlen)
{
  801e6d:	55                   	push   %ebp
  801e6e:	89 e5                	mov    %esp,%ebp
  801e70:	57                   	push   %edi
  801e71:	56                   	push   %esi
  801e72:	53                   	push   %ebx
  801e73:	83 ec 3c             	sub    $0x3c,%esp
  801e76:	8b 75 0c             	mov    0xc(%ebp),%esi
  801e79:	8b 7d 18             	mov    0x18(%ebp),%edi
  err_t err = ERR_OK;
  struct lwip_socket *sock = get_socket(s);
  801e7c:	8b 45 08             	mov    0x8(%ebp),%eax
  801e7f:	e8 bc ea ff ff       	call   800940 <get_socket>
  801e84:	89 c3                	mov    %eax,%ebx
  struct lwip_setgetsockopt_data data;

  if (!sock)
  801e86:	85 c0                	test   %eax,%eax
  801e88:	0f 84 8a 01 00 00    	je     802018 <lwip_getsockopt+0x1ab>
    return -1;

  if ((NULL == optval) || (NULL == optlen)) {
  801e8e:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
  801e92:	74 04                	je     801e98 <lwip_getsockopt+0x2b>
  801e94:	85 ff                	test   %edi,%edi
  801e96:	75 1b                	jne    801eb3 <lwip_getsockopt+0x46>
    sock_set_errno(sock, EFAULT);
  801e98:	c7 43 10 0e 00 00 00 	movl   $0xe,0x10(%ebx)
  801e9f:	c7 05 00 c2 b3 00 0e 	movl   $0xe,0xb3c200
  801ea6:	00 00 00 
    return -1;
  801ea9:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801eae:	e9 a8 01 00 00       	jmp    80205b <lwip_getsockopt+0x1ee>
  }

  /* Do length and type checks for the various options first, to keep it readable. */
  switch (level) {
  801eb3:	83 fe 06             	cmp    $0x6,%esi
  801eb6:	0f 84 a1 00 00 00    	je     801f5d <lwip_getsockopt+0xf0>
  801ebc:	81 fe ff 0f 00 00    	cmp    $0xfff,%esi
  801ec2:	74 0f                	je     801ed3 <lwip_getsockopt+0x66>
#endif /* LWIP_UDP && LWIP_UDPLITE*/
/* UNDEFINED LEVEL */
  default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, level=0x%x, UNIMPL: optname=0x%x, ..)\n",
                                  s, level, optname));
      err = ENOPROTOOPT;
  801ec4:	b8 5c 00 00 00       	mov    $0x5c,%eax
    sock_set_errno(sock, EFAULT);
    return -1;
  }

  /* Do length and type checks for the various options first, to keep it readable. */
  switch (level) {
  801ec9:	85 f6                	test   %esi,%esi
  801ecb:	0f 85 c9 00 00 00    	jne    801f9a <lwip_getsockopt+0x12d>
  801ed1:	eb 74                	jmp    801f47 <lwip_getsockopt+0xda>
   
/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
  801ed3:	83 7d 10 20          	cmpl   $0x20,0x10(%ebp)
  801ed7:	74 3c                	je     801f15 <lwip_getsockopt+0xa8>
  801ed9:	83 7d 10 20          	cmpl   $0x20,0x10(%ebp)
  801edd:	8d 76 00             	lea    0x0(%esi),%esi
  801ee0:	7f 12                	jg     801ef4 <lwip_getsockopt+0x87>
  801ee2:	83 7d 10 02          	cmpl   $0x2,0x10(%ebp)
  801ee6:	74 2d                	je     801f15 <lwip_getsockopt+0xa8>
  801ee8:	83 7d 10 08          	cmpl   $0x8,0x10(%ebp)
  801eec:	0f 85 95 00 00 00    	jne    801f87 <lwip_getsockopt+0x11a>
  801ef2:	eb 21                	jmp    801f15 <lwip_getsockopt+0xa8>
  801ef4:	81 7d 10 07 10 00 00 	cmpl   $0x1007,0x10(%ebp)
  801efb:	0f 8c 86 00 00 00    	jl     801f87 <lwip_getsockopt+0x11a>
  801f01:	81 7d 10 08 10 00 00 	cmpl   $0x1008,0x10(%ebp)
  801f08:	7e 0b                	jle    801f15 <lwip_getsockopt+0xa8>
  801f0a:	81 7d 10 0a 10 00 00 	cmpl   $0x100a,0x10(%ebp)
  801f11:	74 12                	je     801f25 <lwip_getsockopt+0xb8>
  801f13:	eb 72                	jmp    801f87 <lwip_getsockopt+0x11a>
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    case SO_TYPE:
    /* UNIMPL case SO_USELOOPBACK: */
      if (*optlen < sizeof(int)) {
  801f15:	83 3f 03             	cmpl   $0x3,(%edi)
  801f18:	0f 86 01 01 00 00    	jbe    80201f <lwip_getsockopt+0x1b2>
  801f1e:	66 90                	xchg   %ax,%ax
  801f20:	e9 8e 00 00 00       	jmp    801fb3 <lwip_getsockopt+0x146>
}

int
lwip_getsockopt(int s, int level, int optname, void *optval, socklen_t *optlen)
{
  err_t err = ERR_OK;
  801f25:	83 3f 04             	cmpl   $0x4,(%edi)
  801f28:	19 c0                	sbb    %eax,%eax
  801f2a:	83 e0 16             	and    $0x16,%eax
    case SO_NO_CHECK:
      if (*optlen < sizeof(int)) {
        err = EINVAL;
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
  801f2d:	8b 13                	mov    (%ebx),%edx
  801f2f:	83 3a 20             	cmpl   $0x20,(%edx)
  801f32:	0f 85 f1 00 00 00    	jne    802029 <lwip_getsockopt+0x1bc>
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
  801f38:	8b 52 08             	mov    0x8(%edx),%edx
    case SO_NO_CHECK:
      if (*optlen < sizeof(int)) {
        err = EINVAL;
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
  801f3b:	f6 42 10 02          	testb  $0x2,0x10(%edx)
  801f3f:	0f 85 ee 00 00 00    	jne    802033 <lwip_getsockopt+0x1c6>
  801f45:	eb 53                	jmp    801f9a <lwip_getsockopt+0x12d>
    }  /* switch (optname) */
    break;
                     
/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
  801f47:	8b 45 10             	mov    0x10(%ebp),%eax
  801f4a:	83 e8 01             	sub    $0x1,%eax
  801f4d:	83 f8 01             	cmp    $0x1,%eax
  801f50:	77 3c                	ja     801f8e <lwip_getsockopt+0x121>
    /* UNIMPL case IP_HDRINCL: */
    /* UNIMPL case IP_RCVDSTADDR: */
    /* UNIMPL case IP_RCVIF: */
    case IP_TTL:
    case IP_TOS:
      if (*optlen < sizeof(int)) {
  801f52:	83 3f 03             	cmpl   $0x3,(%edi)
  801f55:	0f 86 e2 00 00 00    	jbe    80203d <lwip_getsockopt+0x1d0>
  801f5b:	eb 56                	jmp    801fb3 <lwip_getsockopt+0x146>
    break;
         
#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    if (*optlen < sizeof(int)) {
  801f5d:	83 3f 03             	cmpl   $0x3,(%edi)
  801f60:	0f 86 e1 00 00 00    	jbe    802047 <lwip_getsockopt+0x1da>
      err = EINVAL;
      break;
    }
    
    /* If this is no TCP socket, ignore any options. */
    if (sock->conn->type != NETCONN_TCP)
  801f66:	8b 10                	mov    (%eax),%edx
      return 0;
  801f68:	b8 00 00 00 00       	mov    $0x0,%eax
      err = EINVAL;
      break;
    }
    
    /* If this is no TCP socket, ignore any options. */
    if (sock->conn->type != NETCONN_TCP)
  801f6d:	83 3a 10             	cmpl   $0x10,(%edx)
  801f70:	0f 85 e5 00 00 00    	jne    80205b <lwip_getsockopt+0x1ee>
      return 0;

    switch (optname) {
  801f76:	8b 45 10             	mov    0x10(%ebp),%eax
  801f79:	83 e8 01             	sub    $0x1,%eax
  801f7c:	83 f8 01             	cmp    $0x1,%eax
  801f7f:	0f 87 cc 00 00 00    	ja     802051 <lwip_getsockopt+0x1e4>
  801f85:	eb 0e                	jmp    801f95 <lwip_getsockopt+0x128>
      break;

    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, UNIMPL: optname=0x%x, ..)\n",
                                  s, optname));
      err = ENOPROTOOPT;
  801f87:	b8 5c 00 00 00       	mov    $0x5c,%eax
  801f8c:	eb 0c                	jmp    801f9a <lwip_getsockopt+0x12d>
#endif /* LWIP_IGMP */

    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, UNIMPL: optname=0x%x, ..)\n",
                                  s, optname));
      err = ENOPROTOOPT;
  801f8e:	b8 5c 00 00 00       	mov    $0x5c,%eax
  801f93:	eb 05                	jmp    801f9a <lwip_getsockopt+0x12d>
}

int
lwip_getsockopt(int s, int level, int optname, void *optval, socklen_t *optlen)
{
  err_t err = ERR_OK;
  801f95:	b8 00 00 00 00       	mov    $0x0,%eax
                                  s, level, optname));
      err = ENOPROTOOPT;
  }  /* switch */

   
  if (err != ERR_OK) {
  801f9a:	84 c0                	test   %al,%al
  801f9c:	74 15                	je     801fb3 <lwip_getsockopt+0x146>
    sock_set_errno(sock, err);
  801f9e:	0f be c0             	movsbl %al,%eax
  801fa1:	89 43 10             	mov    %eax,0x10(%ebx)
  801fa4:	a3 00 c2 b3 00       	mov    %eax,0xb3c200
    return -1;
  801fa9:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801fae:	e9 a8 00 00 00       	jmp    80205b <lwip_getsockopt+0x1ee>
  }

  /* Now do the actual option processing */
  data.sock = sock;
  801fb3:	89 5d cc             	mov    %ebx,-0x34(%ebp)
  data.level = level;
  801fb6:	89 75 d4             	mov    %esi,-0x2c(%ebp)
  data.optname = optname;
  801fb9:	8b 45 10             	mov    0x10(%ebp),%eax
  801fbc:	89 45 d8             	mov    %eax,-0x28(%ebp)
  data.optval = optval;
  801fbf:	8b 45 14             	mov    0x14(%ebp),%eax
  801fc2:	89 45 dc             	mov    %eax,-0x24(%ebp)
  data.optlen = optlen;
  801fc5:	89 7d e0             	mov    %edi,-0x20(%ebp)
  data.err = err;
  801fc8:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
  tcpip_callback(lwip_getsockopt_internal, &data);
  801fcc:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  801fd3:	00 
  801fd4:	8d 45 cc             	lea    -0x34(%ebp),%eax
  801fd7:	89 44 24 04          	mov    %eax,0x4(%esp)
  801fdb:	c7 04 24 a4 0d 80 00 	movl   $0x800da4,(%esp)
  801fe2:	e8 4c 06 00 00       	call   802633 <tcpip_callback_with_block>
  sys_arch_sem_wait(sock->conn->op_completed, 0);
  801fe7:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  801fee:	00 
  801fef:	8b 03                	mov    (%ebx),%eax
  801ff1:	8b 40 10             	mov    0x10(%eax),%eax
  801ff4:	89 04 24             	mov    %eax,(%esp)
  801ff7:	e8 79 89 00 00       	call   80a975 <sys_arch_sem_wait>
  /* maybe lwip_getsockopt_internal has changed err */
  err = data.err;
  801ffc:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax

  sock_set_errno(sock, err);
  802000:	0f be d0             	movsbl %al,%edx
  802003:	89 53 10             	mov    %edx,0x10(%ebx)
  802006:	89 15 00 c2 b3 00    	mov    %edx,0xb3c200
  return err ? -1 : 0;
  80200c:	84 c0                	test   %al,%al
  80200e:	0f 95 c0             	setne  %al
  802011:	0f b6 c0             	movzbl %al,%eax
  802014:	f7 d8                	neg    %eax
  802016:	eb 43                	jmp    80205b <lwip_getsockopt+0x1ee>
  err_t err = ERR_OK;
  struct lwip_socket *sock = get_socket(s);
  struct lwip_setgetsockopt_data data;

  if (!sock)
    return -1;
  802018:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80201d:	eb 3c                	jmp    80205b <lwip_getsockopt+0x1ee>
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    case SO_TYPE:
    /* UNIMPL case SO_USELOOPBACK: */
      if (*optlen < sizeof(int)) {
        err = EINVAL;
  80201f:	b8 16 00 00 00       	mov    $0x16,%eax
  802024:	e9 75 ff ff ff       	jmp    801f9e <lwip_getsockopt+0x131>
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
        /* this flag is only available for UDP, not for UDP lite */
        err = EAFNOSUPPORT;
  802029:	b8 61 00 00 00       	mov    $0x61,%eax
  80202e:	e9 6b ff ff ff       	jmp    801f9e <lwip_getsockopt+0x131>
  802033:	b8 61 00 00 00       	mov    $0x61,%eax
  802038:	e9 61 ff ff ff       	jmp    801f9e <lwip_getsockopt+0x131>
    /* UNIMPL case IP_RCVDSTADDR: */
    /* UNIMPL case IP_RCVIF: */
    case IP_TTL:
    case IP_TOS:
      if (*optlen < sizeof(int)) {
        err = EINVAL;
  80203d:	b8 16 00 00 00       	mov    $0x16,%eax
  802042:	e9 57 ff ff ff       	jmp    801f9e <lwip_getsockopt+0x131>
         
#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    if (*optlen < sizeof(int)) {
      err = EINVAL;
  802047:	b8 16 00 00 00       	mov    $0x16,%eax
  80204c:	e9 4d ff ff ff       	jmp    801f9e <lwip_getsockopt+0x131>
      break;
       
    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_TCP, UNIMPL: optname=0x%x, ..)\n",
                                  s, optname));
      err = ENOPROTOOPT;
  802051:	b8 5c 00 00 00       	mov    $0x5c,%eax
  802056:	e9 43 ff ff ff       	jmp    801f9e <lwip_getsockopt+0x131>
  /* maybe lwip_getsockopt_internal has changed err */
  err = data.err;

  sock_set_errno(sock, err);
  return err ? -1 : 0;
}
  80205b:	83 c4 3c             	add    $0x3c,%esp
  80205e:	5b                   	pop    %ebx
  80205f:	5e                   	pop    %esi
  802060:	5f                   	pop    %edi
  802061:	5d                   	pop    %ebp
  802062:	c3                   	ret    

00802063 <lwip_setsockopt>:
  sys_sem_signal(sock->conn->op_completed);
}

int
lwip_setsockopt(int s, int level, int optname, const void *optval, socklen_t optlen)
{
  802063:	55                   	push   %ebp
  802064:	89 e5                	mov    %esp,%ebp
  802066:	57                   	push   %edi
  802067:	56                   	push   %esi
  802068:	53                   	push   %ebx
  802069:	83 ec 3c             	sub    $0x3c,%esp
  80206c:	8b 75 0c             	mov    0xc(%ebp),%esi
  80206f:	8b 7d 14             	mov    0x14(%ebp),%edi
  struct lwip_socket *sock = get_socket(s);
  802072:	8b 45 08             	mov    0x8(%ebp),%eax
  802075:	e8 c6 e8 ff ff       	call   800940 <get_socket>
  80207a:	89 c3                	mov    %eax,%ebx
  int err = ERR_OK;
  struct lwip_setgetsockopt_data data;

  if (!sock)
  80207c:	85 c0                	test   %eax,%eax
  80207e:	0f 84 50 01 00 00    	je     8021d4 <lwip_setsockopt+0x171>
    return -1;

  if (NULL == optval) {
  802084:	85 ff                	test   %edi,%edi
  802086:	75 1b                	jne    8020a3 <lwip_setsockopt+0x40>
    sock_set_errno(sock, EFAULT);
  802088:	c7 40 10 0e 00 00 00 	movl   $0xe,0x10(%eax)
  80208f:	c7 05 00 c2 b3 00 0e 	movl   $0xe,0xb3c200
  802096:	00 00 00 
    return -1;
  802099:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80209e:	e9 74 01 00 00       	jmp    802217 <lwip_setsockopt+0x1b4>
  }

  /* Do length and type checks for the various options first, to keep it readable. */
  switch (level) {
  8020a3:	83 fe 06             	cmp    $0x6,%esi
  8020a6:	74 7e                	je     802126 <lwip_setsockopt+0xc3>
  8020a8:	81 fe ff 0f 00 00    	cmp    $0xfff,%esi
  8020ae:	74 0f                	je     8020bf <lwip_setsockopt+0x5c>
#endif /* LWIP_UDP && LWIP_UDPLITE */
/* UNDEFINED LEVEL */
  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, level=0x%x, UNIMPL: optname=0x%x, ..)\n",
                s, level, optname));
    err = ENOPROTOOPT;
  8020b0:	b8 5c 00 00 00       	mov    $0x5c,%eax
    sock_set_errno(sock, EFAULT);
    return -1;
  }

  /* Do length and type checks for the various options first, to keep it readable. */
  switch (level) {
  8020b5:	85 f6                	test   %esi,%esi
  8020b7:	0f 85 a0 00 00 00    	jne    80215d <lwip_setsockopt+0xfa>
  8020bd:	eb 50                	jmp    80210f <lwip_setsockopt+0xac>

/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
  8020bf:	83 7d 10 20          	cmpl   $0x20,0x10(%ebp)
  8020c3:	74 18                	je     8020dd <lwip_setsockopt+0x7a>
  8020c5:	81 7d 10 0a 10 00 00 	cmpl   $0x100a,0x10(%ebp)
  8020cc:	74 1e                	je     8020ec <lwip_setsockopt+0x89>
#endif /* LWIP_UDP */
      break;
    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, SOL_SOCKET, UNIMPL: optname=0x%x, ..)\n",
                  s, optname));
      err = ENOPROTOOPT;
  8020ce:	b8 5c 00 00 00       	mov    $0x5c,%eax
  /* Do length and type checks for the various options first, to keep it readable. */
  switch (level) {

/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
  8020d3:	83 7d 10 08          	cmpl   $0x8,0x10(%ebp)
  8020d7:	0f 85 80 00 00 00    	jne    80215d <lwip_setsockopt+0xfa>
#if SO_REUSE
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    /* UNIMPL case SO_USELOOPBACK: */
      if (optlen < sizeof(int)) {
  8020dd:	83 7d 18 03          	cmpl   $0x3,0x18(%ebp)
  8020e1:	0f 86 f4 00 00 00    	jbe    8021db <lwip_setsockopt+0x178>
  8020e7:	e9 87 00 00 00       	jmp    802173 <lwip_setsockopt+0x110>

int
lwip_setsockopt(int s, int level, int optname, const void *optval, socklen_t optlen)
{
  struct lwip_socket *sock = get_socket(s);
  int err = ERR_OK;
  8020ec:	83 7d 18 04          	cmpl   $0x4,0x18(%ebp)
  8020f0:	19 c0                	sbb    %eax,%eax
  8020f2:	83 e0 16             	and    $0x16,%eax
    case SO_NO_CHECK:
      if (optlen < sizeof(int)) {
        err = EINVAL;
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
  8020f5:	8b 13                	mov    (%ebx),%edx
  8020f7:	83 3a 20             	cmpl   $0x20,(%edx)
  8020fa:	0f 85 e5 00 00 00    	jne    8021e5 <lwip_setsockopt+0x182>
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
  802100:	8b 52 08             	mov    0x8(%edx),%edx
    case SO_NO_CHECK:
      if (optlen < sizeof(int)) {
        err = EINVAL;
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
  802103:	f6 42 10 02          	testb  $0x2,0x10(%edx)
  802107:	0f 85 e2 00 00 00    	jne    8021ef <lwip_setsockopt+0x18c>
  80210d:	eb 4e                	jmp    80215d <lwip_setsockopt+0xfa>
    }  /* switch (optname) */
    break;

/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
  80210f:	8b 45 10             	mov    0x10(%ebp),%eax
  802112:	83 e8 01             	sub    $0x1,%eax
  802115:	83 f8 01             	cmp    $0x1,%eax
  802118:	77 37                	ja     802151 <lwip_setsockopt+0xee>
    /* UNIMPL case IP_HDRINCL: */
    /* UNIMPL case IP_RCVDSTADDR: */
    /* UNIMPL case IP_RCVIF: */
    case IP_TTL:
    case IP_TOS:
      if (optlen < sizeof(int)) {
  80211a:	83 7d 18 03          	cmpl   $0x3,0x18(%ebp)
  80211e:	0f 86 d5 00 00 00    	jbe    8021f9 <lwip_setsockopt+0x196>
  802124:	eb 4d                	jmp    802173 <lwip_setsockopt+0x110>
    break;

#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    if (optlen < sizeof(int)) {
  802126:	83 7d 18 03          	cmpl   $0x3,0x18(%ebp)
  80212a:	0f 86 d3 00 00 00    	jbe    802203 <lwip_setsockopt+0x1a0>
      err = EINVAL;
      break;
    }

    /* If this is no TCP socket, ignore any options. */
    if (sock->conn->type != NETCONN_TCP)
  802130:	8b 10                	mov    (%eax),%edx
      return 0;
  802132:	b8 00 00 00 00       	mov    $0x0,%eax
      err = EINVAL;
      break;
    }

    /* If this is no TCP socket, ignore any options. */
    if (sock->conn->type != NETCONN_TCP)
  802137:	83 3a 10             	cmpl   $0x10,(%edx)
  80213a:	0f 85 d7 00 00 00    	jne    802217 <lwip_setsockopt+0x1b4>
      return 0;

    switch (optname) {
  802140:	8b 45 10             	mov    0x10(%ebp),%eax
  802143:	83 e8 01             	sub    $0x1,%eax
  802146:	83 f8 01             	cmp    $0x1,%eax
  802149:	0f 87 be 00 00 00    	ja     80220d <lwip_setsockopt+0x1aa>
  80214f:	eb 07                	jmp    802158 <lwip_setsockopt+0xf5>
      break;
#endif /* LWIP_IGMP */
      default:
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IP, UNIMPL: optname=0x%x, ..)\n",
                    s, optname));
        err = ENOPROTOOPT;
  802151:	b8 5c 00 00 00       	mov    $0x5c,%eax
  802156:	eb 05                	jmp    80215d <lwip_setsockopt+0xfa>

int
lwip_setsockopt(int s, int level, int optname, const void *optval, socklen_t optlen)
{
  struct lwip_socket *sock = get_socket(s);
  int err = ERR_OK;
  802158:	b8 00 00 00 00       	mov    $0x0,%eax
                s, level, optname));
    err = ENOPROTOOPT;
  }  /* switch (level) */


  if (err != ERR_OK) {
  80215d:	85 c0                	test   %eax,%eax
  80215f:	74 12                	je     802173 <lwip_setsockopt+0x110>
    sock_set_errno(sock, err);
  802161:	89 43 10             	mov    %eax,0x10(%ebx)
  802164:	a3 00 c2 b3 00       	mov    %eax,0xb3c200
    return -1;
  802169:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80216e:	e9 a4 00 00 00       	jmp    802217 <lwip_setsockopt+0x1b4>
  }


  /* Now do the actual option processing */
  data.sock = sock;
  802173:	89 5d cc             	mov    %ebx,-0x34(%ebp)
  data.level = level;
  802176:	89 75 d4             	mov    %esi,-0x2c(%ebp)
  data.optname = optname;
  802179:	8b 45 10             	mov    0x10(%ebp),%eax
  80217c:	89 45 d8             	mov    %eax,-0x28(%ebp)
  data.optval = (void*)optval;
  80217f:	89 7d dc             	mov    %edi,-0x24(%ebp)
  data.optlen = &optlen;
  802182:	8d 45 18             	lea    0x18(%ebp),%eax
  802185:	89 45 e0             	mov    %eax,-0x20(%ebp)
  data.err = err;
  802188:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
  tcpip_callback(lwip_setsockopt_internal, &data);
  80218c:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  802193:	00 
  802194:	8d 45 cc             	lea    -0x34(%ebp),%eax
  802197:	89 44 24 04          	mov    %eax,0x4(%esp)
  80219b:	c7 04 24 2b 0f 80 00 	movl   $0x800f2b,(%esp)
  8021a2:	e8 8c 04 00 00       	call   802633 <tcpip_callback_with_block>
  sys_arch_sem_wait(sock->conn->op_completed, 0);
  8021a7:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8021ae:	00 
  8021af:	8b 03                	mov    (%ebx),%eax
  8021b1:	8b 40 10             	mov    0x10(%eax),%eax
  8021b4:	89 04 24             	mov    %eax,(%esp)
  8021b7:	e8 b9 87 00 00       	call   80a975 <sys_arch_sem_wait>
  /* maybe lwip_setsockopt_internal has changed err */
  err = data.err;
  8021bc:	0f be 45 e4          	movsbl -0x1c(%ebp),%eax

  sock_set_errno(sock, err);
  8021c0:	89 43 10             	mov    %eax,0x10(%ebx)
  8021c3:	a3 00 c2 b3 00       	mov    %eax,0xb3c200
  return err ? -1 : 0;
  8021c8:	85 c0                	test   %eax,%eax
  8021ca:	0f 95 c0             	setne  %al
  8021cd:	0f b6 c0             	movzbl %al,%eax
  8021d0:	f7 d8                	neg    %eax
  8021d2:	eb 43                	jmp    802217 <lwip_setsockopt+0x1b4>
  struct lwip_socket *sock = get_socket(s);
  int err = ERR_OK;
  struct lwip_setgetsockopt_data data;

  if (!sock)
    return -1;
  8021d4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8021d9:	eb 3c                	jmp    802217 <lwip_setsockopt+0x1b4>
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    /* UNIMPL case SO_USELOOPBACK: */
      if (optlen < sizeof(int)) {
        err = EINVAL;
  8021db:	b8 16 00 00 00       	mov    $0x16,%eax
  8021e0:	e9 7c ff ff ff       	jmp    802161 <lwip_setsockopt+0xfe>
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
        /* this flag is only available for UDP, not for UDP lite */
        err = EAFNOSUPPORT;
  8021e5:	b8 61 00 00 00       	mov    $0x61,%eax
  8021ea:	e9 72 ff ff ff       	jmp    802161 <lwip_setsockopt+0xfe>
  8021ef:	b8 61 00 00 00       	mov    $0x61,%eax
  8021f4:	e9 68 ff ff ff       	jmp    802161 <lwip_setsockopt+0xfe>
    /* UNIMPL case IP_RCVDSTADDR: */
    /* UNIMPL case IP_RCVIF: */
    case IP_TTL:
    case IP_TOS:
      if (optlen < sizeof(int)) {
        err = EINVAL;
  8021f9:	b8 16 00 00 00       	mov    $0x16,%eax
  8021fe:	e9 5e ff ff ff       	jmp    802161 <lwip_setsockopt+0xfe>

#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    if (optlen < sizeof(int)) {
      err = EINVAL;
  802203:	b8 16 00 00 00       	mov    $0x16,%eax
  802208:	e9 54 ff ff ff       	jmp    802161 <lwip_setsockopt+0xfe>
      break;

    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, UNIMPL: optname=0x%x, ..)\n",
                  s, optname));
      err = ENOPROTOOPT;
  80220d:	b8 5c 00 00 00       	mov    $0x5c,%eax
  802212:	e9 4a ff ff ff       	jmp    802161 <lwip_setsockopt+0xfe>
  /* maybe lwip_setsockopt_internal has changed err */
  err = data.err;

  sock_set_errno(sock, err);
  return err ? -1 : 0;
}
  802217:	83 c4 3c             	add    $0x3c,%esp
  80221a:	5b                   	pop    %ebx
  80221b:	5e                   	pop    %esi
  80221c:	5f                   	pop    %edi
  80221d:	5d                   	pop    %ebp
  80221e:	c3                   	ret    

0080221f <lwip_ioctl>:
  sys_sem_signal(sock->conn->op_completed);
}

int
lwip_ioctl(int s, long cmd, void *argp)
{
  80221f:	55                   	push   %ebp
  802220:	89 e5                	mov    %esp,%ebp
  802222:	56                   	push   %esi
  802223:	53                   	push   %ebx
  802224:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  802227:	8b 75 10             	mov    0x10(%ebp),%esi
  struct lwip_socket *sock = get_socket(s);
  80222a:	8b 45 08             	mov    0x8(%ebp),%eax
  80222d:	e8 0e e7 ff ff       	call   800940 <get_socket>
  u16_t buflen = 0;

  if (!sock)
  802232:	85 c0                	test   %eax,%eax
  802234:	0f 84 af 00 00 00    	je     8022e9 <lwip_ioctl+0xca>
    return -1;

  switch (cmd) {
  80223a:	81 fb 7e 66 04 80    	cmp    $0x8004667e,%ebx
  802240:	74 60                	je     8022a2 <lwip_ioctl+0x83>
  802242:	81 fb 7f 66 04 40    	cmp    $0x4004667f,%ebx
  802248:	0f 85 83 00 00 00    	jne    8022d1 <lwip_ioctl+0xb2>
  case FIONREAD:
    if (!argp) {
  80224e:	85 f6                	test   %esi,%esi
  802250:	75 1b                	jne    80226d <lwip_ioctl+0x4e>
      sock_set_errno(sock, EINVAL);
  802252:	c7 40 10 16 00 00 00 	movl   $0x16,0x10(%eax)
  802259:	c7 05 00 c2 b3 00 16 	movl   $0x16,0xb3c200
  802260:	00 00 00 
      return -1;
  802263:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  802268:	e9 81 00 00 00       	jmp    8022ee <lwip_ioctl+0xcf>
    }

    SYS_ARCH_GET(sock->conn->recv_avail, *((u16_t*)argp));
  80226d:	8b 10                	mov    (%eax),%edx
  80226f:	0f b7 52 20          	movzwl 0x20(%edx),%edx
  802273:	66 89 16             	mov    %dx,(%esi)

    /* Check if there is data left from the last recv operation. /maq 041215 */
    if (sock->lastdata) {
  802276:	8b 48 04             	mov    0x4(%eax),%ecx
  802279:	85 c9                	test   %ecx,%ecx
  80227b:	74 0d                	je     80228a <lwip_ioctl+0x6b>
      buflen = netbuf_len(sock->lastdata);
  80227d:	8b 09                	mov    (%ecx),%ecx
      buflen -= sock->lastoffset;
  80227f:	66 03 51 08          	add    0x8(%ecx),%dx

      *((u16_t*)argp) += buflen;
  802283:	66 2b 50 08          	sub    0x8(%eax),%dx
  802287:	66 89 16             	mov    %dx,(%esi)
    }

    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, FIONREAD, %p) = %u\n", s, argp, *((u16_t*)argp)));
    sock_set_errno(sock, 0);
  80228a:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  802291:	c7 05 00 c2 b3 00 00 	movl   $0x0,0xb3c200
  802298:	00 00 00 
    return 0;
  80229b:	b8 00 00 00 00       	mov    $0x0,%eax
  8022a0:	eb 4c                	jmp    8022ee <lwip_ioctl+0xcf>

  case FIONBIO:
    if (argp && *(u32_t*)argp)
  8022a2:	85 f6                	test   %esi,%esi
  8022a4:	74 0d                	je     8022b3 <lwip_ioctl+0x94>
  8022a6:	83 3e 00             	cmpl   $0x0,(%esi)
  8022a9:	74 08                	je     8022b3 <lwip_ioctl+0x94>
      sock->flags |= O_NONBLOCK;
  8022ab:	66 81 48 0e 00 08    	orw    $0x800,0xe(%eax)
  8022b1:	eb 06                	jmp    8022b9 <lwip_ioctl+0x9a>
    else
      sock->flags &= ~O_NONBLOCK;
  8022b3:	66 81 60 0e ff f7    	andw   $0xf7ff,0xe(%eax)
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, FIONBIO, %d)\n", s, !!(sock->flags & O_NONBLOCK)));
    sock_set_errno(sock, 0);
  8022b9:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  8022c0:	c7 05 00 c2 b3 00 00 	movl   $0x0,0xb3c200
  8022c7:	00 00 00 
    return 0;
  8022ca:	b8 00 00 00 00       	mov    $0x0,%eax
  8022cf:	eb 1d                	jmp    8022ee <lwip_ioctl+0xcf>

  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, UNIMPL: 0x%lx, %p)\n", s, cmd, argp));
    sock_set_errno(sock, ENOSYS); /* not yet implemented */
  8022d1:	c7 40 10 26 00 00 00 	movl   $0x26,0x10(%eax)
  8022d8:	c7 05 00 c2 b3 00 26 	movl   $0x26,0xb3c200
  8022df:	00 00 00 
    return -1;
  8022e2:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8022e7:	eb 05                	jmp    8022ee <lwip_ioctl+0xcf>
{
  struct lwip_socket *sock = get_socket(s);
  u16_t buflen = 0;

  if (!sock)
    return -1;
  8022e9:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, UNIMPL: 0x%lx, %p)\n", s, cmd, argp));
    sock_set_errno(sock, ENOSYS); /* not yet implemented */
    return -1;
  } /* switch (cmd) */
}
  8022ee:	5b                   	pop    %ebx
  8022ef:	5e                   	pop    %esi
  8022f0:	5d                   	pop    %ebp
  8022f1:	c3                   	ret    
  8022f2:	66 90                	xchg   %ax,%ax
  8022f4:	66 90                	xchg   %ax,%ax
  8022f6:	66 90                	xchg   %ax,%ax
  8022f8:	66 90                	xchg   %ax,%ax
  8022fa:	66 90                	xchg   %ax,%ax
  8022fc:	66 90                	xchg   %ax,%ax
  8022fe:	66 90                	xchg   %ax,%ax

00802300 <tcpip_tcp_timer>:
 *
 * @param arg unused argument
 */
static void
tcpip_tcp_timer(void *arg)
{
  802300:	55                   	push   %ebp
  802301:	89 e5                	mov    %esp,%ebp
  802303:	83 ec 18             	sub    $0x18,%esp
  LWIP_UNUSED_ARG(arg);

  /* call TCP timer handler */
  tcp_tmr();
  802306:	e8 15 44 00 00       	call   806720 <tcp_tmr>
  /* timer still needed? */
  if (tcp_active_pcbs || tcp_tw_pcbs) {
  80230b:	83 3d 5c c2 b3 00 00 	cmpl   $0x0,0xb3c25c
  802312:	75 09                	jne    80231d <tcpip_tcp_timer+0x1d>
  802314:	83 3d 70 c2 b3 00 00 	cmpl   $0x0,0xb3c270
  80231b:	74 1e                	je     80233b <tcpip_tcp_timer+0x3b>
    /* restart timer */
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
  80231d:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  802324:	00 
  802325:	c7 44 24 04 00 23 80 	movl   $0x802300,0x4(%esp)
  80232c:	00 
  80232d:	c7 04 24 fa 00 00 00 	movl   $0xfa,(%esp)
  802334:	e8 7c 34 00 00       	call   8057b5 <sys_timeout>
  802339:	eb 0a                	jmp    802345 <tcpip_tcp_timer+0x45>
  } else {
    /* disable timer */
    tcpip_tcp_timer_active = 0;
  80233b:	c7 05 00 63 81 00 00 	movl   $0x0,0x816300
  802342:	00 00 00 
  }
}
  802345:	c9                   	leave  
  802346:	c3                   	ret    

00802347 <tcpip_thread>:
 *
 * @param arg unused argument
 */
static void
tcpip_thread(void *arg)
{
  802347:	55                   	push   %ebp
  802348:	89 e5                	mov    %esp,%ebp
  80234a:	53                   	push   %ebx
  80234b:	83 ec 24             	sub    $0x24,%esp
  struct tcpip_msg *msg;
  LWIP_UNUSED_ARG(arg);

#if IP_REASSEMBLY
  sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);
  80234e:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  802355:	00 
  802356:	c7 44 24 04 36 25 80 	movl   $0x802536,0x4(%esp)
  80235d:	00 
  80235e:	c7 04 24 e8 03 00 00 	movl   $0x3e8,(%esp)
  802365:	e8 4b 34 00 00       	call   8057b5 <sys_timeout>
#endif /* IP_REASSEMBLY */
#if LWIP_ARP
  sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
  80236a:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  802371:	00 
  802372:	c7 44 24 04 0d 25 80 	movl   $0x80250d,0x4(%esp)
  802379:	00 
  80237a:	c7 04 24 88 13 00 00 	movl   $0x1388,(%esp)
  802381:	e8 2f 34 00 00       	call   8057b5 <sys_timeout>
#endif /* LWIP_ARP */
#if LWIP_DHCP
  sys_timeout(DHCP_COARSE_TIMER_MSECS, dhcp_timer_coarse, NULL);
  802386:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80238d:	00 
  80238e:	c7 44 24 04 e4 24 80 	movl   $0x8024e4,0x4(%esp)
  802395:	00 
  802396:	c7 04 24 60 ea 00 00 	movl   $0xea60,(%esp)
  80239d:	e8 13 34 00 00       	call   8057b5 <sys_timeout>
  sys_timeout(DHCP_FINE_TIMER_MSECS, dhcp_timer_fine, NULL);
  8023a2:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8023a9:	00 
  8023aa:	c7 44 24 04 bb 24 80 	movl   $0x8024bb,0x4(%esp)
  8023b1:	00 
  8023b2:	c7 04 24 f4 01 00 00 	movl   $0x1f4,(%esp)
  8023b9:	e8 f7 33 00 00       	call   8057b5 <sys_timeout>
#endif /* LWIP_IGMP */
#if LWIP_DNS
  sys_timeout(DNS_TMR_INTERVAL, dns_timer, NULL);
#endif /* LWIP_DNS */

  if (tcpip_init_done != NULL) {
  8023be:	a1 08 63 81 00       	mov    0x816308,%eax
  8023c3:	85 c0                	test   %eax,%eax
  8023c5:	75 05                	jne    8023cc <tcpip_thread+0x85>
    tcpip_init_done(tcpip_init_done_arg);
  }

  LOCK_TCPIP_CORE();
  while (1) {                          /* MAIN Loop */
    sys_mbox_fetch(mbox, (void *)&msg);
  8023c7:	8d 5d f4             	lea    -0xc(%ebp),%ebx
  8023ca:	eb 0d                	jmp    8023d9 <tcpip_thread+0x92>
#if LWIP_DNS
  sys_timeout(DNS_TMR_INTERVAL, dns_timer, NULL);
#endif /* LWIP_DNS */

  if (tcpip_init_done != NULL) {
    tcpip_init_done(tcpip_init_done_arg);
  8023cc:	8b 15 04 63 81 00    	mov    0x816304,%edx
  8023d2:	89 14 24             	mov    %edx,(%esp)
  8023d5:	ff d0                	call   *%eax
  8023d7:	eb ee                	jmp    8023c7 <tcpip_thread+0x80>
  }

  LOCK_TCPIP_CORE();
  while (1) {                          /* MAIN Loop */
    sys_mbox_fetch(mbox, (void *)&msg);
  8023d9:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8023dd:	a1 00 50 81 00       	mov    0x815000,%eax
  8023e2:	89 04 24             	mov    %eax,(%esp)
  8023e5:	e8 a3 32 00 00       	call   80568d <sys_mbox_fetch>
    switch (msg->type) {
  8023ea:	8b 55 f4             	mov    -0xc(%ebp),%edx
  8023ed:	8b 02                	mov    (%edx),%eax
  8023ef:	83 f8 01             	cmp    $0x1,%eax
  8023f2:	74 1e                	je     802412 <tcpip_thread+0xcb>
  8023f4:	83 f8 01             	cmp    $0x1,%eax
  8023f7:	72 0c                	jb     802405 <tcpip_thread+0xbe>
  8023f9:	83 f8 02             	cmp    $0x2,%eax
  8023fc:	74 52                	je     802450 <tcpip_thread+0x109>
  8023fe:	83 f8 03             	cmp    $0x3,%eax
  802401:	74 6e                	je     802471 <tcpip_thread+0x12a>
  802403:	eb d4                	jmp    8023d9 <tcpip_thread+0x92>
#if LWIP_NETCONN
    case TCPIP_MSG_API:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: API message %p\n", (void *)msg));
      msg->msg.apimsg->function(&(msg->msg.apimsg->msg));
  802405:	8b 42 08             	mov    0x8(%edx),%eax
  802408:	8d 50 04             	lea    0x4(%eax),%edx
  80240b:	89 14 24             	mov    %edx,(%esp)
  80240e:	ff 10                	call   *(%eax)
      break;
  802410:	eb c7                	jmp    8023d9 <tcpip_thread+0x92>
#endif /* LWIP_NETCONN */

    case TCPIP_MSG_INPKT:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: PACKET %p\n", (void *)msg));
#if LWIP_ARP
      if (msg->msg.inp.netif->flags & NETIF_FLAG_ETHARP) {
  802412:	8b 42 0c             	mov    0xc(%edx),%eax
  802415:	f6 40 2e 20          	testb  $0x20,0x2e(%eax)
  802419:	74 11                	je     80242c <tcpip_thread+0xe5>
        ethernet_input(msg->msg.inp.p, msg->msg.inp.netif);
  80241b:	89 44 24 04          	mov    %eax,0x4(%esp)
  80241f:	8b 42 08             	mov    0x8(%edx),%eax
  802422:	89 04 24             	mov    %eax,(%esp)
  802425:	e8 3b 80 00 00       	call   80a465 <ethernet_input>
  80242a:	eb 0f                	jmp    80243b <tcpip_thread+0xf4>
      } else
#endif /* LWIP_ARP */
      { ip_input(msg->msg.inp.p, msg->msg.inp.netif);
  80242c:	89 44 24 04          	mov    %eax,0x4(%esp)
  802430:	8b 42 08             	mov    0x8(%edx),%eax
  802433:	89 04 24             	mov    %eax,(%esp)
  802436:	e8 05 47 00 00       	call   806b40 <ip_input>
      }
      memp_free(MEMP_TCPIP_MSG_INPKT, msg);
  80243b:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80243e:	89 44 24 04          	mov    %eax,0x4(%esp)
  802442:	c7 04 24 09 00 00 00 	movl   $0x9,(%esp)
  802449:	e8 f4 25 00 00       	call   804a42 <memp_free>
      break;
  80244e:	eb 89                	jmp    8023d9 <tcpip_thread+0x92>
      break;
#endif /* LWIP_NETIF_API */

    case TCPIP_MSG_CALLBACK:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: CALLBACK %p\n", (void *)msg));
      msg->msg.cb.f(msg->msg.cb.ctx);
  802450:	8b 42 0c             	mov    0xc(%edx),%eax
  802453:	89 04 24             	mov    %eax,(%esp)
  802456:	ff 52 08             	call   *0x8(%edx)
      memp_free(MEMP_TCPIP_MSG_API, msg);
  802459:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80245c:	89 44 24 04          	mov    %eax,0x4(%esp)
  802460:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  802467:	e8 d6 25 00 00       	call   804a42 <memp_free>
      break;
  80246c:	e9 68 ff ff ff       	jmp    8023d9 <tcpip_thread+0x92>

    case TCPIP_MSG_TIMEOUT:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: TIMEOUT %p\n", (void *)msg));

      if(msg->msg.tmo.msecs != 0xffffffff)
  802471:	8b 42 08             	mov    0x8(%edx),%eax
  802474:	83 f8 ff             	cmp    $0xffffffff,%eax
  802477:	74 18                	je     802491 <tcpip_thread+0x14a>
        sys_timeout (msg->msg.tmo.msecs, msg->msg.tmo.h, msg->msg.tmo.arg);
  802479:	8b 4a 10             	mov    0x10(%edx),%ecx
  80247c:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  802480:	8b 52 0c             	mov    0xc(%edx),%edx
  802483:	89 54 24 04          	mov    %edx,0x4(%esp)
  802487:	89 04 24             	mov    %eax,(%esp)
  80248a:	e8 26 33 00 00       	call   8057b5 <sys_timeout>
  80248f:	eb 12                	jmp    8024a3 <tcpip_thread+0x15c>
      else
        sys_untimeout (msg->msg.tmo.h, msg->msg.tmo.arg);
  802491:	8b 42 10             	mov    0x10(%edx),%eax
  802494:	89 44 24 04          	mov    %eax,0x4(%esp)
  802498:	8b 42 0c             	mov    0xc(%edx),%eax
  80249b:	89 04 24             	mov    %eax,(%esp)
  80249e:	e8 cb 33 00 00       	call   80586e <sys_untimeout>
      memp_free(MEMP_TCPIP_MSG_API, msg);
  8024a3:	8b 45 f4             	mov    -0xc(%ebp),%eax
  8024a6:	89 44 24 04          	mov    %eax,0x4(%esp)
  8024aa:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  8024b1:	e8 8c 25 00 00       	call   804a42 <memp_free>
      break;
  8024b6:	e9 1e ff ff ff       	jmp    8023d9 <tcpip_thread+0x92>

008024bb <dhcp_timer_fine>:
 *
 * @param arg unused argument
 */
static void
dhcp_timer_fine(void *arg)
{
  8024bb:	55                   	push   %ebp
  8024bc:	89 e5                	mov    %esp,%ebp
  8024be:	83 ec 18             	sub    $0x18,%esp
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip: dhcp_fine_tmr()\n"));
  dhcp_fine_tmr();
  8024c1:	e8 51 1d 00 00       	call   804217 <dhcp_fine_tmr>
  sys_timeout(DHCP_FINE_TIMER_MSECS, dhcp_timer_fine, NULL);
  8024c6:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8024cd:	00 
  8024ce:	c7 44 24 04 bb 24 80 	movl   $0x8024bb,0x4(%esp)
  8024d5:	00 
  8024d6:	c7 04 24 f4 01 00 00 	movl   $0x1f4,(%esp)
  8024dd:	e8 d3 32 00 00       	call   8057b5 <sys_timeout>
}
  8024e2:	c9                   	leave  
  8024e3:	c3                   	ret    

008024e4 <dhcp_timer_coarse>:
 *
 * @param arg unused argument
 */
static void
dhcp_timer_coarse(void *arg)
{
  8024e4:	55                   	push   %ebp
  8024e5:	89 e5                	mov    %esp,%ebp
  8024e7:	83 ec 18             	sub    $0x18,%esp
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip: dhcp_coarse_tmr()\n"));
  dhcp_coarse_tmr();
  8024ea:	e8 3f 1b 00 00       	call   80402e <dhcp_coarse_tmr>
  sys_timeout(DHCP_COARSE_TIMER_MSECS, dhcp_timer_coarse, NULL);
  8024ef:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8024f6:	00 
  8024f7:	c7 44 24 04 e4 24 80 	movl   $0x8024e4,0x4(%esp)
  8024fe:	00 
  8024ff:	c7 04 24 60 ea 00 00 	movl   $0xea60,(%esp)
  802506:	e8 aa 32 00 00       	call   8057b5 <sys_timeout>
}
  80250b:	c9                   	leave  
  80250c:	c3                   	ret    

0080250d <arp_timer>:
 *
 * @param arg unused argument
 */
static void
arp_timer(void *arg)
{
  80250d:	55                   	push   %ebp
  80250e:	89 e5                	mov    %esp,%ebp
  802510:	83 ec 18             	sub    $0x18,%esp
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip: etharp_tmr()\n"));
  etharp_tmr();
  802513:	e8 c8 77 00 00       	call   809ce0 <etharp_tmr>
  sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
  802518:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80251f:	00 
  802520:	c7 44 24 04 0d 25 80 	movl   $0x80250d,0x4(%esp)
  802527:	00 
  802528:	c7 04 24 88 13 00 00 	movl   $0x1388,(%esp)
  80252f:	e8 81 32 00 00       	call   8057b5 <sys_timeout>
}
  802534:	c9                   	leave  
  802535:	c3                   	ret    

00802536 <ip_reass_timer>:
 *
 * @param arg unused argument
 */
static void
ip_reass_timer(void *arg)
{
  802536:	55                   	push   %ebp
  802537:	89 e5                	mov    %esp,%ebp
  802539:	83 ec 18             	sub    $0x18,%esp
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip: ip_reass_tmr()\n"));
  ip_reass_tmr();
  80253c:	e8 e4 4c 00 00       	call   807225 <ip_reass_tmr>
  sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);
  802541:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  802548:	00 
  802549:	c7 44 24 04 36 25 80 	movl   $0x802536,0x4(%esp)
  802550:	00 
  802551:	c7 04 24 e8 03 00 00 	movl   $0x3e8,(%esp)
  802558:	e8 58 32 00 00       	call   8057b5 <sys_timeout>
}
  80255d:	c9                   	leave  
  80255e:	c3                   	ret    

0080255f <pbuf_free_int>:
 *
 * @param p The pbuf (chain) to be dereferenced.
 */
static void
pbuf_free_int(void *p)
{
  80255f:	55                   	push   %ebp
  802560:	89 e5                	mov    %esp,%ebp
  802562:	83 ec 18             	sub    $0x18,%esp
  struct pbuf *q = p;
  pbuf_free(q);
  802565:	8b 45 08             	mov    0x8(%ebp),%eax
  802568:	89 04 24             	mov    %eax,(%esp)
  80256b:	e8 84 28 00 00       	call   804df4 <pbuf_free>
}
  802570:	c9                   	leave  
  802571:	c3                   	ret    

00802572 <tcp_timer_needed>:
 * the reason is to have the TCP timer only running when
 * there are active (or time-wait) PCBs.
 */
void
tcp_timer_needed(void)
{
  802572:	55                   	push   %ebp
  802573:	89 e5                	mov    %esp,%ebp
  802575:	83 ec 18             	sub    $0x18,%esp
  /* timer is off but needed again? */
  if (!tcpip_tcp_timer_active && (tcp_active_pcbs || tcp_tw_pcbs)) {
  802578:	83 3d 00 63 81 00 00 	cmpl   $0x0,0x816300
  80257f:	75 38                	jne    8025b9 <tcp_timer_needed+0x47>
  802581:	83 3d 5c c2 b3 00 00 	cmpl   $0x0,0xb3c25c
  802588:	75 09                	jne    802593 <tcp_timer_needed+0x21>
  80258a:	83 3d 70 c2 b3 00 00 	cmpl   $0x0,0xb3c270
  802591:	74 26                	je     8025b9 <tcp_timer_needed+0x47>
    /* enable and start timer */
    tcpip_tcp_timer_active = 1;
  802593:	c7 05 00 63 81 00 01 	movl   $0x1,0x816300
  80259a:	00 00 00 
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
  80259d:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8025a4:	00 
  8025a5:	c7 44 24 04 00 23 80 	movl   $0x802300,0x4(%esp)
  8025ac:	00 
  8025ad:	c7 04 24 fa 00 00 00 	movl   $0xfa,(%esp)
  8025b4:	e8 fc 31 00 00       	call   8057b5 <sys_timeout>
  }
}
  8025b9:	c9                   	leave  
  8025ba:	c3                   	ret    

008025bb <tcpip_input>:
err_t
tcpip_input(struct pbuf *p, struct netif *inp)
{
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
  8025bb:	83 3d 00 50 81 00 ff 	cmpl   $0xffffffff,0x815000
  8025c2:	74 57                	je     80261b <tcpip_input+0x60>
 *          to an IP header (if netif doesn't got NETIF_FLAG_ETHARP flag)
 * @param inp the network interface on which the packet was received
 */
err_t
tcpip_input(struct pbuf *p, struct netif *inp)
{
  8025c4:	55                   	push   %ebp
  8025c5:	89 e5                	mov    %esp,%ebp
  8025c7:	53                   	push   %ebx
  8025c8:	83 ec 14             	sub    $0x14,%esp
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
    msg = memp_malloc(MEMP_TCPIP_MSG_INPKT);
  8025cb:	c7 04 24 09 00 00 00 	movl   $0x9,(%esp)
  8025d2:	e8 0b 24 00 00       	call   8049e2 <memp_malloc>
  8025d7:	89 c3                	mov    %eax,%ebx
    if (msg == NULL) {
  8025d9:	85 c0                	test   %eax,%eax
  8025db:	74 44                	je     802621 <tcpip_input+0x66>
      return ERR_MEM;
    }

    msg->type = TCPIP_MSG_INPKT;
  8025dd:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    msg->msg.inp.p = p;
  8025e3:	8b 45 08             	mov    0x8(%ebp),%eax
  8025e6:	89 43 08             	mov    %eax,0x8(%ebx)
    msg->msg.inp.netif = inp;
  8025e9:	8b 45 0c             	mov    0xc(%ebp),%eax
  8025ec:	89 43 0c             	mov    %eax,0xc(%ebx)
    if (sys_mbox_trypost(mbox, msg) != ERR_OK) {
  8025ef:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8025f3:	a1 00 50 81 00       	mov    0x815000,%eax
  8025f8:	89 04 24             	mov    %eax,(%esp)
  8025fb:	e8 8c 84 00 00       	call   80aa8c <sys_mbox_trypost>
  802600:	84 c0                	test   %al,%al
  802602:	74 24                	je     802628 <tcpip_input+0x6d>
      memp_free(MEMP_TCPIP_MSG_INPKT, msg);
  802604:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  802608:	c7 04 24 09 00 00 00 	movl   $0x9,(%esp)
  80260f:	e8 2e 24 00 00       	call   804a42 <memp_free>
      return ERR_MEM;
  802614:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  802619:	eb 12                	jmp    80262d <tcpip_input+0x72>
    }
    return ERR_OK;
  }
  return ERR_VAL;
  80261b:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
}
  802620:	c3                   	ret    
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
    msg = memp_malloc(MEMP_TCPIP_MSG_INPKT);
    if (msg == NULL) {
      return ERR_MEM;
  802621:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  802626:	eb 05                	jmp    80262d <tcpip_input+0x72>
    msg->msg.inp.netif = inp;
    if (sys_mbox_trypost(mbox, msg) != ERR_OK) {
      memp_free(MEMP_TCPIP_MSG_INPKT, msg);
      return ERR_MEM;
    }
    return ERR_OK;
  802628:	b8 00 00 00 00       	mov    $0x0,%eax
  }
  return ERR_VAL;
}
  80262d:	83 c4 14             	add    $0x14,%esp
  802630:	5b                   	pop    %ebx
  802631:	5d                   	pop    %ebp
  802632:	c3                   	ret    

00802633 <tcpip_callback_with_block>:
 * @param block 1 to block until the request is posted, 0 to non-blocking mode
 * @return ERR_OK if the function was called, another err_t if not
 */
err_t
tcpip_callback_with_block(void (*f)(void *ctx), void *ctx, u8_t block)
{
  802633:	55                   	push   %ebp
  802634:	89 e5                	mov    %esp,%ebp
  802636:	56                   	push   %esi
  802637:	53                   	push   %ebx
  802638:	83 ec 10             	sub    $0x10,%esp
  80263b:	8b 75 10             	mov    0x10(%ebp),%esi
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
  80263e:	83 3d 00 50 81 00 ff 	cmpl   $0xffffffff,0x815000
  802645:	74 6e                	je     8026b5 <tcpip_callback_with_block+0x82>
    msg = memp_malloc(MEMP_TCPIP_MSG_API);
  802647:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  80264e:	e8 8f 23 00 00       	call   8049e2 <memp_malloc>
  802653:	89 c3                	mov    %eax,%ebx
    if (msg == NULL) {
  802655:	85 c0                	test   %eax,%eax
  802657:	74 63                	je     8026bc <tcpip_callback_with_block+0x89>
      return ERR_MEM;
    }

    msg->type = TCPIP_MSG_CALLBACK;
  802659:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
    msg->msg.cb.f = f;
  80265f:	8b 45 08             	mov    0x8(%ebp),%eax
  802662:	89 43 08             	mov    %eax,0x8(%ebx)
    msg->msg.cb.ctx = ctx;
  802665:	8b 45 0c             	mov    0xc(%ebp),%eax
  802668:	89 43 0c             	mov    %eax,0xc(%ebx)
    if (block) {
  80266b:	89 f0                	mov    %esi,%eax
  80266d:	84 c0                	test   %al,%al
  80266f:	74 18                	je     802689 <tcpip_callback_with_block+0x56>
      sys_mbox_post(mbox, msg);
  802671:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  802675:	a1 00 50 81 00       	mov    0x815000,%eax
  80267a:	89 04 24             	mov    %eax,(%esp)
  80267d:	e8 d4 84 00 00       	call   80ab56 <sys_mbox_post>
      if (sys_mbox_trypost(mbox, msg) != ERR_OK) {
        memp_free(MEMP_TCPIP_MSG_API, msg);
        return ERR_MEM;
      }
    }
    return ERR_OK;
  802682:	b8 00 00 00 00       	mov    $0x0,%eax
  802687:	eb 3f                	jmp    8026c8 <tcpip_callback_with_block+0x95>
    msg->msg.cb.f = f;
    msg->msg.cb.ctx = ctx;
    if (block) {
      sys_mbox_post(mbox, msg);
    } else {
      if (sys_mbox_trypost(mbox, msg) != ERR_OK) {
  802689:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80268d:	a1 00 50 81 00       	mov    0x815000,%eax
  802692:	89 04 24             	mov    %eax,(%esp)
  802695:	e8 f2 83 00 00       	call   80aa8c <sys_mbox_trypost>
  80269a:	84 c0                	test   %al,%al
  80269c:	74 25                	je     8026c3 <tcpip_callback_with_block+0x90>
        memp_free(MEMP_TCPIP_MSG_API, msg);
  80269e:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8026a2:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  8026a9:	e8 94 23 00 00       	call   804a42 <memp_free>
        return ERR_MEM;
  8026ae:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8026b3:	eb 13                	jmp    8026c8 <tcpip_callback_with_block+0x95>
      }
    }
    return ERR_OK;
  }
  return ERR_VAL;
  8026b5:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  8026ba:	eb 0c                	jmp    8026c8 <tcpip_callback_with_block+0x95>
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
    msg = memp_malloc(MEMP_TCPIP_MSG_API);
    if (msg == NULL) {
      return ERR_MEM;
  8026bc:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8026c1:	eb 05                	jmp    8026c8 <tcpip_callback_with_block+0x95>
      if (sys_mbox_trypost(mbox, msg) != ERR_OK) {
        memp_free(MEMP_TCPIP_MSG_API, msg);
        return ERR_MEM;
      }
    }
    return ERR_OK;
  8026c3:	b8 00 00 00 00       	mov    $0x0,%eax
  }
  return ERR_VAL;
}
  8026c8:	83 c4 10             	add    $0x10,%esp
  8026cb:	5b                   	pop    %ebx
  8026cc:	5e                   	pop    %esi
  8026cd:	5d                   	pop    %ebp
  8026ce:	c3                   	ret    

008026cf <tcpip_timeout>:
err_t
tcpip_timeout(u32_t msecs, sys_timeout_handler h, void *arg)
{
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
  8026cf:	83 3d 00 50 81 00 ff 	cmpl   $0xffffffff,0x815000
  8026d6:	74 46                	je     80271e <tcpip_timeout+0x4f>
  return ERR_VAL;
}

err_t
tcpip_timeout(u32_t msecs, sys_timeout_handler h, void *arg)
{
  8026d8:	55                   	push   %ebp
  8026d9:	89 e5                	mov    %esp,%ebp
  8026db:	83 ec 18             	sub    $0x18,%esp
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
    msg = memp_malloc(MEMP_TCPIP_MSG_API);
  8026de:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  8026e5:	e8 f8 22 00 00       	call   8049e2 <memp_malloc>
    if (msg == NULL) {
  8026ea:	85 c0                	test   %eax,%eax
  8026ec:	74 36                	je     802724 <tcpip_timeout+0x55>
      return ERR_MEM;
    }

    msg->type = TCPIP_MSG_TIMEOUT;
  8026ee:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
    msg->msg.tmo.msecs = msecs;
  8026f4:	8b 55 08             	mov    0x8(%ebp),%edx
  8026f7:	89 50 08             	mov    %edx,0x8(%eax)
    msg->msg.tmo.h = h;
  8026fa:	8b 55 0c             	mov    0xc(%ebp),%edx
  8026fd:	89 50 0c             	mov    %edx,0xc(%eax)
    msg->msg.tmo.arg = arg;
  802700:	8b 55 10             	mov    0x10(%ebp),%edx
  802703:	89 50 10             	mov    %edx,0x10(%eax)
    sys_mbox_post(mbox, msg);
  802706:	89 44 24 04          	mov    %eax,0x4(%esp)
  80270a:	a1 00 50 81 00       	mov    0x815000,%eax
  80270f:	89 04 24             	mov    %eax,(%esp)
  802712:	e8 3f 84 00 00       	call   80ab56 <sys_mbox_post>
    return ERR_OK;
  802717:	b8 00 00 00 00       	mov    $0x0,%eax
  80271c:	eb 0b                	jmp    802729 <tcpip_timeout+0x5a>
  }
  return ERR_VAL;
  80271e:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
}
  802723:	c3                   	ret    
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
    msg = memp_malloc(MEMP_TCPIP_MSG_API);
    if (msg == NULL) {
      return ERR_MEM;
  802724:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    msg->msg.tmo.arg = arg;
    sys_mbox_post(mbox, msg);
    return ERR_OK;
  }
  return ERR_VAL;
}
  802729:	c9                   	leave  
  80272a:	c3                   	ret    

0080272b <tcpip_apimsg>:
 * @param apimsg a struct containing the function to call and its parameters
 * @return ERR_OK if the function was called, another err_t if not
 */
err_t
tcpip_apimsg(struct api_msg *apimsg)
{
  80272b:	55                   	push   %ebp
  80272c:	89 e5                	mov    %esp,%ebp
  80272e:	53                   	push   %ebx
  80272f:	83 ec 34             	sub    $0x34,%esp
  802732:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct tcpip_msg msg;
  
  if (mbox != SYS_MBOX_NULL) {
  802735:	a1 00 50 81 00       	mov    0x815000,%eax
  80273a:	83 f8 ff             	cmp    $0xffffffff,%eax
  80273d:	74 36                	je     802775 <tcpip_apimsg+0x4a>
    msg.type = TCPIP_MSG_API;
  80273f:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    msg.msg.apimsg = apimsg;
  802746:	89 5d ec             	mov    %ebx,-0x14(%ebp)
    sys_mbox_post(mbox, &msg);
  802749:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  80274c:	89 54 24 04          	mov    %edx,0x4(%esp)
  802750:	89 04 24             	mov    %eax,(%esp)
  802753:	e8 fe 83 00 00       	call   80ab56 <sys_mbox_post>
    sys_arch_sem_wait(apimsg->msg.conn->op_completed, 0);
  802758:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80275f:	00 
  802760:	8b 43 04             	mov    0x4(%ebx),%eax
  802763:	8b 40 10             	mov    0x10(%eax),%eax
  802766:	89 04 24             	mov    %eax,(%esp)
  802769:	e8 07 82 00 00       	call   80a975 <sys_arch_sem_wait>
    return ERR_OK;
  80276e:	b8 00 00 00 00       	mov    $0x0,%eax
  802773:	eb 05                	jmp    80277a <tcpip_apimsg+0x4f>
  }
  return ERR_VAL;
  802775:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
}
  80277a:	83 c4 34             	add    $0x34,%esp
  80277d:	5b                   	pop    %ebx
  80277e:	5d                   	pop    %ebp
  80277f:	c3                   	ret    

00802780 <tcpip_init>:
 * @param initfunc a function to call when tcpip_thread is running and finished initializing
 * @param arg argument to pass to initfunc
 */
void
tcpip_init(void (* initfunc)(void *), void *arg)
{
  802780:	55                   	push   %ebp
  802781:	89 e5                	mov    %esp,%ebp
  802783:	83 ec 28             	sub    $0x28,%esp
  lwip_init();
  802786:	e8 f5 03 00 00       	call   802b80 <lwip_init>

  tcpip_init_done = initfunc;
  80278b:	8b 45 08             	mov    0x8(%ebp),%eax
  80278e:	a3 08 63 81 00       	mov    %eax,0x816308
  tcpip_init_done_arg = arg;
  802793:	8b 45 0c             	mov    0xc(%ebp),%eax
  802796:	a3 04 63 81 00       	mov    %eax,0x816304
  mbox = sys_mbox_new(TCPIP_MBOX_SIZE);
  80279b:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8027a2:	e8 3f 80 00 00       	call   80a7e6 <sys_mbox_new>
  8027a7:	a3 00 50 81 00       	mov    %eax,0x815000
#if LWIP_TCPIP_CORE_LOCKING
  lock_tcpip_core = sys_sem_new(1);
#endif /* LWIP_TCPIP_CORE_LOCKING */

  sys_thread_new(TCPIP_THREAD_NAME, tcpip_thread, NULL, TCPIP_THREAD_STACKSIZE, TCPIP_THREAD_PRIO);
  8027ac:	c7 44 24 10 01 00 00 	movl   $0x1,0x10(%esp)
  8027b3:	00 
  8027b4:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  8027bb:	00 
  8027bc:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8027c3:	00 
  8027c4:	c7 44 24 04 47 23 80 	movl   $0x802347,0x4(%esp)
  8027cb:	00 
  8027cc:	c7 04 24 7c 1f 81 00 	movl   $0x811f7c,(%esp)
  8027d3:	e8 dc 84 00 00       	call   80acb4 <sys_thread_new>
}
  8027d8:	c9                   	leave  
  8027d9:	c3                   	ret    

008027da <pbuf_free_callback>:
 * @param p The pbuf (chain) to be dereferenced.
 * @return ERR_OK if callback could be enqueued, an err_t if not
 */
err_t
pbuf_free_callback(struct pbuf *p)
{
  8027da:	55                   	push   %ebp
  8027db:	89 e5                	mov    %esp,%ebp
  8027dd:	83 ec 18             	sub    $0x18,%esp
  return tcpip_callback_with_block(pbuf_free_int, p, 0);
  8027e0:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8027e7:	00 
  8027e8:	8b 45 08             	mov    0x8(%ebp),%eax
  8027eb:	89 44 24 04          	mov    %eax,0x4(%esp)
  8027ef:	c7 04 24 5f 25 80 00 	movl   $0x80255f,(%esp)
  8027f6:	e8 38 fe ff ff       	call   802633 <tcpip_callback_with_block>
}
  8027fb:	c9                   	leave  
  8027fc:	c3                   	ret    

008027fd <mem_free_callback>:
 * @param m the heap memory to free
 * @return ERR_OK if callback could be enqueued, an err_t if not
 */
err_t
mem_free_callback(void *m)
{
  8027fd:	55                   	push   %ebp
  8027fe:	89 e5                	mov    %esp,%ebp
  802800:	83 ec 18             	sub    $0x18,%esp
  return tcpip_callback_with_block(mem_free, m, 0);
  802803:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80280a:	00 
  80280b:	8b 45 08             	mov    0x8(%ebp),%eax
  80280e:	89 44 24 04          	mov    %eax,0x4(%esp)
  802812:	c7 04 24 e5 44 80 00 	movl   $0x8044e5,(%esp)
  802819:	e8 15 fe ff ff       	call   802633 <tcpip_callback_with_block>
}
  80281e:	c9                   	leave  
  80281f:	c3                   	ret    

00802820 <netbuf_new>:
 * @return a pointer to a new netbuf
 *         NULL on lack of memory
 */
struct
netbuf *netbuf_new(void)
{
  802820:	55                   	push   %ebp
  802821:	89 e5                	mov    %esp,%ebp
  802823:	83 ec 18             	sub    $0x18,%esp
  struct netbuf *buf;

  buf = memp_malloc(MEMP_NETBUF);
  802826:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
  80282d:	e8 b0 21 00 00       	call   8049e2 <memp_malloc>
  if (buf != NULL) {
  802832:	85 c0                	test   %eax,%eax
  802834:	74 14                	je     80284a <netbuf_new+0x2a>
    buf->p = NULL;
  802836:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    buf->ptr = NULL;
  80283c:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    buf->addr = NULL;
  802843:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    return buf;
  } else {
    return NULL;
  }
}
  80284a:	c9                   	leave  
  80284b:	c3                   	ret    

0080284c <netbuf_delete>:
 *
 * @param buf pointer to a netbuf allocated by netbuf_new()
 */
void
netbuf_delete(struct netbuf *buf)
{
  80284c:	55                   	push   %ebp
  80284d:	89 e5                	mov    %esp,%ebp
  80284f:	53                   	push   %ebx
  802850:	83 ec 14             	sub    $0x14,%esp
  802853:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (buf != NULL) {
  802856:	85 db                	test   %ebx,%ebx
  802858:	74 2b                	je     802885 <netbuf_delete+0x39>
    if (buf->p != NULL) {
  80285a:	8b 03                	mov    (%ebx),%eax
  80285c:	85 c0                	test   %eax,%eax
  80285e:	74 15                	je     802875 <netbuf_delete+0x29>
      pbuf_free(buf->p);
  802860:	89 04 24             	mov    %eax,(%esp)
  802863:	e8 8c 25 00 00       	call   804df4 <pbuf_free>
      buf->p = buf->ptr = NULL;
  802868:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  80286f:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
    }
    memp_free(MEMP_NETBUF, buf);
  802875:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  802879:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
  802880:	e8 bd 21 00 00       	call   804a42 <memp_free>
  }
}
  802885:	83 c4 14             	add    $0x14,%esp
  802888:	5b                   	pop    %ebx
  802889:	5d                   	pop    %ebp
  80288a:	c3                   	ret    

0080288b <netbuf_alloc>:
 * @return pointer to the allocated memory
 *         NULL if no memory could be allocated
 */
void *
netbuf_alloc(struct netbuf *buf, u16_t size)
{
  80288b:	55                   	push   %ebp
  80288c:	89 e5                	mov    %esp,%ebp
  80288e:	56                   	push   %esi
  80288f:	53                   	push   %ebx
  802890:	83 ec 10             	sub    $0x10,%esp
  802893:	8b 5d 08             	mov    0x8(%ebp),%ebx
  802896:	8b 75 0c             	mov    0xc(%ebp),%esi
  LWIP_ERROR("netbuf_alloc: invalid buf", (buf != NULL), return NULL;);
  802899:	85 db                	test   %ebx,%ebx
  80289b:	75 1c                	jne    8028b9 <netbuf_alloc+0x2e>
  80289d:	c7 44 24 08 89 1f 81 	movl   $0x811f89,0x8(%esp)
  8028a4:	00 
  8028a5:	c7 44 24 04 63 00 00 	movl   $0x63,0x4(%esp)
  8028ac:	00 
  8028ad:	c7 04 24 a3 1f 81 00 	movl   $0x811fa3,(%esp)
  8028b4:	e8 c1 c7 00 00       	call   80f07a <_panic>

  /* Deallocate any previously allocated memory. */
  if (buf->p != NULL) {
  8028b9:	8b 03                	mov    (%ebx),%eax
  8028bb:	85 c0                	test   %eax,%eax
  8028bd:	74 08                	je     8028c7 <netbuf_alloc+0x3c>
    pbuf_free(buf->p);
  8028bf:	89 04 24             	mov    %eax,(%esp)
  8028c2:	e8 2d 25 00 00       	call   804df4 <pbuf_free>
  }
  buf->p = pbuf_alloc(PBUF_TRANSPORT, size, PBUF_RAM);
  8028c7:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8028ce:	00 
  8028cf:	0f b7 c6             	movzwl %si,%eax
  8028d2:	89 44 24 04          	mov    %eax,0x4(%esp)
  8028d6:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8028dd:	e8 f3 25 00 00       	call   804ed5 <pbuf_alloc>
  8028e2:	89 03                	mov    %eax,(%ebx)
  if (buf->p == NULL) {
  8028e4:	85 c0                	test   %eax,%eax
  8028e6:	74 2a                	je     802912 <netbuf_alloc+0x87>
     return NULL;
  }
  LWIP_ASSERT("check that first pbuf can hold size",
  8028e8:	66 3b 70 0a          	cmp    0xa(%eax),%si
  8028ec:	76 1c                	jbe    80290a <netbuf_alloc+0x7f>
  8028ee:	c7 44 24 08 70 20 81 	movl   $0x812070,0x8(%esp)
  8028f5:	00 
  8028f6:	c7 44 24 04 6e 00 00 	movl   $0x6e,0x4(%esp)
  8028fd:	00 
  8028fe:	c7 04 24 a3 1f 81 00 	movl   $0x811fa3,(%esp)
  802905:	e8 70 c7 00 00       	call   80f07a <_panic>
             (buf->p->len >= size));
  buf->ptr = buf->p;
  80290a:	89 43 04             	mov    %eax,0x4(%ebx)
  return buf->p->payload;
  80290d:	8b 40 04             	mov    0x4(%eax),%eax
  802910:	eb 05                	jmp    802917 <netbuf_alloc+0x8c>
  if (buf->p != NULL) {
    pbuf_free(buf->p);
  }
  buf->p = pbuf_alloc(PBUF_TRANSPORT, size, PBUF_RAM);
  if (buf->p == NULL) {
     return NULL;
  802912:	b8 00 00 00 00       	mov    $0x0,%eax
  }
  LWIP_ASSERT("check that first pbuf can hold size",
             (buf->p->len >= size));
  buf->ptr = buf->p;
  return buf->p->payload;
}
  802917:	83 c4 10             	add    $0x10,%esp
  80291a:	5b                   	pop    %ebx
  80291b:	5e                   	pop    %esi
  80291c:	5d                   	pop    %ebp
  80291d:	c3                   	ret    

0080291e <netbuf_free>:
 *
 * @param buf pointer to the netbuf which contains the packet buffer to free
 */
void
netbuf_free(struct netbuf *buf)
{
  80291e:	55                   	push   %ebp
  80291f:	89 e5                	mov    %esp,%ebp
  802921:	53                   	push   %ebx
  802922:	83 ec 14             	sub    $0x14,%esp
  802925:	8b 5d 08             	mov    0x8(%ebp),%ebx
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return;);
  802928:	85 db                	test   %ebx,%ebx
  80292a:	75 1c                	jne    802948 <netbuf_free+0x2a>
  80292c:	c7 44 24 08 b9 1f 81 	movl   $0x811fb9,0x8(%esp)
  802933:	00 
  802934:	c7 44 24 04 7b 00 00 	movl   $0x7b,0x4(%esp)
  80293b:	00 
  80293c:	c7 04 24 a3 1f 81 00 	movl   $0x811fa3,(%esp)
  802943:	e8 32 c7 00 00       	call   80f07a <_panic>
  if (buf->p != NULL) {
  802948:	8b 03                	mov    (%ebx),%eax
  80294a:	85 c0                	test   %eax,%eax
  80294c:	74 08                	je     802956 <netbuf_free+0x38>
    pbuf_free(buf->p);
  80294e:	89 04 24             	mov    %eax,(%esp)
  802951:	e8 9e 24 00 00       	call   804df4 <pbuf_free>
  }
  buf->p = buf->ptr = NULL;
  802956:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  80295d:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
}
  802963:	83 c4 14             	add    $0x14,%esp
  802966:	5b                   	pop    %ebx
  802967:	5d                   	pop    %ebp
  802968:	c3                   	ret    

00802969 <netbuf_ref>:
 * @return ERR_OK if data is referenced
 *         ERR_MEM if data couldn't be referenced due to lack of memory
 */
err_t
netbuf_ref(struct netbuf *buf, const void *dataptr, u16_t size)
{
  802969:	55                   	push   %ebp
  80296a:	89 e5                	mov    %esp,%ebp
  80296c:	56                   	push   %esi
  80296d:	53                   	push   %ebx
  80296e:	83 ec 10             	sub    $0x10,%esp
  802971:	8b 5d 08             	mov    0x8(%ebp),%ebx
  802974:	8b 75 10             	mov    0x10(%ebp),%esi
  LWIP_ERROR("netbuf_ref: invalid buf", (buf != NULL), return ERR_ARG;);
  802977:	85 db                	test   %ebx,%ebx
  802979:	75 1c                	jne    802997 <netbuf_ref+0x2e>
  80297b:	c7 44 24 08 d2 1f 81 	movl   $0x811fd2,0x8(%esp)
  802982:	00 
  802983:	c7 44 24 04 8e 00 00 	movl   $0x8e,0x4(%esp)
  80298a:	00 
  80298b:	c7 04 24 a3 1f 81 00 	movl   $0x811fa3,(%esp)
  802992:	e8 e3 c6 00 00       	call   80f07a <_panic>
  if (buf->p != NULL) {
  802997:	8b 03                	mov    (%ebx),%eax
  802999:	85 c0                	test   %eax,%eax
  80299b:	74 08                	je     8029a5 <netbuf_ref+0x3c>
    pbuf_free(buf->p);
  80299d:	89 04 24             	mov    %eax,(%esp)
  8029a0:	e8 4f 24 00 00       	call   804df4 <pbuf_free>
  }
  buf->p = pbuf_alloc(PBUF_TRANSPORT, 0, PBUF_REF);
  8029a5:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
  8029ac:	00 
  8029ad:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8029b4:	00 
  8029b5:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8029bc:	e8 14 25 00 00       	call   804ed5 <pbuf_alloc>
  8029c1:	89 03                	mov    %eax,(%ebx)
  if (buf->p == NULL) {
  8029c3:	85 c0                	test   %eax,%eax
  8029c5:	75 0e                	jne    8029d5 <netbuf_ref+0x6c>
    buf->ptr = NULL;
  8029c7:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    return ERR_MEM;
  8029ce:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8029d3:	eb 1a                	jmp    8029ef <netbuf_ref+0x86>
  }
  buf->p->payload = (void*)dataptr;
  8029d5:	8b 55 0c             	mov    0xc(%ebp),%edx
  8029d8:	89 50 04             	mov    %edx,0x4(%eax)
  buf->p->len = buf->p->tot_len = size;
  8029db:	8b 03                	mov    (%ebx),%eax
  8029dd:	66 89 70 08          	mov    %si,0x8(%eax)
  8029e1:	66 89 70 0a          	mov    %si,0xa(%eax)
  buf->ptr = buf->p;
  8029e5:	8b 03                	mov    (%ebx),%eax
  8029e7:	89 43 04             	mov    %eax,0x4(%ebx)
  return ERR_OK;
  8029ea:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8029ef:	83 c4 10             	add    $0x10,%esp
  8029f2:	5b                   	pop    %ebx
  8029f3:	5e                   	pop    %esi
  8029f4:	5d                   	pop    %ebp
  8029f5:	c3                   	ret    

008029f6 <netbuf_chain>:
 * @param head the first netbuf
 * @param tail netbuf to chain after head
 */
void
netbuf_chain(struct netbuf *head, struct netbuf *tail)
{
  8029f6:	55                   	push   %ebp
  8029f7:	89 e5                	mov    %esp,%ebp
  8029f9:	56                   	push   %esi
  8029fa:	53                   	push   %ebx
  8029fb:	83 ec 10             	sub    $0x10,%esp
  8029fe:	8b 5d 08             	mov    0x8(%ebp),%ebx
  802a01:	8b 75 0c             	mov    0xc(%ebp),%esi
  LWIP_ERROR("netbuf_ref: invalid head", (head != NULL), return;);
  802a04:	85 db                	test   %ebx,%ebx
  802a06:	75 1c                	jne    802a24 <netbuf_chain+0x2e>
  802a08:	c7 44 24 08 ea 1f 81 	movl   $0x811fea,0x8(%esp)
  802a0f:	00 
  802a10:	c7 44 24 04 a6 00 00 	movl   $0xa6,0x4(%esp)
  802a17:	00 
  802a18:	c7 04 24 a3 1f 81 00 	movl   $0x811fa3,(%esp)
  802a1f:	e8 56 c6 00 00       	call   80f07a <_panic>
  LWIP_ERROR("netbuf_chain: invalid tail", (tail != NULL), return;);
  802a24:	85 f6                	test   %esi,%esi
  802a26:	75 1c                	jne    802a44 <netbuf_chain+0x4e>
  802a28:	c7 44 24 08 03 20 81 	movl   $0x812003,0x8(%esp)
  802a2f:	00 
  802a30:	c7 44 24 04 a7 00 00 	movl   $0xa7,0x4(%esp)
  802a37:	00 
  802a38:	c7 04 24 a3 1f 81 00 	movl   $0x811fa3,(%esp)
  802a3f:	e8 36 c6 00 00       	call   80f07a <_panic>
  pbuf_chain(head->p, tail->p);
  802a44:	8b 06                	mov    (%esi),%eax
  802a46:	89 44 24 04          	mov    %eax,0x4(%esp)
  802a4a:	8b 03                	mov    (%ebx),%eax
  802a4c:	89 04 24             	mov    %eax,(%esp)
  802a4f:	e8 d6 28 00 00       	call   80532a <pbuf_chain>
  head->ptr = head->p;
  802a54:	8b 03                	mov    (%ebx),%eax
  802a56:	89 43 04             	mov    %eax,0x4(%ebx)
  memp_free(MEMP_NETBUF, tail);
  802a59:	89 74 24 04          	mov    %esi,0x4(%esp)
  802a5d:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
  802a64:	e8 d9 1f 00 00       	call   804a42 <memp_free>
}
  802a69:	83 c4 10             	add    $0x10,%esp
  802a6c:	5b                   	pop    %ebx
  802a6d:	5e                   	pop    %esi
  802a6e:	5d                   	pop    %ebp
  802a6f:	c3                   	ret    

00802a70 <netbuf_data>:
 * @return ERR_OK if the information was retreived,
 *         ERR_BUF on error.
 */
err_t
netbuf_data(struct netbuf *buf, void **dataptr, u16_t *len)
{
  802a70:	55                   	push   %ebp
  802a71:	89 e5                	mov    %esp,%ebp
  802a73:	53                   	push   %ebx
  802a74:	83 ec 14             	sub    $0x14,%esp
  802a77:	8b 45 08             	mov    0x8(%ebp),%eax
  802a7a:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  802a7d:	8b 55 10             	mov    0x10(%ebp),%edx
  LWIP_ERROR("netbuf_data: invalid buf", (buf != NULL), return ERR_ARG;);
  802a80:	85 c0                	test   %eax,%eax
  802a82:	75 1c                	jne    802aa0 <netbuf_data+0x30>
  802a84:	c7 44 24 08 1e 20 81 	movl   $0x81201e,0x8(%esp)
  802a8b:	00 
  802a8c:	c7 44 24 04 b9 00 00 	movl   $0xb9,0x4(%esp)
  802a93:	00 
  802a94:	c7 04 24 a3 1f 81 00 	movl   $0x811fa3,(%esp)
  802a9b:	e8 da c5 00 00       	call   80f07a <_panic>
  LWIP_ERROR("netbuf_data: invalid dataptr", (dataptr != NULL), return ERR_ARG;);
  802aa0:	85 c9                	test   %ecx,%ecx
  802aa2:	75 1c                	jne    802ac0 <netbuf_data+0x50>
  802aa4:	c7 44 24 08 37 20 81 	movl   $0x812037,0x8(%esp)
  802aab:	00 
  802aac:	c7 44 24 04 ba 00 00 	movl   $0xba,0x4(%esp)
  802ab3:	00 
  802ab4:	c7 04 24 a3 1f 81 00 	movl   $0x811fa3,(%esp)
  802abb:	e8 ba c5 00 00       	call   80f07a <_panic>
  LWIP_ERROR("netbuf_data: invalid len", (len != NULL), return ERR_ARG;);
  802ac0:	85 d2                	test   %edx,%edx
  802ac2:	75 1c                	jne    802ae0 <netbuf_data+0x70>
  802ac4:	c7 44 24 08 54 20 81 	movl   $0x812054,0x8(%esp)
  802acb:	00 
  802acc:	c7 44 24 04 bb 00 00 	movl   $0xbb,0x4(%esp)
  802ad3:	00 
  802ad4:	c7 04 24 a3 1f 81 00 	movl   $0x811fa3,(%esp)
  802adb:	e8 9a c5 00 00       	call   80f07a <_panic>

  if (buf->ptr == NULL) {
  802ae0:	8b 58 04             	mov    0x4(%eax),%ebx
  802ae3:	85 db                	test   %ebx,%ebx
  802ae5:	74 16                	je     802afd <netbuf_data+0x8d>
    return ERR_BUF;
  }
  *dataptr = buf->ptr->payload;
  802ae7:	8b 5b 04             	mov    0x4(%ebx),%ebx
  802aea:	89 19                	mov    %ebx,(%ecx)
  *len = buf->ptr->len;
  802aec:	8b 40 04             	mov    0x4(%eax),%eax
  802aef:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
  802af3:	66 89 02             	mov    %ax,(%edx)
  return ERR_OK;
  802af6:	b8 00 00 00 00       	mov    $0x0,%eax
  802afb:	eb 05                	jmp    802b02 <netbuf_data+0x92>
  LWIP_ERROR("netbuf_data: invalid buf", (buf != NULL), return ERR_ARG;);
  LWIP_ERROR("netbuf_data: invalid dataptr", (dataptr != NULL), return ERR_ARG;);
  LWIP_ERROR("netbuf_data: invalid len", (len != NULL), return ERR_ARG;);

  if (buf->ptr == NULL) {
    return ERR_BUF;
  802afd:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  }
  *dataptr = buf->ptr->payload;
  *len = buf->ptr->len;
  return ERR_OK;
}
  802b02:	83 c4 14             	add    $0x14,%esp
  802b05:	5b                   	pop    %ebx
  802b06:	5d                   	pop    %ebp
  802b07:	c3                   	ret    

00802b08 <netbuf_next>:
 *         1  if moved to the next part but now there is no next part
 *         0  if moved to the next part and there are still more parts
 */
s8_t
netbuf_next(struct netbuf *buf)
{
  802b08:	55                   	push   %ebp
  802b09:	89 e5                	mov    %esp,%ebp
  802b0b:	83 ec 18             	sub    $0x18,%esp
  802b0e:	8b 45 08             	mov    0x8(%ebp),%eax
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return -1;);
  802b11:	85 c0                	test   %eax,%eax
  802b13:	75 1c                	jne    802b31 <netbuf_next+0x29>
  802b15:	c7 44 24 08 b9 1f 81 	movl   $0x811fb9,0x8(%esp)
  802b1c:	00 
  802b1d:	c7 44 24 04 d2 00 00 	movl   $0xd2,0x4(%esp)
  802b24:	00 
  802b25:	c7 04 24 a3 1f 81 00 	movl   $0x811fa3,(%esp)
  802b2c:	e8 49 c5 00 00       	call   80f07a <_panic>
  if (buf->ptr->next == NULL) {
  802b31:	8b 50 04             	mov    0x4(%eax),%edx
  802b34:	8b 12                	mov    (%edx),%edx
  802b36:	85 d2                	test   %edx,%edx
  802b38:	74 0b                	je     802b45 <netbuf_next+0x3d>
    return -1;
  }
  buf->ptr = buf->ptr->next;
  802b3a:	89 50 04             	mov    %edx,0x4(%eax)
  if (buf->ptr->next == NULL) {
  802b3d:	83 3a 00             	cmpl   $0x0,(%edx)
  802b40:	0f 94 c0             	sete   %al
  802b43:	eb 05                	jmp    802b4a <netbuf_next+0x42>
s8_t
netbuf_next(struct netbuf *buf)
{
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return -1;);
  if (buf->ptr->next == NULL) {
    return -1;
  802b45:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  buf->ptr = buf->ptr->next;
  if (buf->ptr->next == NULL) {
    return 1;
  }
  return 0;
}
  802b4a:	c9                   	leave  
  802b4b:	c3                   	ret    

00802b4c <netbuf_first>:
 *
 * @param buf the netbuf to modify
 */
void
netbuf_first(struct netbuf *buf)
{
  802b4c:	55                   	push   %ebp
  802b4d:	89 e5                	mov    %esp,%ebp
  802b4f:	83 ec 18             	sub    $0x18,%esp
  802b52:	8b 45 08             	mov    0x8(%ebp),%eax
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return;);
  802b55:	85 c0                	test   %eax,%eax
  802b57:	75 1c                	jne    802b75 <netbuf_first+0x29>
  802b59:	c7 44 24 08 b9 1f 81 	movl   $0x811fb9,0x8(%esp)
  802b60:	00 
  802b61:	c7 44 24 04 e7 00 00 	movl   $0xe7,0x4(%esp)
  802b68:	00 
  802b69:	c7 04 24 a3 1f 81 00 	movl   $0x811fa3,(%esp)
  802b70:	e8 05 c5 00 00       	call   80f07a <_panic>
  buf->ptr = buf->p;
  802b75:	8b 10                	mov    (%eax),%edx
  802b77:	89 50 04             	mov    %edx,0x4(%eax)
}
  802b7a:	c9                   	leave  
  802b7b:	c3                   	ret    
  802b7c:	66 90                	xchg   %ax,%ax
  802b7e:	66 90                	xchg   %ax,%ax

00802b80 <lwip_init>:
/**
 * Perform Sanity check of user-configurable values, and initialize all modules.
 */
void
lwip_init(void)
{
  802b80:	55                   	push   %ebp
  802b81:	89 e5                	mov    %esp,%ebp
  802b83:	83 ec 08             	sub    $0x8,%esp
  /* Sanity check user-configurable values */
  lwip_sanity_check();

  /* Modules initialization */
  stats_init();
  sys_init();
  802b86:	e8 fa 79 00 00       	call   80a585 <sys_init>
  mem_init();
  802b8b:	e8 ed 18 00 00       	call   80447d <mem_init>
  memp_init();
  802b90:	e8 f5 1d 00 00       	call   80498a <memp_init>
  pbuf_init();
  netif_init();
#if LWIP_SOCKET
  lwip_socket_init();
  802b95:	e8 9e e4 ff ff       	call   801038 <lwip_socket_init>
  igmp_init();
#endif /* LWIP_IGMP */
#if LWIP_DNS
  dns_init();
#endif /* LWIP_DNS */
}
  802b9a:	c9                   	leave  
  802b9b:	c3                   	ret    
  802b9c:	66 90                	xchg   %ax,%ax
  802b9e:	66 90                	xchg   %ax,%ax

00802ba0 <dhcp_set_state>:
 *
 * TODO: we might also want to reset the timeout here?
 */
static void
dhcp_set_state(struct dhcp *dhcp, u8_t new_state)
{
  802ba0:	55                   	push   %ebp
  802ba1:	89 e5                	mov    %esp,%ebp
  if (new_state != dhcp->state) {
  802ba3:	38 10                	cmp    %dl,(%eax)
  802ba5:	74 06                	je     802bad <dhcp_set_state+0xd>
    dhcp->state = new_state;
  802ba7:	88 10                	mov    %dl,(%eax)
    dhcp->tries = 0;
  802ba9:	c6 40 01 00          	movb   $0x0,0x1(%eax)
  }
}
  802bad:	5d                   	pop    %ebp
  802bae:	c3                   	ret    

00802baf <dhcp_get_option_ptr>:
 *
 * @return a byte offset into the UDP message where the option was found, or
 * zero if the given option was not found.
 */
static u8_t *dhcp_get_option_ptr(struct dhcp *dhcp, u8_t option_type)
{
  802baf:	55                   	push   %ebp
  802bb0:	89 e5                	mov    %esp,%ebp
  802bb2:	57                   	push   %edi
  802bb3:	56                   	push   %esi
  802bb4:	53                   	push   %ebx
  802bb5:	83 ec 08             	sub    $0x8,%esp
  802bb8:	89 45 ec             	mov    %eax,-0x14(%ebp)
  u8_t overload = DHCP_OVERLOAD_NONE;

  /* options available? */
  if ((dhcp->options_in != NULL) && (dhcp->options_in_len > 0)) {
  802bbb:	8b 70 14             	mov    0x14(%eax),%esi
  802bbe:	85 f6                	test   %esi,%esi
  802bc0:	0f 84 c9 00 00 00    	je     802c8f <dhcp_get_option_ptr+0xe0>
  802bc6:	0f b7 78 18          	movzwl 0x18(%eax),%edi
  802bca:	66 85 ff             	test   %di,%di
  802bcd:	0f 84 c3 00 00 00    	je     802c96 <dhcp_get_option_ptr+0xe7>
  802bd3:	b9 00 00 00 00       	mov    $0x0,%ecx
  802bd8:	c6 45 f3 00          	movb   $0x0,-0xd(%ebp)
  802bdc:	eb 2d                	jmp    802c0b <dhcp_get_option_ptr+0x5c>
    u16_t offset = 0;
    /* at least 1 byte to read and no end marker, then at least 3 bytes to read? */
    while ((offset < dhcp->options_in_len) && (options[offset] != DHCP_OPTION_END)) {
      /* LWIP_DEBUGF(DHCP_DEBUG, ("msg_offset=%"U16_F", q->len=%"U16_F, msg_offset, q->len)); */
      /* are the sname and/or file field overloaded with options? */
      if (options[offset] == DHCP_OPTION_OVERLOAD) {
  802bde:	80 fb 34             	cmp    $0x34,%bl
  802be1:	75 12                	jne    802bf5 <dhcp_get_option_ptr+0x46>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("overloaded message detected\n"));
        /* skip option type and length */
        offset += 2;
  802be3:	8d 41 02             	lea    0x2(%ecx),%eax
        overload = options[offset++];
  802be6:	83 c1 03             	add    $0x3,%ecx
  802be9:	0f b7 c0             	movzwl %ax,%eax
  802bec:	0f b6 04 06          	movzbl (%esi,%eax,1),%eax
  802bf0:	88 45 f3             	mov    %al,-0xd(%ebp)
  802bf3:	eb 16                	jmp    802c0b <dhcp_get_option_ptr+0x5c>
      }
      /* requested option found */
      else if (options[offset] == option_type) {
  802bf5:	38 d3                	cmp    %dl,%bl
  802bf7:	0f 84 ac 00 00 00    	je     802ca9 <dhcp_get_option_ptr+0xfa>
        return &options[offset];
      /* skip option */
      } else {
         LWIP_DEBUGF(DHCP_DEBUG, ("skipping option %"U16_F" in options\n", options[offset]));
        /* skip option type */
        offset++;
  802bfd:	8d 41 01             	lea    0x1(%ecx),%eax
        /* skip option length, and then length bytes */
        offset += 1 + options[offset];
  802c00:	0f b7 c0             	movzwl %ax,%eax
  802c03:	0f b6 04 06          	movzbl (%esi,%eax,1),%eax
  802c07:	8d 4c 01 02          	lea    0x2(%ecx,%eax,1),%ecx
  if ((dhcp->options_in != NULL) && (dhcp->options_in_len > 0)) {
    /* start with options field */
    u8_t *options = (u8_t *)dhcp->options_in;
    u16_t offset = 0;
    /* at least 1 byte to read and no end marker, then at least 3 bytes to read? */
    while ((offset < dhcp->options_in_len) && (options[offset] != DHCP_OPTION_END)) {
  802c0b:	66 39 f9             	cmp    %di,%cx
  802c0e:	73 0d                	jae    802c1d <dhcp_get_option_ptr+0x6e>
  802c10:	0f b7 c1             	movzwl %cx,%eax
  802c13:	01 f0                	add    %esi,%eax
  802c15:	0f b6 18             	movzbl (%eax),%ebx
  802c18:	80 fb ff             	cmp    $0xff,%bl
  802c1b:	75 c1                	jne    802bde <dhcp_get_option_ptr+0x2f>
        /* skip option length, and then length bytes */
        offset += 1 + options[offset];
      }
    }
    /* is this an overloaded message? */
    if (overload != DHCP_OVERLOAD_NONE) {
  802c1d:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
  802c21:	84 c0                	test   %al,%al
  802c23:	74 78                	je     802c9d <dhcp_get_option_ptr+0xee>
      u16_t field_len;
      if (overload == DHCP_OVERLOAD_FILE) {
  802c25:	3c 01                	cmp    $0x1,%al
  802c27:	75 10                	jne    802c39 <dhcp_get_option_ptr+0x8a>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("overloaded file field\n"));
        options = (u8_t *)&dhcp->msg_in->file;
  802c29:	8b 45 ec             	mov    -0x14(%ebp),%eax
  802c2c:	8b 70 10             	mov    0x10(%eax),%esi
  802c2f:	83 c6 6c             	add    $0x6c,%esi
        field_len = DHCP_FILE_LEN;
  802c32:	bf 80 00 00 00       	mov    $0x80,%edi
  802c37:	eb 24                	jmp    802c5d <dhcp_get_option_ptr+0xae>
      } else if (overload == DHCP_OVERLOAD_SNAME) {
  802c39:	80 7d f3 02          	cmpb   $0x2,-0xd(%ebp)
  802c3d:	75 10                	jne    802c4f <dhcp_get_option_ptr+0xa0>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("overloaded sname field\n"));
        options = (u8_t *)&dhcp->msg_in->sname;
  802c3f:	8b 45 ec             	mov    -0x14(%ebp),%eax
  802c42:	8b 70 10             	mov    0x10(%eax),%esi
  802c45:	83 c6 2c             	add    $0x2c,%esi
        field_len = DHCP_SNAME_LEN;
  802c48:	bf 40 00 00 00       	mov    $0x40,%edi
  802c4d:	eb 0e                	jmp    802c5d <dhcp_get_option_ptr+0xae>
      /* TODO: check if else if () is necessary */
      } else {
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("overloaded sname and file field\n"));
        options = (u8_t *)&dhcp->msg_in->sname;
  802c4f:	8b 45 ec             	mov    -0x14(%ebp),%eax
  802c52:	8b 70 10             	mov    0x10(%eax),%esi
  802c55:	83 c6 2c             	add    $0x2c,%esi
        field_len = DHCP_FILE_LEN + DHCP_SNAME_LEN;
  802c58:	bf c0 00 00 00       	mov    $0xc0,%edi
      }
      offset = 0;
  802c5d:	b9 00 00 00 00       	mov    $0x0,%ecx

      /* at least 1 byte to read and no end marker */
      while ((offset < field_len) && (options[offset] != DHCP_OPTION_END)) {
  802c62:	eb 12                	jmp    802c76 <dhcp_get_option_ptr+0xc7>
        if (options[offset] == option_type) {
  802c64:	38 da                	cmp    %bl,%dl
  802c66:	74 41                	je     802ca9 <dhcp_get_option_ptr+0xfa>
          return &options[offset];
        /* skip option */
        } else {
          LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("skipping option %"U16_F"\n", options[offset]));
          /* skip option type */
          offset++;
  802c68:	8d 41 01             	lea    0x1(%ecx),%eax
          offset += 1 + options[offset];
  802c6b:	0f b7 c0             	movzwl %ax,%eax
  802c6e:	0f b6 04 06          	movzbl (%esi,%eax,1),%eax
  802c72:	8d 4c 01 02          	lea    0x2(%ecx,%eax,1),%ecx
        field_len = DHCP_FILE_LEN + DHCP_SNAME_LEN;
      }
      offset = 0;

      /* at least 1 byte to read and no end marker */
      while ((offset < field_len) && (options[offset] != DHCP_OPTION_END)) {
  802c76:	66 39 f9             	cmp    %di,%cx
  802c79:	73 29                	jae    802ca4 <dhcp_get_option_ptr+0xf5>
  802c7b:	0f b7 c1             	movzwl %cx,%eax
  802c7e:	01 f0                	add    %esi,%eax
  802c80:	0f b6 18             	movzbl (%eax),%ebx
  802c83:	80 fb ff             	cmp    $0xff,%bl
  802c86:	75 dc                	jne    802c64 <dhcp_get_option_ptr+0xb5>
          offset += 1 + options[offset];
        }
      }
    }
  }
  return NULL;
  802c88:	b8 00 00 00 00       	mov    $0x0,%eax
  802c8d:	eb 1a                	jmp    802ca9 <dhcp_get_option_ptr+0xfa>
  802c8f:	b8 00 00 00 00       	mov    $0x0,%eax
  802c94:	eb 13                	jmp    802ca9 <dhcp_get_option_ptr+0xfa>
  802c96:	b8 00 00 00 00       	mov    $0x0,%eax
  802c9b:	eb 0c                	jmp    802ca9 <dhcp_get_option_ptr+0xfa>
  802c9d:	b8 00 00 00 00       	mov    $0x0,%eax
  802ca2:	eb 05                	jmp    802ca9 <dhcp_get_option_ptr+0xfa>
  802ca4:	b8 00 00 00 00       	mov    $0x0,%eax
}
  802ca9:	83 c4 08             	add    $0x8,%esp
  802cac:	5b                   	pop    %ebx
  802cad:	5e                   	pop    %esi
  802cae:	5f                   	pop    %edi
  802caf:	5d                   	pop    %ebp
  802cb0:	c3                   	ret    

00802cb1 <dhcp_get_option_long>:
 * @param ptr pointer obtained by dhcp_get_option_ptr().
 *
 * @return byte value at the given address.
 */
static u32_t dhcp_get_option_long(u8_t *ptr)
{
  802cb1:	55                   	push   %ebp
  802cb2:	89 e5                	mov    %esp,%ebp
  u32_t value;
  value = (u32_t)(*ptr++) << 24;
  802cb4:	0f b6 08             	movzbl (%eax),%ecx
  802cb7:	c1 e1 18             	shl    $0x18,%ecx
  value |= (u32_t)(*ptr++) << 16;
  802cba:	0f b6 50 01          	movzbl 0x1(%eax),%edx
  802cbe:	c1 e2 10             	shl    $0x10,%edx
  802cc1:	09 d1                	or     %edx,%ecx
  value |= (u32_t)(*ptr++) << 8;
  value |= (u32_t)(*ptr++);
  802cc3:	0f b6 50 03          	movzbl 0x3(%eax),%edx
static u32_t dhcp_get_option_long(u8_t *ptr)
{
  u32_t value;
  value = (u32_t)(*ptr++) << 24;
  value |= (u32_t)(*ptr++) << 16;
  value |= (u32_t)(*ptr++) << 8;
  802cc7:	09 d1                	or     %edx,%ecx
  802cc9:	0f b6 50 02          	movzbl 0x2(%eax),%edx
  802ccd:	c1 e2 08             	shl    $0x8,%edx
  value |= (u32_t)(*ptr++);
  802cd0:	89 c8                	mov    %ecx,%eax
  802cd2:	09 d0                	or     %edx,%eax
  LWIP_DEBUGF(DHCP_DEBUG, ("option long value=%"U32_F"\n", value));
  return value;
}
  802cd4:	5d                   	pop    %ebp
  802cd5:	c3                   	ret    

00802cd6 <dhcp_option_byte>:
 * Concatenate a single byte to the outgoing DHCP message.
 *
 */
static void
dhcp_option_byte(struct dhcp *dhcp, u8_t value)
{
  802cd6:	55                   	push   %ebp
  802cd7:	89 e5                	mov    %esp,%ebp
  802cd9:	56                   	push   %esi
  802cda:	53                   	push   %ebx
  802cdb:	83 ec 10             	sub    $0x10,%esp
  LWIP_ASSERT("dhcp_option_byte: dhcp->options_out_len < DHCP_OPTIONS_LEN", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  802cde:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  802ce2:	66 83 f9 43          	cmp    $0x43,%cx
  802ce6:	76 1c                	jbe    802d04 <dhcp_option_byte+0x2e>
  802ce8:	c7 44 24 08 94 20 81 	movl   $0x812094,0x8(%esp)
  802cef:	00 
  802cf0:	c7 44 24 04 65 04 00 	movl   $0x465,0x4(%esp)
  802cf7:	00 
  802cf8:	c7 04 24 e2 23 81 00 	movl   $0x8123e2,(%esp)
  802cff:	e8 76 c3 00 00       	call   80f07a <_panic>
  dhcp->msg_out->options[dhcp->options_out_len++] = value;
  802d04:	8b 58 20             	mov    0x20(%eax),%ebx
  802d07:	8d 71 01             	lea    0x1(%ecx),%esi
  802d0a:	66 89 70 24          	mov    %si,0x24(%eax)
  802d0e:	0f b7 c9             	movzwl %cx,%ecx
  802d11:	88 94 0b f0 00 00 00 	mov    %dl,0xf0(%ebx,%ecx,1)
}
  802d18:	83 c4 10             	add    $0x10,%esp
  802d1b:	5b                   	pop    %ebx
  802d1c:	5e                   	pop    %esi
  802d1d:	5d                   	pop    %ebp
  802d1e:	c3                   	ret    

00802d1f <dhcp_option>:
 * DHCP message.
 *
 */
static void
dhcp_option(struct dhcp *dhcp, u8_t option_type, u8_t option_len)
{
  802d1f:	55                   	push   %ebp
  802d20:	89 e5                	mov    %esp,%ebp
  802d22:	57                   	push   %edi
  802d23:	56                   	push   %esi
  802d24:	53                   	push   %ebx
  802d25:	83 ec 1c             	sub    $0x1c,%esp
  LWIP_ASSERT("dhcp_option: dhcp->options_out_len + 2 + option_len <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U + option_len <= DHCP_OPTIONS_LEN);
  802d28:	0f b7 58 24          	movzwl 0x24(%eax),%ebx
  802d2c:	0f b7 fb             	movzwl %bx,%edi
  802d2f:	0f b6 f1             	movzbl %cl,%esi
  802d32:	8d 74 37 02          	lea    0x2(%edi,%esi,1),%esi
  802d36:	83 fe 44             	cmp    $0x44,%esi
  802d39:	76 1c                	jbe    802d57 <dhcp_option+0x38>
  802d3b:	c7 44 24 08 d0 20 81 	movl   $0x8120d0,0x8(%esp)
  802d42:	00 
  802d43:	c7 44 24 04 5a 04 00 	movl   $0x45a,0x4(%esp)
  802d4a:	00 
  802d4b:	c7 04 24 e2 23 81 00 	movl   $0x8123e2,(%esp)
  802d52:	e8 23 c3 00 00       	call   80f07a <_panic>
  dhcp->msg_out->options[dhcp->options_out_len++] = option_type;
  802d57:	8b 70 20             	mov    0x20(%eax),%esi
  802d5a:	8d 7b 01             	lea    0x1(%ebx),%edi
  802d5d:	66 89 78 24          	mov    %di,0x24(%eax)
  802d61:	0f b7 db             	movzwl %bx,%ebx
  802d64:	88 94 1e f0 00 00 00 	mov    %dl,0xf0(%esi,%ebx,1)
  dhcp->msg_out->options[dhcp->options_out_len++] = option_len;
  802d6b:	8b 58 20             	mov    0x20(%eax),%ebx
  802d6e:	0f b7 50 24          	movzwl 0x24(%eax),%edx
  802d72:	8d 72 01             	lea    0x1(%edx),%esi
  802d75:	66 89 70 24          	mov    %si,0x24(%eax)
  802d79:	0f b7 d2             	movzwl %dx,%edx
  802d7c:	88 8c 13 f0 00 00 00 	mov    %cl,0xf0(%ebx,%edx,1)
}
  802d83:	83 c4 1c             	add    $0x1c,%esp
  802d86:	5b                   	pop    %ebx
  802d87:	5e                   	pop    %esi
  802d88:	5f                   	pop    %edi
  802d89:	5d                   	pop    %ebp
  802d8a:	c3                   	ret    

00802d8b <dhcp_option_short>:
  dhcp->msg_out->options[dhcp->options_out_len++] = value;
}

static void
dhcp_option_short(struct dhcp *dhcp, u16_t value)
{
  802d8b:	55                   	push   %ebp
  802d8c:	89 e5                	mov    %esp,%ebp
  802d8e:	56                   	push   %esi
  802d8f:	53                   	push   %ebx
  802d90:	83 ec 10             	sub    $0x10,%esp
  LWIP_ASSERT("dhcp_option_short: dhcp->options_out_len + 2 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U <= DHCP_OPTIONS_LEN);
  802d93:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  802d97:	0f b7 d9             	movzwl %cx,%ebx
  802d9a:	83 c3 02             	add    $0x2,%ebx
  802d9d:	83 fb 44             	cmp    $0x44,%ebx
  802da0:	76 1c                	jbe    802dbe <dhcp_option_short+0x33>
  802da2:	c7 44 24 08 18 21 81 	movl   $0x812118,0x8(%esp)
  802da9:	00 
  802daa:	c7 44 24 04 6c 04 00 	movl   $0x46c,0x4(%esp)
  802db1:	00 
  802db2:	c7 04 24 e2 23 81 00 	movl   $0x8123e2,(%esp)
  802db9:	e8 bc c2 00 00       	call   80f07a <_panic>
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff00U) >> 8);
  802dbe:	8d 71 01             	lea    0x1(%ecx),%esi
  802dc1:	66 89 70 24          	mov    %si,0x24(%eax)
  802dc5:	0f b7 c9             	movzwl %cx,%ecx
  802dc8:	89 d3                	mov    %edx,%ebx
  802dca:	66 c1 eb 08          	shr    $0x8,%bx
  802dce:	8b 70 20             	mov    0x20(%eax),%esi
  802dd1:	88 9c 0e f0 00 00 00 	mov    %bl,0xf0(%esi,%ecx,1)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t) (value & 0x00ffU);
  802dd8:	8b 58 20             	mov    0x20(%eax),%ebx
  802ddb:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  802ddf:	8d 71 01             	lea    0x1(%ecx),%esi
  802de2:	66 89 70 24          	mov    %si,0x24(%eax)
  802de6:	0f b7 c9             	movzwl %cx,%ecx
  802de9:	88 94 0b f0 00 00 00 	mov    %dl,0xf0(%ebx,%ecx,1)
}
  802df0:	83 c4 10             	add    $0x10,%esp
  802df3:	5b                   	pop    %ebx
  802df4:	5e                   	pop    %esi
  802df5:	5d                   	pop    %ebp
  802df6:	c3                   	ret    

00802df7 <dhcp_option_trailer>:
 *
 * @param dhcp DHCP state structure
 */
static void
dhcp_option_trailer(struct dhcp *dhcp)
{
  802df7:	55                   	push   %ebp
  802df8:	89 e5                	mov    %esp,%ebp
  802dfa:	53                   	push   %ebx
  802dfb:	83 ec 14             	sub    $0x14,%esp
  LWIP_ERROR("dhcp_option_trailer: dhcp != NULL", (dhcp != NULL), return;);
  802dfe:	85 c0                	test   %eax,%eax
  802e00:	75 1c                	jne    802e1e <dhcp_option_trailer+0x27>
  802e02:	c7 44 24 08 5c 21 81 	movl   $0x81215c,0x8(%esp)
  802e09:	00 
  802e0a:	c7 44 24 04 80 05 00 	movl   $0x580,0x4(%esp)
  802e11:	00 
  802e12:	c7 04 24 e2 23 81 00 	movl   $0x8123e2,(%esp)
  802e19:	e8 5c c2 00 00       	call   80f07a <_panic>
  LWIP_ASSERT("dhcp_option_trailer: dhcp->msg_out != NULL\n", dhcp->msg_out != NULL);
  802e1e:	8b 48 20             	mov    0x20(%eax),%ecx
  802e21:	85 c9                	test   %ecx,%ecx
  802e23:	75 1c                	jne    802e41 <dhcp_option_trailer+0x4a>
  802e25:	c7 44 24 08 80 21 81 	movl   $0x812180,0x8(%esp)
  802e2c:	00 
  802e2d:	c7 44 24 04 81 05 00 	movl   $0x581,0x4(%esp)
  802e34:	00 
  802e35:	c7 04 24 e2 23 81 00 	movl   $0x8123e2,(%esp)
  802e3c:	e8 39 c2 00 00       	call   80f07a <_panic>
  LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  802e41:	0f b7 50 24          	movzwl 0x24(%eax),%edx
  802e45:	66 83 fa 43          	cmp    $0x43,%dx
  802e49:	76 1c                	jbe    802e67 <dhcp_option_trailer+0x70>
  802e4b:	c7 44 24 08 ac 21 81 	movl   $0x8121ac,0x8(%esp)
  802e52:	00 
  802e53:	c7 44 24 04 82 05 00 	movl   $0x582,0x4(%esp)
  802e5a:	00 
  802e5b:	c7 04 24 e2 23 81 00 	movl   $0x8123e2,(%esp)
  802e62:	e8 13 c2 00 00       	call   80f07a <_panic>
  dhcp->msg_out->options[dhcp->options_out_len++] = DHCP_OPTION_END;
  802e67:	8d 5a 01             	lea    0x1(%edx),%ebx
  802e6a:	66 89 58 24          	mov    %bx,0x24(%eax)
  802e6e:	0f b7 d2             	movzwl %dx,%edx
  802e71:	c6 84 11 f0 00 00 00 	movb   $0xff,0xf0(%ecx,%edx,1)
  802e78:	ff 
  /* packet is too small, or not 4 byte aligned? */
  while ((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3)) {
  802e79:	eb 31                	jmp    802eac <dhcp_option_trailer+0xb5>
    /* LWIP_DEBUGF(DHCP_DEBUG,("dhcp_option_trailer:dhcp->options_out_len=%"U16_F", DHCP_OPTIONS_LEN=%"U16_F, dhcp->options_out_len, DHCP_OPTIONS_LEN)); */
    LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  802e7b:	c7 44 24 08 ac 21 81 	movl   $0x8121ac,0x8(%esp)
  802e82:	00 
  802e83:	c7 44 24 04 87 05 00 	movl   $0x587,0x4(%esp)
  802e8a:	00 
  802e8b:	c7 04 24 e2 23 81 00 	movl   $0x8123e2,(%esp)
  802e92:	e8 e3 c1 00 00       	call   80f07a <_panic>
    /* add a fill/padding byte */
    dhcp->msg_out->options[dhcp->options_out_len++] = 0;
  802e97:	8b 48 20             	mov    0x20(%eax),%ecx
  802e9a:	8d 5a 01             	lea    0x1(%edx),%ebx
  802e9d:	66 89 58 24          	mov    %bx,0x24(%eax)
  802ea1:	0f b7 d2             	movzwl %dx,%edx
  802ea4:	c6 84 11 f0 00 00 00 	movb   $0x0,0xf0(%ecx,%edx,1)
  802eab:	00 
  LWIP_ERROR("dhcp_option_trailer: dhcp != NULL", (dhcp != NULL), return;);
  LWIP_ASSERT("dhcp_option_trailer: dhcp->msg_out != NULL\n", dhcp->msg_out != NULL);
  LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  dhcp->msg_out->options[dhcp->options_out_len++] = DHCP_OPTION_END;
  /* packet is too small, or not 4 byte aligned? */
  while ((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3)) {
  802eac:	0f b7 50 24          	movzwl 0x24(%eax),%edx
  802eb0:	66 83 fa 43          	cmp    $0x43,%dx
  802eb4:	76 e1                	jbe    802e97 <dhcp_option_trailer+0xa0>
  802eb6:	f6 c2 03             	test   $0x3,%dl
  802eb9:	75 c0                	jne    802e7b <dhcp_option_trailer+0x84>
    /* LWIP_DEBUGF(DHCP_DEBUG,("dhcp_option_trailer:dhcp->options_out_len=%"U16_F", DHCP_OPTIONS_LEN=%"U16_F, dhcp->options_out_len, DHCP_OPTIONS_LEN)); */
    LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
    /* add a fill/padding byte */
    dhcp->msg_out->options[dhcp->options_out_len++] = 0;
  }
}
  802ebb:	83 c4 14             	add    $0x14,%esp
  802ebe:	5b                   	pop    %ebx
  802ebf:	5d                   	pop    %ebp
  802ec0:	c3                   	ret    

00802ec1 <dhcp_option_long>:
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t) (value & 0x00ffU);
}

static void
dhcp_option_long(struct dhcp *dhcp, u32_t value)
{
  802ec1:	55                   	push   %ebp
  802ec2:	89 e5                	mov    %esp,%ebp
  802ec4:	56                   	push   %esi
  802ec5:	53                   	push   %ebx
  802ec6:	83 ec 10             	sub    $0x10,%esp
  LWIP_ASSERT("dhcp_option_long: dhcp->options_out_len + 4 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 4U <= DHCP_OPTIONS_LEN);
  802ec9:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  802ecd:	0f b7 d9             	movzwl %cx,%ebx
  802ed0:	83 c3 04             	add    $0x4,%ebx
  802ed3:	83 fb 44             	cmp    $0x44,%ebx
  802ed6:	76 1c                	jbe    802ef4 <dhcp_option_long+0x33>
  802ed8:	c7 44 24 08 ec 21 81 	movl   $0x8121ec,0x8(%esp)
  802edf:	00 
  802ee0:	c7 44 24 04 74 04 00 	movl   $0x474,0x4(%esp)
  802ee7:	00 
  802ee8:	c7 04 24 e2 23 81 00 	movl   $0x8123e2,(%esp)
  802eef:	e8 86 c1 00 00       	call   80f07a <_panic>
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff000000UL) >> 24);
  802ef4:	8d 71 01             	lea    0x1(%ecx),%esi
  802ef7:	66 89 70 24          	mov    %si,0x24(%eax)
  802efb:	0f b7 c9             	movzwl %cx,%ecx
  802efe:	89 d3                	mov    %edx,%ebx
  802f00:	c1 eb 18             	shr    $0x18,%ebx
  802f03:	8b 70 20             	mov    0x20(%eax),%esi
  802f06:	88 9c 0e f0 00 00 00 	mov    %bl,0xf0(%esi,%ecx,1)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x00ff0000UL) >> 16);
  802f0d:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  802f11:	8d 71 01             	lea    0x1(%ecx),%esi
  802f14:	66 89 70 24          	mov    %si,0x24(%eax)
  802f18:	0f b7 c9             	movzwl %cx,%ecx
  802f1b:	89 d3                	mov    %edx,%ebx
  802f1d:	c1 eb 10             	shr    $0x10,%ebx
  802f20:	8b 70 20             	mov    0x20(%eax),%esi
  802f23:	88 9c 0e f0 00 00 00 	mov    %bl,0xf0(%esi,%ecx,1)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x0000ff00UL) >> 8);
  802f2a:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  802f2e:	8d 71 01             	lea    0x1(%ecx),%esi
  802f31:	66 89 70 24          	mov    %si,0x24(%eax)
  802f35:	0f b7 c9             	movzwl %cx,%ecx
  802f38:	0f b6 de             	movzbl %dh,%ebx
  802f3b:	8b 70 20             	mov    0x20(%eax),%esi
  802f3e:	88 9c 0e f0 00 00 00 	mov    %bl,0xf0(%esi,%ecx,1)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x000000ffUL));
  802f45:	8b 58 20             	mov    0x20(%eax),%ebx
  802f48:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  802f4c:	8d 71 01             	lea    0x1(%ecx),%esi
  802f4f:	66 89 70 24          	mov    %si,0x24(%eax)
  802f53:	0f b7 c9             	movzwl %cx,%ecx
  802f56:	88 94 0b f0 00 00 00 	mov    %dl,0xf0(%ebx,%ecx,1)
}
  802f5d:	83 c4 10             	add    $0x10,%esp
  802f60:	5b                   	pop    %ebx
  802f61:	5e                   	pop    %esi
  802f62:	5d                   	pop    %ebp
  802f63:	c3                   	ret    

00802f64 <dhcp_create_request>:
 *
 * @param netif the netif under DHCP control
 */
static err_t
dhcp_create_request(struct netif *netif)
{
  802f64:	55                   	push   %ebp
  802f65:	89 e5                	mov    %esp,%ebp
  802f67:	57                   	push   %edi
  802f68:	56                   	push   %esi
  802f69:	53                   	push   %ebx
  802f6a:	83 ec 1c             	sub    $0x1c,%esp
  802f6d:	89 c7                	mov    %eax,%edi
  struct dhcp *dhcp;
  u16_t i;
  LWIP_ERROR("dhcp_create_request: netif != NULL", (netif != NULL), return ERR_ARG;);
  802f6f:	85 c0                	test   %eax,%eax
  802f71:	75 1c                	jne    802f8f <dhcp_create_request+0x2b>
  802f73:	c7 44 24 08 2c 22 81 	movl   $0x81222c,0x8(%esp)
  802f7a:	00 
  802f7b:	c7 44 24 04 2d 05 00 	movl   $0x52d,0x4(%esp)
  802f82:	00 
  802f83:	c7 04 24 e2 23 81 00 	movl   $0x8123e2,(%esp)
  802f8a:	e8 eb c0 00 00       	call   80f07a <_panic>
  dhcp = netif->dhcp;
  802f8f:	8b 58 20             	mov    0x20(%eax),%ebx
  LWIP_ERROR("dhcp_create_request: dhcp != NULL", (dhcp != NULL), return ERR_VAL;);
  802f92:	85 db                	test   %ebx,%ebx
  802f94:	75 1c                	jne    802fb2 <dhcp_create_request+0x4e>
  802f96:	c7 44 24 08 50 22 81 	movl   $0x812250,0x8(%esp)
  802f9d:	00 
  802f9e:	c7 44 24 04 2f 05 00 	movl   $0x52f,0x4(%esp)
  802fa5:	00 
  802fa6:	c7 04 24 e2 23 81 00 	movl   $0x8123e2,(%esp)
  802fad:	e8 c8 c0 00 00       	call   80f07a <_panic>
  LWIP_ASSERT("dhcp_create_request: dhcp->p_out == NULL", dhcp->p_out == NULL);
  802fb2:	83 7b 1c 00          	cmpl   $0x0,0x1c(%ebx)
  802fb6:	74 1c                	je     802fd4 <dhcp_create_request+0x70>
  802fb8:	c7 44 24 08 74 22 81 	movl   $0x812274,0x8(%esp)
  802fbf:	00 
  802fc0:	c7 44 24 04 30 05 00 	movl   $0x530,0x4(%esp)
  802fc7:	00 
  802fc8:	c7 04 24 e2 23 81 00 	movl   $0x8123e2,(%esp)
  802fcf:	e8 a6 c0 00 00       	call   80f07a <_panic>
  LWIP_ASSERT("dhcp_create_request: dhcp->msg_out == NULL", dhcp->msg_out == NULL);
  802fd4:	83 7b 20 00          	cmpl   $0x0,0x20(%ebx)
  802fd8:	74 1c                	je     802ff6 <dhcp_create_request+0x92>
  802fda:	c7 44 24 08 a0 22 81 	movl   $0x8122a0,0x8(%esp)
  802fe1:	00 
  802fe2:	c7 44 24 04 31 05 00 	movl   $0x531,0x4(%esp)
  802fe9:	00 
  802fea:	c7 04 24 e2 23 81 00 	movl   $0x8123e2,(%esp)
  802ff1:	e8 84 c0 00 00       	call   80f07a <_panic>
  dhcp->p_out = pbuf_alloc(PBUF_TRANSPORT, sizeof(struct dhcp_msg), PBUF_RAM);
  802ff6:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  802ffd:	00 
  802ffe:	c7 44 24 04 34 01 00 	movl   $0x134,0x4(%esp)
  803005:	00 
  803006:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80300d:	e8 c3 1e 00 00       	call   804ed5 <pbuf_alloc>
  803012:	89 43 1c             	mov    %eax,0x1c(%ebx)
  if (dhcp->p_out == NULL) {
  803015:	85 c0                	test   %eax,%eax
  803017:	0f 84 2a 01 00 00    	je     803147 <dhcp_create_request+0x1e3>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_create_request(): could not allocate pbuf\n"));
    return ERR_MEM;
  }
  LWIP_ASSERT("dhcp_create_request: check that first pbuf can hold struct dhcp_msg",
  80301d:	66 81 78 0a 33 01    	cmpw   $0x133,0xa(%eax)
  803023:	77 1c                	ja     803041 <dhcp_create_request+0xdd>
  803025:	c7 44 24 08 cc 22 81 	movl   $0x8122cc,0x8(%esp)
  80302c:	00 
  80302d:	c7 44 24 04 38 05 00 	movl   $0x538,0x4(%esp)
  803034:	00 
  803035:	c7 04 24 e2 23 81 00 	movl   $0x8123e2,(%esp)
  80303c:	e8 39 c0 00 00       	call   80f07a <_panic>
           (dhcp->p_out->len >= sizeof(struct dhcp_msg)));

  /* give unique transaction identifier to this request */
  dhcp->xid = xid++;
  803041:	8b 15 04 50 81 00    	mov    0x815004,%edx
  803047:	8d 4a 01             	lea    0x1(%edx),%ecx
  80304a:	89 0d 04 50 81 00    	mov    %ecx,0x815004
  803050:	89 53 04             	mov    %edx,0x4(%ebx)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("transaction id xid++(%"X32_F") dhcp->xid(%"U32_F")\n",xid,dhcp->xid));

  dhcp->msg_out = (struct dhcp_msg *)dhcp->p_out->payload;
  803053:	8b 40 04             	mov    0x4(%eax),%eax
  803056:	89 43 20             	mov    %eax,0x20(%ebx)

  dhcp->msg_out->op = DHCP_BOOTREQUEST;
  803059:	c6 00 01             	movb   $0x1,(%eax)
  /* TODO: make link layer independent */
  dhcp->msg_out->htype = DHCP_HTYPE_ETH;
  80305c:	8b 43 20             	mov    0x20(%ebx),%eax
  80305f:	c6 40 01 01          	movb   $0x1,0x1(%eax)
  /* TODO: make link layer independent */
  dhcp->msg_out->hlen = DHCP_HLEN_ETH;
  803063:	8b 43 20             	mov    0x20(%ebx),%eax
  803066:	c6 40 02 06          	movb   $0x6,0x2(%eax)
  dhcp->msg_out->hops = 0;
  80306a:	8b 43 20             	mov    0x20(%ebx),%eax
  80306d:	c6 40 03 00          	movb   $0x0,0x3(%eax)
  dhcp->msg_out->xid = htonl(dhcp->xid);
  803071:	8b 73 20             	mov    0x20(%ebx),%esi
  803074:	8b 43 04             	mov    0x4(%ebx),%eax
  803077:	89 04 24             	mov    %eax,(%esp)
  80307a:	e8 11 4d 00 00       	call   807d90 <htonl>
  80307f:	89 46 04             	mov    %eax,0x4(%esi)
  dhcp->msg_out->secs = 0;
  803082:	8b 43 20             	mov    0x20(%ebx),%eax
  803085:	66 c7 40 08 00 00    	movw   $0x0,0x8(%eax)
  dhcp->msg_out->flags = 0;
  80308b:	8b 43 20             	mov    0x20(%ebx),%eax
  80308e:	66 c7 40 0a 00 00    	movw   $0x0,0xa(%eax)
  dhcp->msg_out->ciaddr.addr = netif->ip_addr.addr;
  803094:	8b 43 20             	mov    0x20(%ebx),%eax
  803097:	8b 57 04             	mov    0x4(%edi),%edx
  80309a:	89 50 0c             	mov    %edx,0xc(%eax)
  dhcp->msg_out->yiaddr.addr = 0;
  80309d:	8b 43 20             	mov    0x20(%ebx),%eax
  8030a0:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  dhcp->msg_out->siaddr.addr = 0;
  8030a7:	8b 43 20             	mov    0x20(%ebx),%eax
  8030aa:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
  dhcp->msg_out->giaddr.addr = 0;
  8030b1:	8b 43 20             	mov    0x20(%ebx),%eax
  8030b4:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
  8030bb:	b8 00 00 00 00       	mov    $0x0,%eax
  8030c0:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
    /* copy netif hardware address, pad with zeroes */
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  8030c3:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  8030c6:	8b 59 20             	mov    0x20(%ecx),%ebx
  8030c9:	89 c1                	mov    %eax,%ecx
  8030cb:	0f b6 77 24          	movzbl 0x24(%edi),%esi
  8030cf:	ba 00 00 00 00       	mov    $0x0,%edx
  8030d4:	66 39 c6             	cmp    %ax,%si
  8030d7:	76 05                	jbe    8030de <dhcp_create_request+0x17a>
  8030d9:	0f b6 54 07 25       	movzbl 0x25(%edi,%eax,1),%edx
  8030de:	88 54 0b 1c          	mov    %dl,0x1c(%ebx,%ecx,1)
  8030e2:	83 c0 01             	add    $0x1,%eax
  dhcp->msg_out->flags = 0;
  dhcp->msg_out->ciaddr.addr = netif->ip_addr.addr;
  dhcp->msg_out->yiaddr.addr = 0;
  dhcp->msg_out->siaddr.addr = 0;
  dhcp->msg_out->giaddr.addr = 0;
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
  8030e5:	83 f8 10             	cmp    $0x10,%eax
  8030e8:	75 d9                	jne    8030c3 <dhcp_create_request+0x15f>
  8030ea:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
  8030ed:	b0 00                	mov    $0x0,%al
    /* copy netif hardware address, pad with zeroes */
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
    dhcp->msg_out->sname[i] = 0;
  8030ef:	8b 53 20             	mov    0x20(%ebx),%edx
  8030f2:	c6 44 02 2c 00       	movb   $0x0,0x2c(%edx,%eax,1)
  8030f7:	83 c0 01             	add    $0x1,%eax
  dhcp->msg_out->giaddr.addr = 0;
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
    /* copy netif hardware address, pad with zeroes */
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
  8030fa:	83 f8 40             	cmp    $0x40,%eax
  8030fd:	75 f0                	jne    8030ef <dhcp_create_request+0x18b>
  8030ff:	b0 00                	mov    $0x0,%al
    dhcp->msg_out->sname[i] = 0;
  }
  for (i = 0; i < DHCP_FILE_LEN; i++) {
    dhcp->msg_out->file[i] = 0;
  803101:	8b 53 20             	mov    0x20(%ebx),%edx
  803104:	c6 44 02 6c 00       	movb   $0x0,0x6c(%edx,%eax,1)
  803109:	83 c0 01             	add    $0x1,%eax
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
    dhcp->msg_out->sname[i] = 0;
  }
  for (i = 0; i < DHCP_FILE_LEN; i++) {
  80310c:	3d 80 00 00 00       	cmp    $0x80,%eax
  803111:	75 ee                	jne    803101 <dhcp_create_request+0x19d>
    dhcp->msg_out->file[i] = 0;
  }
  dhcp->msg_out->cookie = htonl(0x63825363UL);
  803113:	8b 73 20             	mov    0x20(%ebx),%esi
  803116:	c7 04 24 63 53 82 63 	movl   $0x63825363,(%esp)
  80311d:	e8 6e 4c 00 00       	call   807d90 <htonl>
  803122:	89 86 ec 00 00 00    	mov    %eax,0xec(%esi)
  dhcp->options_out_len = 0;
  803128:	66 c7 43 24 00 00    	movw   $0x0,0x24(%ebx)
  80312e:	b8 00 00 00 00       	mov    $0x0,%eax
  /* fill options field with an incrementing array (for debugging purposes) */
  for (i = 0; i < DHCP_OPTIONS_LEN; i++) {
    dhcp->msg_out->options[i] = (u8_t)i; /* for debugging only, no matter if truncated */
  803133:	8b 53 20             	mov    0x20(%ebx),%edx
  803136:	88 84 02 f0 00 00 00 	mov    %al,0xf0(%edx,%eax,1)
  80313d:	83 c0 01             	add    $0x1,%eax
    dhcp->msg_out->file[i] = 0;
  }
  dhcp->msg_out->cookie = htonl(0x63825363UL);
  dhcp->options_out_len = 0;
  /* fill options field with an incrementing array (for debugging purposes) */
  for (i = 0; i < DHCP_OPTIONS_LEN; i++) {
  803140:	83 f8 44             	cmp    $0x44,%eax
  803143:	75 ee                	jne    803133 <dhcp_create_request+0x1cf>
  803145:	eb 07                	jmp    80314e <dhcp_create_request+0x1ea>
  LWIP_ASSERT("dhcp_create_request: dhcp->p_out == NULL", dhcp->p_out == NULL);
  LWIP_ASSERT("dhcp_create_request: dhcp->msg_out == NULL", dhcp->msg_out == NULL);
  dhcp->p_out = pbuf_alloc(PBUF_TRANSPORT, sizeof(struct dhcp_msg), PBUF_RAM);
  if (dhcp->p_out == NULL) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_create_request(): could not allocate pbuf\n"));
    return ERR_MEM;
  803147:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80314c:	eb 05                	jmp    803153 <dhcp_create_request+0x1ef>
  dhcp->options_out_len = 0;
  /* fill options field with an incrementing array (for debugging purposes) */
  for (i = 0; i < DHCP_OPTIONS_LEN; i++) {
    dhcp->msg_out->options[i] = (u8_t)i; /* for debugging only, no matter if truncated */
  }
  return ERR_OK;
  80314e:	b8 00 00 00 00       	mov    $0x0,%eax
}
  803153:	83 c4 1c             	add    $0x1c,%esp
  803156:	5b                   	pop    %ebx
  803157:	5e                   	pop    %esi
  803158:	5f                   	pop    %edi
  803159:	5d                   	pop    %ebp
  80315a:	c3                   	ret    

0080315b <dhcp_delete_request>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_delete_request(struct netif *netif)
{
  80315b:	55                   	push   %ebp
  80315c:	89 e5                	mov    %esp,%ebp
  80315e:	53                   	push   %ebx
  80315f:	83 ec 14             	sub    $0x14,%esp
  struct dhcp *dhcp;
  LWIP_ERROR("dhcp_delete_request: netif != NULL", (netif != NULL), return;);
  803162:	85 c0                	test   %eax,%eax
  803164:	75 1c                	jne    803182 <dhcp_delete_request+0x27>
  803166:	c7 44 24 08 10 23 81 	movl   $0x812310,0x8(%esp)
  80316d:	00 
  80316e:	c7 44 24 04 69 05 00 	movl   $0x569,0x4(%esp)
  803175:	00 
  803176:	c7 04 24 e2 23 81 00 	movl   $0x8123e2,(%esp)
  80317d:	e8 f8 be 00 00       	call   80f07a <_panic>
  dhcp = netif->dhcp;
  803182:	8b 58 20             	mov    0x20(%eax),%ebx
  LWIP_ERROR("dhcp_delete_request: dhcp != NULL", (dhcp != NULL), return;);
  803185:	85 db                	test   %ebx,%ebx
  803187:	75 1c                	jne    8031a5 <dhcp_delete_request+0x4a>
  803189:	c7 44 24 08 34 23 81 	movl   $0x812334,0x8(%esp)
  803190:	00 
  803191:	c7 44 24 04 6b 05 00 	movl   $0x56b,0x4(%esp)
  803198:	00 
  803199:	c7 04 24 e2 23 81 00 	movl   $0x8123e2,(%esp)
  8031a0:	e8 d5 be 00 00       	call   80f07a <_panic>
  LWIP_ASSERT("dhcp_delete_request: dhcp->p_out != NULL", dhcp->p_out != NULL);
  8031a5:	8b 43 1c             	mov    0x1c(%ebx),%eax
  8031a8:	85 c0                	test   %eax,%eax
  8031aa:	75 1c                	jne    8031c8 <dhcp_delete_request+0x6d>
  8031ac:	c7 44 24 08 58 23 81 	movl   $0x812358,0x8(%esp)
  8031b3:	00 
  8031b4:	c7 44 24 04 6c 05 00 	movl   $0x56c,0x4(%esp)
  8031bb:	00 
  8031bc:	c7 04 24 e2 23 81 00 	movl   $0x8123e2,(%esp)
  8031c3:	e8 b2 be 00 00       	call   80f07a <_panic>
  LWIP_ASSERT("dhcp_delete_request: dhcp->msg_out != NULL", dhcp->msg_out != NULL);
  8031c8:	83 7b 20 00          	cmpl   $0x0,0x20(%ebx)
  8031cc:	75 1c                	jne    8031ea <dhcp_delete_request+0x8f>
  8031ce:	c7 44 24 08 84 23 81 	movl   $0x812384,0x8(%esp)
  8031d5:	00 
  8031d6:	c7 44 24 04 6d 05 00 	movl   $0x56d,0x4(%esp)
  8031dd:	00 
  8031de:	c7 04 24 e2 23 81 00 	movl   $0x8123e2,(%esp)
  8031e5:	e8 90 be 00 00       	call   80f07a <_panic>
  if (dhcp->p_out != NULL) {
    pbuf_free(dhcp->p_out);
  8031ea:	89 04 24             	mov    %eax,(%esp)
  8031ed:	e8 02 1c 00 00       	call   804df4 <pbuf_free>
  }
  dhcp->p_out = NULL;
  8031f2:	c7 43 1c 00 00 00 00 	movl   $0x0,0x1c(%ebx)
  dhcp->msg_out = NULL;
  8031f9:	c7 43 20 00 00 00 00 	movl   $0x0,0x20(%ebx)
}
  803200:	83 c4 14             	add    $0x14,%esp
  803203:	5b                   	pop    %ebx
  803204:	5d                   	pop    %ebp
  803205:	c3                   	ret    

00803206 <dhcp_rebind>:
 *
 * @param netif network interface which must rebind with a DHCP server
 */
static err_t
dhcp_rebind(struct netif *netif)
{
  803206:	55                   	push   %ebp
  803207:	89 e5                	mov    %esp,%ebp
  803209:	57                   	push   %edi
  80320a:	56                   	push   %esi
  80320b:	53                   	push   %ebx
  80320c:	83 ec 2c             	sub    $0x2c,%esp
  80320f:	89 c7                	mov    %eax,%edi
  struct dhcp *dhcp = netif->dhcp;
  803211:	8b 58 20             	mov    0x20(%eax),%ebx
  err_t result;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind()\n"));
  dhcp_set_state(dhcp, DHCP_REBINDING);
  803214:	ba 04 00 00 00       	mov    $0x4,%edx
  803219:	89 d8                	mov    %ebx,%eax
  80321b:	e8 80 f9 ff ff       	call   802ba0 <dhcp_set_state>

  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  803220:	89 f8                	mov    %edi,%eax
  803222:	e8 3d fd ff ff       	call   802f64 <dhcp_create_request>
  803227:	89 c6                	mov    %eax,%esi
  if (result == ERR_OK) {
  803229:	84 c0                	test   %al,%al
  80322b:	0f 85 a3 00 00 00    	jne    8032d4 <dhcp_rebind+0xce>

    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  803231:	b9 01 00 00 00       	mov    $0x1,%ecx
  803236:	ba 35 00 00 00       	mov    $0x35,%edx
  80323b:	89 d8                	mov    %ebx,%eax
  80323d:	e8 dd fa ff ff       	call   802d1f <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_REQUEST);
  803242:	ba 03 00 00 00       	mov    $0x3,%edx
  803247:	89 d8                	mov    %ebx,%eax
  803249:	e8 88 fa ff ff       	call   802cd6 <dhcp_option_byte>

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  80324e:	b9 02 00 00 00       	mov    $0x2,%ecx
  803253:	ba 39 00 00 00       	mov    $0x39,%edx
  803258:	89 d8                	mov    %ebx,%eax
  80325a:	e8 c0 fa ff ff       	call   802d1f <dhcp_option>
    dhcp_option_short(dhcp, 576);
  80325f:	ba 40 02 00 00       	mov    $0x240,%edx
  803264:	89 d8                	mov    %ebx,%eax
  803266:	e8 20 fb ff ff       	call   802d8b <dhcp_option_short>

    dhcp_option(dhcp, DHCP_OPTION_SERVER_ID, 4);
    dhcp_option_long(dhcp, ntohl(dhcp->server_ip_addr.addr));
#endif

    dhcp_option_trailer(dhcp);
  80326b:	89 d8                	mov    %ebx,%eax
  80326d:	e8 85 fb ff ff       	call   802df7 <dhcp_option_trailer>

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  803272:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  803276:	66 05 f0 00          	add    $0xf0,%ax
  80327a:	0f b7 c0             	movzwl %ax,%eax
  80327d:	89 44 24 04          	mov    %eax,0x4(%esp)
  803281:	8b 43 1c             	mov    0x1c(%ebx),%eax
  803284:	89 04 24             	mov    %eax,(%esp)
  803287:	e8 da 1e 00 00       	call   805166 <pbuf_realloc>

    /* broadcast to server */
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  80328c:	c7 44 24 08 43 00 00 	movl   $0x43,0x8(%esp)
  803293:	00 
  803294:	c7 44 24 04 a0 2c 81 	movl   $0x812ca0,0x4(%esp)
  80329b:	00 
  80329c:	8b 43 08             	mov    0x8(%ebx),%eax
  80329f:	89 04 24             	mov    %eax,(%esp)
  8032a2:	e8 8e 64 00 00       	call   809735 <udp_connect>
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  8032a7:	89 7c 24 10          	mov    %edi,0x10(%esp)
  8032ab:	c7 44 24 0c 43 00 00 	movl   $0x43,0xc(%esp)
  8032b2:	00 
  8032b3:	c7 44 24 08 9c 2c 81 	movl   $0x812c9c,0x8(%esp)
  8032ba:	00 
  8032bb:	8b 43 1c             	mov    0x1c(%ebx),%eax
  8032be:	89 44 24 04          	mov    %eax,0x4(%esp)
  8032c2:	8b 43 08             	mov    0x8(%ebx),%eax
  8032c5:	89 04 24             	mov    %eax,(%esp)
  8032c8:	e8 46 62 00 00       	call   809513 <udp_sendto_if>
    dhcp_delete_request(netif);
  8032cd:	89 f8                	mov    %edi,%eax
  8032cf:	e8 87 fe ff ff       	call   80315b <dhcp_delete_request>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind: REBINDING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_rebind: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  8032d4:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
  8032d8:	8d 48 01             	lea    0x1(%eax),%ecx
  8032db:	88 4b 01             	mov    %cl,0x1(%ebx)
  msecs = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
  8032de:	b8 10 27 00 00       	mov    $0x2710,%eax
  8032e3:	80 f9 09             	cmp    $0x9,%cl
  8032e6:	77 08                	ja     8032f0 <dhcp_rebind+0xea>
  8032e8:	0f b6 c9             	movzbl %cl,%ecx
  8032eb:	66 69 c1 e8 03       	imul   $0x3e8,%cx,%ax
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  8032f0:	0f b7 d0             	movzwl %ax,%edx
  8032f3:	81 c2 f3 01 00 00    	add    $0x1f3,%edx
  8032f9:	bf d3 4d 62 10       	mov    $0x10624dd3,%edi
  8032fe:	89 d0                	mov    %edx,%eax
  803300:	f7 ef                	imul   %edi
  803302:	c1 fa 05             	sar    $0x5,%edx
  803305:	66 89 53 26          	mov    %dx,0x26(%ebx)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
}
  803309:	89 f0                	mov    %esi,%eax
  80330b:	83 c4 2c             	add    $0x2c,%esp
  80330e:	5b                   	pop    %ebx
  80330f:	5e                   	pop    %esi
  803310:	5f                   	pop    %edi
  803311:	5d                   	pop    %ebp
  803312:	c3                   	ret    

00803313 <dhcp_discover>:
 *
 * @param netif the netif under DHCP control
 */
static err_t
dhcp_discover(struct netif *netif)
{
  803313:	55                   	push   %ebp
  803314:	89 e5                	mov    %esp,%ebp
  803316:	57                   	push   %edi
  803317:	56                   	push   %esi
  803318:	53                   	push   %ebx
  803319:	83 ec 2c             	sub    $0x2c,%esp
  80331c:	89 c7                	mov    %eax,%edi
  struct dhcp *dhcp = netif->dhcp;
  80331e:	8b 58 20             	mov    0x20(%eax),%ebx
  err_t result = ERR_OK;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_discover()\n"));
  ip_addr_set(&dhcp->offered_ip_addr, IP_ADDR_ANY);
  803321:	a1 a0 2c 81 00       	mov    0x812ca0,%eax
  803326:	89 43 30             	mov    %eax,0x30(%ebx)
  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  803329:	89 f8                	mov    %edi,%eax
  80332b:	e8 34 fc ff ff       	call   802f64 <dhcp_create_request>
  803330:	89 c6                	mov    %eax,%esi
  if (result == ERR_OK) {
  803332:	84 c0                	test   %al,%al
  803334:	0f 85 f0 00 00 00    	jne    80342a <dhcp_discover+0x117>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: making request\n"));
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  80333a:	b9 01 00 00 00       	mov    $0x1,%ecx
  80333f:	ba 35 00 00 00       	mov    $0x35,%edx
  803344:	89 d8                	mov    %ebx,%eax
  803346:	e8 d4 f9 ff ff       	call   802d1f <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_DISCOVER);
  80334b:	ba 01 00 00 00       	mov    $0x1,%edx
  803350:	89 d8                	mov    %ebx,%eax
  803352:	e8 7f f9 ff ff       	call   802cd6 <dhcp_option_byte>

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  803357:	b9 02 00 00 00       	mov    $0x2,%ecx
  80335c:	ba 39 00 00 00       	mov    $0x39,%edx
  803361:	89 d8                	mov    %ebx,%eax
  803363:	e8 b7 f9 ff ff       	call   802d1f <dhcp_option>
    dhcp_option_short(dhcp, 576);
  803368:	ba 40 02 00 00       	mov    $0x240,%edx
  80336d:	89 d8                	mov    %ebx,%eax
  80336f:	e8 17 fa ff ff       	call   802d8b <dhcp_option_short>

    dhcp_option(dhcp, DHCP_OPTION_PARAMETER_REQUEST_LIST, 4/*num options*/);
  803374:	b9 04 00 00 00       	mov    $0x4,%ecx
  803379:	ba 37 00 00 00       	mov    $0x37,%edx
  80337e:	89 d8                	mov    %ebx,%eax
  803380:	e8 9a f9 ff ff       	call   802d1f <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_OPTION_SUBNET_MASK);
  803385:	ba 01 00 00 00       	mov    $0x1,%edx
  80338a:	89 d8                	mov    %ebx,%eax
  80338c:	e8 45 f9 ff ff       	call   802cd6 <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_ROUTER);
  803391:	ba 03 00 00 00       	mov    $0x3,%edx
  803396:	89 d8                	mov    %ebx,%eax
  803398:	e8 39 f9 ff ff       	call   802cd6 <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_BROADCAST);
  80339d:	ba 1c 00 00 00       	mov    $0x1c,%edx
  8033a2:	89 d8                	mov    %ebx,%eax
  8033a4:	e8 2d f9 ff ff       	call   802cd6 <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_DNS_SERVER);
  8033a9:	ba 06 00 00 00       	mov    $0x6,%edx
  8033ae:	89 d8                	mov    %ebx,%eax
  8033b0:	e8 21 f9 ff ff       	call   802cd6 <dhcp_option_byte>

    dhcp_option_trailer(dhcp);
  8033b5:	89 d8                	mov    %ebx,%eax
  8033b7:	e8 3b fa ff ff       	call   802df7 <dhcp_option_trailer>

    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: realloc()ing\n"));
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  8033bc:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  8033c0:	66 05 f0 00          	add    $0xf0,%ax
  8033c4:	0f b7 c0             	movzwl %ax,%eax
  8033c7:	89 44 24 04          	mov    %eax,0x4(%esp)
  8033cb:	8b 43 1c             	mov    0x1c(%ebx),%eax
  8033ce:	89 04 24             	mov    %eax,(%esp)
  8033d1:	e8 90 1d 00 00       	call   805166 <pbuf_realloc>

    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  8033d6:	c7 44 24 08 43 00 00 	movl   $0x43,0x8(%esp)
  8033dd:	00 
  8033de:	c7 44 24 04 a0 2c 81 	movl   $0x812ca0,0x4(%esp)
  8033e5:	00 
  8033e6:	8b 43 08             	mov    0x8(%ebx),%eax
  8033e9:	89 04 24             	mov    %eax,(%esp)
  8033ec:	e8 44 63 00 00       	call   809735 <udp_connect>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: sendto(DISCOVER, IP_ADDR_BROADCAST, DHCP_SERVER_PORT)\n"));
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  8033f1:	89 7c 24 10          	mov    %edi,0x10(%esp)
  8033f5:	c7 44 24 0c 43 00 00 	movl   $0x43,0xc(%esp)
  8033fc:	00 
  8033fd:	c7 44 24 08 9c 2c 81 	movl   $0x812c9c,0x8(%esp)
  803404:	00 
  803405:	8b 43 1c             	mov    0x1c(%ebx),%eax
  803408:	89 44 24 04          	mov    %eax,0x4(%esp)
  80340c:	8b 43 08             	mov    0x8(%ebx),%eax
  80340f:	89 04 24             	mov    %eax,(%esp)
  803412:	e8 fc 60 00 00       	call   809513 <udp_sendto_if>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: deleting()ing\n"));
    dhcp_delete_request(netif);
  803417:	89 f8                	mov    %edi,%eax
  803419:	e8 3d fd ff ff       	call   80315b <dhcp_delete_request>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_discover: SELECTING\n"));
    dhcp_set_state(dhcp, DHCP_SELECTING);
  80341e:	ba 06 00 00 00       	mov    $0x6,%edx
  803423:	89 d8                	mov    %ebx,%eax
  803425:	e8 76 f7 ff ff       	call   802ba0 <dhcp_set_state>
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_discover: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  80342a:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
  80342e:	8d 48 01             	lea    0x1(%eax),%ecx
  803431:	88 4b 01             	mov    %cl,0x1(%ebx)
  if(dhcp->tries >= 9 && dhcp->autoip_coop_state == DHCP_AUTOIP_COOP_STATE_OFF) {
    dhcp->autoip_coop_state = DHCP_AUTOIP_COOP_STATE_ON;
    autoip_start(netif);
  }
#endif /* LWIP_DHCP_AUTOIP_COOP */
  msecs = dhcp->tries < 4 ? (dhcp->tries + 1) * 1000 : 10 * 1000;
  803434:	b8 10 27 00 00       	mov    $0x2710,%eax
  803439:	80 f9 03             	cmp    $0x3,%cl
  80343c:	77 0b                	ja     803449 <dhcp_discover+0x136>
  80343e:	0f b6 c1             	movzbl %cl,%eax
  803441:	83 c0 01             	add    $0x1,%eax
  803444:	66 69 c0 e8 03       	imul   $0x3e8,%ax,%ax
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  803449:	0f b7 d0             	movzwl %ax,%edx
  80344c:	81 c2 f3 01 00 00    	add    $0x1f3,%edx
  803452:	b9 d3 4d 62 10       	mov    $0x10624dd3,%ecx
  803457:	89 d0                	mov    %edx,%eax
  803459:	f7 e9                	imul   %ecx
  80345b:	c1 fa 05             	sar    $0x5,%edx
  80345e:	66 89 53 26          	mov    %dx,0x26(%ebx)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_discover(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
}
  803462:	89 f0                	mov    %esi,%eax
  803464:	83 c4 2c             	add    $0x2c,%esp
  803467:	5b                   	pop    %ebx
  803468:	5e                   	pop    %esi
  803469:	5f                   	pop    %edi
  80346a:	5d                   	pop    %ebp
  80346b:	c3                   	ret    

0080346c <dhcp_select>:
 * @param netif the netif under DHCP control
 * @return lwIP specific error (see error.h)
 */
static err_t
dhcp_select(struct netif *netif)
{
  80346c:	55                   	push   %ebp
  80346d:	89 e5                	mov    %esp,%ebp
  80346f:	57                   	push   %edi
  803470:	56                   	push   %esi
  803471:	53                   	push   %ebx
  803472:	83 ec 2c             	sub    $0x2c,%esp
  803475:	89 c7                	mov    %eax,%edi
  struct dhcp *dhcp = netif->dhcp;
  803477:	8b 58 20             	mov    0x20(%eax),%ebx
#endif /* LWIP_NETIF_HOSTNAME */

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_select(netif=%p) %c%c%"U16_F"\n", (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));

  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  80347a:	e8 e5 fa ff ff       	call   802f64 <dhcp_create_request>
  80347f:	89 c6                	mov    %eax,%esi
  if (result == ERR_OK) {
  803481:	84 c0                	test   %al,%al
  803483:	0f 85 3a 01 00 00    	jne    8035c3 <dhcp_select+0x157>
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  803489:	b9 01 00 00 00       	mov    $0x1,%ecx
  80348e:	ba 35 00 00 00       	mov    $0x35,%edx
  803493:	89 d8                	mov    %ebx,%eax
  803495:	e8 85 f8 ff ff       	call   802d1f <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_REQUEST);
  80349a:	ba 03 00 00 00       	mov    $0x3,%edx
  80349f:	89 d8                	mov    %ebx,%eax
  8034a1:	e8 30 f8 ff ff       	call   802cd6 <dhcp_option_byte>

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  8034a6:	b9 02 00 00 00       	mov    $0x2,%ecx
  8034ab:	ba 39 00 00 00       	mov    $0x39,%edx
  8034b0:	89 d8                	mov    %ebx,%eax
  8034b2:	e8 68 f8 ff ff       	call   802d1f <dhcp_option>
    dhcp_option_short(dhcp, 576);
  8034b7:	ba 40 02 00 00       	mov    $0x240,%edx
  8034bc:	89 d8                	mov    %ebx,%eax
  8034be:	e8 c8 f8 ff ff       	call   802d8b <dhcp_option_short>

    /* MUST request the offered IP address */
    dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
  8034c3:	b9 04 00 00 00       	mov    $0x4,%ecx
  8034c8:	ba 32 00 00 00       	mov    $0x32,%edx
  8034cd:	89 d8                	mov    %ebx,%eax
  8034cf:	e8 4b f8 ff ff       	call   802d1f <dhcp_option>
    dhcp_option_long(dhcp, ntohl(dhcp->offered_ip_addr.addr));
  8034d4:	8b 43 30             	mov    0x30(%ebx),%eax
  8034d7:	89 04 24             	mov    %eax,(%esp)
  8034da:	e8 eb 4a 00 00       	call   807fca <ntohl>
  8034df:	89 c2                	mov    %eax,%edx
  8034e1:	89 d8                	mov    %ebx,%eax
  8034e3:	e8 d9 f9 ff ff       	call   802ec1 <dhcp_option_long>

    dhcp_option(dhcp, DHCP_OPTION_SERVER_ID, 4);
  8034e8:	b9 04 00 00 00       	mov    $0x4,%ecx
  8034ed:	ba 36 00 00 00       	mov    $0x36,%edx
  8034f2:	89 d8                	mov    %ebx,%eax
  8034f4:	e8 26 f8 ff ff       	call   802d1f <dhcp_option>
    dhcp_option_long(dhcp, ntohl(dhcp->server_ip_addr.addr));
  8034f9:	8b 43 2c             	mov    0x2c(%ebx),%eax
  8034fc:	89 04 24             	mov    %eax,(%esp)
  8034ff:	e8 c6 4a 00 00       	call   807fca <ntohl>
  803504:	89 c2                	mov    %eax,%edx
  803506:	89 d8                	mov    %ebx,%eax
  803508:	e8 b4 f9 ff ff       	call   802ec1 <dhcp_option_long>

    dhcp_option(dhcp, DHCP_OPTION_PARAMETER_REQUEST_LIST, 4/*num options*/);
  80350d:	b9 04 00 00 00       	mov    $0x4,%ecx
  803512:	ba 37 00 00 00       	mov    $0x37,%edx
  803517:	89 d8                	mov    %ebx,%eax
  803519:	e8 01 f8 ff ff       	call   802d1f <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_OPTION_SUBNET_MASK);
  80351e:	ba 01 00 00 00       	mov    $0x1,%edx
  803523:	89 d8                	mov    %ebx,%eax
  803525:	e8 ac f7 ff ff       	call   802cd6 <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_ROUTER);
  80352a:	ba 03 00 00 00       	mov    $0x3,%edx
  80352f:	89 d8                	mov    %ebx,%eax
  803531:	e8 a0 f7 ff ff       	call   802cd6 <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_BROADCAST);
  803536:	ba 1c 00 00 00       	mov    $0x1c,%edx
  80353b:	89 d8                	mov    %ebx,%eax
  80353d:	e8 94 f7 ff ff       	call   802cd6 <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_DNS_SERVER);
  803542:	ba 06 00 00 00       	mov    $0x6,%edx
  803547:	89 d8                	mov    %ebx,%eax
  803549:	e8 88 f7 ff ff       	call   802cd6 <dhcp_option_byte>
        dhcp_option_byte(dhcp, *p++);
      }
    }
#endif /* LWIP_NETIF_HOSTNAME */

    dhcp_option_trailer(dhcp);
  80354e:	89 d8                	mov    %ebx,%eax
  803550:	e8 a2 f8 ff ff       	call   802df7 <dhcp_option_trailer>
    /* shrink the pbuf to the actual content length */
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  803555:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  803559:	66 05 f0 00          	add    $0xf0,%ax
  80355d:	0f b7 c0             	movzwl %ax,%eax
  803560:	89 44 24 04          	mov    %eax,0x4(%esp)
  803564:	8b 43 1c             	mov    0x1c(%ebx),%eax
  803567:	89 04 24             	mov    %eax,(%esp)
  80356a:	e8 f7 1b 00 00       	call   805166 <pbuf_realloc>

    /* TODO: we really should bind to a specific local interface here
       but we cannot specify an unconfigured netif as it is addressless */
    /* send broadcast to any DHCP server */
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  80356f:	89 7c 24 10          	mov    %edi,0x10(%esp)
  803573:	c7 44 24 0c 43 00 00 	movl   $0x43,0xc(%esp)
  80357a:	00 
  80357b:	c7 44 24 08 9c 2c 81 	movl   $0x812c9c,0x8(%esp)
  803582:	00 
  803583:	8b 43 1c             	mov    0x1c(%ebx),%eax
  803586:	89 44 24 04          	mov    %eax,0x4(%esp)
  80358a:	8b 43 08             	mov    0x8(%ebx),%eax
  80358d:	89 04 24             	mov    %eax,(%esp)
  803590:	e8 7e 5f 00 00       	call   809513 <udp_sendto_if>
    /* reconnect to any (or to server here?!) */
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  803595:	c7 44 24 08 43 00 00 	movl   $0x43,0x8(%esp)
  80359c:	00 
  80359d:	c7 44 24 04 a0 2c 81 	movl   $0x812ca0,0x4(%esp)
  8035a4:	00 
  8035a5:	8b 43 08             	mov    0x8(%ebx),%eax
  8035a8:	89 04 24             	mov    %eax,(%esp)
  8035ab:	e8 85 61 00 00       	call   809735 <udp_connect>
    dhcp_delete_request(netif);
  8035b0:	89 f8                	mov    %edi,%eax
  8035b2:	e8 a4 fb ff ff       	call   80315b <dhcp_delete_request>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_select: REQUESTING\n"));
    dhcp_set_state(dhcp, DHCP_REQUESTING);
  8035b7:	ba 01 00 00 00       	mov    $0x1,%edx
  8035bc:	89 d8                	mov    %ebx,%eax
  8035be:	e8 dd f5 ff ff       	call   802ba0 <dhcp_set_state>
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_select: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  8035c3:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
  8035c7:	8d 48 01             	lea    0x1(%eax),%ecx
  8035ca:	88 4b 01             	mov    %cl,0x1(%ebx)
  msecs = dhcp->tries < 4 ? dhcp->tries * 1000 : 4 * 1000;
  8035cd:	b8 a0 0f 00 00       	mov    $0xfa0,%eax
  8035d2:	80 f9 03             	cmp    $0x3,%cl
  8035d5:	77 08                	ja     8035df <dhcp_select+0x173>
  8035d7:	0f b6 c9             	movzbl %cl,%ecx
  8035da:	66 69 c1 e8 03       	imul   $0x3e8,%cx,%ax
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  8035df:	0f b7 d0             	movzwl %ax,%edx
  8035e2:	81 c2 f3 01 00 00    	add    $0x1f3,%edx
  8035e8:	bf d3 4d 62 10       	mov    $0x10624dd3,%edi
  8035ed:	89 d0                	mov    %edx,%eax
  8035ef:	f7 ef                	imul   %edi
  8035f1:	c1 fa 05             	sar    $0x5,%edx
  8035f4:	66 89 53 26          	mov    %dx,0x26(%ebx)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_select(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
}
  8035f8:	89 f0                	mov    %esi,%eax
  8035fa:	83 c4 2c             	add    $0x2c,%esp
  8035fd:	5b                   	pop    %ebx
  8035fe:	5e                   	pop    %esi
  8035ff:	5f                   	pop    %edi
  803600:	5d                   	pop    %ebp
  803601:	c3                   	ret    

00803602 <dhcp_check>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_check(struct netif *netif)
{
  803602:	55                   	push   %ebp
  803603:	89 e5                	mov    %esp,%ebp
  803605:	53                   	push   %ebx
  803606:	83 ec 14             	sub    $0x14,%esp
  struct dhcp *dhcp = netif->dhcp;
  803609:	8b 58 20             	mov    0x20(%eax),%ebx
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_check(netif=%p) %c%c\n", (void *)netif, (s16_t)netif->name[0],
    (s16_t)netif->name[1]));
  /* create an ARP query for the offered IP address, expecting that no host
     responds, as the IP address should not be in use. */
  result = etharp_query(netif, &dhcp->offered_ip_addr, NULL);
  80360c:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  803613:	00 
  803614:	8d 53 30             	lea    0x30(%ebx),%edx
  803617:	89 54 24 04          	mov    %edx,0x4(%esp)
  80361b:	89 04 24             	mov    %eax,(%esp)
  80361e:	e8 e1 6a 00 00       	call   80a104 <etharp_query>
  if (result != ERR_OK) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_check: could not perform ARP query\n"));
  }
  dhcp->tries++;
  803623:	80 43 01 01          	addb   $0x1,0x1(%ebx)
  msecs = 500;
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  803627:	66 c7 43 26 01 00    	movw   $0x1,0x26(%ebx)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_check(): set request timeout %"U16_F" msecs\n", msecs));
  dhcp_set_state(dhcp, DHCP_CHECKING);
  80362d:	ba 08 00 00 00       	mov    $0x8,%edx
  803632:	89 d8                	mov    %ebx,%eax
  803634:	e8 67 f5 ff ff       	call   802ba0 <dhcp_set_state>
}
  803639:	83 c4 14             	add    $0x14,%esp
  80363c:	5b                   	pop    %ebx
  80363d:	5d                   	pop    %ebp
  80363e:	c3                   	ret    

0080363f <dhcp_bind>:
 *
 * @param netif network interface to bind to the offered address
 */
static void
dhcp_bind(struct netif *netif)
{
  80363f:	55                   	push   %ebp
  803640:	89 e5                	mov    %esp,%ebp
  803642:	57                   	push   %edi
  803643:	56                   	push   %esi
  803644:	53                   	push   %ebx
  803645:	83 ec 2c             	sub    $0x2c,%esp
  803648:	89 c6                	mov    %eax,%esi
  u32_t timeout;
  struct dhcp *dhcp;
  struct ip_addr sn_mask, gw_addr;
  LWIP_ERROR("dhcp_bind: netif != NULL", (netif != NULL), return;);
  80364a:	85 c0                	test   %eax,%eax
  80364c:	75 1c                	jne    80366a <dhcp_bind+0x2b>
  80364e:	c7 44 24 08 f7 23 81 	movl   $0x8123f7,0x8(%esp)
  803655:	00 
  803656:	c7 44 24 04 3d 03 00 	movl   $0x33d,0x4(%esp)
  80365d:	00 
  80365e:	c7 04 24 e2 23 81 00 	movl   $0x8123e2,(%esp)
  803665:	e8 10 ba 00 00       	call   80f07a <_panic>
  dhcp = netif->dhcp;
  80366a:	8b 58 20             	mov    0x20(%eax),%ebx
  LWIP_ERROR("dhcp_bind: dhcp != NULL", (dhcp != NULL), return;);
  80366d:	85 db                	test   %ebx,%ebx
  80366f:	75 1c                	jne    80368d <dhcp_bind+0x4e>
  803671:	c7 44 24 08 10 24 81 	movl   $0x812410,0x8(%esp)
  803678:	00 
  803679:	c7 44 24 04 3f 03 00 	movl   $0x33f,0x4(%esp)
  803680:	00 
  803681:	c7 04 24 e2 23 81 00 	movl   $0x8123e2,(%esp)
  803688:	e8 ed b9 00 00       	call   80f07a <_panic>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_bind(netif=%p) %c%c%"U16_F"\n", (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));

  /* temporary DHCP lease? */
  if (dhcp->offered_t1_renew != 0xffffffffUL) {
  80368d:	8b 43 50             	mov    0x50(%ebx),%eax
  803690:	83 f8 ff             	cmp    $0xffffffff,%eax
  803693:	74 2a                	je     8036bf <dhcp_bind+0x80>
    /* set renewal period timer */
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_bind(): t1 renewal timer %"U32_F" secs\n", dhcp->offered_t1_renew));
    timeout = (dhcp->offered_t1_renew + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
  803695:	83 c0 1e             	add    $0x1e,%eax
  803698:	ba 89 88 88 88       	mov    $0x88888889,%edx
  80369d:	f7 e2                	mul    %edx
  80369f:	c1 ea 05             	shr    $0x5,%edx
  8036a2:	81 fa ff ff 00 00    	cmp    $0xffff,%edx
  8036a8:	b8 ff ff 00 00       	mov    $0xffff,%eax
  8036ad:	0f 46 c2             	cmovbe %edx,%eax
    if(timeout > 0xffff) {
      timeout = 0xffff;
    }
    dhcp->t1_timeout = (u16_t)timeout;
  8036b0:	66 85 c0             	test   %ax,%ax
  8036b3:	ba 01 00 00 00       	mov    $0x1,%edx
  8036b8:	0f 44 c2             	cmove  %edx,%eax
  8036bb:	66 89 43 28          	mov    %ax,0x28(%ebx)
      dhcp->t1_timeout = 1;
    }
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_bind(): set request timeout %"U32_F" msecs\n", dhcp->offered_t1_renew*1000));
  }
  /* set renewal period timer */
  if (dhcp->offered_t2_rebind != 0xffffffffUL) {
  8036bf:	8b 43 54             	mov    0x54(%ebx),%eax
  8036c2:	83 f8 ff             	cmp    $0xffffffff,%eax
  8036c5:	74 2a                	je     8036f1 <dhcp_bind+0xb2>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_bind(): t2 rebind timer %"U32_F" secs\n", dhcp->offered_t2_rebind));
    timeout = (dhcp->offered_t2_rebind + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
  8036c7:	83 c0 1e             	add    $0x1e,%eax
  8036ca:	ba 89 88 88 88       	mov    $0x88888889,%edx
  8036cf:	f7 e2                	mul    %edx
  8036d1:	c1 ea 05             	shr    $0x5,%edx
  8036d4:	81 fa ff ff 00 00    	cmp    $0xffff,%edx
  8036da:	b8 ff ff 00 00       	mov    $0xffff,%eax
  8036df:	0f 46 c2             	cmovbe %edx,%eax
    if(timeout > 0xffff) {
      timeout = 0xffff;
    }
    dhcp->t2_timeout = (u16_t)timeout;
  8036e2:	66 85 c0             	test   %ax,%ax
  8036e5:	ba 01 00 00 00       	mov    $0x1,%edx
  8036ea:	0f 44 c2             	cmove  %edx,%eax
  8036ed:	66 89 43 2a          	mov    %ax,0x2a(%ebx)
      dhcp->t2_timeout = 1;
    }
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_bind(): set request timeout %"U32_F" msecs\n", dhcp->offered_t2_rebind*1000));
  }
  /* copy offered network mask */
  ip_addr_set(&sn_mask, &dhcp->offered_sn_mask);
  8036f1:	83 fb cc             	cmp    $0xffffffcc,%ebx
  8036f4:	0f 84 be 00 00 00    	je     8037b8 <dhcp_bind+0x179>
  8036fa:	8b 43 34             	mov    0x34(%ebx),%eax
  8036fd:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  /* subnet mask not given? */
  /* TODO: this is not a valid check. what if the network mask is 0? */
  if (sn_mask.addr == 0) {
  803700:	85 c0                	test   %eax,%eax
  803702:	75 48                	jne    80374c <dhcp_bind+0x10d>
    /* choose a safe subnet mask given the network class */
    u8_t first_octet = ip4_addr1(&sn_mask);
  803704:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80370b:	e8 ba 48 00 00       	call   807fca <ntohl>
  803710:	c1 e8 18             	shr    $0x18,%eax
    if (first_octet <= 127) {
  803713:	84 c0                	test   %al,%al
  803715:	78 11                	js     803728 <dhcp_bind+0xe9>
      sn_mask.addr = htonl(0xff000000);
  803717:	c7 04 24 00 00 00 ff 	movl   $0xff000000,(%esp)
  80371e:	e8 6d 46 00 00       	call   807d90 <htonl>
  803723:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  803726:	eb 24                	jmp    80374c <dhcp_bind+0x10d>
    } else if (first_octet >= 192) {
  803728:	3c bf                	cmp    $0xbf,%al
  80372a:	76 11                	jbe    80373d <dhcp_bind+0xfe>
      sn_mask.addr = htonl(0xffffff00);
  80372c:	c7 04 24 00 ff ff ff 	movl   $0xffffff00,(%esp)
  803733:	e8 58 46 00 00       	call   807d90 <htonl>
  803738:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80373b:	eb 0f                	jmp    80374c <dhcp_bind+0x10d>
    } else {
      sn_mask.addr = htonl(0xffff0000);
  80373d:	c7 04 24 00 00 ff ff 	movl   $0xffff0000,(%esp)
  803744:	e8 47 46 00 00       	call   807d90 <htonl>
  803749:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    }
  }

  ip_addr_set(&gw_addr, &dhcp->offered_gw_addr);
  80374c:	83 fb c8             	cmp    $0xffffffc8,%ebx
  80374f:	74 0a                	je     80375b <dhcp_bind+0x11c>
  803751:	8b 43 38             	mov    0x38(%ebx),%eax
  803754:	89 45 e0             	mov    %eax,-0x20(%ebp)
  /* gateway address not given? */
  if (gw_addr.addr == 0) {
  803757:	85 c0                	test   %eax,%eax
  803759:	75 1a                	jne    803775 <dhcp_bind+0x136>
    /* copy network address */
    gw_addr.addr = (dhcp->offered_ip_addr.addr & sn_mask.addr);
  80375b:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  80375e:	23 7b 30             	and    0x30(%ebx),%edi
  803761:	89 7d e0             	mov    %edi,-0x20(%ebp)
    /* use first host address on network as gateway */
    gw_addr.addr |= htonl(0x00000001);
  803764:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  80376b:	e8 20 46 00 00       	call   807d90 <htonl>
  803770:	09 c7                	or     %eax,%edi
  803772:	89 7d e0             	mov    %edi,-0x20(%ebp)
  }

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_bind(): IP: 0x%08"X32_F"\n", dhcp->offered_ip_addr.addr));
  netif_set_ipaddr(netif, &dhcp->offered_ip_addr);
  803775:	8d 43 30             	lea    0x30(%ebx),%eax
  803778:	89 44 24 04          	mov    %eax,0x4(%esp)
  80377c:	89 34 24             	mov    %esi,(%esp)
  80377f:	e8 93 13 00 00       	call   804b17 <netif_set_ipaddr>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_bind(): SN: 0x%08"X32_F"\n", sn_mask.addr));
  netif_set_netmask(netif, &sn_mask);
  803784:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  803787:	89 44 24 04          	mov    %eax,0x4(%esp)
  80378b:	89 34 24             	mov    %esi,(%esp)
  80378e:	e8 f5 14 00 00       	call   804c88 <netif_set_netmask>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_bind(): GW: 0x%08"X32_F"\n", gw_addr.addr));
  netif_set_gw(netif, &gw_addr);
  803793:	8d 45 e0             	lea    -0x20(%ebp),%eax
  803796:	89 44 24 04          	mov    %eax,0x4(%esp)
  80379a:	89 34 24             	mov    %esi,(%esp)
  80379d:	e8 cb 14 00 00       	call   804c6d <netif_set_gw>
  /* bring the interface up */
  netif_set_up(netif);
  8037a2:	89 34 24             	mov    %esi,(%esp)
  8037a5:	e8 06 15 00 00       	call   804cb0 <netif_set_up>
  /* netif is now bound to DHCP leased address */
  dhcp_set_state(dhcp, DHCP_BOUND);
  8037aa:	ba 0a 00 00 00       	mov    $0xa,%edx
  8037af:	89 d8                	mov    %ebx,%eax
  8037b1:	e8 ea f3 ff ff       	call   802ba0 <dhcp_set_state>
  8037b6:	eb 0c                	jmp    8037c4 <dhcp_bind+0x185>
      dhcp->t2_timeout = 1;
    }
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_bind(): set request timeout %"U32_F" msecs\n", dhcp->offered_t2_rebind*1000));
  }
  /* copy offered network mask */
  ip_addr_set(&sn_mask, &dhcp->offered_sn_mask);
  8037b8:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  8037bf:	e9 40 ff ff ff       	jmp    803704 <dhcp_bind+0xc5>
  netif_set_gw(netif, &gw_addr);
  /* bring the interface up */
  netif_set_up(netif);
  /* netif is now bound to DHCP leased address */
  dhcp_set_state(dhcp, DHCP_BOUND);
}
  8037c4:	83 c4 2c             	add    $0x2c,%esp
  8037c7:	5b                   	pop    %ebx
  8037c8:	5e                   	pop    %esi
  8037c9:	5f                   	pop    %edi
  8037ca:	5d                   	pop    %ebp
  8037cb:	c3                   	ret    

008037cc <dhcp_free_reply>:
 * Free the incoming DHCP message including contiguous copy of
 * its DHCP options.
 *
 */
static void dhcp_free_reply(struct dhcp *dhcp)
{
  8037cc:	55                   	push   %ebp
  8037cd:	89 e5                	mov    %esp,%ebp
  8037cf:	53                   	push   %ebx
  8037d0:	83 ec 14             	sub    $0x14,%esp
  8037d3:	89 c3                	mov    %eax,%ebx
  if (dhcp->msg_in != NULL) {
  8037d5:	8b 40 10             	mov    0x10(%eax),%eax
  8037d8:	85 c0                	test   %eax,%eax
  8037da:	74 0f                	je     8037eb <dhcp_free_reply+0x1f>
    mem_free((void *)dhcp->msg_in);
  8037dc:	89 04 24             	mov    %eax,(%esp)
  8037df:	e8 01 0d 00 00       	call   8044e5 <mem_free>
    dhcp->msg_in = NULL;
  8037e4:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  }
  if (dhcp->options_in) {
  8037eb:	8b 43 14             	mov    0x14(%ebx),%eax
  8037ee:	85 c0                	test   %eax,%eax
  8037f0:	74 15                	je     803807 <dhcp_free_reply+0x3b>
    mem_free((void *)dhcp->options_in);
  8037f2:	89 04 24             	mov    %eax,(%esp)
  8037f5:	e8 eb 0c 00 00       	call   8044e5 <mem_free>
    dhcp->options_in = NULL;
  8037fa:	c7 43 14 00 00 00 00 	movl   $0x0,0x14(%ebx)
    dhcp->options_in_len = 0;
  803801:	66 c7 43 18 00 00    	movw   $0x0,0x18(%ebx)
  }
  LWIP_DEBUGF(DHCP_DEBUG, ("dhcp_free_reply(): free'd\n"));
}
  803807:	83 c4 14             	add    $0x14,%esp
  80380a:	5b                   	pop    %ebx
  80380b:	5d                   	pop    %ebp
  80380c:	c3                   	ret    

0080380d <dhcp_recv>:

/**
 * If an incoming DHCP message is in response to us, then trigger the state machine
 */
static void dhcp_recv(void *arg, struct udp_pcb *pcb, struct pbuf *p, struct ip_addr *addr, u16_t port)
{
  80380d:	55                   	push   %ebp
  80380e:	89 e5                	mov    %esp,%ebp
  803810:	57                   	push   %edi
  803811:	56                   	push   %esi
  803812:	53                   	push   %ebx
  803813:	83 ec 2c             	sub    $0x2c,%esp
  803816:	8b 5d 08             	mov    0x8(%ebp),%ebx
  803819:	8b 7d 10             	mov    0x10(%ebp),%edi
  struct netif *netif = (struct netif *)arg;
  struct dhcp *dhcp = netif->dhcp;
  80381c:	8b 73 20             	mov    0x20(%ebx),%esi
  struct dhcp_msg *reply_msg = (struct dhcp_msg *)p->payload;
  80381f:	8b 4f 04             	mov    0x4(%edi),%ecx
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("pbuf->tot_len = %"U16_F"\n", p->tot_len));
  /* prevent warnings about unused arguments */
  LWIP_UNUSED_ARG(pcb);
  LWIP_UNUSED_ARG(addr);
  LWIP_UNUSED_ARG(port);
  dhcp->p = p;
  803822:	89 7e 0c             	mov    %edi,0xc(%esi)
  /* TODO: check packet length before reading them */
  if (reply_msg->op != DHCP_BOOTREPLY) {
  803825:	80 39 02             	cmpb   $0x2,(%ecx)
  803828:	0f 85 0d 04 00 00    	jne    803c3b <dhcp_recv+0x42e>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("not a DHCP reply message, but type %"U16_F"\n", (u16_t)reply_msg->op));
    goto free_pbuf_and_return;
  }
  /* iterate through hardware address and match against DHCP message */
  for (i = 0; i < netif->hwaddr_len; i++) {
  80382e:	0f b6 43 24          	movzbl 0x24(%ebx),%eax
  803832:	ba 00 00 00 00       	mov    $0x0,%edx
  803837:	89 75 e4             	mov    %esi,-0x1c(%ebp)
  80383a:	89 ce                	mov    %ecx,%esi
  80383c:	89 c1                	mov    %eax,%ecx
  80383e:	eb 12                	jmp    803852 <dhcp_recv+0x45>
    if (netif->hwaddr[i] != reply_msg->chaddr[i]) {
  803840:	0f b6 44 13 25       	movzbl 0x25(%ebx,%edx,1),%eax
  803845:	83 c2 01             	add    $0x1,%edx
  803848:	3a 44 16 1b          	cmp    0x1b(%esi,%edx,1),%al
  80384c:	0f 85 e6 03 00 00    	jne    803c38 <dhcp_recv+0x42b>
  if (reply_msg->op != DHCP_BOOTREPLY) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("not a DHCP reply message, but type %"U16_F"\n", (u16_t)reply_msg->op));
    goto free_pbuf_and_return;
  }
  /* iterate through hardware address and match against DHCP message */
  for (i = 0; i < netif->hwaddr_len; i++) {
  803852:	38 d1                	cmp    %dl,%cl
  803854:	77 ea                	ja     803840 <dhcp_recv+0x33>
  803856:	89 f1                	mov    %esi,%ecx
  803858:	8b 75 e4             	mov    -0x1c(%ebp),%esi
        (u16_t)i, (u16_t)netif->hwaddr[i], (u16_t)i, (u16_t)reply_msg->chaddr[i]));
      goto free_pbuf_and_return;
    }
  }
  /* match transaction ID against what we expected */
  if (ntohl(reply_msg->xid) != dhcp->xid) {
  80385b:	8b 41 04             	mov    0x4(%ecx),%eax
  80385e:	89 04 24             	mov    %eax,(%esp)
  803861:	e8 64 47 00 00       	call   807fca <ntohl>
  803866:	3b 46 04             	cmp    0x4(%esi),%eax
  803869:	0f 85 cc 03 00 00    	jne    803c3b <dhcp_recv+0x42e>
 */
static err_t
dhcp_unfold_reply(struct dhcp *dhcp)
{
  u16_t ret;
  LWIP_ERROR("dhcp != NULL", (dhcp != NULL), return ERR_ARG;);
  80386f:	85 f6                	test   %esi,%esi
  803871:	75 1c                	jne    80388f <dhcp_recv+0x82>
  803873:	c7 44 24 08 1b 24 81 	movl   $0x81241b,0x8(%esp)
  80387a:	00 
  80387b:	c7 44 24 04 89 04 00 	movl   $0x489,0x4(%esp)
  803882:	00 
  803883:	c7 04 24 e2 23 81 00 	movl   $0x8123e2,(%esp)
  80388a:	e8 eb b7 00 00       	call   80f07a <_panic>
  LWIP_ERROR("dhcp->p != NULL", (dhcp->p != NULL), return ERR_VAL;);
  80388f:	83 7e 0c 00          	cmpl   $0x0,0xc(%esi)
  803893:	75 1c                	jne    8038b1 <dhcp_recv+0xa4>
  803895:	c7 44 24 08 28 24 81 	movl   $0x812428,0x8(%esp)
  80389c:	00 
  80389d:	c7 44 24 04 8a 04 00 	movl   $0x48a,0x4(%esp)
  8038a4:	00 
  8038a5:	c7 04 24 e2 23 81 00 	movl   $0x8123e2,(%esp)
  8038ac:	e8 c9 b7 00 00       	call   80f07a <_panic>
  /* free any left-overs from previous unfolds */
  dhcp_free_reply(dhcp);
  8038b1:	89 f0                	mov    %esi,%eax
  8038b3:	e8 14 ff ff ff       	call   8037cc <dhcp_free_reply>
  /* options present? */
  if (dhcp->p->tot_len > (sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN)) {
  8038b8:	8b 46 0c             	mov    0xc(%esi),%eax
  8038bb:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  8038bf:	66 3d f0 00          	cmp    $0xf0,%ax
  8038c3:	76 1e                	jbe    8038e3 <dhcp_recv+0xd6>
    dhcp->options_in_len = dhcp->p->tot_len - (sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  8038c5:	66 2d f0 00          	sub    $0xf0,%ax
  8038c9:	66 89 46 18          	mov    %ax,0x18(%esi)
    dhcp->options_in = mem_malloc(dhcp->options_in_len);
  8038cd:	0f b7 c0             	movzwl %ax,%eax
  8038d0:	89 04 24             	mov    %eax,(%esp)
  8038d3:	e8 e7 0e 00 00       	call   8047bf <mem_malloc>
  8038d8:	89 46 14             	mov    %eax,0x14(%esi)
    if (dhcp->options_in == NULL) {
  8038db:	85 c0                	test   %eax,%eax
  8038dd:	0f 84 58 03 00 00    	je     803c3b <dhcp_recv+0x42e>
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_unfold_reply(): could not allocate dhcp->options\n"));
      return ERR_MEM;
    }
  }
  dhcp->msg_in = mem_malloc(sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  8038e3:	c7 04 24 f0 00 00 00 	movl   $0xf0,(%esp)
  8038ea:	e8 d0 0e 00 00       	call   8047bf <mem_malloc>
  8038ef:	89 46 10             	mov    %eax,0x10(%esi)
  if (dhcp->msg_in == NULL) {
  8038f2:	85 c0                	test   %eax,%eax
  8038f4:	75 17                	jne    80390d <dhcp_recv+0x100>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_unfold_reply(): could not allocate dhcp->msg_in\n"));
    mem_free((void *)dhcp->options_in);
  8038f6:	8b 46 14             	mov    0x14(%esi),%eax
  8038f9:	89 04 24             	mov    %eax,(%esp)
  8038fc:	e8 e4 0b 00 00       	call   8044e5 <mem_free>
    dhcp->options_in = NULL;
  803901:	c7 46 14 00 00 00 00 	movl   $0x0,0x14(%esi)
  803908:	e9 2e 03 00 00       	jmp    803c3b <dhcp_recv+0x42e>
    return ERR_MEM;
  }

  /** copy the DHCP message without options */
  ret = pbuf_copy_partial(dhcp->p, dhcp->msg_in, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN, 0);
  80390d:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  803914:	00 
  803915:	c7 44 24 08 f0 00 00 	movl   $0xf0,0x8(%esp)
  80391c:	00 
  80391d:	89 44 24 04          	mov    %eax,0x4(%esp)
  803921:	8b 46 0c             	mov    0xc(%esi),%eax
  803924:	89 04 24             	mov    %eax,(%esp)
  803927:	e8 73 1c 00 00       	call   80559f <pbuf_copy_partial>
  LWIP_ASSERT("ret == sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN", ret == sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  80392c:	66 3d f0 00          	cmp    $0xf0,%ax
  803930:	74 1c                	je     80394e <dhcp_recv+0x141>
  803932:	c7 44 24 08 b0 23 81 	movl   $0x8123b0,0x8(%esp)
  803939:	00 
  80393a:	c7 44 24 04 a0 04 00 	movl   $0x4a0,0x4(%esp)
  803941:	00 
  803942:	c7 04 24 e2 23 81 00 	movl   $0x8123e2,(%esp)
  803949:	e8 2c b7 00 00       	call   80f07a <_panic>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_unfold_reply(): copied %"U16_F" bytes into dhcp->msg_in[]\n",
     sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN));

  if (dhcp->options_in != NULL) {
  80394e:	8b 46 14             	mov    0x14(%esi),%eax
  803951:	85 c0                	test   %eax,%eax
  803953:	0f 84 f3 02 00 00    	je     803c4c <dhcp_recv+0x43f>
    /** copy the DHCP options */
    ret = pbuf_copy_partial(dhcp->p, dhcp->options_in, dhcp->options_in_len, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  803959:	c7 44 24 0c f0 00 00 	movl   $0xf0,0xc(%esp)
  803960:	00 
  803961:	0f b7 56 18          	movzwl 0x18(%esi),%edx
  803965:	89 54 24 08          	mov    %edx,0x8(%esp)
  803969:	89 44 24 04          	mov    %eax,0x4(%esp)
  80396d:	8b 46 0c             	mov    0xc(%esi),%eax
  803970:	89 04 24             	mov    %eax,(%esp)
  803973:	e8 27 1c 00 00       	call   80559f <pbuf_copy_partial>
    LWIP_ASSERT("ret == dhcp->options_in_len", ret == dhcp->options_in_len);
  803978:	66 3b 46 18          	cmp    0x18(%esi),%ax
  80397c:	0f 84 ca 02 00 00    	je     803c4c <dhcp_recv+0x43f>
  803982:	c7 44 24 08 38 24 81 	movl   $0x812438,0x8(%esp)
  803989:	00 
  80398a:	c7 44 24 04 a7 04 00 	movl   $0x4a7,0x4(%esp)
  803991:	00 
  803992:	c7 04 24 e2 23 81 00 	movl   $0x8123e2,(%esp)
  803999:	e8 dc b6 00 00       	call   80f07a <_panic>
 */
static u8_t
dhcp_get_option_byte(u8_t *ptr)
{
  LWIP_DEBUGF(DHCP_DEBUG, ("option byte value=%"U16_F"\n", (u16_t)(*ptr)));
  return *ptr;
  80399e:	0f b6 40 02          	movzbl 0x2(%eax),%eax
  }

  /* read DHCP message type */
  msg_type = dhcp_get_option_byte(options_ptr + 2);
  /* message type is DHCP ACK? */
  if (msg_type == DHCP_ACK) {
  8039a2:	3c 05                	cmp    $0x5,%al
  8039a4:	0f 85 c3 01 00 00    	jne    803b6d <dhcp_recv+0x360>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_ACK received\n"));
    /* in requesting state? */
    if (dhcp->state == DHCP_REQUESTING) {
  8039aa:	0f b6 06             	movzbl (%esi),%eax
  8039ad:	3c 01                	cmp    $0x1,%al
  8039af:	0f 85 9b 01 00 00    	jne    803b50 <dhcp_recv+0x343>
 * @param netif the netif under DHCP control
 */
static void
dhcp_handle_ack(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  8039b5:	8b 43 20             	mov    0x20(%ebx),%eax
  8039b8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  u8_t *option_ptr;
  /* clear options we might not get from the ACK */
  dhcp->offered_sn_mask.addr = 0;
  8039bb:	c7 40 34 00 00 00 00 	movl   $0x0,0x34(%eax)
  dhcp->offered_gw_addr.addr = 0;
  8039c2:	c7 40 38 00 00 00 00 	movl   $0x0,0x38(%eax)
  dhcp->offered_bc_addr.addr = 0;
  8039c9:	c7 40 3c 00 00 00 00 	movl   $0x0,0x3c(%eax)

  /* lease time given? */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_LEASE_TIME);
  8039d0:	ba 33 00 00 00       	mov    $0x33,%edx
  8039d5:	e8 d5 f1 ff ff       	call   802baf <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  8039da:	85 c0                	test   %eax,%eax
  8039dc:	74 0e                	je     8039ec <dhcp_recv+0x1df>
    /* remember offered lease time */
    dhcp->offered_t0_lease = dhcp_get_option_long(option_ptr + 2);
  8039de:	83 c0 02             	add    $0x2,%eax
  8039e1:	e8 cb f2 ff ff       	call   802cb1 <dhcp_get_option_long>
  8039e6:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  8039e9:	89 41 4c             	mov    %eax,0x4c(%ecx)
  }
  /* renewal period given? */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_T1);
  8039ec:	ba 3a 00 00 00       	mov    $0x3a,%edx
  8039f1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8039f4:	e8 b6 f1 ff ff       	call   802baf <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  8039f9:	85 c0                	test   %eax,%eax
  8039fb:	74 10                	je     803a0d <dhcp_recv+0x200>
    /* remember given renewal period */
    dhcp->offered_t1_renew = dhcp_get_option_long(option_ptr + 2);
  8039fd:	83 c0 02             	add    $0x2,%eax
  803a00:	e8 ac f2 ff ff       	call   802cb1 <dhcp_get_option_long>
  803a05:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  803a08:	89 41 50             	mov    %eax,0x50(%ecx)
  803a0b:	eb 0e                	jmp    803a1b <dhcp_recv+0x20e>
  } else {
    /* calculate safe periods for renewal */
    dhcp->offered_t1_renew = dhcp->offered_t0_lease / 2;
  803a0d:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  803a10:	8b 41 4c             	mov    0x4c(%ecx),%eax
  803a13:	89 45 e0             	mov    %eax,-0x20(%ebp)
  803a16:	d1 e8                	shr    %eax
  803a18:	89 41 50             	mov    %eax,0x50(%ecx)
  }

  /* renewal period given? */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_T2);
  803a1b:	ba 3b 00 00 00       	mov    $0x3b,%edx
  803a20:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  803a23:	e8 87 f1 ff ff       	call   802baf <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  803a28:	85 c0                	test   %eax,%eax
  803a2a:	74 10                	je     803a3c <dhcp_recv+0x22f>
    /* remember given rebind period */
    dhcp->offered_t2_rebind = dhcp_get_option_long(option_ptr + 2);
  803a2c:	83 c0 02             	add    $0x2,%eax
  803a2f:	e8 7d f2 ff ff       	call   802cb1 <dhcp_get_option_long>
  803a34:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  803a37:	89 41 54             	mov    %eax,0x54(%ecx)
  803a3a:	eb 09                	jmp    803a45 <dhcp_recv+0x238>
  } else {
    /* calculate safe periods for rebinding */
    dhcp->offered_t2_rebind = dhcp->offered_t0_lease;
  803a3c:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  803a3f:	8b 41 4c             	mov    0x4c(%ecx),%eax
  803a42:	89 41 54             	mov    %eax,0x54(%ecx)
  }

  /* (y)our internet address */
  ip_addr_set(&dhcp->offered_ip_addr, &dhcp->msg_in->yiaddr);
  803a45:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  803a48:	8b 40 10             	mov    0x10(%eax),%eax
  803a4b:	83 f8 f0             	cmp    $0xfffffff0,%eax
  803a4e:	74 05                	je     803a55 <dhcp_recv+0x248>
  803a50:	8b 40 10             	mov    0x10(%eax),%eax
  803a53:	eb 05                	jmp    803a5a <dhcp_recv+0x24d>
  803a55:	b8 00 00 00 00       	mov    $0x0,%eax
  803a5a:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  803a5d:	89 41 30             	mov    %eax,0x30(%ecx)
    strcpy(dhcp->boot_file_name, dhcp->msg_in->file);
  }
#endif

  /* subnet mask */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_SUBNET_MASK);
  803a60:	ba 01 00 00 00       	mov    $0x1,%edx
  803a65:	89 c8                	mov    %ecx,%eax
  803a67:	e8 43 f1 ff ff       	call   802baf <dhcp_get_option_ptr>
  /* subnet mask given? */
  if (option_ptr != NULL) {
  803a6c:	85 c0                	test   %eax,%eax
  803a6e:	74 16                	je     803a86 <dhcp_recv+0x279>
    dhcp->offered_sn_mask.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  803a70:	83 c0 02             	add    $0x2,%eax
  803a73:	e8 39 f2 ff ff       	call   802cb1 <dhcp_get_option_long>
  803a78:	89 04 24             	mov    %eax,(%esp)
  803a7b:	e8 10 43 00 00       	call   807d90 <htonl>
  803a80:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  803a83:	89 41 34             	mov    %eax,0x34(%ecx)
  }

  /* gateway router */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_ROUTER);
  803a86:	ba 03 00 00 00       	mov    $0x3,%edx
  803a8b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  803a8e:	e8 1c f1 ff ff       	call   802baf <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  803a93:	85 c0                	test   %eax,%eax
  803a95:	74 16                	je     803aad <dhcp_recv+0x2a0>
    dhcp->offered_gw_addr.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  803a97:	83 c0 02             	add    $0x2,%eax
  803a9a:	e8 12 f2 ff ff       	call   802cb1 <dhcp_get_option_long>
  803a9f:	89 04 24             	mov    %eax,(%esp)
  803aa2:	e8 e9 42 00 00       	call   807d90 <htonl>
  803aa7:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  803aaa:	89 41 38             	mov    %eax,0x38(%ecx)
  }

  /* broadcast address */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_BROADCAST);
  803aad:	ba 1c 00 00 00       	mov    $0x1c,%edx
  803ab2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  803ab5:	e8 f5 f0 ff ff       	call   802baf <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  803aba:	85 c0                	test   %eax,%eax
  803abc:	74 16                	je     803ad4 <dhcp_recv+0x2c7>
    dhcp->offered_bc_addr.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  803abe:	83 c0 02             	add    $0x2,%eax
  803ac1:	e8 eb f1 ff ff       	call   802cb1 <dhcp_get_option_long>
  803ac6:	89 04 24             	mov    %eax,(%esp)
  803ac9:	e8 c2 42 00 00       	call   807d90 <htonl>
  803ace:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  803ad1:	89 41 3c             	mov    %eax,0x3c(%ecx)
  }
  
  /* DNS servers */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_DNS_SERVER);
  803ad4:	ba 06 00 00 00       	mov    $0x6,%edx
  803ad9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  803adc:	e8 ce f0 ff ff       	call   802baf <dhcp_get_option_ptr>
  803ae1:	89 45 dc             	mov    %eax,-0x24(%ebp)
  if (option_ptr != NULL) {
  803ae4:	85 c0                	test   %eax,%eax
  803ae6:	74 56                	je     803b3e <dhcp_recv+0x331>
    u8_t n;
    dhcp->dns_count = dhcp_get_option_byte(&option_ptr[1]) / (u32_t)sizeof(struct ip_addr);
  803ae8:	0f b6 40 01          	movzbl 0x1(%eax),%eax
  803aec:	c0 e8 02             	shr    $0x2,%al
  803aef:	0f b6 c0             	movzbl %al,%eax
    /* limit to at most DHCP_MAX_DNS DNS servers */
    if (dhcp->dns_count > DHCP_MAX_DNS)
      dhcp->dns_count = DHCP_MAX_DNS;
  803af2:	83 f8 03             	cmp    $0x3,%eax
  803af5:	ba 02 00 00 00       	mov    $0x2,%edx
  803afa:	0f 43 c2             	cmovae %edx,%eax
  803afd:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  803b00:	89 41 40             	mov    %eax,0x40(%ecx)
    /* calculate safe periods for rebinding */
    dhcp->offered_t2_rebind = dhcp->offered_t0_lease;
  }

  /* (y)our internet address */
  ip_addr_set(&dhcp->offered_ip_addr, &dhcp->msg_in->yiaddr);
  803b03:	c6 45 e0 00          	movb   $0x0,-0x20(%ebp)
  803b07:	89 5d 08             	mov    %ebx,0x8(%ebp)
  803b0a:	eb 23                	jmp    803b2f <dhcp_recv+0x322>
    dhcp->dns_count = dhcp_get_option_byte(&option_ptr[1]) / (u32_t)sizeof(struct ip_addr);
    /* limit to at most DHCP_MAX_DNS DNS servers */
    if (dhcp->dns_count > DHCP_MAX_DNS)
      dhcp->dns_count = DHCP_MAX_DNS;
    for (n = 0; n < dhcp->dns_count; n++) {
      dhcp->offered_dns_addr[n].addr = htonl(dhcp_get_option_long(&option_ptr[2 + n * 4]));
  803b0c:	0f b6 5d e0          	movzbl -0x20(%ebp),%ebx
  803b10:	8b 45 dc             	mov    -0x24(%ebp),%eax
  803b13:	8d 44 98 02          	lea    0x2(%eax,%ebx,4),%eax
  803b17:	e8 95 f1 ff ff       	call   802cb1 <dhcp_get_option_long>
  803b1c:	89 04 24             	mov    %eax,(%esp)
  803b1f:	e8 6c 42 00 00       	call   807d90 <htonl>
  803b24:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  803b27:	89 44 99 44          	mov    %eax,0x44(%ecx,%ebx,4)
    u8_t n;
    dhcp->dns_count = dhcp_get_option_byte(&option_ptr[1]) / (u32_t)sizeof(struct ip_addr);
    /* limit to at most DHCP_MAX_DNS DNS servers */
    if (dhcp->dns_count > DHCP_MAX_DNS)
      dhcp->dns_count = DHCP_MAX_DNS;
    for (n = 0; n < dhcp->dns_count; n++) {
  803b2b:	80 45 e0 01          	addb   $0x1,-0x20(%ebp)
  803b2f:	0f b6 45 e0          	movzbl -0x20(%ebp),%eax
  803b33:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  803b36:	3b 41 40             	cmp    0x40(%ecx),%eax
  803b39:	72 d1                	jb     803b0c <dhcp_recv+0x2ff>
  803b3b:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (msg_type == DHCP_ACK) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_ACK received\n"));
    /* in requesting state? */
    if (dhcp->state == DHCP_REQUESTING) {
      dhcp_handle_ack(netif);
      dhcp->request_timeout = 0;
  803b3e:	66 c7 46 26 00 00    	movw   $0x0,0x26(%esi)
#if DHCP_DOES_ARP_CHECK
      /* check if the acknowledged lease address is already in use */
      dhcp_check(netif);
  803b44:	89 d8                	mov    %ebx,%eax
  803b46:	e8 b7 fa ff ff       	call   803602 <dhcp_check>
  803b4b:	e9 eb 00 00 00       	jmp    803c3b <dhcp_recv+0x42e>
      /* bind interface to the acknowledged lease address */
      dhcp_bind(netif);
#endif
    }
    /* already bound to the given lease address? */
    else if ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REBINDING) || (dhcp->state == DHCP_RENEWING)) {
  803b50:	83 e8 03             	sub    $0x3,%eax
  803b53:	3c 02                	cmp    $0x2,%al
  803b55:	0f 87 e0 00 00 00    	ja     803c3b <dhcp_recv+0x42e>
      dhcp->request_timeout = 0;
  803b5b:	66 c7 46 26 00 00    	movw   $0x0,0x26(%esi)
      dhcp_bind(netif);
  803b61:	89 d8                	mov    %ebx,%eax
  803b63:	e8 d7 fa ff ff       	call   80363f <dhcp_bind>
  803b68:	e9 ce 00 00 00       	jmp    803c3b <dhcp_recv+0x42e>
    }
  }
  /* received a DHCP_NAK in appropriate state? */
  else if ((msg_type == DHCP_NAK) &&
  803b6d:	3c 06                	cmp    $0x6,%al
  803b6f:	75 6d                	jne    803bde <dhcp_recv+0x3d1>
    ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REQUESTING) ||
  803b71:	0f b6 06             	movzbl (%esi),%eax
  803b74:	8d 50 fd             	lea    -0x3(%eax),%edx
      dhcp->request_timeout = 0;
      dhcp_bind(netif);
    }
  }
  /* received a DHCP_NAK in appropriate state? */
  else if ((msg_type == DHCP_NAK) &&
  803b77:	80 fa 02             	cmp    $0x2,%dl
  803b7a:	76 08                	jbe    803b84 <dhcp_recv+0x377>
  803b7c:	3c 01                	cmp    $0x1,%al
  803b7e:	0f 85 b7 00 00 00    	jne    803c3b <dhcp_recv+0x42e>
    ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REQUESTING) ||
     (dhcp->state == DHCP_REBINDING) || (dhcp->state == DHCP_RENEWING  ))) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_NAK received\n"));
    dhcp->request_timeout = 0;
  803b84:	66 c7 46 26 00 00    	movw   $0x0,0x26(%esi)
 * @param netif the netif under DHCP control
 */
static void
dhcp_handle_nak(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  803b8a:	8b 43 20             	mov    0x20(%ebx),%eax
  803b8d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_handle_nak(netif=%p) %c%c%"U16_F"\n", 
    (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  /* Set the interface down since the address must no longer be used, as per RFC2131 */
  netif_set_down(netif);
  803b90:	89 1c 24             	mov    %ebx,(%esp)
  803b93:	e8 4e 11 00 00       	call   804ce6 <netif_set_down>
  /* remove IP address from interface */
  netif_set_ipaddr(netif, IP_ADDR_ANY);
  803b98:	c7 44 24 04 a0 2c 81 	movl   $0x812ca0,0x4(%esp)
  803b9f:	00 
  803ba0:	89 1c 24             	mov    %ebx,(%esp)
  803ba3:	e8 6f 0f 00 00       	call   804b17 <netif_set_ipaddr>
  netif_set_gw(netif, IP_ADDR_ANY);
  803ba8:	c7 44 24 04 a0 2c 81 	movl   $0x812ca0,0x4(%esp)
  803baf:	00 
  803bb0:	89 1c 24             	mov    %ebx,(%esp)
  803bb3:	e8 b5 10 00 00       	call   804c6d <netif_set_gw>
  netif_set_netmask(netif, IP_ADDR_ANY); 
  803bb8:	c7 44 24 04 a0 2c 81 	movl   $0x812ca0,0x4(%esp)
  803bbf:	00 
  803bc0:	89 1c 24             	mov    %ebx,(%esp)
  803bc3:	e8 c0 10 00 00       	call   804c88 <netif_set_netmask>
  /* Change to a defined state */
  dhcp_set_state(dhcp, DHCP_BACKING_OFF);
  803bc8:	ba 0c 00 00 00       	mov    $0xc,%edx
  803bcd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  803bd0:	e8 cb ef ff ff       	call   802ba0 <dhcp_set_state>
  /* We can immediately restart discovery */
  dhcp_discover(netif);
  803bd5:	89 d8                	mov    %ebx,%eax
  803bd7:	e8 37 f7 ff ff       	call   803313 <dhcp_discover>
  803bdc:	eb 5d                	jmp    803c3b <dhcp_recv+0x42e>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_NAK received\n"));
    dhcp->request_timeout = 0;
    dhcp_handle_nak(netif);
  }
  /* received a DHCP_OFFER in DHCP_SELECTING state? */
  else if ((msg_type == DHCP_OFFER) && (dhcp->state == DHCP_SELECTING)) {
  803bde:	3c 02                	cmp    $0x2,%al
  803be0:	75 59                	jne    803c3b <dhcp_recv+0x42e>
  803be2:	80 3e 06             	cmpb   $0x6,(%esi)
  803be5:	75 54                	jne    803c3b <dhcp_recv+0x42e>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_OFFER received in DHCP_SELECTING state\n"));
    dhcp->request_timeout = 0;
  803be7:	66 c7 46 26 00 00    	movw   $0x0,0x26(%esi)
 * @param netif the netif under DHCP control
 */
static void
dhcp_handle_offer(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  803bed:	8b 43 20             	mov    0x20(%ebx),%eax
  803bf0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  /* obtain the server address */
  u8_t *option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_SERVER_ID);
  803bf3:	ba 36 00 00 00       	mov    $0x36,%edx
  803bf8:	e8 b2 ef ff ff       	call   802baf <dhcp_get_option_ptr>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_handle_offer(netif=%p) %c%c%"U16_F"\n",
    (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  if (option_ptr != NULL) {
  803bfd:	85 c0                	test   %eax,%eax
  803bff:	74 3a                	je     803c3b <dhcp_recv+0x42e>
    dhcp->server_ip_addr.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  803c01:	83 c0 02             	add    $0x2,%eax
  803c04:	e8 a8 f0 ff ff       	call   802cb1 <dhcp_get_option_long>
  803c09:	89 04 24             	mov    %eax,(%esp)
  803c0c:	e8 7f 41 00 00       	call   807d90 <htonl>
  803c11:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  803c14:	89 41 2c             	mov    %eax,0x2c(%ecx)
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_handle_offer(): server 0x%08"X32_F"\n", dhcp->server_ip_addr.addr));
    /* remember offered address */
    ip_addr_set(&dhcp->offered_ip_addr, (struct ip_addr *)&dhcp->msg_in->yiaddr);
  803c17:	8b 41 10             	mov    0x10(%ecx),%eax
  803c1a:	83 f8 f0             	cmp    $0xfffffff0,%eax
  803c1d:	74 05                	je     803c24 <dhcp_recv+0x417>
  803c1f:	8b 40 10             	mov    0x10(%eax),%eax
  803c22:	eb 05                	jmp    803c29 <dhcp_recv+0x41c>
  803c24:	b8 00 00 00 00       	mov    $0x0,%eax
  803c29:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  803c2c:	89 41 30             	mov    %eax,0x30(%ecx)
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_handle_offer(): offer for 0x%08"X32_F"\n", dhcp->offered_ip_addr.addr));

    dhcp_select(netif);
  803c2f:	89 d8                	mov    %ebx,%eax
  803c31:	e8 36 f8 ff ff       	call   80346c <dhcp_select>
  803c36:	eb 03                	jmp    803c3b <dhcp_recv+0x42e>
  803c38:	8b 75 e4             	mov    -0x1c(%ebp),%esi
    dhcp->request_timeout = 0;
    /* remember offered lease */
    dhcp_handle_offer(netif);
  }
free_pbuf_and_return:
  pbuf_free(p);
  803c3b:	89 3c 24             	mov    %edi,(%esp)
  803c3e:	e8 b1 11 00 00       	call   804df4 <pbuf_free>
  dhcp->p = NULL;
  803c43:	c7 46 0c 00 00 00 00 	movl   $0x0,0xc(%esi)
  803c4a:	eb 16                	jmp    803c62 <dhcp_recv+0x455>
    goto free_pbuf_and_return;
  }

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("searching DHCP_OPTION_MESSAGE_TYPE\n"));
  /* obtain pointer to DHCP message type */
  options_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_MESSAGE_TYPE);
  803c4c:	ba 35 00 00 00       	mov    $0x35,%edx
  803c51:	89 f0                	mov    %esi,%eax
  803c53:	e8 57 ef ff ff       	call   802baf <dhcp_get_option_ptr>
  if (options_ptr == NULL) {
  803c58:	85 c0                	test   %eax,%eax
  803c5a:	0f 85 3e fd ff ff    	jne    80399e <dhcp_recv+0x191>
  803c60:	eb d9                	jmp    803c3b <dhcp_recv+0x42e>
    dhcp_handle_offer(netif);
  }
free_pbuf_and_return:
  pbuf_free(p);
  dhcp->p = NULL;
}
  803c62:	83 c4 2c             	add    $0x2c,%esp
  803c65:	5b                   	pop    %ebx
  803c66:	5e                   	pop    %esi
  803c67:	5f                   	pop    %edi
  803c68:	5d                   	pop    %ebp
  803c69:	c3                   	ret    

00803c6a <dhcp_inform>:
 *
 * @param netif The lwIP network interface
 */
void
dhcp_inform(struct netif *netif)
{
  803c6a:	55                   	push   %ebp
  803c6b:	89 e5                	mov    %esp,%ebp
  803c6d:	57                   	push   %edi
  803c6e:	56                   	push   %esi
  803c6f:	53                   	push   %ebx
  803c70:	83 ec 2c             	sub    $0x2c,%esp
  803c73:	8b 75 08             	mov    0x8(%ebp),%esi
  struct dhcp *dhcp, *old_dhcp = netif->dhcp;
  803c76:	8b 7e 20             	mov    0x20(%esi),%edi
  err_t result = ERR_OK;
  dhcp = mem_malloc(sizeof(struct dhcp));
  803c79:	c7 04 24 58 00 00 00 	movl   $0x58,(%esp)
  803c80:	e8 3a 0b 00 00       	call   8047bf <mem_malloc>
  803c85:	89 c3                	mov    %eax,%ebx
  if (dhcp == NULL) {
  803c87:	85 c0                	test   %eax,%eax
  803c89:	0f 84 47 01 00 00    	je     803dd6 <dhcp_inform+0x16c>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_inform(): could not allocate dhcp\n"));
    return;
  }
  netif->dhcp = dhcp;
  803c8f:	89 46 20             	mov    %eax,0x20(%esi)
  memset(dhcp, 0, sizeof(struct dhcp));
  803c92:	c7 44 24 08 58 00 00 	movl   $0x58,0x8(%esp)
  803c99:	00 
  803c9a:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  803ca1:	00 
  803ca2:	89 04 24             	mov    %eax,(%esp)
  803ca5:	e8 3d bc 00 00       	call   80f8e7 <memset>

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_inform(): allocated dhcp\n"));
  dhcp->pcb = udp_new();
  803caa:	e8 75 5b 00 00       	call   809824 <udp_new>
  803caf:	89 43 08             	mov    %eax,0x8(%ebx)
  if (dhcp->pcb == NULL) {
  803cb2:	85 c0                	test   %eax,%eax
  803cb4:	75 0d                	jne    803cc3 <dhcp_inform+0x59>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_inform(): could not obtain pcb"));
    mem_free((void *)dhcp);
  803cb6:	89 1c 24             	mov    %ebx,(%esp)
  803cb9:	e8 27 08 00 00       	call   8044e5 <mem_free>
    return;
  803cbe:	e9 13 01 00 00       	jmp    803dd6 <dhcp_inform+0x16c>
  }
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_inform(): created new udp pcb\n"));
  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  803cc3:	89 f0                	mov    %esi,%eax
  803cc5:	e8 9a f2 ff ff       	call   802f64 <dhcp_create_request>
  if (result == ERR_OK) {
  803cca:	84 c0                	test   %al,%al
  803ccc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  803cd0:	0f 85 f7 00 00 00    	jne    803dcd <dhcp_inform+0x163>

    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  803cd6:	b9 01 00 00 00       	mov    $0x1,%ecx
  803cdb:	ba 35 00 00 00       	mov    $0x35,%edx
  803ce0:	89 d8                	mov    %ebx,%eax
  803ce2:	e8 38 f0 ff ff       	call   802d1f <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_INFORM);
  803ce7:	ba 08 00 00 00       	mov    $0x8,%edx
  803cec:	89 d8                	mov    %ebx,%eax
  803cee:	e8 e3 ef ff ff       	call   802cd6 <dhcp_option_byte>

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  803cf3:	b9 02 00 00 00       	mov    $0x2,%ecx
  803cf8:	ba 39 00 00 00       	mov    $0x39,%edx
  803cfd:	89 d8                	mov    %ebx,%eax
  803cff:	e8 1b f0 ff ff       	call   802d1f <dhcp_option>
    /* TODO: use netif->mtu ?! */
    dhcp_option_short(dhcp, 576);
  803d04:	ba 40 02 00 00       	mov    $0x240,%edx
  803d09:	89 d8                	mov    %ebx,%eax
  803d0b:	e8 7b f0 ff ff       	call   802d8b <dhcp_option_short>

    dhcp_option_trailer(dhcp);
  803d10:	89 d8                	mov    %ebx,%eax
  803d12:	e8 e0 f0 ff ff       	call   802df7 <dhcp_option_trailer>

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  803d17:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  803d1b:	66 05 f0 00          	add    $0xf0,%ax
  803d1f:	0f b7 c0             	movzwl %ax,%eax
  803d22:	89 44 24 04          	mov    %eax,0x4(%esp)
  803d26:	8b 43 1c             	mov    0x1c(%ebx),%eax
  803d29:	89 04 24             	mov    %eax,(%esp)
  803d2c:	e8 35 14 00 00       	call   805166 <pbuf_realloc>

    udp_bind(dhcp->pcb, IP_ADDR_ANY, DHCP_CLIENT_PORT);
  803d31:	c7 44 24 08 44 00 00 	movl   $0x44,0x8(%esp)
  803d38:	00 
  803d39:	c7 44 24 04 a0 2c 81 	movl   $0x812ca0,0x4(%esp)
  803d40:	00 
  803d41:	8b 43 08             	mov    0x8(%ebx),%eax
  803d44:	89 04 24             	mov    %eax,(%esp)
  803d47:	e8 f5 56 00 00       	call   809441 <udp_bind>
    udp_connect(dhcp->pcb, IP_ADDR_BROADCAST, DHCP_SERVER_PORT);
  803d4c:	c7 44 24 08 43 00 00 	movl   $0x43,0x8(%esp)
  803d53:	00 
  803d54:	c7 44 24 04 9c 2c 81 	movl   $0x812c9c,0x4(%esp)
  803d5b:	00 
  803d5c:	8b 43 08             	mov    0x8(%ebx),%eax
  803d5f:	89 04 24             	mov    %eax,(%esp)
  803d62:	e8 ce 59 00 00       	call   809735 <udp_connect>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_inform: INFORMING\n"));
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  803d67:	89 74 24 10          	mov    %esi,0x10(%esp)
  803d6b:	c7 44 24 0c 43 00 00 	movl   $0x43,0xc(%esp)
  803d72:	00 
  803d73:	c7 44 24 08 9c 2c 81 	movl   $0x812c9c,0x8(%esp)
  803d7a:	00 
  803d7b:	8b 43 1c             	mov    0x1c(%ebx),%eax
  803d7e:	89 44 24 04          	mov    %eax,0x4(%esp)
  803d82:	8b 43 08             	mov    0x8(%ebx),%eax
  803d85:	89 04 24             	mov    %eax,(%esp)
  803d88:	e8 86 57 00 00       	call   809513 <udp_sendto_if>
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  803d8d:	c7 44 24 08 43 00 00 	movl   $0x43,0x8(%esp)
  803d94:	00 
  803d95:	c7 44 24 04 a0 2c 81 	movl   $0x812ca0,0x4(%esp)
  803d9c:	00 
  803d9d:	8b 43 08             	mov    0x8(%ebx),%eax
  803da0:	89 04 24             	mov    %eax,(%esp)
  803da3:	e8 8d 59 00 00       	call   809735 <udp_connect>
    dhcp_delete_request(netif);
  803da8:	89 f0                	mov    %esi,%eax
  803daa:	e8 ac f3 ff ff       	call   80315b <dhcp_delete_request>
  803daf:	eb 1c                	jmp    803dcd <dhcp_inform+0x163>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_inform: could not allocate DHCP request\n"));
  }

  if (dhcp != NULL) {
    if (dhcp->pcb != NULL) {
      udp_remove(dhcp->pcb);
  803db1:	89 04 24             	mov    %eax,(%esp)
  803db4:	e8 25 5a 00 00       	call   8097de <udp_remove>
    }
    dhcp->pcb = NULL;
  803db9:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    mem_free((void *)dhcp);
  803dc0:	89 1c 24             	mov    %ebx,(%esp)
  803dc3:	e8 1d 07 00 00       	call   8044e5 <mem_free>
    netif->dhcp = old_dhcp;
  803dc8:	89 7e 20             	mov    %edi,0x20(%esi)
  803dcb:	eb 09                	jmp    803dd6 <dhcp_inform+0x16c>
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_inform: could not allocate DHCP request\n"));
  }

  if (dhcp != NULL) {
    if (dhcp->pcb != NULL) {
  803dcd:	8b 43 08             	mov    0x8(%ebx),%eax
  803dd0:	85 c0                	test   %eax,%eax
  803dd2:	75 dd                	jne    803db1 <dhcp_inform+0x147>
  803dd4:	eb e3                	jmp    803db9 <dhcp_inform+0x14f>
    }
    dhcp->pcb = NULL;
    mem_free((void *)dhcp);
    netif->dhcp = old_dhcp;
  }
}
  803dd6:	83 c4 2c             	add    $0x2c,%esp
  803dd9:	5b                   	pop    %ebx
  803dda:	5e                   	pop    %esi
  803ddb:	5f                   	pop    %edi
  803ddc:	5d                   	pop    %ebp
  803ddd:	c3                   	ret    

00803dde <dhcp_arp_reply>:
 *
 * @param netif the network interface on which the reply was received
 * @param addr The IP address we received a reply from
 */
void dhcp_arp_reply(struct netif *netif, struct ip_addr *addr)
{
  803dde:	55                   	push   %ebp
  803ddf:	89 e5                	mov    %esp,%ebp
  803de1:	56                   	push   %esi
  803de2:	53                   	push   %ebx
  803de3:	83 ec 20             	sub    $0x20,%esp
  803de6:	8b 75 08             	mov    0x8(%ebp),%esi
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  803de9:	85 f6                	test   %esi,%esi
  803deb:	75 1c                	jne    803e09 <dhcp_arp_reply+0x2b>
  803ded:	c7 44 24 08 02 24 81 	movl   $0x812402,0x8(%esp)
  803df4:	00 
  803df5:	c7 44 24 04 b5 02 00 	movl   $0x2b5,0x4(%esp)
  803dfc:	00 
  803dfd:	c7 04 24 e2 23 81 00 	movl   $0x8123e2,(%esp)
  803e04:	e8 71 b2 00 00       	call   80f07a <_panic>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_arp_reply()\n"));
  /* is a DHCP client doing an ARP check? */
  if ((netif->dhcp != NULL) && (netif->dhcp->state == DHCP_CHECKING)) {
  803e09:	8b 5e 20             	mov    0x20(%esi),%ebx
  803e0c:	85 db                	test   %ebx,%ebx
  803e0e:	0f 84 04 01 00 00    	je     803f18 <dhcp_arp_reply+0x13a>
  803e14:	80 3b 08             	cmpb   $0x8,(%ebx)
  803e17:	0f 85 fb 00 00 00    	jne    803f18 <dhcp_arp_reply+0x13a>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_arp_reply(): CHECKING, arp reply for 0x%08"X32_F"\n", addr->addr));
    /* did a host respond with the address we
       were offered by the DHCP server? */
    if (ip_addr_cmp(addr, &netif->dhcp->offered_ip_addr)) {
  803e1d:	8b 45 0c             	mov    0xc(%ebp),%eax
  803e20:	8b 4b 30             	mov    0x30(%ebx),%ecx
  803e23:	39 08                	cmp    %ecx,(%eax)
  803e25:	0f 85 ed 00 00 00    	jne    803f18 <dhcp_arp_reply+0x13a>
{
  struct dhcp *dhcp = netif->dhcp;
  err_t result = ERR_OK;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_decline()\n"));
  dhcp_set_state(dhcp, DHCP_BACKING_OFF);
  803e2b:	ba 0c 00 00 00       	mov    $0xc,%edx
  803e30:	89 d8                	mov    %ebx,%eax
  803e32:	e8 69 ed ff ff       	call   802ba0 <dhcp_set_state>
  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  803e37:	89 f0                	mov    %esi,%eax
  803e39:	e8 26 f1 ff ff       	call   802f64 <dhcp_create_request>
  if (result == ERR_OK) {
  803e3e:	84 c0                	test   %al,%al
  803e40:	0f 85 c8 00 00 00    	jne    803f0e <dhcp_arp_reply+0x130>
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  803e46:	b9 01 00 00 00       	mov    $0x1,%ecx
  803e4b:	ba 35 00 00 00       	mov    $0x35,%edx
  803e50:	89 d8                	mov    %ebx,%eax
  803e52:	e8 c8 ee ff ff       	call   802d1f <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_DECLINE);
  803e57:	ba 04 00 00 00       	mov    $0x4,%edx
  803e5c:	89 d8                	mov    %ebx,%eax
  803e5e:	e8 73 ee ff ff       	call   802cd6 <dhcp_option_byte>

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  803e63:	b9 02 00 00 00       	mov    $0x2,%ecx
  803e68:	ba 39 00 00 00       	mov    $0x39,%edx
  803e6d:	89 d8                	mov    %ebx,%eax
  803e6f:	e8 ab ee ff ff       	call   802d1f <dhcp_option>
    dhcp_option_short(dhcp, 576);
  803e74:	ba 40 02 00 00       	mov    $0x240,%edx
  803e79:	89 d8                	mov    %ebx,%eax
  803e7b:	e8 0b ef ff ff       	call   802d8b <dhcp_option_short>

    dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
  803e80:	b9 04 00 00 00       	mov    $0x4,%ecx
  803e85:	ba 32 00 00 00       	mov    $0x32,%edx
  803e8a:	89 d8                	mov    %ebx,%eax
  803e8c:	e8 8e ee ff ff       	call   802d1f <dhcp_option>
    dhcp_option_long(dhcp, ntohl(dhcp->offered_ip_addr.addr));
  803e91:	8b 43 30             	mov    0x30(%ebx),%eax
  803e94:	89 04 24             	mov    %eax,(%esp)
  803e97:	e8 2e 41 00 00       	call   807fca <ntohl>
  803e9c:	89 c2                	mov    %eax,%edx
  803e9e:	89 d8                	mov    %ebx,%eax
  803ea0:	e8 1c f0 ff ff       	call   802ec1 <dhcp_option_long>

    dhcp_option_trailer(dhcp);
  803ea5:	89 d8                	mov    %ebx,%eax
  803ea7:	e8 4b ef ff ff       	call   802df7 <dhcp_option_trailer>
    /* resize pbuf to reflect true size of options */
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  803eac:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  803eb0:	66 05 f0 00          	add    $0xf0,%ax
  803eb4:	0f b7 c0             	movzwl %ax,%eax
  803eb7:	89 44 24 04          	mov    %eax,0x4(%esp)
  803ebb:	8b 43 1c             	mov    0x1c(%ebx),%eax
  803ebe:	89 04 24             	mov    %eax,(%esp)
  803ec1:	e8 a0 12 00 00       	call   805166 <pbuf_realloc>

    /* @todo: should we really connect here? we are performing sendto() */
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  803ec6:	c7 44 24 08 43 00 00 	movl   $0x43,0x8(%esp)
  803ecd:	00 
  803ece:	c7 44 24 04 a0 2c 81 	movl   $0x812ca0,0x4(%esp)
  803ed5:	00 
  803ed6:	8b 43 08             	mov    0x8(%ebx),%eax
  803ed9:	89 04 24             	mov    %eax,(%esp)
  803edc:	e8 54 58 00 00       	call   809735 <udp_connect>
    /* per section 4.4.4, broadcast DECLINE messages */
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  803ee1:	89 74 24 10          	mov    %esi,0x10(%esp)
  803ee5:	c7 44 24 0c 43 00 00 	movl   $0x43,0xc(%esp)
  803eec:	00 
  803eed:	c7 44 24 08 9c 2c 81 	movl   $0x812c9c,0x8(%esp)
  803ef4:	00 
  803ef5:	8b 43 1c             	mov    0x1c(%ebx),%eax
  803ef8:	89 44 24 04          	mov    %eax,0x4(%esp)
  803efc:	8b 43 08             	mov    0x8(%ebx),%eax
  803eff:	89 04 24             	mov    %eax,(%esp)
  803f02:	e8 0c 56 00 00       	call   809513 <udp_sendto_if>
    dhcp_delete_request(netif);
  803f07:	89 f0                	mov    %esi,%eax
  803f09:	e8 4d f2 ff ff       	call   80315b <dhcp_delete_request>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_decline: BACKING OFF\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_decline: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  803f0e:	80 43 01 01          	addb   $0x1,0x1(%ebx)
  msecs = 10*1000;
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  803f12:	66 c7 43 26 14 00    	movw   $0x14,0x26(%ebx)
      /* we will not accept the offered address */
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE | 1, ("dhcp_arp_reply(): arp reply matched with offered address, declining\n"));
      dhcp_decline(netif);
    }
  }
}
  803f18:	83 c4 20             	add    $0x20,%esp
  803f1b:	5b                   	pop    %ebx
  803f1c:	5e                   	pop    %esi
  803f1d:	5d                   	pop    %ebp
  803f1e:	c3                   	ret    

00803f1f <dhcp_renew>:
 *
 * @param netif network interface which must renew its lease
 */
err_t
dhcp_renew(struct netif *netif)
{
  803f1f:	55                   	push   %ebp
  803f20:	89 e5                	mov    %esp,%ebp
  803f22:	57                   	push   %edi
  803f23:	56                   	push   %esi
  803f24:	53                   	push   %ebx
  803f25:	83 ec 2c             	sub    $0x2c,%esp
  803f28:	8b 75 08             	mov    0x8(%ebp),%esi
  struct dhcp *dhcp = netif->dhcp;
  803f2b:	8b 5e 20             	mov    0x20(%esi),%ebx
  err_t result;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_renew()\n"));
  dhcp_set_state(dhcp, DHCP_RENEWING);
  803f2e:	ba 05 00 00 00       	mov    $0x5,%edx
  803f33:	89 d8                	mov    %ebx,%eax
  803f35:	e8 66 ec ff ff       	call   802ba0 <dhcp_set_state>

  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  803f3a:	89 f0                	mov    %esi,%eax
  803f3c:	e8 23 f0 ff ff       	call   802f64 <dhcp_create_request>
  803f41:	89 c7                	mov    %eax,%edi
  if (result == ERR_OK) {
  803f43:	84 c0                	test   %al,%al
  803f45:	0f 85 a4 00 00 00    	jne    803fef <dhcp_renew+0xd0>

    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  803f4b:	b9 01 00 00 00       	mov    $0x1,%ecx
  803f50:	ba 35 00 00 00       	mov    $0x35,%edx
  803f55:	89 d8                	mov    %ebx,%eax
  803f57:	e8 c3 ed ff ff       	call   802d1f <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_REQUEST);
  803f5c:	ba 03 00 00 00       	mov    $0x3,%edx
  803f61:	89 d8                	mov    %ebx,%eax
  803f63:	e8 6e ed ff ff       	call   802cd6 <dhcp_option_byte>

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  803f68:	b9 02 00 00 00       	mov    $0x2,%ecx
  803f6d:	ba 39 00 00 00       	mov    $0x39,%edx
  803f72:	89 d8                	mov    %ebx,%eax
  803f74:	e8 a6 ed ff ff       	call   802d1f <dhcp_option>
    /* TODO: use netif->mtu in some way */
    dhcp_option_short(dhcp, 576);
  803f79:	ba 40 02 00 00       	mov    $0x240,%edx
  803f7e:	89 d8                	mov    %ebx,%eax
  803f80:	e8 06 ee ff ff       	call   802d8b <dhcp_option_short>
#if 0
    dhcp_option(dhcp, DHCP_OPTION_SERVER_ID, 4);
    dhcp_option_long(dhcp, ntohl(dhcp->server_ip_addr.addr));
#endif
    /* append DHCP message trailer */
    dhcp_option_trailer(dhcp);
  803f85:	89 d8                	mov    %ebx,%eax
  803f87:	e8 6b ee ff ff       	call   802df7 <dhcp_option_trailer>

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  803f8c:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  803f90:	66 05 f0 00          	add    $0xf0,%ax
  803f94:	0f b7 c0             	movzwl %ax,%eax
  803f97:	89 44 24 04          	mov    %eax,0x4(%esp)
  803f9b:	8b 43 1c             	mov    0x1c(%ebx),%eax
  803f9e:	89 04 24             	mov    %eax,(%esp)
  803fa1:	e8 c0 11 00 00       	call   805166 <pbuf_realloc>

    udp_connect(dhcp->pcb, &dhcp->server_ip_addr, DHCP_SERVER_PORT);
  803fa6:	8d 43 2c             	lea    0x2c(%ebx),%eax
  803fa9:	c7 44 24 08 43 00 00 	movl   $0x43,0x8(%esp)
  803fb0:	00 
  803fb1:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  803fb4:	89 44 24 04          	mov    %eax,0x4(%esp)
  803fb8:	8b 43 08             	mov    0x8(%ebx),%eax
  803fbb:	89 04 24             	mov    %eax,(%esp)
  803fbe:	e8 72 57 00 00       	call   809735 <udp_connect>
    udp_sendto_if(dhcp->pcb, dhcp->p_out, &dhcp->server_ip_addr, DHCP_SERVER_PORT, netif);
  803fc3:	89 74 24 10          	mov    %esi,0x10(%esp)
  803fc7:	c7 44 24 0c 43 00 00 	movl   $0x43,0xc(%esp)
  803fce:	00 
  803fcf:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  803fd2:	89 44 24 08          	mov    %eax,0x8(%esp)
  803fd6:	8b 43 1c             	mov    0x1c(%ebx),%eax
  803fd9:	89 44 24 04          	mov    %eax,0x4(%esp)
  803fdd:	8b 43 08             	mov    0x8(%ebx),%eax
  803fe0:	89 04 24             	mov    %eax,(%esp)
  803fe3:	e8 2b 55 00 00       	call   809513 <udp_sendto_if>
    dhcp_delete_request(netif);
  803fe8:	89 f0                	mov    %esi,%eax
  803fea:	e8 6c f1 ff ff       	call   80315b <dhcp_delete_request>

    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_renew: RENEWING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_renew: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  803fef:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
  803ff3:	8d 48 01             	lea    0x1(%eax),%ecx
  803ff6:	88 4b 01             	mov    %cl,0x1(%ebx)
  /* back-off on retries, but to a maximum of 20 seconds */
  msecs = dhcp->tries < 10 ? dhcp->tries * 2000 : 20 * 1000;
  803ff9:	b8 20 4e 00 00       	mov    $0x4e20,%eax
  803ffe:	80 f9 09             	cmp    $0x9,%cl
  804001:	77 08                	ja     80400b <dhcp_renew+0xec>
  804003:	0f b6 c9             	movzbl %cl,%ecx
  804006:	66 69 c1 d0 07       	imul   $0x7d0,%cx,%ax
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  80400b:	0f b7 d0             	movzwl %ax,%edx
  80400e:	81 c2 f3 01 00 00    	add    $0x1f3,%edx
  804014:	be d3 4d 62 10       	mov    $0x10624dd3,%esi
  804019:	89 d0                	mov    %edx,%eax
  80401b:	f7 ee                	imul   %esi
  80401d:	c1 fa 05             	sar    $0x5,%edx
  804020:	66 89 53 26          	mov    %dx,0x26(%ebx)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_renew(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
}
  804024:	89 f8                	mov    %edi,%eax
  804026:	83 c4 2c             	add    $0x2c,%esp
  804029:	5b                   	pop    %ebx
  80402a:	5e                   	pop    %esi
  80402b:	5f                   	pop    %edi
  80402c:	5d                   	pop    %ebp
  80402d:	c3                   	ret    

0080402e <dhcp_coarse_tmr>:
 * The DHCP timer that checks for lease renewal/rebind timeouts.
 *
 */
void
dhcp_coarse_tmr()
{
  80402e:	55                   	push   %ebp
  80402f:	89 e5                	mov    %esp,%ebp
  804031:	53                   	push   %ebx
  804032:	83 ec 14             	sub    $0x14,%esp
  struct netif *netif = netif_list;
  804035:	8b 1d 54 c2 b3 00    	mov    0xb3c254,%ebx
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_coarse_tmr()\n"));
  /* iterate through all network interfaces */
  while (netif != NULL) {
  80403b:	eb 67                	jmp    8040a4 <dhcp_coarse_tmr+0x76>
    /* only act on DHCP configured interfaces */
    if (netif->dhcp != NULL) {
  80403d:	8b 43 20             	mov    0x20(%ebx),%eax
  804040:	85 c0                	test   %eax,%eax
  804042:	74 5e                	je     8040a2 <dhcp_coarse_tmr+0x74>
      /* timer is active (non zero), and triggers (zeroes) now? */
      if (netif->dhcp->t2_timeout-- == 1) {
  804044:	0f b7 50 2a          	movzwl 0x2a(%eax),%edx
  804048:	8d 4a ff             	lea    -0x1(%edx),%ecx
  80404b:	66 89 48 2a          	mov    %cx,0x2a(%eax)
  80404f:	66 83 fa 01          	cmp    $0x1,%dx
  804053:	75 1d                	jne    804072 <dhcp_coarse_tmr+0x44>
static void
dhcp_t2_timeout(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_t2_timeout()\n"));
  if ((dhcp->state == DHCP_REQUESTING) || (dhcp->state == DHCP_BOUND) || (dhcp->state == DHCP_RENEWING)) {
  804055:	8b 43 20             	mov    0x20(%ebx),%eax
  804058:	0f b6 00             	movzbl (%eax),%eax
  80405b:	89 c2                	mov    %eax,%edx
  80405d:	83 e2 fb             	and    $0xfffffffb,%edx
  804060:	80 fa 01             	cmp    $0x1,%dl
  804063:	74 04                	je     804069 <dhcp_coarse_tmr+0x3b>
  804065:	3c 0a                	cmp    $0xa,%al
  804067:	75 39                	jne    8040a2 <dhcp_coarse_tmr+0x74>
    /* just retry to rebind */
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_t2_timeout(): must rebind\n"));
    dhcp_rebind(netif);
  804069:	89 d8                	mov    %ebx,%eax
  80406b:	e8 96 f1 ff ff       	call   803206 <dhcp_rebind>
  804070:	eb 30                	jmp    8040a2 <dhcp_coarse_tmr+0x74>
      if (netif->dhcp->t2_timeout-- == 1) {
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_coarse_tmr(): t2 timeout\n"));
        /* this clients' rebind timeout triggered */
        dhcp_t2_timeout(netif);
      /* timer is active (non zero), and triggers (zeroes) now */
      } else if (netif->dhcp->t1_timeout-- == 1) {
  804072:	8b 53 20             	mov    0x20(%ebx),%edx
  804075:	0f b7 42 28          	movzwl 0x28(%edx),%eax
  804079:	8d 48 ff             	lea    -0x1(%eax),%ecx
  80407c:	66 89 4a 28          	mov    %cx,0x28(%edx)
  804080:	66 83 f8 01          	cmp    $0x1,%ax
  804084:	75 1c                	jne    8040a2 <dhcp_coarse_tmr+0x74>
static void
dhcp_t1_timeout(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_t1_timeout()\n"));
  if ((dhcp->state == DHCP_REQUESTING) || (dhcp->state == DHCP_BOUND) || (dhcp->state == DHCP_RENEWING)) {
  804086:	8b 43 20             	mov    0x20(%ebx),%eax
  804089:	0f b6 00             	movzbl (%eax),%eax
  80408c:	89 c2                	mov    %eax,%edx
  80408e:	83 e2 fb             	and    $0xfffffffb,%edx
  804091:	80 fa 01             	cmp    $0x1,%dl
  804094:	74 04                	je     80409a <dhcp_coarse_tmr+0x6c>
  804096:	3c 0a                	cmp    $0xa,%al
  804098:	75 08                	jne    8040a2 <dhcp_coarse_tmr+0x74>
    /* just retry to renew - note that the rebind timer (t2) will
     * eventually time-out if renew tries fail. */
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_t1_timeout(): must renew\n"));
    dhcp_renew(netif);
  80409a:	89 1c 24             	mov    %ebx,(%esp)
  80409d:	e8 7d fe ff ff       	call   803f1f <dhcp_renew>
        /* this clients' renewal timeout triggered */
        dhcp_t1_timeout(netif);
      }
    }
    /* proceed to next netif */
    netif = netif->next;
  8040a2:	8b 1b                	mov    (%ebx),%ebx
dhcp_coarse_tmr()
{
  struct netif *netif = netif_list;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_coarse_tmr()\n"));
  /* iterate through all network interfaces */
  while (netif != NULL) {
  8040a4:	85 db                	test   %ebx,%ebx
  8040a6:	75 95                	jne    80403d <dhcp_coarse_tmr+0xf>
      }
    }
    /* proceed to next netif */
    netif = netif->next;
  }
}
  8040a8:	83 c4 14             	add    $0x14,%esp
  8040ab:	5b                   	pop    %ebx
  8040ac:	5d                   	pop    %ebp
  8040ad:	c3                   	ret    

008040ae <dhcp_release>:
 *
 * @param netif network interface which must release its lease
 */
err_t
dhcp_release(struct netif *netif)
{
  8040ae:	55                   	push   %ebp
  8040af:	89 e5                	mov    %esp,%ebp
  8040b1:	57                   	push   %edi
  8040b2:	56                   	push   %esi
  8040b3:	53                   	push   %ebx
  8040b4:	83 ec 2c             	sub    $0x2c,%esp
  8040b7:	8b 75 08             	mov    0x8(%ebp),%esi
  struct dhcp *dhcp = netif->dhcp;
  8040ba:	8b 5e 20             	mov    0x20(%esi),%ebx
  err_t result;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_release()\n"));

  /* idle DHCP client */
  dhcp_set_state(dhcp, DHCP_OFF);
  8040bd:	ba 0d 00 00 00       	mov    $0xd,%edx
  8040c2:	89 d8                	mov    %ebx,%eax
  8040c4:	e8 d7 ea ff ff       	call   802ba0 <dhcp_set_state>
  /* clean old DHCP offer */
  dhcp->server_ip_addr.addr = 0;
  8040c9:	c7 43 2c 00 00 00 00 	movl   $0x0,0x2c(%ebx)
  dhcp->offered_ip_addr.addr = dhcp->offered_sn_mask.addr = 0;
  8040d0:	c7 43 34 00 00 00 00 	movl   $0x0,0x34(%ebx)
  8040d7:	c7 43 30 00 00 00 00 	movl   $0x0,0x30(%ebx)
  dhcp->offered_gw_addr.addr = dhcp->offered_bc_addr.addr = 0;
  8040de:	c7 43 3c 00 00 00 00 	movl   $0x0,0x3c(%ebx)
  8040e5:	c7 43 38 00 00 00 00 	movl   $0x0,0x38(%ebx)
  dhcp->offered_t0_lease = dhcp->offered_t1_renew = dhcp->offered_t2_rebind = 0;
  8040ec:	c7 43 54 00 00 00 00 	movl   $0x0,0x54(%ebx)
  8040f3:	c7 43 50 00 00 00 00 	movl   $0x0,0x50(%ebx)
  8040fa:	c7 43 4c 00 00 00 00 	movl   $0x0,0x4c(%ebx)
  dhcp->dns_count = 0;
  804101:	c7 43 40 00 00 00 00 	movl   $0x0,0x40(%ebx)
  
  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  804108:	89 f0                	mov    %esi,%eax
  80410a:	e8 55 ee ff ff       	call   802f64 <dhcp_create_request>
  80410f:	89 c7                	mov    %eax,%edi
  if (result == ERR_OK) {
  804111:	84 c0                	test   %al,%al
  804113:	0f 85 87 00 00 00    	jne    8041a0 <dhcp_release+0xf2>
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  804119:	b9 01 00 00 00       	mov    $0x1,%ecx
  80411e:	ba 35 00 00 00       	mov    $0x35,%edx
  804123:	89 d8                	mov    %ebx,%eax
  804125:	e8 f5 eb ff ff       	call   802d1f <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_RELEASE);
  80412a:	ba 07 00 00 00       	mov    $0x7,%edx
  80412f:	89 d8                	mov    %ebx,%eax
  804131:	e8 a0 eb ff ff       	call   802cd6 <dhcp_option_byte>

    dhcp_option_trailer(dhcp);
  804136:	89 d8                	mov    %ebx,%eax
  804138:	e8 ba ec ff ff       	call   802df7 <dhcp_option_trailer>

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  80413d:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  804141:	66 05 f0 00          	add    $0xf0,%ax
  804145:	0f b7 c0             	movzwl %ax,%eax
  804148:	89 44 24 04          	mov    %eax,0x4(%esp)
  80414c:	8b 43 1c             	mov    0x1c(%ebx),%eax
  80414f:	89 04 24             	mov    %eax,(%esp)
  804152:	e8 0f 10 00 00       	call   805166 <pbuf_realloc>

    udp_connect(dhcp->pcb, &dhcp->server_ip_addr, DHCP_SERVER_PORT);
  804157:	8d 43 2c             	lea    0x2c(%ebx),%eax
  80415a:	c7 44 24 08 43 00 00 	movl   $0x43,0x8(%esp)
  804161:	00 
  804162:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  804165:	89 44 24 04          	mov    %eax,0x4(%esp)
  804169:	8b 43 08             	mov    0x8(%ebx),%eax
  80416c:	89 04 24             	mov    %eax,(%esp)
  80416f:	e8 c1 55 00 00       	call   809735 <udp_connect>
    udp_sendto_if(dhcp->pcb, dhcp->p_out, &dhcp->server_ip_addr, DHCP_SERVER_PORT, netif);
  804174:	89 74 24 10          	mov    %esi,0x10(%esp)
  804178:	c7 44 24 0c 43 00 00 	movl   $0x43,0xc(%esp)
  80417f:	00 
  804180:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  804183:	89 44 24 08          	mov    %eax,0x8(%esp)
  804187:	8b 43 1c             	mov    0x1c(%ebx),%eax
  80418a:	89 44 24 04          	mov    %eax,0x4(%esp)
  80418e:	8b 43 08             	mov    0x8(%ebx),%eax
  804191:	89 04 24             	mov    %eax,(%esp)
  804194:	e8 7a 53 00 00       	call   809513 <udp_sendto_if>
    dhcp_delete_request(netif);
  804199:	89 f0                	mov    %esi,%eax
  80419b:	e8 bb ef ff ff       	call   80315b <dhcp_delete_request>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_release: RELEASED, DHCP_OFF\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_release: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  8041a0:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
  8041a4:	8d 48 01             	lea    0x1(%eax),%ecx
  8041a7:	88 4b 01             	mov    %cl,0x1(%ebx)
  msecs = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
  8041aa:	b8 10 27 00 00       	mov    $0x2710,%eax
  8041af:	80 f9 09             	cmp    $0x9,%cl
  8041b2:	77 08                	ja     8041bc <dhcp_release+0x10e>
  8041b4:	0f b6 c9             	movzbl %cl,%ecx
  8041b7:	66 69 c1 e8 03       	imul   $0x3e8,%cx,%ax
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  8041bc:	0f b7 d0             	movzwl %ax,%edx
  8041bf:	81 c2 f3 01 00 00    	add    $0x1f3,%edx
  8041c5:	b9 d3 4d 62 10       	mov    $0x10624dd3,%ecx
  8041ca:	89 d0                	mov    %edx,%eax
  8041cc:	f7 e9                	imul   %ecx
  8041ce:	c1 fa 05             	sar    $0x5,%edx
  8041d1:	66 89 53 26          	mov    %dx,0x26(%ebx)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_release(): set request timeout %"U16_F" msecs\n", msecs));
  /* bring the interface down */
  netif_set_down(netif);
  8041d5:	89 34 24             	mov    %esi,(%esp)
  8041d8:	e8 09 0b 00 00       	call   804ce6 <netif_set_down>
  /* remove IP address from interface */
  netif_set_ipaddr(netif, IP_ADDR_ANY);
  8041dd:	c7 44 24 04 a0 2c 81 	movl   $0x812ca0,0x4(%esp)
  8041e4:	00 
  8041e5:	89 34 24             	mov    %esi,(%esp)
  8041e8:	e8 2a 09 00 00       	call   804b17 <netif_set_ipaddr>
  netif_set_gw(netif, IP_ADDR_ANY);
  8041ed:	c7 44 24 04 a0 2c 81 	movl   $0x812ca0,0x4(%esp)
  8041f4:	00 
  8041f5:	89 34 24             	mov    %esi,(%esp)
  8041f8:	e8 70 0a 00 00       	call   804c6d <netif_set_gw>
  netif_set_netmask(netif, IP_ADDR_ANY);
  8041fd:	c7 44 24 04 a0 2c 81 	movl   $0x812ca0,0x4(%esp)
  804204:	00 
  804205:	89 34 24             	mov    %esi,(%esp)
  804208:	e8 7b 0a 00 00       	call   804c88 <netif_set_netmask>
  
  /* TODO: netif_down(netif); */
  return result;
}
  80420d:	89 f8                	mov    %edi,%eax
  80420f:	83 c4 2c             	add    $0x2c,%esp
  804212:	5b                   	pop    %ebx
  804213:	5e                   	pop    %esi
  804214:	5f                   	pop    %edi
  804215:	5d                   	pop    %ebp
  804216:	c3                   	ret    

00804217 <dhcp_fine_tmr>:
 * This timer checks whether an outstanding DHCP request is timed out.
 * 
 */
void
dhcp_fine_tmr()
{
  804217:	55                   	push   %ebp
  804218:	89 e5                	mov    %esp,%ebp
  80421a:	53                   	push   %ebx
  80421b:	83 ec 14             	sub    $0x14,%esp
  struct netif *netif = netif_list;
  80421e:	8b 1d 54 c2 b3 00    	mov    0xb3c254,%ebx
  /* loop through netif's */
  while (netif != NULL) {
  804224:	e9 c3 00 00 00       	jmp    8042ec <dhcp_fine_tmr+0xd5>
    /* only act on DHCP configured interfaces */
    if (netif->dhcp != NULL) {
  804229:	8b 43 20             	mov    0x20(%ebx),%eax
  80422c:	85 c0                	test   %eax,%eax
  80422e:	0f 84 b6 00 00 00    	je     8042ea <dhcp_fine_tmr+0xd3>
      /* timer is active (non zero), and is about to trigger now */      
      if (netif->dhcp->request_timeout > 1) {
  804234:	0f b7 50 26          	movzwl 0x26(%eax),%edx
  804238:	66 83 fa 01          	cmp    $0x1,%dx
  80423c:	76 0c                	jbe    80424a <dhcp_fine_tmr+0x33>
        netif->dhcp->request_timeout--;
  80423e:	83 ea 01             	sub    $0x1,%edx
  804241:	66 89 50 26          	mov    %dx,0x26(%eax)
  804245:	e9 a0 00 00 00       	jmp    8042ea <dhcp_fine_tmr+0xd3>
      }
      else if (netif->dhcp->request_timeout == 1) {
  80424a:	66 83 fa 01          	cmp    $0x1,%dx
  80424e:	0f 85 96 00 00 00    	jne    8042ea <dhcp_fine_tmr+0xd3>
        netif->dhcp->request_timeout--;
  804254:	66 c7 40 26 00 00    	movw   $0x0,0x26(%eax)
 * @param netif the netif under DHCP control
 */
static void
dhcp_timeout(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  80425a:	8b 53 20             	mov    0x20(%ebx),%edx
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_timeout()\n"));
  /* back-off period has passed, or server selection timed out */
  if ((dhcp->state == DHCP_BACKING_OFF) || (dhcp->state == DHCP_SELECTING)) {
  80425d:	0f b6 02             	movzbl (%edx),%eax
  804260:	3c 06                	cmp    $0x6,%al
  804262:	74 04                	je     804268 <dhcp_fine_tmr+0x51>
  804264:	3c 0c                	cmp    $0xc,%al
  804266:	75 0a                	jne    804272 <dhcp_fine_tmr+0x5b>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_timeout(): restarting discovery\n"));
    dhcp_discover(netif);
  804268:	89 d8                	mov    %ebx,%eax
  80426a:	e8 a4 f0 ff ff       	call   803313 <dhcp_discover>
  80426f:	90                   	nop
  804270:	eb 78                	jmp    8042ea <dhcp_fine_tmr+0xd3>
  /* receiving the requested lease timed out */
  } else if (dhcp->state == DHCP_REQUESTING) {
  804272:	3c 01                	cmp    $0x1,%al
  804274:	75 20                	jne    804296 <dhcp_fine_tmr+0x7f>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REQUESTING, DHCP request timed out\n"));
    if (dhcp->tries <= 5) {
  804276:	80 7a 01 05          	cmpb   $0x5,0x1(%edx)
  80427a:	77 09                	ja     804285 <dhcp_fine_tmr+0x6e>
      dhcp_select(netif);
  80427c:	89 d8                	mov    %ebx,%eax
  80427e:	e8 e9 f1 ff ff       	call   80346c <dhcp_select>
  804283:	eb 65                	jmp    8042ea <dhcp_fine_tmr+0xd3>
    } else {
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REQUESTING, releasing, restarting\n"));
      dhcp_release(netif);
  804285:	89 1c 24             	mov    %ebx,(%esp)
  804288:	e8 21 fe ff ff       	call   8040ae <dhcp_release>
      dhcp_discover(netif);
  80428d:	89 d8                	mov    %ebx,%eax
  80428f:	e8 7f f0 ff ff       	call   803313 <dhcp_discover>
  804294:	eb 54                	jmp    8042ea <dhcp_fine_tmr+0xd3>
    }
  /* received no ARP reply for the offered address (which is good) */
  } else if (dhcp->state == DHCP_CHECKING) {
  804296:	3c 08                	cmp    $0x8,%al
  804298:	75 1a                	jne    8042b4 <dhcp_fine_tmr+0x9d>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): CHECKING, ARP request timed out\n"));
    if (dhcp->tries <= 1) {
  80429a:	80 7a 01 01          	cmpb   $0x1,0x1(%edx)
  80429e:	66 90                	xchg   %ax,%ax
  8042a0:	77 09                	ja     8042ab <dhcp_fine_tmr+0x94>
      dhcp_check(netif);
  8042a2:	89 d8                	mov    %ebx,%eax
  8042a4:	e8 59 f3 ff ff       	call   803602 <dhcp_check>
  8042a9:	eb 3f                	jmp    8042ea <dhcp_fine_tmr+0xd3>
    /* no ARP replies on the offered address,
       looks like the IP address is indeed free */
    } else {
      /* bind the interface to the offered address */
      dhcp_bind(netif);
  8042ab:	89 d8                	mov    %ebx,%eax
  8042ad:	e8 8d f3 ff ff       	call   80363f <dhcp_bind>
  8042b2:	eb 36                	jmp    8042ea <dhcp_fine_tmr+0xd3>
    }
  }
  /* did not get response to renew request? */
  else if (dhcp->state == DHCP_RENEWING) {
  8042b4:	3c 05                	cmp    $0x5,%al
  8042b6:	75 0f                	jne    8042c7 <dhcp_fine_tmr+0xb0>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): RENEWING, DHCP request timed out\n"));
    /* just retry renewal */
    /* note that the rebind timer will eventually time-out if renew does not work */
    dhcp_renew(netif);
  8042b8:	89 1c 24             	mov    %ebx,(%esp)
  8042bb:	90                   	nop
  8042bc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  8042c0:	e8 5a fc ff ff       	call   803f1f <dhcp_renew>
  8042c5:	eb 23                	jmp    8042ea <dhcp_fine_tmr+0xd3>
  /* did not get response to rebind request? */
  } else if (dhcp->state == DHCP_REBINDING) {
  8042c7:	3c 04                	cmp    $0x4,%al
  8042c9:	75 1f                	jne    8042ea <dhcp_fine_tmr+0xd3>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REBINDING, DHCP request timed out\n"));
    if (dhcp->tries <= 8) {
  8042cb:	80 7a 01 08          	cmpb   $0x8,0x1(%edx)
  8042cf:	90                   	nop
  8042d0:	77 09                	ja     8042db <dhcp_fine_tmr+0xc4>
      dhcp_rebind(netif);
  8042d2:	89 d8                	mov    %ebx,%eax
  8042d4:	e8 2d ef ff ff       	call   803206 <dhcp_rebind>
  8042d9:	eb 0f                	jmp    8042ea <dhcp_fine_tmr+0xd3>
    } else {
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): RELEASING, DISCOVERING\n"));
      dhcp_release(netif);
  8042db:	89 1c 24             	mov    %ebx,(%esp)
  8042de:	e8 cb fd ff ff       	call   8040ae <dhcp_release>
      dhcp_discover(netif);
  8042e3:	89 d8                	mov    %ebx,%eax
  8042e5:	e8 29 f0 ff ff       	call   803313 <dhcp_discover>
        /* this clients' request timeout triggered */
        dhcp_timeout(netif);
      }
    }
    /* proceed to next network interface */
    netif = netif->next;
  8042ea:	8b 1b                	mov    (%ebx),%ebx
void
dhcp_fine_tmr()
{
  struct netif *netif = netif_list;
  /* loop through netif's */
  while (netif != NULL) {
  8042ec:	85 db                	test   %ebx,%ebx
  8042ee:	0f 85 35 ff ff ff    	jne    804229 <dhcp_fine_tmr+0x12>
      }
    }
    /* proceed to next network interface */
    netif = netif->next;
  }
}
  8042f4:	83 c4 14             	add    $0x14,%esp
  8042f7:	5b                   	pop    %ebx
  8042f8:	5d                   	pop    %ebp
  8042f9:	c3                   	ret    

008042fa <dhcp_stop>:
 *
 * @param netif The network interface to stop DHCP on
 */
void
dhcp_stop(struct netif *netif)
{
  8042fa:	55                   	push   %ebp
  8042fb:	89 e5                	mov    %esp,%ebp
  8042fd:	56                   	push   %esi
  8042fe:	53                   	push   %ebx
  8042ff:	83 ec 10             	sub    $0x10,%esp
  804302:	8b 75 08             	mov    0x8(%ebp),%esi
  struct dhcp *dhcp = netif->dhcp;
  804305:	8b 5e 20             	mov    0x20(%esi),%ebx
  LWIP_ERROR("dhcp_stop: netif != NULL", (netif != NULL), return;);
  804308:	85 f6                	test   %esi,%esi
  80430a:	75 1c                	jne    804328 <dhcp_stop+0x2e>
  80430c:	c7 44 24 08 54 24 81 	movl   $0x812454,0x8(%esp)
  804313:	00 
  804314:	c7 44 24 04 2c 04 00 	movl   $0x42c,0x4(%esp)
  80431b:	00 
  80431c:	c7 04 24 e2 23 81 00 	movl   $0x8123e2,(%esp)
  804323:	e8 52 ad 00 00       	call   80f07a <_panic>
  /* Remove the flag that says this netif is handled by DHCP. */
  netif->flags &= ~NETIF_FLAG_DHCP;
  804328:	80 66 2e f7          	andb   $0xf7,0x2e(%esi)

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_stop()\n"));
  /* netif is DHCP configured? */
  if (dhcp != NULL) {
  80432c:	85 db                	test   %ebx,%ebx
  80432e:	74 42                	je     804372 <dhcp_stop+0x78>
    if (dhcp->pcb != NULL) {
  804330:	8b 43 08             	mov    0x8(%ebx),%eax
  804333:	85 c0                	test   %eax,%eax
  804335:	74 0f                	je     804346 <dhcp_stop+0x4c>
      udp_remove(dhcp->pcb);
  804337:	89 04 24             	mov    %eax,(%esp)
  80433a:	e8 9f 54 00 00       	call   8097de <udp_remove>
      dhcp->pcb = NULL;
  80433f:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    }
    if (dhcp->p != NULL) {
  804346:	8b 43 0c             	mov    0xc(%ebx),%eax
  804349:	85 c0                	test   %eax,%eax
  80434b:	74 0f                	je     80435c <dhcp_stop+0x62>
      pbuf_free(dhcp->p);
  80434d:	89 04 24             	mov    %eax,(%esp)
  804350:	e8 9f 0a 00 00       	call   804df4 <pbuf_free>
      dhcp->p = NULL;
  804355:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
    }
    /* free unfolded reply */
    dhcp_free_reply(dhcp);
  80435c:	89 d8                	mov    %ebx,%eax
  80435e:	e8 69 f4 ff ff       	call   8037cc <dhcp_free_reply>
    mem_free((void *)dhcp);
  804363:	89 1c 24             	mov    %ebx,(%esp)
  804366:	e8 7a 01 00 00       	call   8044e5 <mem_free>
    netif->dhcp = NULL;
  80436b:	c7 46 20 00 00 00 00 	movl   $0x0,0x20(%esi)
  }
}
  804372:	83 c4 10             	add    $0x10,%esp
  804375:	5b                   	pop    %ebx
  804376:	5e                   	pop    %esi
  804377:	5d                   	pop    %ebp
  804378:	c3                   	ret    

00804379 <dhcp_start>:
 * - ERR_OK - No error
 * - ERR_MEM - Out of memory
 */
err_t
dhcp_start(struct netif *netif)
{
  804379:	55                   	push   %ebp
  80437a:	89 e5                	mov    %esp,%ebp
  80437c:	56                   	push   %esi
  80437d:	53                   	push   %ebx
  80437e:	83 ec 10             	sub    $0x10,%esp
  804381:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct dhcp *dhcp;
  err_t result = ERR_OK;

  LWIP_ERROR("netif != NULL", (netif != NULL), return ERR_ARG;);
  804384:	85 db                	test   %ebx,%ebx
  804386:	75 1c                	jne    8043a4 <dhcp_start+0x2b>
  804388:	c7 44 24 08 02 24 81 	movl   $0x812402,0x8(%esp)
  80438f:	00 
  804390:	c7 44 24 04 38 02 00 	movl   $0x238,0x4(%esp)
  804397:	00 
  804398:	c7 04 24 e2 23 81 00 	movl   $0x8123e2,(%esp)
  80439f:	e8 d6 ac 00 00       	call   80f07a <_panic>
  dhcp = netif->dhcp;
  8043a4:	8b 73 20             	mov    0x20(%ebx),%esi
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_start(netif=%p) %c%c%"U16_F"\n", (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  /* Remove the flag that says this netif is handled by DHCP,
     it is set when we succeeded starting. */
  netif->flags &= ~NETIF_FLAG_DHCP;
  8043a7:	80 63 2e f7          	andb   $0xf7,0x2e(%ebx)

  /* no DHCP client attached yet? */
  if (dhcp == NULL) {
  8043ab:	85 f6                	test   %esi,%esi
  8043ad:	75 19                	jne    8043c8 <dhcp_start+0x4f>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): starting new DHCP client\n"));
    dhcp = mem_malloc(sizeof(struct dhcp));
  8043af:	c7 04 24 58 00 00 00 	movl   $0x58,(%esp)
  8043b6:	e8 04 04 00 00       	call   8047bf <mem_malloc>
  8043bb:	89 c6                	mov    %eax,%esi
    if (dhcp == NULL) {
  8043bd:	85 c0                	test   %eax,%eax
  8043bf:	0f 84 ac 00 00 00    	je     804471 <dhcp_start+0xf8>
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): could not allocate dhcp\n"));
      return ERR_MEM;
    }
    /* store this dhcp client in the netif */
    netif->dhcp = dhcp;
  8043c5:	89 43 20             	mov    %eax,0x20(%ebx)
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE | 3, ("dhcp_start(): restarting DHCP configuration\n"));
  }
    
  /* clear data structure */
  memset(dhcp, 0, sizeof(struct dhcp));
  8043c8:	c7 44 24 08 58 00 00 	movl   $0x58,0x8(%esp)
  8043cf:	00 
  8043d0:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8043d7:	00 
  8043d8:	89 34 24             	mov    %esi,(%esp)
  8043db:	e8 07 b5 00 00       	call   80f8e7 <memset>
  /* allocate UDP PCB */
  dhcp->pcb = udp_new();
  8043e0:	e8 3f 54 00 00       	call   809824 <udp_new>
  8043e5:	89 46 08             	mov    %eax,0x8(%esi)
  if (dhcp->pcb == NULL) {
  8043e8:	85 c0                	test   %eax,%eax
  8043ea:	75 16                	jne    804402 <dhcp_start+0x89>
    LWIP_DEBUGF(DHCP_DEBUG  | LWIP_DBG_TRACE, ("dhcp_start(): could not obtain pcb\n"));
    mem_free((void *)dhcp);
  8043ec:	89 34 24             	mov    %esi,(%esp)
  8043ef:	e8 f1 00 00 00       	call   8044e5 <mem_free>
    netif->dhcp = dhcp = NULL;
  8043f4:	c7 43 20 00 00 00 00 	movl   $0x0,0x20(%ebx)
    return ERR_MEM;
  8043fb:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  804400:	eb 74                	jmp    804476 <dhcp_start+0xfd>
  }
  /* set up local and remote port for the pcb */
  udp_bind(dhcp->pcb, IP_ADDR_ANY, DHCP_CLIENT_PORT);
  804402:	c7 44 24 08 44 00 00 	movl   $0x44,0x8(%esp)
  804409:	00 
  80440a:	c7 44 24 04 a0 2c 81 	movl   $0x812ca0,0x4(%esp)
  804411:	00 
  804412:	89 04 24             	mov    %eax,(%esp)
  804415:	e8 27 50 00 00       	call   809441 <udp_bind>
  udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  80441a:	c7 44 24 08 43 00 00 	movl   $0x43,0x8(%esp)
  804421:	00 
  804422:	c7 44 24 04 a0 2c 81 	movl   $0x812ca0,0x4(%esp)
  804429:	00 
  80442a:	8b 46 08             	mov    0x8(%esi),%eax
  80442d:	89 04 24             	mov    %eax,(%esp)
  804430:	e8 00 53 00 00       	call   809735 <udp_connect>
  /* set up the recv callback and argument */
  udp_recv(dhcp->pcb, dhcp_recv, netif);
  804435:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  804439:	c7 44 24 04 0d 38 80 	movl   $0x80380d,0x4(%esp)
  804440:	00 
  804441:	8b 46 08             	mov    0x8(%esi),%eax
  804444:	89 04 24             	mov    %eax,(%esp)
  804447:	e8 7e 53 00 00       	call   8097ca <udp_recv>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): starting DHCP configuration\n"));
  /* (re)start the DHCP negotiation */
  result = dhcp_discover(netif);
  80444c:	89 d8                	mov    %ebx,%eax
  80444e:	e8 c0 ee ff ff       	call   803313 <dhcp_discover>
  if (result != ERR_OK) {
  804453:	84 c0                	test   %al,%al
  804455:	74 0f                	je     804466 <dhcp_start+0xed>
    /* free resources allocated above */
    dhcp_stop(netif);
  804457:	89 1c 24             	mov    %ebx,(%esp)
  80445a:	e8 9b fe ff ff       	call   8042fa <dhcp_stop>
    return ERR_MEM;
  80445f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  804464:	eb 10                	jmp    804476 <dhcp_start+0xfd>
  }
  /* Set the flag that says this netif is handled by DHCP. */
  netif->flags |= NETIF_FLAG_DHCP;
  804466:	80 4b 2e 08          	orb    $0x8,0x2e(%ebx)
  return result;
  80446a:	b8 00 00 00 00       	mov    $0x0,%eax
  80446f:	eb 05                	jmp    804476 <dhcp_start+0xfd>
  if (dhcp == NULL) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): starting new DHCP client\n"));
    dhcp = mem_malloc(sizeof(struct dhcp));
    if (dhcp == NULL) {
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): could not allocate dhcp\n"));
      return ERR_MEM;
  804471:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    return ERR_MEM;
  }
  /* Set the flag that says this netif is handled by DHCP. */
  netif->flags |= NETIF_FLAG_DHCP;
  return result;
}
  804476:	83 c4 10             	add    $0x10,%esp
  804479:	5b                   	pop    %ebx
  80447a:	5e                   	pop    %esi
  80447b:	5d                   	pop    %ebp
  80447c:	c3                   	ret    

0080447d <mem_init>:
/**
 * Zero the heap and initialize start, end and lowest-free
 */
void
mem_init(void)
{
  80447d:	55                   	push   %ebp
  80447e:	89 e5                	mov    %esp,%ebp
  804480:	83 ec 18             	sub    $0x18,%esp

  LWIP_ASSERT("Sanity check alignment",
    (SIZEOF_STRUCT_MEM & (MEM_ALIGNMENT-1)) == 0);

  /* align the heap */
  ram = LWIP_MEM_ALIGN(ram_heap);
  804483:	b8 43 63 81 00       	mov    $0x816343,%eax
  804488:	83 e0 fc             	and    $0xfffffffc,%eax
  80448b:	a3 2c 63 81 00       	mov    %eax,0x81632c
  /* initialize the start of the heap */
  mem = (struct mem *)ram;
  mem->next = MEM_SIZE_ALIGNED;
  804490:	c7 00 00 00 22 00    	movl   $0x220000,(%eax)
  mem->prev = 0;
  804496:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  mem->used = 0;
  80449d:	c6 40 08 00          	movb   $0x0,0x8(%eax)
  /* initialize the end of the heap */
  ram_end = (struct mem *)&ram[MEM_SIZE_ALIGNED];
  8044a1:	8d 90 00 00 22 00    	lea    0x220000(%eax),%edx
  8044a7:	89 15 28 63 81 00    	mov    %edx,0x816328
  ram_end->used = 1;
  8044ad:	c6 80 08 00 22 00 01 	movb   $0x1,0x220008(%eax)
  ram_end->next = MEM_SIZE_ALIGNED;
  8044b4:	c7 80 00 00 22 00 00 	movl   $0x220000,0x220000(%eax)
  8044bb:	00 22 00 
  ram_end->prev = MEM_SIZE_ALIGNED;
  8044be:	c7 80 04 00 22 00 00 	movl   $0x220000,0x220004(%eax)
  8044c5:	00 22 00 

  mem_sem = sys_sem_new(1);
  8044c8:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  8044cf:	e8 4a 61 00 00       	call   80a61e <sys_sem_new>
  8044d4:	a3 20 63 81 00       	mov    %eax,0x816320

  /* initialize the lowest-free pointer to the start of the heap */
  lfree = (struct mem *)ram;
  8044d9:	a1 2c 63 81 00       	mov    0x81632c,%eax
  8044de:	a3 24 63 81 00       	mov    %eax,0x816324

  MEM_STATS_AVAIL(avail, MEM_SIZE_ALIGNED);
}
  8044e3:	c9                   	leave  
  8044e4:	c3                   	ret    

008044e5 <mem_free>:
 * @param rmem is the data portion of a struct mem as returned by a previous
 *             call to mem_malloc()
 */
void
mem_free(void *rmem)
{
  8044e5:	55                   	push   %ebp
  8044e6:	89 e5                	mov    %esp,%ebp
  8044e8:	56                   	push   %esi
  8044e9:	53                   	push   %ebx
  8044ea:	83 ec 10             	sub    $0x10,%esp
  8044ed:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct mem *mem;
  LWIP_MEM_FREE_DECL_PROTECT();

  if (rmem == NULL) {
  8044f0:	85 db                	test   %ebx,%ebx
  8044f2:	0f 84 6f 01 00 00    	je     804667 <mem_free+0x182>
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_TRACE | 2, ("mem_free(p == NULL) was called.\n"));
    return;
  }
  LWIP_ASSERT("mem_free: sanity check alignment", (((mem_ptr_t)rmem) & (MEM_ALIGNMENT-1)) == 0);
  8044f8:	f6 c3 03             	test   $0x3,%bl
  8044fb:	74 1c                	je     804519 <mem_free+0x34>
  8044fd:	c7 44 24 08 70 24 81 	movl   $0x812470,0x8(%esp)
  804504:	00 
  804505:	c7 44 24 04 30 01 00 	movl   $0x130,0x4(%esp)
  80450c:	00 
  80450d:	c7 04 24 67 25 81 00 	movl   $0x812567,(%esp)
  804514:	e8 61 ab 00 00       	call   80f07a <_panic>

  LWIP_ASSERT("mem_free: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
  804519:	3b 1d 2c 63 81 00    	cmp    0x81632c,%ebx
  80451f:	72 08                	jb     804529 <mem_free+0x44>
  804521:	3b 1d 28 63 81 00    	cmp    0x816328,%ebx
  804527:	72 1c                	jb     804545 <mem_free+0x60>
  804529:	c7 44 24 08 7b 25 81 	movl   $0x81257b,0x8(%esp)
  804530:	00 
  804531:	c7 44 24 04 33 01 00 	movl   $0x133,0x4(%esp)
  804538:	00 
  804539:	c7 04 24 67 25 81 00 	movl   $0x812567,(%esp)
  804540:	e8 35 ab 00 00       	call   80f07a <_panic>
    MEM_STATS_INC(illegal);
    SYS_ARCH_UNPROTECT(lev);
    return;
  }
  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();
  804545:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80454c:	00 
  80454d:	a1 20 63 81 00       	mov    0x816320,%eax
  804552:	89 04 24             	mov    %eax,(%esp)
  804555:	e8 1b 64 00 00       	call   80a975 <sys_arch_sem_wait>
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
  80455a:	8d 43 f4             	lea    -0xc(%ebx),%eax
  /* ... which has to be in a used state ... */
  LWIP_ASSERT("mem_free: mem->used", mem->used);
  80455d:	80 7b fc 00          	cmpb   $0x0,-0x4(%ebx)
  804561:	75 1c                	jne    80457f <mem_free+0x9a>
  804563:	c7 44 24 08 92 25 81 	movl   $0x812592,0x8(%esp)
  80456a:	00 
  80456b:	c7 44 24 04 43 01 00 	movl   $0x143,0x4(%esp)
  804572:	00 
  804573:	c7 04 24 67 25 81 00 	movl   $0x812567,(%esp)
  80457a:	e8 fb aa 00 00       	call   80f07a <_panic>
  /* ... and is now unused. */
  mem->used = 0;
  80457f:	c6 43 fc 00          	movb   $0x0,-0x4(%ebx)

  if (mem < lfree) {
  804583:	3b 05 24 63 81 00    	cmp    0x816324,%eax
  804589:	73 05                	jae    804590 <mem_free+0xab>
    /* the newly freed struct is now the lowest */
    lfree = mem;
  80458b:	a3 24 63 81 00       	mov    %eax,0x816324
plug_holes(struct mem *mem)
{
  struct mem *nmem;
  struct mem *pmem;

  LWIP_ASSERT("plug_holes: mem >= ram", (u8_t *)mem >= ram);
  804590:	8b 15 2c 63 81 00    	mov    0x81632c,%edx
  804596:	39 d0                	cmp    %edx,%eax
  804598:	73 1c                	jae    8045b6 <mem_free+0xd1>
  80459a:	c7 44 24 08 a6 25 81 	movl   $0x8125a6,0x8(%esp)
  8045a1:	00 
  8045a2:	c7 44 24 04 e3 00 00 	movl   $0xe3,0x4(%esp)
  8045a9:	00 
  8045aa:	c7 04 24 67 25 81 00 	movl   $0x812567,(%esp)
  8045b1:	e8 c4 aa 00 00       	call   80f07a <_panic>
  LWIP_ASSERT("plug_holes: mem < ram_end", (u8_t *)mem < (u8_t *)ram_end);
  8045b6:	8b 35 28 63 81 00    	mov    0x816328,%esi
  8045bc:	39 f0                	cmp    %esi,%eax
  8045be:	72 1c                	jb     8045dc <mem_free+0xf7>
  8045c0:	c7 44 24 08 bd 25 81 	movl   $0x8125bd,0x8(%esp)
  8045c7:	00 
  8045c8:	c7 44 24 04 e4 00 00 	movl   $0xe4,0x4(%esp)
  8045cf:	00 
  8045d0:	c7 04 24 67 25 81 00 	movl   $0x812567,(%esp)
  8045d7:	e8 9e aa 00 00       	call   80f07a <_panic>
  LWIP_ASSERT("plug_holes: mem->used == 0", mem->used == 0);

  /* plug hole forward */
  LWIP_ASSERT("plug_holes: mem->next <= MEM_SIZE_ALIGNED", mem->next <= MEM_SIZE_ALIGNED);
  8045dc:	8b 4b f4             	mov    -0xc(%ebx),%ecx
  8045df:	81 f9 00 00 22 00    	cmp    $0x220000,%ecx
  8045e5:	76 1c                	jbe    804603 <mem_free+0x11e>
  8045e7:	c7 44 24 08 94 24 81 	movl   $0x812494,0x8(%esp)
  8045ee:	00 
  8045ef:	c7 44 24 04 e8 00 00 	movl   $0xe8,0x4(%esp)
  8045f6:	00 
  8045f7:	c7 04 24 67 25 81 00 	movl   $0x812567,(%esp)
  8045fe:	e8 77 aa 00 00       	call   80f07a <_panic>

  nmem = (struct mem *)&ram[mem->next];
  804603:	01 d1                	add    %edx,%ecx
  if (mem != nmem && nmem->used == 0 && (u8_t *)nmem != (u8_t *)ram_end) {
  804605:	39 c8                	cmp    %ecx,%eax
  804607:	74 26                	je     80462f <mem_free+0x14a>
  804609:	80 79 08 00          	cmpb   $0x0,0x8(%ecx)
  80460d:	75 20                	jne    80462f <mem_free+0x14a>
  80460f:	39 ce                	cmp    %ecx,%esi
  804611:	74 1c                	je     80462f <mem_free+0x14a>
    /* if mem->next is unused and not end of ram, combine mem and mem->next */
    if (lfree == nmem) {
  804613:	3b 0d 24 63 81 00    	cmp    0x816324,%ecx
  804619:	75 05                	jne    804620 <mem_free+0x13b>
      lfree = mem;
  80461b:	a3 24 63 81 00       	mov    %eax,0x816324
    }
    mem->next = nmem->next;
  804620:	8b 31                	mov    (%ecx),%esi
  804622:	89 73 f4             	mov    %esi,-0xc(%ebx)
    ((struct mem *)&ram[nmem->next])->prev = (u8_t *)mem - ram;
  804625:	8b 09                	mov    (%ecx),%ecx
  804627:	89 c6                	mov    %eax,%esi
  804629:	29 d6                	sub    %edx,%esi
  80462b:	89 74 0a 04          	mov    %esi,0x4(%edx,%ecx,1)
  }

  /* plug hole backward */
  pmem = (struct mem *)&ram[mem->prev];
  80462f:	89 d1                	mov    %edx,%ecx
  804631:	03 4b f8             	add    -0x8(%ebx),%ecx
  if (pmem != mem && pmem->used == 0) {
  804634:	39 c8                	cmp    %ecx,%eax
  804636:	74 22                	je     80465a <mem_free+0x175>
  804638:	80 79 08 00          	cmpb   $0x0,0x8(%ecx)
  80463c:	75 1c                	jne    80465a <mem_free+0x175>
    /* if mem->prev is unused, combine mem and mem->prev */
    if (lfree == mem) {
  80463e:	3b 05 24 63 81 00    	cmp    0x816324,%eax
  804644:	75 06                	jne    80464c <mem_free+0x167>
      lfree = pmem;
  804646:	89 0d 24 63 81 00    	mov    %ecx,0x816324
    }
    pmem->next = mem->next;
  80464c:	8b 43 f4             	mov    -0xc(%ebx),%eax
  80464f:	89 01                	mov    %eax,(%ecx)
    ((struct mem *)&ram[mem->next])->prev = (u8_t *)pmem - ram;
  804651:	8b 43 f4             	mov    -0xc(%ebx),%eax
  804654:	29 d1                	sub    %edx,%ecx
  804656:	89 4c 02 04          	mov    %ecx,0x4(%edx,%eax,1)
  /* finally, see if prev or next are free also */
  plug_holes(mem);
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
  80465a:	a1 20 63 81 00       	mov    0x816320,%eax
  80465f:	89 04 24             	mov    %eax,(%esp)
  804662:	e8 99 62 00 00       	call   80a900 <sys_sem_signal>
}
  804667:	83 c4 10             	add    $0x10,%esp
  80466a:	5b                   	pop    %ebx
  80466b:	5e                   	pop    %esi
  80466c:	5d                   	pop    %ebp
  80466d:	c3                   	ret    

0080466e <mem_realloc>:
 *         or NULL if newsize is > old size, in which case rmem is NOT touched
 *         or freed!
 */
void *
mem_realloc(void *rmem, mem_size_t newsize)
{
  80466e:	55                   	push   %ebp
  80466f:	89 e5                	mov    %esp,%ebp
  804671:	57                   	push   %edi
  804672:	56                   	push   %esi
  804673:	53                   	push   %ebx
  804674:	83 ec 1c             	sub    $0x1c,%esp
  804677:	8b 5d 08             	mov    0x8(%ebp),%ebx
  /* use the FREE_PROTECT here: it protects with sem OR SYS_ARCH_PROTECT */
  LWIP_MEM_FREE_DECL_PROTECT();

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  newsize = LWIP_MEM_ALIGN_SIZE(newsize);
  80467a:	8b 45 0c             	mov    0xc(%ebp),%eax
  80467d:	8d 70 03             	lea    0x3(%eax),%esi
  804680:	83 e6 fc             	and    $0xfffffffc,%esi

  if(newsize < MIN_SIZE_ALIGNED) {
  804683:	83 fe 0b             	cmp    $0xb,%esi
  804686:	76 0d                	jbe    804695 <mem_realloc+0x27>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    newsize = MIN_SIZE_ALIGNED;
  }

  if (newsize > MEM_SIZE_ALIGNED) {
  804688:	81 fe 00 00 22 00    	cmp    $0x220000,%esi
  80468e:	76 0a                	jbe    80469a <mem_realloc+0x2c>
  804690:	e9 1d 01 00 00       	jmp    8047b2 <mem_realloc+0x144>
     adjust for alignment. */
  newsize = LWIP_MEM_ALIGN_SIZE(newsize);

  if(newsize < MIN_SIZE_ALIGNED) {
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    newsize = MIN_SIZE_ALIGNED;
  804695:	be 0c 00 00 00       	mov    $0xc,%esi

  if (newsize > MEM_SIZE_ALIGNED) {
    return NULL;
  }

  LWIP_ASSERT("mem_realloc: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
  80469a:	a1 2c 63 81 00       	mov    0x81632c,%eax
  80469f:	39 d8                	cmp    %ebx,%eax
  8046a1:	77 08                	ja     8046ab <mem_realloc+0x3d>
  8046a3:	3b 1d 28 63 81 00    	cmp    0x816328,%ebx
  8046a9:	72 1c                	jb     8046c7 <mem_realloc+0x59>
  8046ab:	c7 44 24 08 d7 25 81 	movl   $0x8125d7,0x8(%esp)
  8046b2:	00 
  8046b3:	c7 44 24 04 79 01 00 	movl   $0x179,0x4(%esp)
  8046ba:	00 
  8046bb:	c7 04 24 67 25 81 00 	movl   $0x812567,(%esp)
  8046c2:	e8 b3 a9 00 00       	call   80f07a <_panic>
    MEM_STATS_INC(illegal);
    SYS_ARCH_UNPROTECT(lev);
    return rmem;
  }
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
  8046c7:	8d 53 f4             	lea    -0xc(%ebx),%edx
  /* ... and its offset pointer */
  ptr = (u8_t *)mem - ram;
  8046ca:	29 c2                	sub    %eax,%edx
  8046cc:	89 55 e4             	mov    %edx,-0x1c(%ebp)

  size = mem->next - ptr - SIZEOF_STRUCT_MEM;
  8046cf:	8b 43 f4             	mov    -0xc(%ebx),%eax
  8046d2:	8d 78 f4             	lea    -0xc(%eax),%edi
  8046d5:	29 d7                	sub    %edx,%edi
  LWIP_ASSERT("mem_realloc can only shrink memory", newsize <= size);
  8046d7:	39 f7                	cmp    %esi,%edi
  8046d9:	73 1c                	jae    8046f7 <mem_realloc+0x89>
  8046db:	c7 44 24 08 c0 24 81 	movl   $0x8124c0,0x8(%esp)
  8046e2:	00 
  8046e3:	c7 44 24 04 8a 01 00 	movl   $0x18a,0x4(%esp)
  8046ea:	00 
  8046eb:	c7 04 24 67 25 81 00 	movl   $0x812567,(%esp)
  8046f2:	e8 83 a9 00 00       	call   80f07a <_panic>
    /* not supported */
    return NULL;
  }
  if (newsize == size) {
    /* No change in size, simply return */
    return rmem;
  8046f7:	89 d8                	mov    %ebx,%eax
  LWIP_ASSERT("mem_realloc can only shrink memory", newsize <= size);
  if (newsize > size) {
    /* not supported */
    return NULL;
  }
  if (newsize == size) {
  8046f9:	39 fe                	cmp    %edi,%esi
  8046fb:	0f 84 b6 00 00 00    	je     8047b7 <mem_realloc+0x149>
    /* No change in size, simply return */
    return rmem;
  }

  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();
  804701:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  804708:	00 
  804709:	a1 20 63 81 00       	mov    0x816320,%eax
  80470e:	89 04 24             	mov    %eax,(%esp)
  804711:	e8 5f 62 00 00       	call   80a975 <sys_arch_sem_wait>

  MEM_STATS_DEC_USED(used, (size - newsize));

  mem2 = (struct mem *)&ram[mem->next];
  804716:	a1 2c 63 81 00       	mov    0x81632c,%eax
  80471b:	89 c2                	mov    %eax,%edx
  80471d:	03 53 f4             	add    -0xc(%ebx),%edx
  if(mem2->used == 0) {
  804720:	80 7a 08 00          	cmpb   $0x0,0x8(%edx)
  804724:	75 3c                	jne    804762 <mem_realloc+0xf4>
    /* The next struct is unused, we can simply move it at little */
    mem_size_t next;
    /* remember the old next pointer */
    next = mem2->next;
  804726:	8b 0a                	mov    (%edx),%ecx
    /* create new struct mem which is moved directly after the shrinked mem */
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
  804728:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  80472b:	8d 74 3e 0c          	lea    0xc(%esi,%edi,1),%esi
    if (lfree == mem2) {
  80472f:	39 15 24 63 81 00    	cmp    %edx,0x816324
  804735:	75 09                	jne    804740 <mem_realloc+0xd2>
      lfree = (struct mem *)&ram[ptr2];
  804737:	8d 14 30             	lea    (%eax,%esi,1),%edx
  80473a:	89 15 24 63 81 00    	mov    %edx,0x816324
    }
    mem2 = (struct mem *)&ram[ptr2];
  804740:	8d 14 30             	lea    (%eax,%esi,1),%edx
    mem2->used = 0;
  804743:	c6 42 08 00          	movb   $0x0,0x8(%edx)
    /* restore the next pointer */
    mem2->next = next;
  804747:	89 0a                	mov    %ecx,(%edx)
    /* link it back to mem */
    mem2->prev = ptr;
  804749:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  80474c:	89 4a 04             	mov    %ecx,0x4(%edx)
    /* link mem to it */
    mem->next = ptr2;
  80474f:	89 73 f4             	mov    %esi,-0xc(%ebx)
    /* last thing to restore linked list: as we have moved mem2,
     * let 'mem2->next->prev' point to mem2 again. but only if mem2->next is not
     * the end of the heap */
    if (mem2->next != MEM_SIZE_ALIGNED) {
  804752:	8b 12                	mov    (%edx),%edx
  804754:	81 fa 00 00 22 00    	cmp    $0x220000,%edx
  80475a:	74 45                	je     8047a1 <mem_realloc+0x133>
      ((struct mem *)&ram[mem2->next])->prev = ptr2;
  80475c:	89 74 10 04          	mov    %esi,0x4(%eax,%edx,1)
  804760:	eb 3f                	jmp    8047a1 <mem_realloc+0x133>
    }
    /* no need to plug holes, we've already done that */
  } else if (newsize + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED <= size) {
  804762:	8d 56 18             	lea    0x18(%esi),%edx
  804765:	39 d7                	cmp    %edx,%edi
  804767:	72 38                	jb     8047a1 <mem_realloc+0x133>
     * Old size ('size') must be big enough to contain at least 'newsize' plus a struct mem
     * ('SIZEOF_STRUCT_MEM') with some data ('MIN_SIZE_ALIGNED').
     * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
     *       region that couldn't hold data, but when mem->next gets freed,
     *       the 2 regions would be combined, resulting in more free memory */
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
  804769:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  80476c:	8d 4c 0e 0c          	lea    0xc(%esi,%ecx,1),%ecx
    mem2 = (struct mem *)&ram[ptr2];
  804770:	8d 14 08             	lea    (%eax,%ecx,1),%edx
    if (mem2 < lfree) {
  804773:	3b 15 24 63 81 00    	cmp    0x816324,%edx
  804779:	73 06                	jae    804781 <mem_realloc+0x113>
      lfree = mem2;
  80477b:	89 15 24 63 81 00    	mov    %edx,0x816324
    }
    mem2->used = 0;
  804781:	c6 42 08 00          	movb   $0x0,0x8(%edx)
    mem2->next = mem->next;
  804785:	8b 73 f4             	mov    -0xc(%ebx),%esi
  804788:	89 32                	mov    %esi,(%edx)
    mem2->prev = ptr;
  80478a:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  80478d:	89 7a 04             	mov    %edi,0x4(%edx)
    mem->next = ptr2;
  804790:	89 4b f4             	mov    %ecx,-0xc(%ebx)
    if (mem2->next != MEM_SIZE_ALIGNED) {
  804793:	8b 12                	mov    (%edx),%edx
  804795:	81 fa 00 00 22 00    	cmp    $0x220000,%edx
  80479b:	74 04                	je     8047a1 <mem_realloc+0x133>
      ((struct mem *)&ram[mem2->next])->prev = ptr2;
  80479d:	89 4c 10 04          	mov    %ecx,0x4(%eax,%edx,1)
    -> the remaining space stays unused since it is too small
  } */
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
  8047a1:	a1 20 63 81 00       	mov    0x816320,%eax
  8047a6:	89 04 24             	mov    %eax,(%esp)
  8047a9:	e8 52 61 00 00       	call   80a900 <sys_sem_signal>
  return rmem;
  8047ae:	89 d8                	mov    %ebx,%eax
  8047b0:	eb 05                	jmp    8047b7 <mem_realloc+0x149>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    newsize = MIN_SIZE_ALIGNED;
  }

  if (newsize > MEM_SIZE_ALIGNED) {
    return NULL;
  8047b2:	b8 00 00 00 00       	mov    $0x0,%eax
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
  return rmem;
}
  8047b7:	83 c4 1c             	add    $0x1c,%esp
  8047ba:	5b                   	pop    %ebx
  8047bb:	5e                   	pop    %esi
  8047bc:	5f                   	pop    %edi
  8047bd:	5d                   	pop    %ebp
  8047be:	c3                   	ret    

008047bf <mem_malloc>:
 *
 * Note that the returned value will always be aligned (as defined by MEM_ALIGNMENT).
 */
void *
mem_malloc(mem_size_t size)
{
  8047bf:	55                   	push   %ebp
  8047c0:	89 e5                	mov    %esp,%ebp
  8047c2:	57                   	push   %edi
  8047c3:	56                   	push   %esi
  8047c4:	53                   	push   %ebx
  8047c5:	83 ec 1c             	sub    $0x1c,%esp
  8047c8:	8b 75 08             	mov    0x8(%ebp),%esi
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  u8_t local_mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_ALLOC_DECL_PROTECT();

  if (size == 0) {
  8047cb:	85 f6                	test   %esi,%esi
  8047cd:	0f 84 69 01 00 00    	je     80493c <mem_malloc+0x17d>
    return NULL;
  }

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  size = LWIP_MEM_ALIGN_SIZE(size);
  8047d3:	83 c6 03             	add    $0x3,%esi
  8047d6:	83 e6 fc             	and    $0xfffffffc,%esi

  if(size < MIN_SIZE_ALIGNED) {
  8047d9:	83 fe 0b             	cmp    $0xb,%esi
  8047dc:	76 0d                	jbe    8047eb <mem_malloc+0x2c>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    size = MIN_SIZE_ALIGNED;
  }

  if (size > MEM_SIZE_ALIGNED) {
  8047de:	81 fe 00 00 22 00    	cmp    $0x220000,%esi
  8047e4:	76 0a                	jbe    8047f0 <mem_malloc+0x31>
  8047e6:	e9 58 01 00 00       	jmp    804943 <mem_malloc+0x184>
     adjust for alignment. */
  size = LWIP_MEM_ALIGN_SIZE(size);

  if(size < MIN_SIZE_ALIGNED) {
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    size = MIN_SIZE_ALIGNED;
  8047eb:	be 0c 00 00 00       	mov    $0xc,%esi
  if (size > MEM_SIZE_ALIGNED) {
    return NULL;
  }

  /* protect the heap from concurrent access */
  sys_arch_sem_wait(mem_sem, 0);
  8047f0:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8047f7:	00 
  8047f8:	a1 20 63 81 00       	mov    0x816320,%eax
  8047fd:	89 04 24             	mov    %eax,(%esp)
  804800:	e8 70 61 00 00       	call   80a975 <sys_arch_sem_wait>
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (u8_t *)lfree - ram; ptr < MEM_SIZE_ALIGNED - size;
  804805:	8b 15 2c 63 81 00    	mov    0x81632c,%edx
  80480b:	a1 24 63 81 00       	mov    0x816324,%eax
  804810:	29 d0                	sub    %edx,%eax
  804812:	b9 00 00 22 00       	mov    $0x220000,%ecx
  804817:	29 f1                	sub    %esi,%ecx
  804819:	e9 02 01 00 00       	jmp    804920 <mem_malloc+0x161>
         ptr = ((struct mem *)&ram[ptr])->next) {
      mem = (struct mem *)&ram[ptr];
  80481e:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
        local_mem_free_count = mem_free_count;
      }
      mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

      if ((!mem->used) &&
  804821:	80 7b 08 00          	cmpb   $0x0,0x8(%ebx)
  804825:	0f 85 f3 00 00 00    	jne    80491e <mem_malloc+0x15f>
          (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
  80482b:	8b 3b                	mov    (%ebx),%edi
  80482d:	83 ef 0c             	sub    $0xc,%edi
  804830:	29 c7                	sub    %eax,%edi
        local_mem_free_count = mem_free_count;
      }
      mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

      if ((!mem->used) &&
  804832:	39 f7                	cmp    %esi,%edi
  804834:	0f 82 e4 00 00 00    	jb     80491e <mem_malloc+0x15f>
          (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
        /* mem is not used and at least perfect fit is possible:
         * mem->next - (ptr + SIZEOF_STRUCT_MEM) gives us the 'user data size' of mem */

        if (mem->next - (ptr + SIZEOF_STRUCT_MEM) >= (size + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED)) {
  80483a:	8d 4e 18             	lea    0x18(%esi),%ecx
  80483d:	39 f9                	cmp    %edi,%ecx
  80483f:	77 2c                	ja     80486d <mem_malloc+0xae>
           * struct mem would fit in but no data between mem2 and mem2->next
           * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
           *       region that couldn't hold data, but when mem->next gets freed,
           *       the 2 regions would be combined, resulting in more free memory
           */
          ptr2 = ptr + SIZEOF_STRUCT_MEM + size;
  804841:	8d 4c 30 0c          	lea    0xc(%eax,%esi,1),%ecx
          /* create mem2 struct */
          mem2 = (struct mem *)&ram[ptr2];
  804845:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  804848:	01 d1                	add    %edx,%ecx
          mem2->used = 0;
  80484a:	c6 41 08 00          	movb   $0x0,0x8(%ecx)
          mem2->next = mem->next;
  80484e:	8b 3b                	mov    (%ebx),%edi
  804850:	89 39                	mov    %edi,(%ecx)
          mem2->prev = ptr;
  804852:	89 41 04             	mov    %eax,0x4(%ecx)
          /* and insert it between mem and mem->next */
          mem->next = ptr2;
  804855:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  804858:	89 3b                	mov    %edi,(%ebx)
          mem->used = 1;
  80485a:	c6 43 08 01          	movb   $0x1,0x8(%ebx)

          if (mem2->next != MEM_SIZE_ALIGNED) {
  80485e:	8b 01                	mov    (%ecx),%eax
  804860:	3d 00 00 22 00       	cmp    $0x220000,%eax
  804865:	74 0a                	je     804871 <mem_malloc+0xb2>
            ((struct mem *)&ram[mem2->next])->prev = ptr2;
  804867:	89 7c 02 04          	mov    %edi,0x4(%edx,%eax,1)
  80486b:	eb 04                	jmp    804871 <mem_malloc+0xb2>
           * take care of this).
           * -> near fit or excact fit: do not split, no mem2 creation
           * also can't move mem->next directly behind mem, since mem->next
           * will always be used at this point!
           */
          mem->used = 1;
  80486d:	c6 43 08 01          	movb   $0x1,0x8(%ebx)
          MEM_STATS_INC_USED(used, mem->next - ((u8_t *)mem - ram));
        }

        if (mem == lfree) {
  804871:	3b 1d 24 63 81 00    	cmp    0x816324,%ebx
  804877:	75 2c                	jne    8048a5 <mem_malloc+0xe6>
          /* Find next free block after mem and update lowest free pointer */
          while (lfree->used && lfree != ram_end) {
  804879:	8b 15 28 63 81 00    	mov    0x816328,%edx
            LWIP_MEM_ALLOC_UNPROTECT();
            /* prevent high interrupt latency... */
            LWIP_MEM_ALLOC_PROTECT();
            lfree = (struct mem *)&ram[lfree->next];
  80487f:	8b 0d 2c 63 81 00    	mov    0x81632c,%ecx
  804885:	89 d8                	mov    %ebx,%eax
  804887:	eb 06                	jmp    80488f <mem_malloc+0xd0>
  804889:	89 cf                	mov    %ecx,%edi
  80488b:	03 38                	add    (%eax),%edi
  80488d:	89 f8                	mov    %edi,%eax
          MEM_STATS_INC_USED(used, mem->next - ((u8_t *)mem - ram));
        }

        if (mem == lfree) {
          /* Find next free block after mem and update lowest free pointer */
          while (lfree->used && lfree != ram_end) {
  80488f:	80 78 08 00          	cmpb   $0x0,0x8(%eax)
  804893:	75 07                	jne    80489c <mem_malloc+0xdd>
  804895:	a3 24 63 81 00       	mov    %eax,0x816324
  80489a:	eb 09                	jmp    8048a5 <mem_malloc+0xe6>
  80489c:	39 c2                	cmp    %eax,%edx
  80489e:	75 e9                	jne    804889 <mem_malloc+0xca>
  8048a0:	a3 24 63 81 00       	mov    %eax,0x816324
            lfree = (struct mem *)&ram[lfree->next];
          }
          LWIP_ASSERT("mem_malloc: !lfree->used", ((lfree == ram_end) || (!lfree->used)));
        }
        LWIP_MEM_ALLOC_UNPROTECT();
        sys_sem_signal(mem_sem);
  8048a5:	a1 20 63 81 00       	mov    0x816320,%eax
  8048aa:	89 04 24             	mov    %eax,(%esp)
  8048ad:	e8 4e 60 00 00       	call   80a900 <sys_sem_signal>
        LWIP_ASSERT("mem_malloc: allocated memory not above ram_end.",
  8048b2:	8d 44 33 0c          	lea    0xc(%ebx,%esi,1),%eax
  8048b6:	39 05 28 63 81 00    	cmp    %eax,0x816328
  8048bc:	73 1c                	jae    8048da <mem_malloc+0x11b>
  8048be:	c7 44 24 08 e4 24 81 	movl   $0x8124e4,0x8(%esp)
  8048c5:	00 
  8048c6:	c7 44 24 04 4b 02 00 	movl   $0x24b,0x4(%esp)
  8048cd:	00 
  8048ce:	c7 04 24 67 25 81 00 	movl   $0x812567,(%esp)
  8048d5:	e8 a0 a7 00 00       	call   80f07a <_panic>
         (mem_ptr_t)mem + SIZEOF_STRUCT_MEM + size <= (mem_ptr_t)ram_end);
        LWIP_ASSERT("mem_malloc: allocated memory properly aligned.",
  8048da:	8d 43 0c             	lea    0xc(%ebx),%eax
  8048dd:	a8 03                	test   $0x3,%al
  8048df:	74 1c                	je     8048fd <mem_malloc+0x13e>
  8048e1:	c7 44 24 08 14 25 81 	movl   $0x812514,0x8(%esp)
  8048e8:	00 
  8048e9:	c7 44 24 04 4d 02 00 	movl   $0x24d,0x4(%esp)
  8048f0:	00 
  8048f1:	c7 04 24 67 25 81 00 	movl   $0x812567,(%esp)
  8048f8:	e8 7d a7 00 00       	call   80f07a <_panic>
         (unsigned long)((u8_t *)mem + SIZEOF_STRUCT_MEM) % MEM_ALIGNMENT == 0);
        LWIP_ASSERT("mem_malloc: sanity check alignment",
  8048fd:	f6 c3 03             	test   $0x3,%bl
  804900:	74 46                	je     804948 <mem_malloc+0x189>
  804902:	c7 44 24 08 44 25 81 	movl   $0x812544,0x8(%esp)
  804909:	00 
  80490a:	c7 44 24 04 4f 02 00 	movl   $0x24f,0x4(%esp)
  804911:	00 
  804912:	c7 04 24 67 25 81 00 	movl   $0x812567,(%esp)
  804919:	e8 5c a7 00 00       	call   80f07a <_panic>

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (u8_t *)lfree - ram; ptr < MEM_SIZE_ALIGNED - size;
         ptr = ((struct mem *)&ram[ptr])->next) {
  80491e:	8b 03                	mov    (%ebx),%eax
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (u8_t *)lfree - ram; ptr < MEM_SIZE_ALIGNED - size;
  804920:	39 c8                	cmp    %ecx,%eax
  804922:	0f 82 f6 fe ff ff    	jb     80481e <mem_malloc+0x5f>
  } while(local_mem_free_count != 0);
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_DEBUGF(MEM_DEBUG | 2, ("mem_malloc: could not allocate %"S16_F" bytes\n", (s16_t)size));
  MEM_STATS_INC(err);
  LWIP_MEM_ALLOC_UNPROTECT();
  sys_sem_signal(mem_sem);
  804928:	a1 20 63 81 00       	mov    0x816320,%eax
  80492d:	89 04 24             	mov    %eax,(%esp)
  804930:	e8 cb 5f 00 00       	call   80a900 <sys_sem_signal>
  return NULL;
  804935:	b8 00 00 00 00       	mov    $0x0,%eax
  80493a:	eb 0c                	jmp    804948 <mem_malloc+0x189>
  u8_t local_mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_ALLOC_DECL_PROTECT();

  if (size == 0) {
    return NULL;
  80493c:	b8 00 00 00 00       	mov    $0x0,%eax
  804941:	eb 05                	jmp    804948 <mem_malloc+0x189>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    size = MIN_SIZE_ALIGNED;
  }

  if (size > MEM_SIZE_ALIGNED) {
    return NULL;
  804943:	b8 00 00 00 00       	mov    $0x0,%eax
  LWIP_DEBUGF(MEM_DEBUG | 2, ("mem_malloc: could not allocate %"S16_F" bytes\n", (s16_t)size));
  MEM_STATS_INC(err);
  LWIP_MEM_ALLOC_UNPROTECT();
  sys_sem_signal(mem_sem);
  return NULL;
}
  804948:	83 c4 1c             	add    $0x1c,%esp
  80494b:	5b                   	pop    %ebx
  80494c:	5e                   	pop    %esi
  80494d:	5f                   	pop    %edi
  80494e:	5d                   	pop    %ebp
  80494f:	c3                   	ret    

00804950 <mem_calloc>:
 * @param count number of objects to allocate
 * @param size size of the objects to allocate
 * @return pointer to allocated memory / NULL pointer if there is an error
 */
void *mem_calloc(mem_size_t count, mem_size_t size)
{
  804950:	55                   	push   %ebp
  804951:	89 e5                	mov    %esp,%ebp
  804953:	56                   	push   %esi
  804954:	53                   	push   %ebx
  804955:	83 ec 10             	sub    $0x10,%esp
  void *p;

  /* allocate 'count' objects of size 'size' */
  p = mem_malloc(count * size);
  804958:	8b 75 0c             	mov    0xc(%ebp),%esi
  80495b:	0f af 75 08          	imul   0x8(%ebp),%esi
  80495f:	89 34 24             	mov    %esi,(%esp)
  804962:	e8 58 fe ff ff       	call   8047bf <mem_malloc>
  804967:	89 c3                	mov    %eax,%ebx
  if (p) {
  804969:	85 c0                	test   %eax,%eax
  80496b:	74 14                	je     804981 <mem_calloc+0x31>
    /* zero the memory */
    memset(p, 0, count * size);
  80496d:	89 74 24 08          	mov    %esi,0x8(%esp)
  804971:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  804978:	00 
  804979:	89 04 24             	mov    %eax,(%esp)
  80497c:	e8 66 af 00 00       	call   80f8e7 <memset>
  }
  return p;
}
  804981:	89 d8                	mov    %ebx,%eax
  804983:	83 c4 10             	add    $0x10,%esp
  804986:	5b                   	pop    %ebx
  804987:	5e                   	pop    %esi
  804988:	5d                   	pop    %ebp
  804989:	c3                   	ret    

0080498a <memp_init>:
 * 
 * Carves out memp_memory into linked lists for each pool-type.
 */
void
memp_init(void)
{
  80498a:	55                   	push   %ebp
  80498b:	89 e5                	mov    %esp,%ebp
  80498d:	56                   	push   %esi
  80498e:	53                   	push   %ebx
    MEMP_STATS_AVAIL(max, i, 0);
    MEMP_STATS_AVAIL(err, i, 0);
    MEMP_STATS_AVAIL(avail, i, memp_num[i]);
  }

  memp = LWIP_MEM_ALIGN(memp_memory);
  80498f:	b8 63 63 a3 00       	mov    $0xa36363,%eax
  804994:	83 e0 fc             	and    $0xfffffffc,%eax
  804997:	ba 00 00 00 00       	mov    $0x0,%edx
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
    memp_tab[i] = NULL;
  80499c:	c7 84 12 e0 53 b3 00 	movl   $0x0,0xb353e0(%edx,%edx,1)
  8049a3:	00 00 00 00 
    /* create a linked list of memp elements */
    for (j = 0; j < memp_num[i]; ++j) {
  8049a7:	0f b7 b2 68 26 81 00 	movzwl 0x812668(%edx),%esi
  8049ae:	b9 00 00 00 00       	mov    $0x0,%ecx
  8049b3:	eb 1c                	jmp    8049d1 <memp_init+0x47>
      memp->next = memp_tab[i];
  8049b5:	8b 9c 12 e0 53 b3 00 	mov    0xb353e0(%edx,%edx,1),%ebx
  8049bc:	89 18                	mov    %ebx,(%eax)
      memp_tab[i] = memp;
  8049be:	89 84 12 e0 53 b3 00 	mov    %eax,0xb353e0(%edx,%edx,1)
      memp = (struct memp *)((u8_t *)memp + MEMP_SIZE + memp_sizes[i]);
  8049c5:	0f b7 9a 84 26 81 00 	movzwl 0x812684(%edx),%ebx
  8049cc:	01 d8                	add    %ebx,%eax
  memp = LWIP_MEM_ALIGN(memp_memory);
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
    memp_tab[i] = NULL;
    /* create a linked list of memp elements */
    for (j = 0; j < memp_num[i]; ++j) {
  8049ce:	83 c1 01             	add    $0x1,%ecx
  8049d1:	66 39 f1             	cmp    %si,%cx
  8049d4:	75 df                	jne    8049b5 <memp_init+0x2b>
  8049d6:	83 c2 02             	add    $0x2,%edx
    MEMP_STATS_AVAIL(avail, i, memp_num[i]);
  }

  memp = LWIP_MEM_ALIGN(memp_memory);
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
  8049d9:	83 fa 1c             	cmp    $0x1c,%edx
  8049dc:	75 be                	jne    80499c <memp_init+0x12>
#if MEMP_OVERFLOW_CHECK
  memp_overflow_init();
  /* check everything a first time to see if it worked */
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK */
}
  8049de:	5b                   	pop    %ebx
  8049df:	5e                   	pop    %esi
  8049e0:	5d                   	pop    %ebp
  8049e1:	c3                   	ret    

008049e2 <memp_malloc>:
#if !MEMP_OVERFLOW_CHECK
memp_malloc(memp_t type)
#else
memp_malloc_fn(memp_t type, const char* file, const int line)
#endif
{
  8049e2:	55                   	push   %ebp
  8049e3:	89 e5                	mov    %esp,%ebp
  8049e5:	83 ec 18             	sub    $0x18,%esp
  8049e8:	8b 55 08             	mov    0x8(%ebp),%edx
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);
 
  LWIP_ERROR("memp_malloc: type < MEMP_MAX", (type < MEMP_MAX), return NULL;);
  8049eb:	83 fa 0d             	cmp    $0xd,%edx
  8049ee:	76 1c                	jbe    804a0c <memp_malloc+0x2a>
  8049f0:	c7 44 24 08 f1 25 81 	movl   $0x8125f1,0x8(%esp)
  8049f7:	00 
  8049f8:	c7 44 24 04 2d 01 00 	movl   $0x12d,0x4(%esp)
  8049ff:	00 
  804a00:	c7 04 24 0e 26 81 00 	movl   $0x81260e,(%esp)
  804a07:	e8 6e a6 00 00       	call   80f07a <_panic>
  SYS_ARCH_PROTECT(old_level);
#if MEMP_OVERFLOW_CHECK >= 2
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK >= 2 */

  memp = memp_tab[type];
  804a0c:	8b 04 95 e0 53 b3 00 	mov    0xb353e0(,%edx,4),%eax
  
  if (memp != NULL) {    
  804a13:	85 c0                	test   %eax,%eax
  804a15:	74 29                	je     804a40 <memp_malloc+0x5e>
    memp_tab[type] = memp->next;    
  804a17:	8b 08                	mov    (%eax),%ecx
  804a19:	89 0c 95 e0 53 b3 00 	mov    %ecx,0xb353e0(,%edx,4)
    memp->next = NULL;
    memp->file = file;
    memp->line = line;
#endif /* MEMP_OVERFLOW_CHECK */
    MEMP_STATS_INC_USED(used, type);
    LWIP_ASSERT("memp_malloc: memp properly aligned",
  804a20:	a8 03                	test   $0x3,%al
  804a22:	74 1c                	je     804a40 <memp_malloc+0x5e>
  804a24:	c7 44 24 08 24 26 81 	movl   $0x812624,0x8(%esp)
  804a2b:	00 
  804a2c:	c7 44 24 04 3f 01 00 	movl   $0x13f,0x4(%esp)
  804a33:	00 
  804a34:	c7 04 24 0e 26 81 00 	movl   $0x81260e,(%esp)
  804a3b:	e8 3a a6 00 00       	call   80f07a <_panic>
  }

  SYS_ARCH_UNPROTECT(old_level);

  return memp;
}
  804a40:	c9                   	leave  
  804a41:	c3                   	ret    

00804a42 <memp_free>:
 * @param type the pool where to put mem
 * @param mem the memp element to free
 */
void
memp_free(memp_t type, void *mem)
{
  804a42:	55                   	push   %ebp
  804a43:	89 e5                	mov    %esp,%ebp
  804a45:	83 ec 18             	sub    $0x18,%esp
  804a48:	8b 55 08             	mov    0x8(%ebp),%edx
  804a4b:	8b 45 0c             	mov    0xc(%ebp),%eax
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);

  if (mem == NULL) {
  804a4e:	85 c0                	test   %eax,%eax
  804a50:	74 30                	je     804a82 <memp_free+0x40>
    return;
  }
  LWIP_ASSERT("memp_free: mem properly aligned",
  804a52:	a8 03                	test   $0x3,%al
  804a54:	74 1c                	je     804a72 <memp_free+0x30>
  804a56:	c7 44 24 08 48 26 81 	movl   $0x812648,0x8(%esp)
  804a5d:	00 
  804a5e:	c7 44 24 04 5b 01 00 	movl   $0x15b,0x4(%esp)
  804a65:	00 
  804a66:	c7 04 24 0e 26 81 00 	movl   $0x81260e,(%esp)
  804a6d:	e8 08 a6 00 00       	call   80f07a <_panic>
#endif /* MEMP_OVERFLOW_CHECK >= 2 */
#endif /* MEMP_OVERFLOW_CHECK */

  MEMP_STATS_DEC(used, type); 
  
  memp->next = memp_tab[type]; 
  804a72:	8b 0c 95 e0 53 b3 00 	mov    0xb353e0(,%edx,4),%ecx
  804a79:	89 08                	mov    %ecx,(%eax)
  memp_tab[type] = memp;
  804a7b:	89 04 95 e0 53 b3 00 	mov    %eax,0xb353e0(,%edx,4)
#if MEMP_SANITY_CHECK
  LWIP_ASSERT("memp sanity", memp_sanity());
#endif /* MEMP_SANITY_CHECK */

  SYS_ARCH_UNPROTECT(old_level);
}
  804a82:	c9                   	leave  
  804a83:	c3                   	ret    
  804a84:	66 90                	xchg   %ax,%ax
  804a86:	66 90                	xchg   %ax,%ax
  804a88:	66 90                	xchg   %ax,%ax
  804a8a:	66 90                	xchg   %ax,%ax
  804a8c:	66 90                	xchg   %ax,%ax
  804a8e:	66 90                	xchg   %ax,%ax

00804a90 <netif_remove>:
 * Remove a network interface from the list of lwIP netifs.
 *
 * @param netif the network interface to remove
 */
void netif_remove(struct netif * netif)
{
  804a90:	55                   	push   %ebp
  804a91:	89 e5                	mov    %esp,%ebp
  804a93:	8b 4d 08             	mov    0x8(%ebp),%ecx
  if ( netif == NULL ) return;
  804a96:	85 c9                	test   %ecx,%ecx
  804a98:	74 3c                	je     804ad6 <netif_remove+0x46>
#endif /* LWIP_IGMP */

  snmp_delete_ipaddridx_tree(netif);

  /*  is it the first netif? */
  if (netif_list == netif) {
  804a9a:	a1 54 c2 b3 00       	mov    0xb3c254,%eax
  804a9f:	39 c8                	cmp    %ecx,%eax
  804aa1:	75 19                	jne    804abc <netif_remove+0x2c>
    netif_list = netif->next;
  804aa3:	8b 00                	mov    (%eax),%eax
  804aa5:	a3 54 c2 b3 00       	mov    %eax,0xb3c254
  804aaa:	eb 18                	jmp    804ac4 <netif_remove+0x34>
  }
  else {
    /*  look for netif further down the list */
    struct netif * tmpNetif;
    for (tmpNetif = netif_list; tmpNetif != NULL; tmpNetif = tmpNetif->next) {
      if (tmpNetif->next == netif) {
  804aac:	8b 10                	mov    (%eax),%edx
  804aae:	39 ca                	cmp    %ecx,%edx
  804ab0:	74 04                	je     804ab6 <netif_remove+0x26>
    snmp_dec_iflist();
  }
  else {
    /*  look for netif further down the list */
    struct netif * tmpNetif;
    for (tmpNetif = netif_list; tmpNetif != NULL; tmpNetif = tmpNetif->next) {
  804ab2:	89 d0                	mov    %edx,%eax
  804ab4:	eb 06                	jmp    804abc <netif_remove+0x2c>
      if (tmpNetif->next == netif) {
        tmpNetif->next = netif->next;
  804ab6:	8b 11                	mov    (%ecx),%edx
  804ab8:	89 10                	mov    %edx,(%eax)
  804aba:	eb 08                	jmp    804ac4 <netif_remove+0x34>
    snmp_dec_iflist();
  }
  else {
    /*  look for netif further down the list */
    struct netif * tmpNetif;
    for (tmpNetif = netif_list; tmpNetif != NULL; tmpNetif = tmpNetif->next) {
  804abc:	85 c0                	test   %eax,%eax
  804abe:	66 90                	xchg   %ax,%ax
  804ac0:	75 ea                	jne    804aac <netif_remove+0x1c>
  804ac2:	eb 12                	jmp    804ad6 <netif_remove+0x46>
    }
    if (tmpNetif == NULL)
      return; /*  we didn't find any netif today */
  }
  /* this netif is default? */
  if (netif_default == netif)
  804ac4:	39 0d 58 c2 b3 00    	cmp    %ecx,0xb3c258
  804aca:	75 0a                	jne    804ad6 <netif_remove+0x46>
  else
  {
    /* install default route */
    snmp_insert_iprteidx_tree(1, netif);
  }
  netif_default = netif;
  804acc:	c7 05 58 c2 b3 00 00 	movl   $0x0,0xb3c258
  804ad3:	00 00 00 
  /* this netif is default? */
  if (netif_default == netif)
    /* reset default netif */
    netif_set_default(NULL);
  LWIP_DEBUGF( NETIF_DEBUG, ("netif_remove: removed netif\n") );
}
  804ad6:	5d                   	pop    %ebp
  804ad7:	c3                   	ret    

00804ad8 <netif_find>:
 * @param name the name of the netif (like netif->name) plus concatenated number
 * in ascii representation (e.g. 'en0')
 */
struct netif *
netif_find(char *name)
{
  804ad8:	55                   	push   %ebp
  804ad9:	89 e5                	mov    %esp,%ebp
  804adb:	53                   	push   %ebx
  804adc:	8b 4d 08             	mov    0x8(%ebp),%ecx
  struct netif *netif;
  u8_t num;

  if (name == NULL) {
  804adf:	85 c9                	test   %ecx,%ecx
  804ae1:	74 2c                	je     804b0f <netif_find+0x37>
    return NULL;
  }

  num = name[2] - '0';
  804ae3:	0f b6 41 02          	movzbl 0x2(%ecx),%eax
  804ae7:	8d 50 d0             	lea    -0x30(%eax),%edx

  for(netif = netif_list; netif != NULL; netif = netif->next) {
  804aea:	a1 54 c2 b3 00       	mov    0xb3c254,%eax
  804aef:	eb 18                	jmp    804b09 <netif_find+0x31>
    if (num == netif->num &&
  804af1:	38 50 31             	cmp    %dl,0x31(%eax)
  804af4:	75 11                	jne    804b07 <netif_find+0x2f>
  804af6:	0f b6 58 2f          	movzbl 0x2f(%eax),%ebx
  804afa:	38 19                	cmp    %bl,(%ecx)
  804afc:	75 09                	jne    804b07 <netif_find+0x2f>
       name[0] == netif->name[0] &&
  804afe:	0f b6 58 30          	movzbl 0x30(%eax),%ebx
  804b02:	38 59 01             	cmp    %bl,0x1(%ecx)
  804b05:	74 0d                	je     804b14 <netif_find+0x3c>
    return NULL;
  }

  num = name[2] - '0';

  for(netif = netif_list; netif != NULL; netif = netif->next) {
  804b07:	8b 00                	mov    (%eax),%eax
  804b09:	85 c0                	test   %eax,%eax
  804b0b:	75 e4                	jne    804af1 <netif_find+0x19>
  804b0d:	eb 05                	jmp    804b14 <netif_find+0x3c>
{
  struct netif *netif;
  u8_t num;

  if (name == NULL) {
    return NULL;
  804b0f:	b8 00 00 00 00       	mov    $0x0,%eax
      return netif;
    }
  }
  LWIP_DEBUGF(NETIF_DEBUG, ("netif_find: didn't find %c%c\n", name[0], name[1]));
  return NULL;
}
  804b14:	5b                   	pop    %ebx
  804b15:	5d                   	pop    %ebp
  804b16:	c3                   	ret    

00804b17 <netif_set_ipaddr>:
 * @note call netif_set_addr() if you also want to change netmask and
 * default gateway
 */
void
netif_set_ipaddr(struct netif *netif, struct ip_addr *ipaddr)
{
  804b17:	55                   	push   %ebp
  804b18:	89 e5                	mov    %esp,%ebp
  804b1a:	57                   	push   %edi
  804b1b:	56                   	push   %esi
  804b1c:	53                   	push   %ebx
  804b1d:	83 ec 1c             	sub    $0x1c,%esp
  804b20:	8b 5d 08             	mov    0x8(%ebp),%ebx
  804b23:	8b 75 0c             	mov    0xc(%ebp),%esi
#if LWIP_TCP
  struct tcp_pcb *pcb;
  struct tcp_pcb_listen *lpcb;

  /* address is actually being changed? */
  if ((ip_addr_cmp(ipaddr, &(netif->ip_addr))) == 0)
  804b26:	8b 43 04             	mov    0x4(%ebx),%eax
  804b29:	39 06                	cmp    %eax,(%esi)
  804b2b:	74 53                	je     804b80 <netif_set_ipaddr+0x69>
  {
    /* extern struct tcp_pcb *tcp_active_pcbs; defined by tcp.h */
    LWIP_DEBUGF(NETIF_DEBUG | 1, ("netif_set_ipaddr: netif address being changed\n"));
    pcb = tcp_active_pcbs;
  804b2d:	a1 5c c2 b3 00       	mov    0xb3c25c,%eax
    while (pcb != NULL) {
  804b32:	eb 19                	jmp    804b4d <netif_set_ipaddr+0x36>
      /* PCB bound to current local interface address? */
      if (ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))) {
  804b34:	8b 4b 04             	mov    0x4(%ebx),%ecx
  804b37:	39 08                	cmp    %ecx,(%eax)
  804b39:	75 0f                	jne    804b4a <netif_set_ipaddr+0x33>
        /* this connection must be aborted */
        struct tcp_pcb *next = pcb->next;
  804b3b:	8b 78 0c             	mov    0xc(%eax),%edi
        LWIP_DEBUGF(NETIF_DEBUG | 1, ("netif_set_ipaddr: aborting TCP pcb %p\n", (void *)pcb));
        tcp_abort(pcb);
  804b3e:	89 04 24             	mov    %eax,(%esp)
  804b41:	e8 93 16 00 00       	call   8061d9 <tcp_abort>
        pcb = next;
  804b46:	89 f8                	mov    %edi,%eax
  804b48:	eb 03                	jmp    804b4d <netif_set_ipaddr+0x36>
      } else {
        pcb = pcb->next;
  804b4a:	8b 40 0c             	mov    0xc(%eax),%eax
  if ((ip_addr_cmp(ipaddr, &(netif->ip_addr))) == 0)
  {
    /* extern struct tcp_pcb *tcp_active_pcbs; defined by tcp.h */
    LWIP_DEBUGF(NETIF_DEBUG | 1, ("netif_set_ipaddr: netif address being changed\n"));
    pcb = tcp_active_pcbs;
    while (pcb != NULL) {
  804b4d:	85 c0                	test   %eax,%eax
  804b4f:	75 e3                	jne    804b34 <netif_set_ipaddr+0x1d>
        pcb = next;
      } else {
        pcb = pcb->next;
      }
    }
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  804b51:	a1 64 c2 b3 00       	mov    0xb3c264,%eax
  804b56:	eb 24                	jmp    804b7c <netif_set_ipaddr+0x65>
      /* PCB bound to current local interface address? */
      if ((!(ip_addr_isany(&(lpcb->local_ip)))) &&
  804b58:	85 c0                	test   %eax,%eax
  804b5a:	74 1d                	je     804b79 <netif_set_ipaddr+0x62>
  804b5c:	8b 10                	mov    (%eax),%edx
  804b5e:	85 d2                	test   %edx,%edx
  804b60:	74 17                	je     804b79 <netif_set_ipaddr+0x62>
  804b62:	3b 53 04             	cmp    0x4(%ebx),%edx
  804b65:	75 12                	jne    804b79 <netif_set_ipaddr+0x62>
          (ip_addr_cmp(&(lpcb->local_ip), &(netif->ip_addr)))) {
        /* The PCB is listening to the old ipaddr and
         * is set to listen to the new one instead */
        ip_addr_set(&(lpcb->local_ip), ipaddr);
  804b67:	85 f6                	test   %esi,%esi
  804b69:	74 07                	je     804b72 <netif_set_ipaddr+0x5b>
  804b6b:	8b 16                	mov    (%esi),%edx
  804b6d:	8d 76 00             	lea    0x0(%esi),%esi
  804b70:	eb 05                	jmp    804b77 <netif_set_ipaddr+0x60>
  804b72:	ba 00 00 00 00       	mov    $0x0,%edx
  804b77:	89 10                	mov    %edx,(%eax)
        pcb = next;
      } else {
        pcb = pcb->next;
      }
    }
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  804b79:	8b 40 0c             	mov    0xc(%eax),%eax
  804b7c:	85 c0                	test   %eax,%eax
  804b7e:	75 d8                	jne    804b58 <netif_set_ipaddr+0x41>
  }
#endif
  snmp_delete_ipaddridx_tree(netif);
  snmp_delete_iprteidx_tree(0,netif);
  /* set new IP address to netif */
  ip_addr_set(&(netif->ip_addr), ipaddr);
  804b80:	85 f6                	test   %esi,%esi
  804b82:	74 04                	je     804b88 <netif_set_ipaddr+0x71>
  804b84:	8b 06                	mov    (%esi),%eax
  804b86:	eb 05                	jmp    804b8d <netif_set_ipaddr+0x76>
  804b88:	b8 00 00 00 00       	mov    $0x0,%eax
  804b8d:	89 43 04             	mov    %eax,0x4(%ebx)
    netif->name[0], netif->name[1],
    ip4_addr1(&netif->ip_addr),
    ip4_addr2(&netif->ip_addr),
    ip4_addr3(&netif->ip_addr),
    ip4_addr4(&netif->ip_addr)));
}
  804b90:	83 c4 1c             	add    $0x1c,%esp
  804b93:	5b                   	pop    %ebx
  804b94:	5e                   	pop    %esi
  804b95:	5f                   	pop    %edi
  804b96:	5d                   	pop    %ebp
  804b97:	c3                   	ret    

00804b98 <netif_set_addr>:
 * @param gw the new default gateway
 */
void
netif_set_addr(struct netif *netif, struct ip_addr *ipaddr, struct ip_addr *netmask,
    struct ip_addr *gw)
{
  804b98:	55                   	push   %ebp
  804b99:	89 e5                	mov    %esp,%ebp
  804b9b:	57                   	push   %edi
  804b9c:	56                   	push   %esi
  804b9d:	53                   	push   %ebx
  804b9e:	83 ec 1c             	sub    $0x1c,%esp
  804ba1:	8b 5d 08             	mov    0x8(%ebp),%ebx
  804ba4:	8b 7d 10             	mov    0x10(%ebp),%edi
  804ba7:	8b 75 14             	mov    0x14(%ebp),%esi
  netif_set_ipaddr(netif, ipaddr);
  804baa:	8b 45 0c             	mov    0xc(%ebp),%eax
  804bad:	89 44 24 04          	mov    %eax,0x4(%esp)
  804bb1:	89 1c 24             	mov    %ebx,(%esp)
  804bb4:	e8 5e ff ff ff       	call   804b17 <netif_set_ipaddr>
void
netif_set_netmask(struct netif *netif, struct ip_addr *netmask)
{
  snmp_delete_iprteidx_tree(0, netif);
  /* set new netmask to netif */
  ip_addr_set(&(netif->netmask), netmask);
  804bb9:	85 ff                	test   %edi,%edi
  804bbb:	74 04                	je     804bc1 <netif_set_addr+0x29>
  804bbd:	8b 07                	mov    (%edi),%eax
  804bbf:	eb 05                	jmp    804bc6 <netif_set_addr+0x2e>
  804bc1:	b8 00 00 00 00       	mov    $0x0,%eax
  804bc6:	89 43 08             	mov    %eax,0x8(%ebx)
 * @note call netif_set_addr() if you also want to change ip address and netmask
 */
void
netif_set_gw(struct netif *netif, struct ip_addr *gw)
{
  ip_addr_set(&(netif->gw), gw);
  804bc9:	85 f6                	test   %esi,%esi
  804bcb:	74 04                	je     804bd1 <netif_set_addr+0x39>
  804bcd:	8b 06                	mov    (%esi),%eax
  804bcf:	eb 05                	jmp    804bd6 <netif_set_addr+0x3e>
  804bd1:	b8 00 00 00 00       	mov    $0x0,%eax
  804bd6:	89 43 0c             	mov    %eax,0xc(%ebx)
    struct ip_addr *gw)
{
  netif_set_ipaddr(netif, ipaddr);
  netif_set_netmask(netif, netmask);
  netif_set_gw(netif, gw);
}
  804bd9:	83 c4 1c             	add    $0x1c,%esp
  804bdc:	5b                   	pop    %ebx
  804bdd:	5e                   	pop    %esi
  804bde:	5f                   	pop    %edi
  804bdf:	5d                   	pop    %ebp
  804be0:	c3                   	ret    

00804be1 <netif_add>:
netif_add(struct netif *netif, struct ip_addr *ipaddr, struct ip_addr *netmask,
  struct ip_addr *gw,
  void *state,
  err_t (* init)(struct netif *netif),
  err_t (* input)(struct pbuf *p, struct netif *netif))
{
  804be1:	55                   	push   %ebp
  804be2:	89 e5                	mov    %esp,%ebp
  804be4:	53                   	push   %ebx
  804be5:	83 ec 14             	sub    $0x14,%esp
  804be8:	8b 5d 08             	mov    0x8(%ebp),%ebx
  static u8_t netifnum = 0;

  /* reset new interface configuration state */
  netif->ip_addr.addr = 0;
  804beb:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  netif->netmask.addr = 0;
  804bf2:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
  netif->gw.addr = 0;
  804bf9:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
  netif->flags = 0;
  804c00:	c6 43 2e 00          	movb   $0x0,0x2e(%ebx)
#if LWIP_DHCP
  /* netif not under DHCP control by default */
  netif->dhcp = NULL;
  804c04:	c7 43 20 00 00 00 00 	movl   $0x0,0x20(%ebx)
  netif->loop_first = NULL;
  netif->loop_last = NULL;
#endif /* ENABLE_LOOPBACK */

  /* remember netif specific state information data */
  netif->state = state;
  804c0b:	8b 45 18             	mov    0x18(%ebp),%eax
  804c0e:	89 43 1c             	mov    %eax,0x1c(%ebx)
  netif->num = netifnum++;
  804c11:	0f b6 05 18 54 b3 00 	movzbl 0xb35418,%eax
  804c18:	8d 50 01             	lea    0x1(%eax),%edx
  804c1b:	88 15 18 54 b3 00    	mov    %dl,0xb35418
  804c21:	88 43 31             	mov    %al,0x31(%ebx)
  netif->input = input;
  804c24:	8b 45 20             	mov    0x20(%ebp),%eax
  804c27:	89 43 10             	mov    %eax,0x10(%ebx)
#endif /* LWIP_NETIF_HWADDRHINT*/
#if ENABLE_LOOPBACK && LWIP_LOOPBACK_MAX_PBUFS
  netif->loop_cnt_current = 0;
#endif /* ENABLE_LOOPBACK && LWIP_LOOPBACK_MAX_PBUFS */

  netif_set_addr(netif, ipaddr, netmask, gw);
  804c2a:	8b 45 14             	mov    0x14(%ebp),%eax
  804c2d:	89 44 24 0c          	mov    %eax,0xc(%esp)
  804c31:	8b 45 10             	mov    0x10(%ebp),%eax
  804c34:	89 44 24 08          	mov    %eax,0x8(%esp)
  804c38:	8b 45 0c             	mov    0xc(%ebp),%eax
  804c3b:	89 44 24 04          	mov    %eax,0x4(%esp)
  804c3f:	89 1c 24             	mov    %ebx,(%esp)
  804c42:	e8 51 ff ff ff       	call   804b98 <netif_set_addr>

  /* call user specified initialization function for netif */
  if (init(netif) != ERR_OK) {
  804c47:	89 1c 24             	mov    %ebx,(%esp)
  804c4a:	ff 55 1c             	call   *0x1c(%ebp)
  804c4d:	84 c0                	test   %al,%al
  804c4f:	75 11                	jne    804c62 <netif_add+0x81>
    return NULL;
  }

  /* add this netif to the list */
  netif->next = netif_list;
  804c51:	a1 54 c2 b3 00       	mov    0xb3c254,%eax
  804c56:	89 03                	mov    %eax,(%ebx)
  netif_list = netif;
  804c58:	89 1d 54 c2 b3 00    	mov    %ebx,0xb3c254
  LWIP_DEBUGF(NETIF_DEBUG, (" netmask "));
  ip_addr_debug_print(NETIF_DEBUG, netmask);
  LWIP_DEBUGF(NETIF_DEBUG, (" gw "));
  ip_addr_debug_print(NETIF_DEBUG, gw);
  LWIP_DEBUGF(NETIF_DEBUG, ("\n"));
  return netif;
  804c5e:	89 d8                	mov    %ebx,%eax
  804c60:	eb 05                	jmp    804c67 <netif_add+0x86>

  netif_set_addr(netif, ipaddr, netmask, gw);

  /* call user specified initialization function for netif */
  if (init(netif) != ERR_OK) {
    return NULL;
  804c62:	b8 00 00 00 00       	mov    $0x0,%eax
  ip_addr_debug_print(NETIF_DEBUG, netmask);
  LWIP_DEBUGF(NETIF_DEBUG, (" gw "));
  ip_addr_debug_print(NETIF_DEBUG, gw);
  LWIP_DEBUGF(NETIF_DEBUG, ("\n"));
  return netif;
}
  804c67:	83 c4 14             	add    $0x14,%esp
  804c6a:	5b                   	pop    %ebx
  804c6b:	5d                   	pop    %ebp
  804c6c:	c3                   	ret    

00804c6d <netif_set_gw>:
 *
 * @note call netif_set_addr() if you also want to change ip address and netmask
 */
void
netif_set_gw(struct netif *netif, struct ip_addr *gw)
{
  804c6d:	55                   	push   %ebp
  804c6e:	89 e5                	mov    %esp,%ebp
  804c70:	8b 45 0c             	mov    0xc(%ebp),%eax
  ip_addr_set(&(netif->gw), gw);
  804c73:	85 c0                	test   %eax,%eax
  804c75:	74 04                	je     804c7b <netif_set_gw+0xe>
  804c77:	8b 10                	mov    (%eax),%edx
  804c79:	eb 05                	jmp    804c80 <netif_set_gw+0x13>
  804c7b:	ba 00 00 00 00       	mov    $0x0,%edx
  804c80:	8b 45 08             	mov    0x8(%ebp),%eax
  804c83:	89 50 0c             	mov    %edx,0xc(%eax)
    netif->name[0], netif->name[1],
    ip4_addr1(&netif->gw),
    ip4_addr2(&netif->gw),
    ip4_addr3(&netif->gw),
    ip4_addr4(&netif->gw)));
}
  804c86:	5d                   	pop    %ebp
  804c87:	c3                   	ret    

00804c88 <netif_set_netmask>:
 * @note call netif_set_addr() if you also want to change ip address and
 * default gateway
 */
void
netif_set_netmask(struct netif *netif, struct ip_addr *netmask)
{
  804c88:	55                   	push   %ebp
  804c89:	89 e5                	mov    %esp,%ebp
  804c8b:	8b 45 0c             	mov    0xc(%ebp),%eax
  snmp_delete_iprteidx_tree(0, netif);
  /* set new netmask to netif */
  ip_addr_set(&(netif->netmask), netmask);
  804c8e:	85 c0                	test   %eax,%eax
  804c90:	74 04                	je     804c96 <netif_set_netmask+0xe>
  804c92:	8b 10                	mov    (%eax),%edx
  804c94:	eb 05                	jmp    804c9b <netif_set_netmask+0x13>
  804c96:	ba 00 00 00 00       	mov    $0x0,%edx
  804c9b:	8b 45 08             	mov    0x8(%ebp),%eax
  804c9e:	89 50 08             	mov    %edx,0x8(%eax)
    netif->name[0], netif->name[1],
    ip4_addr1(&netif->netmask),
    ip4_addr2(&netif->netmask),
    ip4_addr3(&netif->netmask),
    ip4_addr4(&netif->netmask)));
}
  804ca1:	5d                   	pop    %ebp
  804ca2:	c3                   	ret    

00804ca3 <netif_set_default>:
 *
 * @param netif the default network interface
 */
void
netif_set_default(struct netif *netif)
{
  804ca3:	55                   	push   %ebp
  804ca4:	89 e5                	mov    %esp,%ebp
  else
  {
    /* install default route */
    snmp_insert_iprteidx_tree(1, netif);
  }
  netif_default = netif;
  804ca6:	8b 45 08             	mov    0x8(%ebp),%eax
  804ca9:	a3 58 c2 b3 00       	mov    %eax,0xb3c258
  LWIP_DEBUGF(NETIF_DEBUG, ("netif: setting default interface %c%c\n",
           netif ? netif->name[0] : '\'', netif ? netif->name[1] : '\''));
}
  804cae:	5d                   	pop    %ebp
  804caf:	c3                   	ret    

00804cb0 <netif_set_up>:
 * up once configured.
 * 
 * @see dhcp_start()
 */ 
void netif_set_up(struct netif *netif)
{
  804cb0:	55                   	push   %ebp
  804cb1:	89 e5                	mov    %esp,%ebp
  804cb3:	83 ec 18             	sub    $0x18,%esp
  804cb6:	8b 55 08             	mov    0x8(%ebp),%edx
  if ( !(netif->flags & NETIF_FLAG_UP )) {
  804cb9:	0f b6 42 2e          	movzbl 0x2e(%edx),%eax
  804cbd:	a8 01                	test   $0x1,%al
  804cbf:	75 23                	jne    804ce4 <netif_set_up+0x34>
    netif->flags |= NETIF_FLAG_UP;
  804cc1:	89 c1                	mov    %eax,%ecx
  804cc3:	83 c9 01             	or     $0x1,%ecx
  804cc6:	88 4a 2e             	mov    %cl,0x2e(%edx)
    /** For Ethernet network interfaces, we would like to send a
     *  "gratuitous ARP"; this is an ARP packet sent by a node in order
     *  to spontaneously cause other nodes to update an entry in their
     *  ARP cache. From RFC 3220 "IP Mobility Support for IPv4" section 4.6.
     */ 
    if (netif->flags & NETIF_FLAG_ETHARP) {
  804cc9:	a8 20                	test   $0x20,%al
  804ccb:	74 17                	je     804ce4 <netif_set_up+0x34>
      etharp_query(netif, &(netif->ip_addr), NULL);
  804ccd:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  804cd4:	00 
  804cd5:	8d 42 04             	lea    0x4(%edx),%eax
  804cd8:	89 44 24 04          	mov    %eax,0x4(%esp)
  804cdc:	89 14 24             	mov    %edx,(%esp)
  804cdf:	e8 20 54 00 00       	call   80a104 <etharp_query>
    }
#endif /* LWIP_ARP */
    
  }
}
  804ce4:	c9                   	leave  
  804ce5:	c3                   	ret    

00804ce6 <netif_set_down>:
 * up once configured.
 * 
 * @see dhcp_start()
 */ 
void netif_set_down(struct netif *netif)
{
  804ce6:	55                   	push   %ebp
  804ce7:	89 e5                	mov    %esp,%ebp
  804ce9:	8b 45 08             	mov    0x8(%ebp),%eax
  if ( netif->flags & NETIF_FLAG_UP )
  804cec:	0f b6 50 2e          	movzbl 0x2e(%eax),%edx
  804cf0:	f6 c2 01             	test   $0x1,%dl
  804cf3:	74 06                	je     804cfb <netif_set_down+0x15>
    {
      netif->flags &= ~NETIF_FLAG_UP;
  804cf5:	83 e2 fe             	and    $0xfffffffe,%edx
  804cf8:	88 50 2e             	mov    %dl,0x2e(%eax)
#endif
      
      NETIF_LINK_CALLBACK(netif);
      NETIF_STATUS_CALLBACK(netif);
    }
}
  804cfb:	5d                   	pop    %ebp
  804cfc:	c3                   	ret    

00804cfd <netif_is_up>:

/**
 * Ask if an interface is up
 */ 
u8_t netif_is_up(struct netif *netif)
{
  804cfd:	55                   	push   %ebp
  804cfe:	89 e5                	mov    %esp,%ebp
  return (netif->flags & NETIF_FLAG_UP)?1:0;
  804d00:	8b 45 08             	mov    0x8(%ebp),%eax
  804d03:	0f b6 40 2e          	movzbl 0x2e(%eax),%eax
  804d07:	83 e0 01             	and    $0x1,%eax
}
  804d0a:	5d                   	pop    %ebp
  804d0b:	c3                   	ret    
  804d0c:	66 90                	xchg   %ax,%ax
  804d0e:	66 90                	xchg   %ax,%ax

00804d10 <pbuf_header>:
 * @return non-zero on failure, zero on success.
 *
 */
u8_t
pbuf_header(struct pbuf *p, s16_t header_size_increment)
{
  804d10:	55                   	push   %ebp
  804d11:	89 e5                	mov    %esp,%ebp
  804d13:	56                   	push   %esi
  804d14:	53                   	push   %ebx
  804d15:	83 ec 10             	sub    $0x10,%esp
  804d18:	8b 55 08             	mov    0x8(%ebp),%edx
  804d1b:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  u16_t type;
  void *payload;
  u16_t increment_magnitude;

  LWIP_ASSERT("p != NULL", p != NULL);
  804d1e:	85 d2                	test   %edx,%edx
  804d20:	75 1c                	jne    804d3e <pbuf_header+0x2e>
  804d22:	c7 44 24 08 64 27 81 	movl   $0x812764,0x8(%esp)
  804d29:	00 
  804d2a:	c7 44 24 04 64 01 00 	movl   $0x164,0x4(%esp)
  804d31:	00 
  804d32:	c7 04 24 a0 26 81 00 	movl   $0x8126a0,(%esp)
  804d39:	e8 3c a3 00 00       	call   80f07a <_panic>
  if ((header_size_increment == 0) || (p == NULL))
  804d3e:	66 85 c9             	test   %cx,%cx
  804d41:	0f 84 a1 00 00 00    	je     804de8 <pbuf_header+0xd8>
  if (header_size_increment < 0){
    increment_magnitude = -header_size_increment;
    /* Check that we aren't going to move off the end of the pbuf */
    LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
  } else {
    increment_magnitude = header_size_increment;
  804d47:	89 cb                	mov    %ecx,%ebx

  LWIP_ASSERT("p != NULL", p != NULL);
  if ((header_size_increment == 0) || (p == NULL))
    return 0;
 
  if (header_size_increment < 0){
  804d49:	66 85 c9             	test   %cx,%cx
  804d4c:	79 24                	jns    804d72 <pbuf_header+0x62>
    increment_magnitude = -header_size_increment;
  804d4e:	f7 db                	neg    %ebx
    /* Check that we aren't going to move off the end of the pbuf */
    LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
  804d50:	66 3b 5a 0a          	cmp    0xa(%edx),%bx
  804d54:	76 1c                	jbe    804d72 <pbuf_header+0x62>
  804d56:	c7 44 24 08 b5 26 81 	movl   $0x8126b5,0x8(%esp)
  804d5d:	00 
  804d5e:	c7 44 24 04 6b 01 00 	movl   $0x16b,0x4(%esp)
  804d65:	00 
  804d66:	c7 04 24 a0 26 81 00 	movl   $0x8126a0,(%esp)
  804d6d:	e8 08 a3 00 00       	call   80f07a <_panic>
    LWIP_ASSERT("p->payload - increment_magnitude >= p + SIZEOF_STRUCT_PBUF",
                (u8_t *)p->payload - increment_magnitude >= (u8_t *)p + SIZEOF_STRUCT_PBUF);
#endif
  }

  type = p->type;
  804d72:	0f b6 42 0c          	movzbl 0xc(%edx),%eax
  /* remember current payload pointer */
  payload = p->payload;
  804d76:	8b 72 04             	mov    0x4(%edx),%esi

  /* pbuf types containing payloads? */
  if (type == PBUF_RAM || type == PBUF_POOL) {
  804d79:	66 83 f8 03          	cmp    $0x3,%ax
  804d7d:	74 05                	je     804d84 <pbuf_header+0x74>
  804d7f:	66 85 c0             	test   %ax,%ax
  804d82:	75 13                	jne    804d97 <pbuf_header+0x87>
    /* set new payload pointer */
    p->payload = (u8_t *)p->payload - header_size_increment;
  804d84:	0f bf c1             	movswl %cx,%eax
  804d87:	29 c6                	sub    %eax,%esi
    /* boundary check fails? */
    if ((u8_t *)p->payload < (u8_t *)p + SIZEOF_STRUCT_PBUF) {
  804d89:	8d 5a 10             	lea    0x10(%edx),%ebx
        (void *)p->payload,
        (void *)(p + 1)));\
      /* restore old payload pointer */
      p->payload = payload;
      /* bail out unsuccesfully */
      return 1;
  804d8c:	b8 01 00 00 00       	mov    $0x1,%eax
  /* pbuf types containing payloads? */
  if (type == PBUF_RAM || type == PBUF_POOL) {
    /* set new payload pointer */
    p->payload = (u8_t *)p->payload - header_size_increment;
    /* boundary check fails? */
    if ((u8_t *)p->payload < (u8_t *)p + SIZEOF_STRUCT_PBUF) {
  804d91:	39 de                	cmp    %ebx,%esi
  804d93:	73 41                	jae    804dd6 <pbuf_header+0xc6>
  804d95:	eb 56                	jmp    804ded <pbuf_header+0xdd>
      p->payload = payload;
      /* bail out unsuccesfully */
      return 1;
    }
  /* pbuf types refering to external payloads? */
  } else if (type == PBUF_REF || type == PBUF_ROM) {
  804d97:	83 e8 01             	sub    $0x1,%eax
  804d9a:	66 83 f8 01          	cmp    $0x1,%ax
  804d9e:	77 1a                	ja     804dba <pbuf_header+0xaa>
      /* increase payload pointer */
      p->payload = (u8_t *)p->payload - header_size_increment;
    } else {
      /* cannot expand payload to front (yet!)
       * bail out unsuccesfully */
      return 1;
  804da0:	b8 01 00 00 00       	mov    $0x1,%eax
      return 1;
    }
  /* pbuf types refering to external payloads? */
  } else if (type == PBUF_REF || type == PBUF_ROM) {
    /* hide a header in the payload? */
    if ((header_size_increment < 0) && (increment_magnitude <= p->len)) {
  804da5:	66 85 c9             	test   %cx,%cx
  804da8:	79 43                	jns    804ded <pbuf_header+0xdd>
  804daa:	66 3b 5a 0a          	cmp    0xa(%edx),%bx
  804dae:	77 3d                	ja     804ded <pbuf_header+0xdd>
      /* increase payload pointer */
      p->payload = (u8_t *)p->payload - header_size_increment;
  804db0:	0f bf c1             	movswl %cx,%eax
  804db3:	29 c6                	sub    %eax,%esi
  804db5:	89 72 04             	mov    %esi,0x4(%edx)
  804db8:	eb 1f                	jmp    804dd9 <pbuf_header+0xc9>
      return 1;
    }
  }
  else {
    /* Unknown type */
    LWIP_ASSERT("bad pbuf type", 0);
  804dba:	c7 44 24 08 d3 26 81 	movl   $0x8126d3,0x8(%esp)
  804dc1:	00 
  804dc2:	c7 44 24 04 9a 01 00 	movl   $0x19a,0x4(%esp)
  804dc9:	00 
  804dca:	c7 04 24 a0 26 81 00 	movl   $0x8126a0,(%esp)
  804dd1:	e8 a4 a2 00 00       	call   80f07a <_panic>
  payload = p->payload;

  /* pbuf types containing payloads? */
  if (type == PBUF_RAM || type == PBUF_POOL) {
    /* set new payload pointer */
    p->payload = (u8_t *)p->payload - header_size_increment;
  804dd6:	89 72 04             	mov    %esi,0x4(%edx)
    /* Unknown type */
    LWIP_ASSERT("bad pbuf type", 0);
    return 1;
  }
  /* modify pbuf length fields */
  p->len += header_size_increment;
  804dd9:	66 01 4a 0a          	add    %cx,0xa(%edx)
  p->tot_len += header_size_increment;
  804ddd:	66 01 4a 08          	add    %cx,0x8(%edx)

  LWIP_DEBUGF(PBUF_DEBUG, ("pbuf_header: old %p new %p (%"S16_F")\n",
    (void *)payload, (void *)p->payload, header_size_increment));

  return 0;
  804de1:	b8 00 00 00 00       	mov    $0x0,%eax
  804de6:	eb 05                	jmp    804ded <pbuf_header+0xdd>
  void *payload;
  u16_t increment_magnitude;

  LWIP_ASSERT("p != NULL", p != NULL);
  if ((header_size_increment == 0) || (p == NULL))
    return 0;
  804de8:	b8 00 00 00 00       	mov    $0x0,%eax

  LWIP_DEBUGF(PBUF_DEBUG, ("pbuf_header: old %p new %p (%"S16_F")\n",
    (void *)payload, (void *)p->payload, header_size_increment));

  return 0;
}
  804ded:	83 c4 10             	add    $0x10,%esp
  804df0:	5b                   	pop    %ebx
  804df1:	5e                   	pop    %esi
  804df2:	5d                   	pop    %ebp
  804df3:	c3                   	ret    

00804df4 <pbuf_free>:
 * 1->1->1 becomes .......
 *
 */
u8_t
pbuf_free(struct pbuf *p)
{
  804df4:	55                   	push   %ebp
  804df5:	89 e5                	mov    %esp,%ebp
  804df7:	56                   	push   %esi
  804df8:	53                   	push   %ebx
  804df9:	83 ec 10             	sub    $0x10,%esp
  804dfc:	8b 55 08             	mov    0x8(%ebp),%edx
  u16_t type;
  struct pbuf *q;
  u8_t count;

  if (p == NULL) {
  804dff:	85 d2                	test   %edx,%edx
  804e01:	75 1c                	jne    804e1f <pbuf_free+0x2b>
    LWIP_ASSERT("p != NULL", p != NULL);
  804e03:	c7 44 24 08 64 27 81 	movl   $0x812764,0x8(%esp)
  804e0a:	00 
  804e0b:	c7 44 24 04 d0 01 00 	movl   $0x1d0,0x4(%esp)
  804e12:	00 
  804e13:	c7 04 24 a0 26 81 00 	movl   $0x8126a0,(%esp)
  804e1a:	e8 5b a2 00 00       	call   80f07a <_panic>
  }
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_free(%p)\n", (void *)p));

  PERF_START;

  LWIP_ASSERT("pbuf_free: sane type",
  804e1f:	80 7a 0c 03          	cmpb   $0x3,0xc(%edx)
  804e23:	0f 86 99 00 00 00    	jbe    804ec2 <pbuf_free+0xce>
  804e29:	c7 44 24 08 e1 26 81 	movl   $0x8126e1,0x8(%esp)
  804e30:	00 
  804e31:	c7 44 24 04 db 01 00 	movl   $0x1db,0x4(%esp)
  804e38:	00 
  804e39:	c7 04 24 a0 26 81 00 	movl   $0x8126a0,(%esp)
  804e40:	e8 35 a2 00 00       	call   80f07a <_panic>
      } else {
        mem_free(p);
      }
      count++;
      /* proceed to next pbuf */
      p = q;
  804e45:	89 f2                	mov    %esi,%edx
    /* Since decrementing ref cannot be guaranteed to be a single machine operation
     * we must protect it. We put the new ref into a local variable to prevent
     * further protection. */
    SYS_ARCH_PROTECT(old_level);
    /* all pbufs in a chain are referenced at least once */
    LWIP_ASSERT("pbuf_free: p->ref > 0", p->ref > 0);
  804e47:	0f b7 4a 0e          	movzwl 0xe(%edx),%ecx
  804e4b:	66 85 c9             	test   %cx,%cx
  804e4e:	75 1c                	jne    804e6c <pbuf_free+0x78>
  804e50:	c7 44 24 08 f6 26 81 	movl   $0x8126f6,0x8(%esp)
  804e57:	00 
  804e58:	c7 44 24 04 e8 01 00 	movl   $0x1e8,0x4(%esp)
  804e5f:	00 
  804e60:	c7 04 24 a0 26 81 00 	movl   $0x8126a0,(%esp)
  804e67:	e8 0e a2 00 00       	call   80f07a <_panic>
    /* decrease reference count (number of pointers to pbuf) */
    ref = --(p->ref);
  804e6c:	83 e9 01             	sub    $0x1,%ecx
  804e6f:	66 89 4a 0e          	mov    %cx,0xe(%edx)
    SYS_ARCH_UNPROTECT(old_level);
    /* this pbuf is no longer referenced to? */
    if (ref == 0) {
  804e73:	66 85 c9             	test   %cx,%cx
  804e76:	75 54                	jne    804ecc <pbuf_free+0xd8>
      /* remember next pbuf in chain for next iteration */
      q = p->next;
  804e78:	8b 32                	mov    (%edx),%esi
      LWIP_DEBUGF( PBUF_DEBUG | 2, ("pbuf_free: deallocating %p\n", (void *)p));
      type = p->type;
  804e7a:	0f b6 42 0c          	movzbl 0xc(%edx),%eax
      /* is this a pbuf from the pool? */
      if (type == PBUF_POOL) {
  804e7e:	66 83 f8 03          	cmp    $0x3,%ax
  804e82:	75 12                	jne    804e96 <pbuf_free+0xa2>
        memp_free(MEMP_PBUF_POOL, p);
  804e84:	89 54 24 04          	mov    %edx,0x4(%esp)
  804e88:	c7 04 24 0d 00 00 00 	movl   $0xd,(%esp)
  804e8f:	e8 ae fb ff ff       	call   804a42 <memp_free>
  804e94:	eb 23                	jmp    804eb9 <pbuf_free+0xc5>
      /* is this a ROM or RAM referencing pbuf? */
      } else if (type == PBUF_ROM || type == PBUF_REF) {
  804e96:	83 e8 01             	sub    $0x1,%eax
  804e99:	66 83 f8 01          	cmp    $0x1,%ax
  804e9d:	77 12                	ja     804eb1 <pbuf_free+0xbd>
        memp_free(MEMP_PBUF, p);
  804e9f:	89 54 24 04          	mov    %edx,0x4(%esp)
  804ea3:	c7 04 24 0c 00 00 00 	movl   $0xc,(%esp)
  804eaa:	e8 93 fb ff ff       	call   804a42 <memp_free>
  804eaf:	eb 08                	jmp    804eb9 <pbuf_free+0xc5>
      /* type == PBUF_RAM */
      } else {
        mem_free(p);
  804eb1:	89 14 24             	mov    %edx,(%esp)
  804eb4:	e8 2c f6 ff ff       	call   8044e5 <mem_free>
      }
      count++;
  804eb9:	83 c3 01             	add    $0x1,%ebx
    p->type == PBUF_REF || p->type == PBUF_POOL);

  count = 0;
  /* de-allocate all consecutive pbufs from the head of the chain that
   * obtain a zero reference count after decrementing*/
  while (p != NULL) {
  804ebc:	85 f6                	test   %esi,%esi
  804ebe:	75 85                	jne    804e45 <pbuf_free+0x51>
  804ec0:	eb 0a                	jmp    804ecc <pbuf_free+0xd8>
  }
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_free(%p)\n", (void *)p));

  PERF_START;

  LWIP_ASSERT("pbuf_free: sane type",
  804ec2:	bb 00 00 00 00       	mov    $0x0,%ebx
  804ec7:	e9 7b ff ff ff       	jmp    804e47 <pbuf_free+0x53>
    }
  }
  PERF_STOP("pbuf_free");
  /* return number of de-allocated pbufs */
  return count;
}
  804ecc:	89 d8                	mov    %ebx,%eax
  804ece:	83 c4 10             	add    $0x10,%esp
  804ed1:	5b                   	pop    %ebx
  804ed2:	5e                   	pop    %esi
  804ed3:	5d                   	pop    %ebp
  804ed4:	c3                   	ret    

00804ed5 <pbuf_alloc>:
 * @return the allocated pbuf. If multiple pbufs where allocated, this
 * is the first pbuf of a pbuf chain.
 */
struct pbuf *
pbuf_alloc(pbuf_layer layer, u16_t length, pbuf_type type)
{
  804ed5:	55                   	push   %ebp
  804ed6:	89 e5                	mov    %esp,%ebp
  804ed8:	57                   	push   %edi
  804ed9:	56                   	push   %esi
  804eda:	53                   	push   %ebx
  804edb:	83 ec 1c             	sub    $0x1c,%esp
  804ede:	8b 45 08             	mov    0x8(%ebp),%eax
  804ee1:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  s32_t rem_len; /* remaining length */
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc(length=%"U16_F")\n", length));

  /* determine header offset */
  offset = 0;
  switch (layer) {
  804ee4:	83 f8 01             	cmp    $0x1,%eax
  804ee7:	74 11                	je     804efa <pbuf_alloc+0x25>
  804ee9:	83 f8 01             	cmp    $0x1,%eax
  804eec:	72 14                	jb     804f02 <pbuf_alloc+0x2d>
  804eee:	83 f8 02             	cmp    $0x2,%eax
  804ef1:	74 19                	je     804f0c <pbuf_alloc+0x37>
  804ef3:	83 f8 03             	cmp    $0x3,%eax
  804ef6:	74 3a                	je     804f32 <pbuf_alloc+0x5d>
  804ef8:	eb 1c                	jmp    804f16 <pbuf_alloc+0x41>
  u16_t offset;
  s32_t rem_len; /* remaining length */
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc(length=%"U16_F")\n", length));

  /* determine header offset */
  offset = 0;
  804efa:	bf 00 00 00 00       	mov    $0x0,%edi
  804eff:	90                   	nop
  804f00:	eb 05                	jmp    804f07 <pbuf_alloc+0x32>
  switch (layer) {
  case PBUF_TRANSPORT:
    /* add room for transport (often TCP) layer header */
    offset += PBUF_TRANSPORT_HLEN;
  804f02:	bf 14 00 00 00       	mov    $0x14,%edi
    /* FALLTHROUGH */
  case PBUF_IP:
    /* add room for IP layer header */
    offset += PBUF_IP_HLEN;
  804f07:	83 c7 14             	add    $0x14,%edi
  804f0a:	eb 05                	jmp    804f11 <pbuf_alloc+0x3c>
  u16_t offset;
  s32_t rem_len; /* remaining length */
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc(length=%"U16_F")\n", length));

  /* determine header offset */
  offset = 0;
  804f0c:	bf 00 00 00 00       	mov    $0x0,%edi
    /* add room for IP layer header */
    offset += PBUF_IP_HLEN;
    /* FALLTHROUGH */
  case PBUF_LINK:
    /* add room for link layer header */
    offset += PBUF_LINK_HLEN;
  804f11:	83 c7 0e             	add    $0xe,%edi
    break;
  804f14:	eb 21                	jmp    804f37 <pbuf_alloc+0x62>
  case PBUF_RAW:
    break;
  default:
    LWIP_ASSERT("pbuf_alloc: bad pbuf layer", 0);
  804f16:	c7 44 24 08 0c 27 81 	movl   $0x81270c,0x8(%esp)
  804f1d:	00 
  804f1e:	c7 44 24 04 8a 00 00 	movl   $0x8a,0x4(%esp)
  804f25:	00 
  804f26:	c7 04 24 a0 26 81 00 	movl   $0x8126a0,(%esp)
  804f2d:	e8 48 a1 00 00       	call   80f07a <_panic>
  u16_t offset;
  s32_t rem_len; /* remaining length */
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc(length=%"U16_F")\n", length));

  /* determine header offset */
  offset = 0;
  804f32:	bf 00 00 00 00       	mov    $0x0,%edi
  default:
    LWIP_ASSERT("pbuf_alloc: bad pbuf layer", 0);
    return NULL;
  }

  switch (type) {
  804f37:	83 7d 10 02          	cmpl   $0x2,0x10(%ebp)
  804f3b:	77 0f                	ja     804f4c <pbuf_alloc+0x77>
  804f3d:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
  804f41:	0f 82 6a 01 00 00    	jb     8050b1 <pbuf_alloc+0x1dc>
  804f47:	e9 a5 01 00 00       	jmp    8050f1 <pbuf_alloc+0x21c>
  804f4c:	83 7d 10 03          	cmpl   $0x3,0x10(%ebp)
  804f50:	0f 85 cb 01 00 00    	jne    805121 <pbuf_alloc+0x24c>
  case PBUF_POOL:
    /* allocate head of pbuf chain into p */
      p = memp_malloc(MEMP_PBUF_POOL);
  804f56:	c7 04 24 0d 00 00 00 	movl   $0xd,(%esp)
  804f5d:	e8 80 fa ff ff       	call   8049e2 <memp_malloc>
  804f62:	89 c6                	mov    %eax,%esi
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc: allocated pbuf %p\n", (void *)p));
    if (p == NULL) {
  804f64:	85 c0                	test   %eax,%eax
  804f66:	0f 84 df 01 00 00    	je     80514b <pbuf_alloc+0x276>
      return NULL;
    }
    p->type = type;
  804f6c:	c6 40 0c 03          	movb   $0x3,0xc(%eax)
    p->next = NULL;
  804f70:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

    /* make the payload pointer point 'offset' bytes into pbuf data memory */
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + (SIZEOF_STRUCT_PBUF + offset)));
  804f76:	0f b7 ff             	movzwl %di,%edi
  804f79:	8d 54 38 13          	lea    0x13(%eax,%edi,1),%edx
  804f7d:	83 e2 fc             	and    $0xfffffffc,%edx
  804f80:	89 50 04             	mov    %edx,0x4(%eax)
    LWIP_ASSERT("pbuf_alloc: pbuf p->payload properly aligned",
            ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
    /* the total length of the pbuf chain is the requested size */
    p->tot_len = length;
  804f83:	66 89 58 08          	mov    %bx,0x8(%eax)
    /* set the length of the first pbuf in the chain */
    p->len = LWIP_MIN(length, PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset));
  804f87:	0f b7 db             	movzwl %bx,%ebx
  804f8a:	83 c7 03             	add    $0x3,%edi
  804f8d:	83 e7 fc             	and    $0xfffffffc,%edi
  804f90:	b8 d0 07 00 00       	mov    $0x7d0,%eax
  804f95:	29 f8                	sub    %edi,%eax
  804f97:	39 d8                	cmp    %ebx,%eax
  804f99:	0f 4f c3             	cmovg  %ebx,%eax
  804f9c:	66 89 46 0a          	mov    %ax,0xa(%esi)
  804fa0:	0f b7 c0             	movzwl %ax,%eax
    LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
  804fa3:	8d be e0 07 00 00    	lea    0x7e0(%esi),%edi
  804fa9:	89 7d e4             	mov    %edi,-0x1c(%ebp)
  804fac:	01 c2                	add    %eax,%edx
  804fae:	39 d7                	cmp    %edx,%edi
  804fb0:	73 1c                	jae    804fce <pbuf_alloc+0xf9>
  804fb2:	c7 44 24 08 24 28 81 	movl   $0x812824,0x8(%esp)
  804fb9:	00 
  804fba:	c7 44 24 04 a3 00 00 	movl   $0xa3,0x4(%esp)
  804fc1:	00 
  804fc2:	c7 04 24 a0 26 81 00 	movl   $0x8126a0,(%esp)
  804fc9:	e8 ac a0 00 00       	call   80f07a <_panic>
                ((u8_t*)p->payload + p->len <=
                 (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
    /* set reference count (needed here in case we fail) */
    p->ref = 1;
  804fce:	66 c7 46 0e 01 00    	movw   $0x1,0xe(%esi)
    /* now allocate the tail of the pbuf chain */

    /* remember first pbuf for linkage in next iteration */
    r = p;
    /* remaining length to be allocated */
    rem_len = length - p->len;
  804fd4:	29 c3                	sub    %eax,%ebx
    p->ref = 1;

    /* now allocate the tail of the pbuf chain */

    /* remember first pbuf for linkage in next iteration */
    r = p;
  804fd6:	89 f7                	mov    %esi,%edi
    /* remaining length to be allocated */
    rem_len = length - p->len;
    /* any remaining pbufs to be allocated? */
    while (rem_len > 0) {
  804fd8:	e9 c7 00 00 00       	jmp    8050a4 <pbuf_alloc+0x1cf>
      q = memp_malloc(MEMP_PBUF_POOL);
  804fdd:	c7 04 24 0d 00 00 00 	movl   $0xd,(%esp)
  804fe4:	e8 f9 f9 ff ff       	call   8049e2 <memp_malloc>
      if (q == NULL) {
  804fe9:	85 c0                	test   %eax,%eax
  804feb:	75 12                	jne    804fff <pbuf_alloc+0x12a>
        /* free chain so far allocated */
        pbuf_free(p);
  804fed:	89 34 24             	mov    %esi,(%esp)
  804ff0:	e8 ff fd ff ff       	call   804df4 <pbuf_free>
        /* bail out unsuccesfully */
        return NULL;
  804ff5:	b8 00 00 00 00       	mov    $0x0,%eax
  804ffa:	e9 5f 01 00 00       	jmp    80515e <pbuf_alloc+0x289>
      }
      q->type = type;
  804fff:	c6 40 0c 03          	movb   $0x3,0xc(%eax)
      q->flags = 0;
  805003:	c6 40 0d 00          	movb   $0x0,0xd(%eax)
      q->next = NULL;
  805007:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
      /* make previous pbuf point to this pbuf */
      r->next = q;
  80500d:	89 07                	mov    %eax,(%edi)
      /* set total length of this pbuf and next in chain */
      LWIP_ASSERT("rem_len < max_u16_t", rem_len < 0xffff);
  80500f:	81 fb fe ff 00 00    	cmp    $0xfffe,%ebx
  805015:	7e 1c                	jle    805033 <pbuf_alloc+0x15e>
  805017:	c7 44 24 08 27 27 81 	movl   $0x812727,0x8(%esp)
  80501e:	00 
  80501f:	c7 44 24 04 bc 00 00 	movl   $0xbc,0x4(%esp)
  805026:	00 
  805027:	c7 04 24 a0 26 81 00 	movl   $0x8126a0,(%esp)
  80502e:	e8 47 a0 00 00       	call   80f07a <_panic>
      q->tot_len = (u16_t)rem_len;
  805033:	66 89 58 08          	mov    %bx,0x8(%eax)
      /* this pbuf length is pool size, unless smaller sized tail */
      q->len = LWIP_MIN((u16_t)rem_len, PBUF_POOL_BUFSIZE_ALIGNED);
  805037:	66 81 fb cf 07       	cmp    $0x7cf,%bx
  80503c:	b9 d0 07 00 00       	mov    $0x7d0,%ecx
  805041:	0f 46 cb             	cmovbe %ebx,%ecx
  805044:	66 89 48 0a          	mov    %cx,0xa(%eax)
      q->payload = (void *)((u8_t *)q + SIZEOF_STRUCT_PBUF);
  805048:	8d 50 10             	lea    0x10(%eax),%edx
  80504b:	89 50 04             	mov    %edx,0x4(%eax)
      LWIP_ASSERT("pbuf_alloc: pbuf q->payload properly aligned",
  80504e:	f6 c2 03             	test   $0x3,%dl
  805051:	74 1c                	je     80506f <pbuf_alloc+0x19a>
  805053:	c7 44 24 08 58 28 81 	movl   $0x812858,0x8(%esp)
  80505a:	00 
  80505b:	c7 44 24 04 c2 00 00 	movl   $0xc2,0x4(%esp)
  805062:	00 
  805063:	c7 04 24 a0 26 81 00 	movl   $0x8126a0,(%esp)
  80506a:	e8 0b a0 00 00       	call   80f07a <_panic>
              ((mem_ptr_t)q->payload % MEM_ALIGNMENT) == 0);
      LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
  80506f:	0f b7 56 0a          	movzwl 0xa(%esi),%edx
  805073:	03 56 04             	add    0x4(%esi),%edx
  805076:	39 55 e4             	cmp    %edx,-0x1c(%ebp)
  805079:	73 1c                	jae    805097 <pbuf_alloc+0x1c2>
  80507b:	c7 44 24 08 24 28 81 	movl   $0x812824,0x8(%esp)
  805082:	00 
  805083:	c7 44 24 04 c5 00 00 	movl   $0xc5,0x4(%esp)
  80508a:	00 
  80508b:	c7 04 24 a0 26 81 00 	movl   $0x8126a0,(%esp)
  805092:	e8 e3 9f 00 00       	call   80f07a <_panic>
                  ((u8_t*)p->payload + p->len <=
                   (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
      q->ref = 1;
  805097:	66 c7 40 0e 01 00    	movw   $0x1,0xe(%eax)
      /* calculate remaining length to be allocated */
      rem_len -= q->len;
  80509d:	0f b7 c9             	movzwl %cx,%ecx
  8050a0:	29 cb                	sub    %ecx,%ebx
      /* remember this pbuf for linkage in next iteration */
      r = q;
  8050a2:	89 c7                	mov    %eax,%edi
    /* remember first pbuf for linkage in next iteration */
    r = p;
    /* remaining length to be allocated */
    rem_len = length - p->len;
    /* any remaining pbufs to be allocated? */
    while (rem_len > 0) {
  8050a4:	85 db                	test   %ebx,%ebx
  8050a6:	0f 8f 31 ff ff ff    	jg     804fdd <pbuf_alloc+0x108>
  8050ac:	e9 8c 00 00 00       	jmp    80513d <pbuf_alloc+0x268>
    /*r->next = NULL;*/

    break;
  case PBUF_RAM:
    /* If pbuf is to be allocated in RAM, allocate memory for it. */
    p = (struct pbuf*)mem_malloc(LWIP_MEM_ALIGN_SIZE(SIZEOF_STRUCT_PBUF + offset) + LWIP_MEM_ALIGN_SIZE(length));
  8050b1:	0f b7 ff             	movzwl %di,%edi
  8050b4:	8d 57 13             	lea    0x13(%edi),%edx
  8050b7:	83 e2 fc             	and    $0xfffffffc,%edx
  8050ba:	0f b7 c3             	movzwl %bx,%eax
  8050bd:	83 c0 03             	add    $0x3,%eax
  8050c0:	83 e0 fc             	and    $0xfffffffc,%eax
  8050c3:	01 d0                	add    %edx,%eax
  8050c5:	89 04 24             	mov    %eax,(%esp)
  8050c8:	e8 f2 f6 ff ff       	call   8047bf <mem_malloc>
  8050cd:	89 c6                	mov    %eax,%esi
    if (p == NULL) {
  8050cf:	85 c0                	test   %eax,%eax
  8050d1:	74 7f                	je     805152 <pbuf_alloc+0x27d>
      return NULL;
    }
    /* Set up internal structure of the pbuf. */
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + SIZEOF_STRUCT_PBUF + offset));
  8050d3:	8d 44 38 13          	lea    0x13(%eax,%edi,1),%eax
  8050d7:	83 e0 fc             	and    $0xfffffffc,%eax
  8050da:	89 46 04             	mov    %eax,0x4(%esi)
    p->len = p->tot_len = length;
  8050dd:	66 89 5e 08          	mov    %bx,0x8(%esi)
  8050e1:	66 89 5e 0a          	mov    %bx,0xa(%esi)
    p->next = NULL;
  8050e5:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
    p->type = type;
  8050eb:	c6 46 0c 00          	movb   $0x0,0xc(%esi)
  8050ef:	eb 4c                	jmp    80513d <pbuf_alloc+0x268>
  /* pbuf references existing (non-volatile static constant) ROM payload? */
  case PBUF_ROM:
  /* pbuf references existing (externally allocated) RAM payload? */
  case PBUF_REF:
    /* only allocate memory for the pbuf structure */
    p = memp_malloc(MEMP_PBUF);
  8050f1:	c7 04 24 0c 00 00 00 	movl   $0xc,(%esp)
  8050f8:	e8 e5 f8 ff ff       	call   8049e2 <memp_malloc>
  8050fd:	89 c6                	mov    %eax,%esi
    if (p == NULL) {
  8050ff:	85 c0                	test   %eax,%eax
  805101:	74 56                	je     805159 <pbuf_alloc+0x284>
      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 2, ("pbuf_alloc: Could not allocate MEMP_PBUF for PBUF_%s.\n",
                  (type == PBUF_ROM) ? "ROM" : "REF"));
      return NULL;
    }
    /* caller must set this field properly, afterwards */
    p->payload = NULL;
  805103:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    p->len = p->tot_len = length;
  80510a:	66 89 58 08          	mov    %bx,0x8(%eax)
  80510e:	66 89 58 0a          	mov    %bx,0xa(%eax)
    p->next = NULL;
  805112:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    p->type = type;
  805118:	0f b6 45 10          	movzbl 0x10(%ebp),%eax
  80511c:	88 46 0c             	mov    %al,0xc(%esi)
    break;
  80511f:	eb 1c                	jmp    80513d <pbuf_alloc+0x268>
  default:
    LWIP_ASSERT("pbuf_alloc: erroneous type", 0);
  805121:	c7 44 24 08 3b 27 81 	movl   $0x81273b,0x8(%esp)
  805128:	00 
  805129:	c7 44 24 04 f1 00 00 	movl   $0xf1,0x4(%esp)
  805130:	00 
  805131:	c7 04 24 a0 26 81 00 	movl   $0x8126a0,(%esp)
  805138:	e8 3d 9f 00 00       	call   80f07a <_panic>
    return NULL;
  }
  /* set reference count */
  p->ref = 1;
  80513d:	66 c7 46 0e 01 00    	movw   $0x1,0xe(%esi)
  /* set flags */
  p->flags = 0;
  805143:	c6 46 0d 00          	movb   $0x0,0xd(%esi)
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc(length=%"U16_F") == %p\n", length, (void *)p));
  return p;
  805147:	89 f0                	mov    %esi,%eax
  805149:	eb 13                	jmp    80515e <pbuf_alloc+0x289>
  case PBUF_POOL:
    /* allocate head of pbuf chain into p */
      p = memp_malloc(MEMP_PBUF_POOL);
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc: allocated pbuf %p\n", (void *)p));
    if (p == NULL) {
      return NULL;
  80514b:	b8 00 00 00 00       	mov    $0x0,%eax
  805150:	eb 0c                	jmp    80515e <pbuf_alloc+0x289>
    break;
  case PBUF_RAM:
    /* If pbuf is to be allocated in RAM, allocate memory for it. */
    p = (struct pbuf*)mem_malloc(LWIP_MEM_ALIGN_SIZE(SIZEOF_STRUCT_PBUF + offset) + LWIP_MEM_ALIGN_SIZE(length));
    if (p == NULL) {
      return NULL;
  805152:	b8 00 00 00 00       	mov    $0x0,%eax
  805157:	eb 05                	jmp    80515e <pbuf_alloc+0x289>
    /* only allocate memory for the pbuf structure */
    p = memp_malloc(MEMP_PBUF);
    if (p == NULL) {
      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 2, ("pbuf_alloc: Could not allocate MEMP_PBUF for PBUF_%s.\n",
                  (type == PBUF_ROM) ? "ROM" : "REF"));
      return NULL;
  805159:	b8 00 00 00 00       	mov    $0x0,%eax
  p->ref = 1;
  /* set flags */
  p->flags = 0;
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc(length=%"U16_F") == %p\n", length, (void *)p));
  return p;
}
  80515e:	83 c4 1c             	add    $0x1c,%esp
  805161:	5b                   	pop    %ebx
  805162:	5e                   	pop    %esi
  805163:	5f                   	pop    %edi
  805164:	5d                   	pop    %ebp
  805165:	c3                   	ret    

00805166 <pbuf_realloc>:
 *
 * @note Despite its name, pbuf_realloc cannot grow the size of a pbuf (chain).
 */
void
pbuf_realloc(struct pbuf *p, u16_t new_len)
{
  805166:	55                   	push   %ebp
  805167:	89 e5                	mov    %esp,%ebp
  805169:	56                   	push   %esi
  80516a:	53                   	push   %ebx
  80516b:	83 ec 10             	sub    $0x10,%esp
  80516e:	8b 5d 08             	mov    0x8(%ebp),%ebx
  805171:	8b 55 0c             	mov    0xc(%ebp),%edx
  struct pbuf *q;
  u16_t rem_len; /* remaining length */
  s32_t grow;

  LWIP_ASSERT("pbuf_realloc: p != NULL", p != NULL);
  805174:	85 db                	test   %ebx,%ebx
  805176:	75 1c                	jne    805194 <pbuf_realloc+0x2e>
  805178:	c7 44 24 08 56 27 81 	movl   $0x812756,0x8(%esp)
  80517f:	00 
  805180:	c7 44 24 04 13 01 00 	movl   $0x113,0x4(%esp)
  805187:	00 
  805188:	c7 04 24 a0 26 81 00 	movl   $0x8126a0,(%esp)
  80518f:	e8 e6 9e 00 00       	call   80f07a <_panic>
  805194:	89 d6                	mov    %edx,%esi
  LWIP_ASSERT("pbuf_realloc: sane p->type", p->type == PBUF_POOL ||
  805196:	80 7b 0c 03          	cmpb   $0x3,0xc(%ebx)
  80519a:	76 1c                	jbe    8051b8 <pbuf_realloc+0x52>
  80519c:	c7 44 24 08 6e 27 81 	movl   $0x81276e,0x8(%esp)
  8051a3:	00 
  8051a4:	c7 44 24 04 17 01 00 	movl   $0x117,0x4(%esp)
  8051ab:	00 
  8051ac:	c7 04 24 a0 26 81 00 	movl   $0x8126a0,(%esp)
  8051b3:	e8 c2 9e 00 00       	call   80f07a <_panic>
              p->type == PBUF_ROM ||
              p->type == PBUF_RAM ||
              p->type == PBUF_REF);

  /* desired length larger than current length? */
  if (new_len >= p->tot_len) {
  8051b8:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  8051bc:	66 39 d0             	cmp    %dx,%ax
  8051bf:	0f 86 be 00 00 00    	jbe    805283 <pbuf_realloc+0x11d>
    return;
  }

  /* the pbuf chain grows by (new_len - p->tot_len) bytes
   * (which may be negative in case of shrinking) */
  grow = new_len - p->tot_len;
  8051c5:	0f b7 d2             	movzwl %dx,%edx
  8051c8:	0f b7 c0             	movzwl %ax,%eax
  8051cb:	29 c2                	sub    %eax,%edx

  /* first, step over any pbufs that should remain in the chain */
  rem_len = new_len;
  q = p;
  /* should this pbuf be kept? */
  while (rem_len > q->len) {
  8051cd:	eb 4c                	jmp    80521b <pbuf_realloc+0xb5>
    /* decrease remaining length by pbuf length */
    rem_len -= q->len;
  8051cf:	29 c6                	sub    %eax,%esi
    /* decrease total length indicator */
    LWIP_ASSERT("grow < max_u16_t", grow < 0xffff);
  8051d1:	81 fa fe ff 00 00    	cmp    $0xfffe,%edx
  8051d7:	7e 1c                	jle    8051f5 <pbuf_realloc+0x8f>
  8051d9:	c7 44 24 08 89 27 81 	movl   $0x812789,0x8(%esp)
  8051e0:	00 
  8051e1:	c7 44 24 04 2b 01 00 	movl   $0x12b,0x4(%esp)
  8051e8:	00 
  8051e9:	c7 04 24 a0 26 81 00 	movl   $0x8126a0,(%esp)
  8051f0:	e8 85 9e 00 00       	call   80f07a <_panic>
    q->tot_len += (u16_t)grow;
  8051f5:	66 01 53 08          	add    %dx,0x8(%ebx)
    /* proceed to next pbuf in chain */
    q = q->next;
  8051f9:	8b 1b                	mov    (%ebx),%ebx
    LWIP_ASSERT("pbuf_realloc: q != NULL", q != NULL);
  8051fb:	85 db                	test   %ebx,%ebx
  8051fd:	75 1c                	jne    80521b <pbuf_realloc+0xb5>
  8051ff:	c7 44 24 08 9a 27 81 	movl   $0x81279a,0x8(%esp)
  805206:	00 
  805207:	c7 44 24 04 2f 01 00 	movl   $0x12f,0x4(%esp)
  80520e:	00 
  80520f:	c7 04 24 a0 26 81 00 	movl   $0x8126a0,(%esp)
  805216:	e8 5f 9e 00 00       	call   80f07a <_panic>

  /* first, step over any pbufs that should remain in the chain */
  rem_len = new_len;
  q = p;
  /* should this pbuf be kept? */
  while (rem_len > q->len) {
  80521b:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80521f:	66 39 c6             	cmp    %ax,%si
  805222:	77 ab                	ja     8051cf <pbuf_realloc+0x69>
  /* we have now reached the new last pbuf (in q) */
  /* rem_len == desired length for pbuf q */

  /* shrink allocated memory for PBUF_RAM */
  /* (other types merely adjust their length fields */
  if ((q->type == PBUF_RAM) && (rem_len != q->len)) {
  805224:	80 7b 0c 00          	cmpb   $0x0,0xc(%ebx)
  805228:	75 3d                	jne    805267 <pbuf_realloc+0x101>
  80522a:	66 39 c6             	cmp    %ax,%si
  80522d:	74 38                	je     805267 <pbuf_realloc+0x101>
    /* reallocate and adjust the length of the pbuf that will be split */
    q = mem_realloc(q, (u8_t *)q->payload - (u8_t *)q + rem_len);
  80522f:	8b 4b 04             	mov    0x4(%ebx),%ecx
  805232:	29 d9                	sub    %ebx,%ecx
  805234:	0f b7 c6             	movzwl %si,%eax
  805237:	01 c8                	add    %ecx,%eax
  805239:	89 44 24 04          	mov    %eax,0x4(%esp)
  80523d:	89 1c 24             	mov    %ebx,(%esp)
  805240:	e8 29 f4 ff ff       	call   80466e <mem_realloc>
  805245:	89 c3                	mov    %eax,%ebx
    LWIP_ASSERT("mem_realloc give q == NULL", q != NULL);
  805247:	85 c0                	test   %eax,%eax
  805249:	75 1c                	jne    805267 <pbuf_realloc+0x101>
  80524b:	c7 44 24 08 b2 27 81 	movl   $0x8127b2,0x8(%esp)
  805252:	00 
  805253:	c7 44 24 04 39 01 00 	movl   $0x139,0x4(%esp)
  80525a:	00 
  80525b:	c7 04 24 a0 26 81 00 	movl   $0x8126a0,(%esp)
  805262:	e8 13 9e 00 00       	call   80f07a <_panic>
  }
  /* adjust length fields for new last pbuf */
  q->len = rem_len;
  805267:	66 89 73 0a          	mov    %si,0xa(%ebx)
  q->tot_len = q->len;
  80526b:	66 89 73 08          	mov    %si,0x8(%ebx)

  /* any remaining pbufs in chain? */
  if (q->next != NULL) {
  80526f:	8b 03                	mov    (%ebx),%eax
  805271:	85 c0                	test   %eax,%eax
  805273:	74 08                	je     80527d <pbuf_realloc+0x117>
    /* free remaining pbufs in chain */
    pbuf_free(q->next);
  805275:	89 04 24             	mov    %eax,(%esp)
  805278:	e8 77 fb ff ff       	call   804df4 <pbuf_free>
  }
  /* q is last packet in chain */
  q->next = NULL;
  80527d:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)

}
  805283:	83 c4 10             	add    $0x10,%esp
  805286:	5b                   	pop    %ebx
  805287:	5e                   	pop    %esi
  805288:	5d                   	pop    %ebp
  805289:	c3                   	ret    

0080528a <pbuf_clen>:
 * @return the number of pbufs in a chain
 */

u8_t
pbuf_clen(struct pbuf *p)
{
  80528a:	55                   	push   %ebp
  80528b:	89 e5                	mov    %esp,%ebp
  80528d:	8b 55 08             	mov    0x8(%ebp),%edx
  u8_t len;

  len = 0;
  805290:	b8 00 00 00 00       	mov    $0x0,%eax
  while (p != NULL) {
  805295:	eb 05                	jmp    80529c <pbuf_clen+0x12>
    ++len;
  805297:	83 c0 01             	add    $0x1,%eax
    p = p->next;
  80529a:	8b 12                	mov    (%edx),%edx
pbuf_clen(struct pbuf *p)
{
  u8_t len;

  len = 0;
  while (p != NULL) {
  80529c:	85 d2                	test   %edx,%edx
  80529e:	75 f7                	jne    805297 <pbuf_clen+0xd>
    ++len;
    p = p->next;
  }
  return len;
}
  8052a0:	5d                   	pop    %ebp
  8052a1:	c3                   	ret    

008052a2 <pbuf_ref>:
 * @param p pbuf to increase reference counter of
 *
 */
void
pbuf_ref(struct pbuf *p)
{
  8052a2:	55                   	push   %ebp
  8052a3:	89 e5                	mov    %esp,%ebp
  8052a5:	8b 45 08             	mov    0x8(%ebp),%eax
  SYS_ARCH_DECL_PROTECT(old_level);
  /* pbuf given? */
  if (p != NULL) {
  8052a8:	85 c0                	test   %eax,%eax
  8052aa:	74 05                	je     8052b1 <pbuf_ref+0xf>
    SYS_ARCH_PROTECT(old_level);
    ++(p->ref);
  8052ac:	66 83 40 0e 01       	addw   $0x1,0xe(%eax)
    SYS_ARCH_UNPROTECT(old_level);
  }
}
  8052b1:	5d                   	pop    %ebp
  8052b2:	c3                   	ret    

008052b3 <pbuf_cat>:
 * @see pbuf_chain()
 */

void
pbuf_cat(struct pbuf *h, struct pbuf *t)
{
  8052b3:	55                   	push   %ebp
  8052b4:	89 e5                	mov    %esp,%ebp
  8052b6:	53                   	push   %ebx
  8052b7:	83 ec 14             	sub    $0x14,%esp
  8052ba:	8b 45 08             	mov    0x8(%ebp),%eax
  8052bd:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  struct pbuf *p;

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
  8052c0:	85 c0                	test   %eax,%eax
  8052c2:	74 04                	je     8052c8 <pbuf_cat+0x15>
  8052c4:	85 db                	test   %ebx,%ebx
  8052c6:	75 26                	jne    8052ee <pbuf_cat+0x3b>
  8052c8:	c7 44 24 08 88 28 81 	movl   $0x812888,0x8(%esp)
  8052cf:	00 
  8052d0:	c7 44 24 04 42 02 00 	movl   $0x242,0x4(%esp)
  8052d7:	00 
  8052d8:	c7 04 24 a0 26 81 00 	movl   $0x8126a0,(%esp)
  8052df:	e8 96 9d 00 00       	call   80f07a <_panic>
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
    /* add total length of second chain to all totals of first chain */
    p->tot_len += t->tot_len;
  8052e4:	0f b7 4b 08          	movzwl 0x8(%ebx),%ecx
  8052e8:	66 01 48 08          	add    %cx,0x8(%eax)

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
  8052ec:	89 d0                	mov    %edx,%eax
  8052ee:	8b 10                	mov    (%eax),%edx
  8052f0:	85 d2                	test   %edx,%edx
  8052f2:	75 f0                	jne    8052e4 <pbuf_cat+0x31>
    /* add total length of second chain to all totals of first chain */
    p->tot_len += t->tot_len;
  }
  /* { p is last pbuf of first h chain, p->next == NULL } */
  LWIP_ASSERT("p->tot_len == p->len (of last pbuf in chain)", p->tot_len == p->len);
  8052f4:	0f b7 50 08          	movzwl 0x8(%eax),%edx
  8052f8:	66 3b 50 0a          	cmp    0xa(%eax),%dx
  8052fc:	74 1c                	je     80531a <pbuf_cat+0x67>
  8052fe:	c7 44 24 08 c0 28 81 	movl   $0x8128c0,0x8(%esp)
  805305:	00 
  805306:	c7 44 24 04 4a 02 00 	movl   $0x24a,0x4(%esp)
  80530d:	00 
  80530e:	c7 04 24 a0 26 81 00 	movl   $0x8126a0,(%esp)
  805315:	e8 60 9d 00 00       	call   80f07a <_panic>
  LWIP_ASSERT("p->next == NULL", p->next == NULL);
  /* add total length of second chain to last pbuf total of first chain */
  p->tot_len += t->tot_len;
  80531a:	66 03 53 08          	add    0x8(%ebx),%dx
  80531e:	66 89 50 08          	mov    %dx,0x8(%eax)
  /* chain last pbuf of head (p) with first of tail (t) */
  p->next = t;
  805322:	89 18                	mov    %ebx,(%eax)
  /* p->next now references t, but the caller will drop its reference to t,
   * so netto there is no change to the reference count of t.
   */
}
  805324:	83 c4 14             	add    $0x14,%esp
  805327:	5b                   	pop    %ebx
  805328:	5d                   	pop    %ebp
  805329:	c3                   	ret    

0080532a <pbuf_chain>:
 * The ->ref field of the first pbuf of the tail chain is adjusted.
 *
 */
void
pbuf_chain(struct pbuf *h, struct pbuf *t)
{
  80532a:	55                   	push   %ebp
  80532b:	89 e5                	mov    %esp,%ebp
  80532d:	53                   	push   %ebx
  80532e:	83 ec 14             	sub    $0x14,%esp
  805331:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  pbuf_cat(h, t);
  805334:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  805338:	8b 45 08             	mov    0x8(%ebp),%eax
  80533b:	89 04 24             	mov    %eax,(%esp)
  80533e:	e8 70 ff ff ff       	call   8052b3 <pbuf_cat>
  /* t is now referenced by h */
  pbuf_ref(t);
  805343:	89 1c 24             	mov    %ebx,(%esp)
  805346:	e8 57 ff ff ff       	call   8052a2 <pbuf_ref>
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_FRESH | 2, ("pbuf_chain: %p references %p\n", (void *)h, (void *)t));
}
  80534b:	83 c4 14             	add    $0x14,%esp
  80534e:	5b                   	pop    %ebx
  80534f:	5d                   	pop    %ebp
  805350:	c3                   	ret    

00805351 <pbuf_dechain>:
 * @return remainder of the pbuf chain, or NULL if it was de-allocated.
 * @note May not be called on a packet queue.
 */
struct pbuf *
pbuf_dechain(struct pbuf *p)
{
  805351:	55                   	push   %ebp
  805352:	89 e5                	mov    %esp,%ebp
  805354:	57                   	push   %edi
  805355:	56                   	push   %esi
  805356:	53                   	push   %ebx
  805357:	83 ec 1c             	sub    $0x1c,%esp
  80535a:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct pbuf *q;
  u8_t tail_gone = 1;
  /* tail */
  q = p->next;
  80535d:	8b 33                	mov    (%ebx),%esi
  /* pbuf has successor in chain? */
  if (q != NULL) {
  80535f:	85 f6                	test   %esi,%esi
  805361:	0f 84 86 00 00 00    	je     8053ed <pbuf_dechain+0x9c>
    /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
    LWIP_ASSERT("p->tot_len == p->len + q->tot_len", q->tot_len == p->tot_len - p->len);
  805367:	0f b7 53 08          	movzwl 0x8(%ebx),%edx
  80536b:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80536f:	0f b7 4e 08          	movzwl 0x8(%esi),%ecx
  805373:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  805376:	0f b7 fa             	movzwl %dx,%edi
  805379:	0f b7 c8             	movzwl %ax,%ecx
  80537c:	29 cf                	sub    %ecx,%edi
  80537e:	39 7d e4             	cmp    %edi,-0x1c(%ebp)
  805381:	74 1c                	je     80539f <pbuf_dechain+0x4e>
  805383:	c7 44 24 08 f0 28 81 	movl   $0x8128f0,0x8(%esp)
  80538a:	00 
  80538b:	c7 44 24 04 80 02 00 	movl   $0x280,0x4(%esp)
  805392:	00 
  805393:	c7 04 24 a0 26 81 00 	movl   $0x8126a0,(%esp)
  80539a:	e8 db 9c 00 00       	call   80f07a <_panic>
    /* enforce invariant if assertion is disabled */
    q->tot_len = p->tot_len - p->len;
  80539f:	29 c2                	sub    %eax,%edx
  8053a1:	66 89 56 08          	mov    %dx,0x8(%esi)
    /* decouple pbuf from remainder */
    p->next = NULL;
  8053a5:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
    /* total length of pbuf p is its own length only */
    p->tot_len = p->len;
  8053ab:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  8053af:	66 89 43 08          	mov    %ax,0x8(%ebx)
    /* q is no longer referenced by p, free it */
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_STATE, ("pbuf_dechain: unreferencing %p\n", (void *)q));
    tail_gone = pbuf_free(q);
  8053b3:	89 34 24             	mov    %esi,(%esp)
  8053b6:	e8 39 fa ff ff       	call   804df4 <pbuf_free>
                  ("pbuf_dechain: deallocated %p (as it is no longer referenced)\n", (void *)q));
    }
    /* return remaining tail or NULL if deallocated */
  }
  /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
  LWIP_ASSERT("p->tot_len == p->len", p->tot_len == p->len);
  8053bb:	0f b7 4b 0a          	movzwl 0xa(%ebx),%ecx
  8053bf:	66 39 4b 08          	cmp    %cx,0x8(%ebx)
  8053c3:	74 1c                	je     8053e1 <pbuf_dechain+0x90>
  8053c5:	c7 44 24 08 cd 27 81 	movl   $0x8127cd,0x8(%esp)
  8053cc:	00 
  8053cd:	c7 44 24 04 91 02 00 	movl   $0x291,0x4(%esp)
  8053d4:	00 
  8053d5:	c7 04 24 a0 26 81 00 	movl   $0x8126a0,(%esp)
  8053dc:	e8 99 9c 00 00       	call   80f07a <_panic>
  return ((tail_gone > 0) ? NULL : q);
  8053e1:	84 c0                	test   %al,%al
  8053e3:	b8 00 00 00 00       	mov    $0x0,%eax
  8053e8:	0f 44 c6             	cmove  %esi,%eax
  8053eb:	eb 0f                	jmp    8053fc <pbuf_dechain+0xab>
                  ("pbuf_dechain: deallocated %p (as it is no longer referenced)\n", (void *)q));
    }
    /* return remaining tail or NULL if deallocated */
  }
  /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
  LWIP_ASSERT("p->tot_len == p->len", p->tot_len == p->len);
  8053ed:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  8053f1:	66 39 43 08          	cmp    %ax,0x8(%ebx)
  8053f5:	75 ce                	jne    8053c5 <pbuf_dechain+0x74>
  return ((tail_gone > 0) ? NULL : q);
  8053f7:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8053fc:	83 c4 1c             	add    $0x1c,%esp
  8053ff:	5b                   	pop    %ebx
  805400:	5e                   	pop    %esi
  805401:	5f                   	pop    %edi
  805402:	5d                   	pop    %ebp
  805403:	c3                   	ret    

00805404 <pbuf_copy>:
 *         ERR_ARG if one of the pbufs is NULL or p_to is not big
 *                 enough to hold p_from
 */
err_t
pbuf_copy(struct pbuf *p_to, struct pbuf *p_from)
{
  805404:	55                   	push   %ebp
  805405:	89 e5                	mov    %esp,%ebp
  805407:	57                   	push   %edi
  805408:	56                   	push   %esi
  805409:	53                   	push   %ebx
  80540a:	83 ec 1c             	sub    $0x1c,%esp
  80540d:	8b 75 08             	mov    0x8(%ebp),%esi
  805410:	8b 5d 0c             	mov    0xc(%ebp),%ebx

  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_copy(%p, %p)\n",
    (void*)p_to, (void*)p_from));

  /* is the target big enough to hold the source? */
  LWIP_ERROR("pbuf_copy: target not big enough to hold source", ((p_to != NULL) &&
  805413:	85 f6                	test   %esi,%esi
  805415:	74 0e                	je     805425 <pbuf_copy+0x21>
  805417:	85 db                	test   %ebx,%ebx
  805419:	74 0a                	je     805425 <pbuf_copy+0x21>
  80541b:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  80541f:	66 39 46 08          	cmp    %ax,0x8(%esi)
  805423:	73 1c                	jae    805441 <pbuf_copy+0x3d>
  805425:	c7 44 24 08 14 29 81 	movl   $0x812914,0x8(%esp)
  80542c:	00 
  80542d:	c7 44 24 04 b1 02 00 	movl   $0x2b1,0x4(%esp)
  805434:	00 
  805435:	c7 04 24 a0 26 81 00 	movl   $0x8126a0,(%esp)
  80543c:	e8 39 9c 00 00       	call   80f07a <_panic>
  805441:	bf 00 00 00 00       	mov    $0x0,%edi
  805446:	66 c7 45 e4 00 00    	movw   $0x0,-0x1c(%ebp)
  80544c:	66 89 7d e6          	mov    %di,-0x1a(%ebp)
             (p_from != NULL) && (p_to->tot_len >= p_from->tot_len)), return ERR_ARG;);

  /* iterate through pbuf chain */
  do
  {
    LWIP_ASSERT("p_to != NULL", p_to != NULL);
  805450:	85 f6                	test   %esi,%esi
  805452:	75 1c                	jne    805470 <pbuf_copy+0x6c>
  805454:	c7 44 24 08 e2 27 81 	movl   $0x8127e2,0x8(%esp)
  80545b:	00 
  80545c:	c7 44 24 04 b6 02 00 	movl   $0x2b6,0x4(%esp)
  805463:	00 
  805464:	c7 04 24 a0 26 81 00 	movl   $0x8126a0,(%esp)
  80546b:	e8 0a 9c 00 00       	call   80f07a <_panic>
    /* copy one part of the original chain */
    if ((p_to->len - offset_to) >= (p_from->len - offset_from)) {
  805470:	0f b7 4e 0a          	movzwl 0xa(%esi),%ecx
  805474:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  805478:	29 c1                	sub    %eax,%ecx
  80547a:	0f b7 53 0a          	movzwl 0xa(%ebx),%edx
  80547e:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  805482:	29 c2                	sub    %eax,%edx
      /* complete current p_from fits into current p_to */
      len = p_from->len - offset_from;
  805484:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  805488:	66 2b 45 e6          	sub    -0x1a(%ebp),%ax
  80548c:	0f b7 7e 0a          	movzwl 0xa(%esi),%edi
  805490:	66 2b 7d e4          	sub    -0x1c(%ebp),%di
  805494:	39 d1                	cmp    %edx,%ecx
  805496:	0f 4c c7             	cmovl  %edi,%eax
    } else {
      /* current p_from does not fit into current p_to */
      len = p_to->len - offset_to;
    }
    MEMCPY((u8_t*)p_to->payload + offset_to, (u8_t*)p_from->payload + offset_from, len);
  805499:	89 c7                	mov    %eax,%edi
  80549b:	0f b7 c0             	movzwl %ax,%eax
  80549e:	89 44 24 08          	mov    %eax,0x8(%esp)
  8054a2:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  8054a6:	03 43 04             	add    0x4(%ebx),%eax
  8054a9:	89 44 24 04          	mov    %eax,0x4(%esp)
  8054ad:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  8054b1:	03 46 04             	add    0x4(%esi),%eax
  8054b4:	89 04 24             	mov    %eax,(%esp)
  8054b7:	e8 e0 a4 00 00       	call   80f99c <memcpy>
    offset_to += len;
  8054bc:	66 01 7d e4          	add    %di,-0x1c(%ebp)
    offset_from += len;
  8054c0:	66 01 7d e6          	add    %di,-0x1a(%ebp)
    LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
  8054c4:	0f b7 46 0a          	movzwl 0xa(%esi),%eax
  8054c8:	66 39 45 e4          	cmp    %ax,-0x1c(%ebp)
  8054cc:	76 1c                	jbe    8054ea <pbuf_copy+0xe6>
  8054ce:	c7 44 24 08 ef 27 81 	movl   $0x8127ef,0x8(%esp)
  8054d5:	00 
  8054d6:	c7 44 24 04 c2 02 00 	movl   $0x2c2,0x4(%esp)
  8054dd:	00 
  8054de:	c7 04 24 a0 26 81 00 	movl   $0x8126a0,(%esp)
  8054e5:	e8 90 9b 00 00       	call   80f07a <_panic>
    if (offset_to == p_to->len) {
  8054ea:	66 39 45 e4          	cmp    %ax,-0x1c(%ebp)
  8054ee:	75 08                	jne    8054f8 <pbuf_copy+0xf4>
      /* on to next p_to (if any) */
      offset_to = 0;
      p_to = p_to->next;
  8054f0:	8b 36                	mov    (%esi),%esi
    offset_to += len;
    offset_from += len;
    LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
    if (offset_to == p_to->len) {
      /* on to next p_to (if any) */
      offset_to = 0;
  8054f2:	66 c7 45 e4 00 00    	movw   $0x0,-0x1c(%ebp)
      p_to = p_to->next;
    }
    LWIP_ASSERT("offset_from <= p_from->len", offset_from <= p_from->len);
  8054f8:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  8054fc:	66 39 45 e6          	cmp    %ax,-0x1a(%ebp)
  805500:	76 1c                	jbe    80551e <pbuf_copy+0x11a>
  805502:	c7 44 24 08 06 28 81 	movl   $0x812806,0x8(%esp)
  805509:	00 
  80550a:	c7 44 24 04 c8 02 00 	movl   $0x2c8,0x4(%esp)
  805511:	00 
  805512:	c7 04 24 a0 26 81 00 	movl   $0x8126a0,(%esp)
  805519:	e8 5c 9b 00 00       	call   80f07a <_panic>
    if (offset_from >= p_from->len) {
  80551e:	66 39 45 e6          	cmp    %ax,-0x1a(%ebp)
  805522:	72 08                	jb     80552c <pbuf_copy+0x128>
      /* on to next p_from (if any) */
      offset_from = 0;
      p_from = p_from->next;
  805524:	8b 1b                	mov    (%ebx),%ebx
      p_to = p_to->next;
    }
    LWIP_ASSERT("offset_from <= p_from->len", offset_from <= p_from->len);
    if (offset_from >= p_from->len) {
      /* on to next p_from (if any) */
      offset_from = 0;
  805526:	66 c7 45 e6 00 00    	movw   $0x0,-0x1a(%ebp)
      p_from = p_from->next;
    }

    if((p_from != NULL) && (p_from->len == p_from->tot_len)) {
  80552c:	85 db                	test   %ebx,%ebx
  80552e:	74 2b                	je     80555b <pbuf_copy+0x157>
  805530:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  805534:	66 39 43 0a          	cmp    %ax,0xa(%ebx)
  805538:	75 21                	jne    80555b <pbuf_copy+0x157>
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
  80553a:	83 3b 00             	cmpl   $0x0,(%ebx)
  80553d:	74 1c                	je     80555b <pbuf_copy+0x157>
  80553f:	c7 44 24 08 44 29 81 	movl   $0x812944,0x8(%esp)
  805546:	00 
  805547:	c7 44 24 04 d2 02 00 	movl   $0x2d2,0x4(%esp)
  80554e:	00 
  80554f:	c7 04 24 a0 26 81 00 	movl   $0x8126a0,(%esp)
  805556:	e8 1f 9b 00 00       	call   80f07a <_panic>
                 (p_from->next == NULL), return ERR_VAL;);
    }
    if((p_to != NULL) && (p_to->len == p_to->tot_len)) {
  80555b:	85 f6                	test   %esi,%esi
  80555d:	74 2b                	je     80558a <pbuf_copy+0x186>
  80555f:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  805563:	66 39 46 0a          	cmp    %ax,0xa(%esi)
  805567:	75 21                	jne    80558a <pbuf_copy+0x186>
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
  805569:	83 3e 00             	cmpl   $0x0,(%esi)
  80556c:	74 1c                	je     80558a <pbuf_copy+0x186>
  80556e:	c7 44 24 08 44 29 81 	movl   $0x812944,0x8(%esp)
  805575:	00 
  805576:	c7 44 24 04 d7 02 00 	movl   $0x2d7,0x4(%esp)
  80557d:	00 
  80557e:	c7 04 24 a0 26 81 00 	movl   $0x8126a0,(%esp)
  805585:	e8 f0 9a 00 00       	call   80f07a <_panic>
                  (p_to->next == NULL), return ERR_VAL;);
    }
  } while (p_from);
  80558a:	85 db                	test   %ebx,%ebx
  80558c:	0f 85 be fe ff ff    	jne    805450 <pbuf_copy+0x4c>
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 1, ("pbuf_copy: end of chain reached.\n"));
  return ERR_OK;
}
  805592:	b8 00 00 00 00       	mov    $0x0,%eax
  805597:	83 c4 1c             	add    $0x1c,%esp
  80559a:	5b                   	pop    %ebx
  80559b:	5e                   	pop    %esi
  80559c:	5f                   	pop    %edi
  80559d:	5d                   	pop    %ebp
  80559e:	c3                   	ret    

0080559f <pbuf_copy_partial>:
 * @param len length of data to copy (dataptr must be big enough)
 * @param offset offset into the packet buffer from where to begin copying len bytes
 */
u16_t
pbuf_copy_partial(struct pbuf *buf, void *dataptr, u16_t len, u16_t offset)
{
  80559f:	55                   	push   %ebp
  8055a0:	89 e5                	mov    %esp,%ebp
  8055a2:	57                   	push   %edi
  8055a3:	56                   	push   %esi
  8055a4:	53                   	push   %ebx
  8055a5:	83 ec 1c             	sub    $0x1c,%esp
  8055a8:	8b 5d 08             	mov    0x8(%ebp),%ebx
  8055ab:	0f b7 75 10          	movzwl 0x10(%ebp),%esi
  8055af:	0f b7 45 14          	movzwl 0x14(%ebp),%eax
  struct pbuf *p;
  u16_t left;
  u16_t buf_copy_len;
  u16_t copied_total = 0;

  LWIP_ERROR("netbuf_copy_partial: invalid buf", (buf != NULL), return 0;);
  8055b3:	85 db                	test   %ebx,%ebx
  8055b5:	75 1c                	jne    8055d3 <pbuf_copy_partial+0x34>
  8055b7:	c7 44 24 08 70 29 81 	movl   $0x812970,0x8(%esp)
  8055be:	00 
  8055bf:	c7 44 24 04 ef 02 00 	movl   $0x2ef,0x4(%esp)
  8055c6:	00 
  8055c7:	c7 04 24 a0 26 81 00 	movl   $0x8126a0,(%esp)
  8055ce:	e8 a7 9a 00 00       	call   80f07a <_panic>
  LWIP_ERROR("netbuf_copy_partial: invalid dataptr", (dataptr != NULL), return 0;);
  8055d3:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  8055d7:	74 0e                	je     8055e7 <pbuf_copy_partial+0x48>
  8055d9:	66 c7 45 e4 00 00    	movw   $0x0,-0x1c(%ebp)
  8055df:	66 c7 45 e6 00 00    	movw   $0x0,-0x1a(%ebp)
  8055e5:	eb 6b                	jmp    805652 <pbuf_copy_partial+0xb3>
  8055e7:	c7 44 24 08 94 29 81 	movl   $0x812994,0x8(%esp)
  8055ee:	00 
  8055ef:	c7 44 24 04 f0 02 00 	movl   $0x2f0,0x4(%esp)
  8055f6:	00 
  8055f7:	c7 04 24 a0 26 81 00 	movl   $0x8126a0,(%esp)
  8055fe:	e8 77 9a 00 00       	call   80f07a <_panic>
    return 0;
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; len != 0 && p != NULL; p = p->next) {
    if ((offset != 0) && (offset >= p->len)) {
  805603:	66 85 c0             	test   %ax,%ax
  805606:	74 0d                	je     805615 <pbuf_copy_partial+0x76>
  805608:	0f b7 53 0a          	movzwl 0xa(%ebx),%edx
  80560c:	66 39 d0             	cmp    %dx,%ax
  80560f:	72 04                	jb     805615 <pbuf_copy_partial+0x76>
      /* don't copy from this buffer -> on to the next */
      offset -= p->len;
  805611:	29 d0                	sub    %edx,%eax
  805613:	eb 3b                	jmp    805650 <pbuf_copy_partial+0xb1>
    } else {
      /* copy from this buffer. maybe only partially. */
      buf_copy_len = p->len - offset;
  805615:	0f b7 7b 0a          	movzwl 0xa(%ebx),%edi
  805619:	29 c7                	sub    %eax,%edi
  80561b:	66 39 f7             	cmp    %si,%di
  80561e:	0f 47 fe             	cmova  %esi,%edi
      if (buf_copy_len > len)
          buf_copy_len = len;
      /* copy the necessary parts of the buffer */
      MEMCPY(&((char*)dataptr)[left], &((char*)p->payload)[offset], buf_copy_len);
  805621:	0f b7 d7             	movzwl %di,%edx
  805624:	89 54 24 08          	mov    %edx,0x8(%esp)
  805628:	0f b7 c0             	movzwl %ax,%eax
  80562b:	03 43 04             	add    0x4(%ebx),%eax
  80562e:	89 44 24 04          	mov    %eax,0x4(%esp)
  805632:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  805636:	03 45 0c             	add    0xc(%ebp),%eax
  805639:	89 04 24             	mov    %eax,(%esp)
  80563c:	e8 5b a3 00 00       	call   80f99c <memcpy>
      copied_total += buf_copy_len;
  805641:	66 01 7d e4          	add    %di,-0x1c(%ebp)
      left += buf_copy_len;
  805645:	66 01 7d e6          	add    %di,-0x1a(%ebp)
      len -= buf_copy_len;
  805649:	29 fe                	sub    %edi,%esi
      offset = 0;
  80564b:	b8 00 00 00 00       	mov    $0x0,%eax
  if((buf == NULL) || (dataptr == NULL)) {
    return 0;
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; len != 0 && p != NULL; p = p->next) {
  805650:	8b 1b                	mov    (%ebx),%ebx
  805652:	85 db                	test   %ebx,%ebx
  805654:	74 05                	je     80565b <pbuf_copy_partial+0xbc>
  805656:	66 85 f6             	test   %si,%si
  805659:	75 a8                	jne    805603 <pbuf_copy_partial+0x64>
      len -= buf_copy_len;
      offset = 0;
    }
  }
  return copied_total;
}
  80565b:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  80565f:	83 c4 1c             	add    $0x1c,%esp
  805662:	5b                   	pop    %ebx
  805663:	5e                   	pop    %esi
  805664:	5f                   	pop    %edi
  805665:	5d                   	pop    %ebp
  805666:	c3                   	ret    
  805667:	66 90                	xchg   %ax,%ax
  805669:	66 90                	xchg   %ax,%ax
  80566b:	66 90                	xchg   %ax,%ax
  80566d:	66 90                	xchg   %ax,%ax
  80566f:	90                   	nop

00805670 <sswt_handler>:
 *
 * @param arg struct sswt_cb* used to signal a semaphore and end waiting.
 */
static void
sswt_handler(void *arg)
{
  805670:	55                   	push   %ebp
  805671:	89 e5                	mov    %esp,%ebp
  805673:	83 ec 18             	sub    $0x18,%esp
  805676:	8b 45 08             	mov    0x8(%ebp),%eax
  struct sswt_cb *sswt_cb = (struct sswt_cb *) arg;

  /* Timeout. Set flag to TRUE and signal semaphore */
  sswt_cb->timeflag = 1;
  805679:	66 c7 00 01 00       	movw   $0x1,(%eax)
  sys_sem_signal(*(sswt_cb->psem));
  80567e:	8b 40 04             	mov    0x4(%eax),%eax
  805681:	8b 00                	mov    (%eax),%eax
  805683:	89 04 24             	mov    %eax,(%esp)
  805686:	e8 75 52 00 00       	call   80a900 <sys_sem_signal>
}
  80568b:	c9                   	leave  
  80568c:	c3                   	ret    

0080568d <sys_mbox_fetch>:
 * @param mbox the mbox to fetch the message from
 * @param msg the place to store the message
 */
void
sys_mbox_fetch(sys_mbox_t mbox, void **msg)
{
  80568d:	55                   	push   %ebp
  80568e:	89 e5                	mov    %esp,%ebp
  805690:	57                   	push   %edi
  805691:	56                   	push   %esi
  805692:	53                   	push   %ebx
  805693:	83 ec 1c             	sub    $0x1c,%esp
  805696:	8b 7d 0c             	mov    0xc(%ebp),%edi
  struct sys_timeo *tmptimeout;
  sys_timeout_handler h;
  void *arg;

 again:
  timeouts = sys_arch_timeouts();
  805699:	e8 ce 56 00 00       	call   80ad6c <sys_arch_timeouts>
  80569e:	89 c3                	mov    %eax,%ebx

  if (!timeouts || !timeouts->next) {
  8056a0:	85 c0                	test   %eax,%eax
  8056a2:	74 06                	je     8056aa <sys_mbox_fetch+0x1d>
  8056a4:	8b 00                	mov    (%eax),%eax
  8056a6:	85 c0                	test   %eax,%eax
  8056a8:	75 19                	jne    8056c3 <sys_mbox_fetch+0x36>
    UNLOCK_TCPIP_CORE();
    time_needed = sys_arch_mbox_fetch(mbox, msg, 0);
  8056aa:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8056b1:	00 
  8056b2:	89 7c 24 04          	mov    %edi,0x4(%esp)
  8056b6:	8b 45 08             	mov    0x8(%ebp),%eax
  8056b9:	89 04 24             	mov    %eax,(%esp)
  8056bc:	e8 d7 54 00 00       	call   80ab98 <sys_arch_mbox_fetch>
  8056c1:	eb 5d                	jmp    805720 <sys_mbox_fetch+0x93>
    LOCK_TCPIP_CORE();
  } else {
    if (timeouts->next->time > 0) {
  8056c3:	8b 40 04             	mov    0x4(%eax),%eax
  8056c6:	85 c0                	test   %eax,%eax
  8056c8:	74 18                	je     8056e2 <sys_mbox_fetch+0x55>
      UNLOCK_TCPIP_CORE();
      time_needed = sys_arch_mbox_fetch(mbox, msg, timeouts->next->time);
  8056ca:	89 44 24 08          	mov    %eax,0x8(%esp)
  8056ce:	89 7c 24 04          	mov    %edi,0x4(%esp)
  8056d2:	8b 45 08             	mov    0x8(%ebp),%eax
  8056d5:	89 04 24             	mov    %eax,(%esp)
  8056d8:	e8 bb 54 00 00       	call   80ab98 <sys_arch_mbox_fetch>
      LOCK_TCPIP_CORE();
    } else {
      time_needed = SYS_ARCH_TIMEOUT;
    }

    if (time_needed == SYS_ARCH_TIMEOUT) {
  8056dd:	83 f8 ff             	cmp    $0xffffffff,%eax
  8056e0:	75 27                	jne    805709 <sys_mbox_fetch+0x7c>
      /* If time == SYS_ARCH_TIMEOUT, a timeout occured before a message
         could be fetched. We should now call the timeout handler and
         deallocate the memory allocated for the timeout. */
      tmptimeout = timeouts->next;
  8056e2:	8b 03                	mov    (%ebx),%eax
      timeouts->next = tmptimeout->next;
  8056e4:	8b 10                	mov    (%eax),%edx
  8056e6:	89 13                	mov    %edx,(%ebx)
      h   = tmptimeout->h;
  8056e8:	8b 58 08             	mov    0x8(%eax),%ebx
      arg = tmptimeout->arg;
  8056eb:	8b 70 0c             	mov    0xc(%eax),%esi
      memp_free(MEMP_SYS_TIMEOUT, tmptimeout);
  8056ee:	89 44 24 04          	mov    %eax,0x4(%esp)
  8056f2:	c7 04 24 0b 00 00 00 	movl   $0xb,(%esp)
  8056f9:	e8 44 f3 ff ff       	call   804a42 <memp_free>
      if (h != NULL) {
  8056fe:	85 db                	test   %ebx,%ebx
  805700:	74 97                	je     805699 <sys_mbox_fetch+0xc>
        LWIP_DEBUGF(SYS_DEBUG, ("smf calling h=%p(%p)\n", (void*)&h, arg));
        h(arg);
  805702:	89 34 24             	mov    %esi,(%esp)
  805705:	ff d3                	call   *%ebx
  805707:	eb 90                	jmp    805699 <sys_mbox_fetch+0xc>
      goto again;
    } else {
      /* If time != SYS_ARCH_TIMEOUT, a message was received before the timeout
         occured. The time variable is set to the number of
         milliseconds we waited for the message. */
      if (time_needed < timeouts->next->time) {
  805709:	8b 13                	mov    (%ebx),%edx
  80570b:	8b 4a 04             	mov    0x4(%edx),%ecx
  80570e:	39 c8                	cmp    %ecx,%eax
  805710:	73 07                	jae    805719 <sys_mbox_fetch+0x8c>
        timeouts->next->time -= time_needed;
  805712:	29 c1                	sub    %eax,%ecx
  805714:	89 4a 04             	mov    %ecx,0x4(%edx)
  805717:	eb 07                	jmp    805720 <sys_mbox_fetch+0x93>
      } else {
        timeouts->next->time = 0;
  805719:	c7 42 04 00 00 00 00 	movl   $0x0,0x4(%edx)
      }
    }
  }
}
  805720:	83 c4 1c             	add    $0x1c,%esp
  805723:	5b                   	pop    %ebx
  805724:	5e                   	pop    %esi
  805725:	5f                   	pop    %edi
  805726:	5d                   	pop    %ebp
  805727:	c3                   	ret    

00805728 <sys_sem_wait>:
 *
 * @param sem semaphore to wait for
 */
void
sys_sem_wait(sys_sem_t sem)
{
  805728:	55                   	push   %ebp
  805729:	89 e5                	mov    %esp,%ebp
  80572b:	57                   	push   %edi
  80572c:	56                   	push   %esi
  80572d:	53                   	push   %ebx
  80572e:	83 ec 1c             	sub    $0x1c,%esp
  805731:	8b 75 08             	mov    0x8(%ebp),%esi
  sys_timeout_handler h;
  void *arg;

 again:

  timeouts = sys_arch_timeouts();
  805734:	e8 33 56 00 00       	call   80ad6c <sys_arch_timeouts>
  805739:	89 c3                	mov    %eax,%ebx

  if (!timeouts || !timeouts->next) {
  80573b:	85 c0                	test   %eax,%eax
  80573d:	74 06                	je     805745 <sys_sem_wait+0x1d>
  80573f:	8b 00                	mov    (%eax),%eax
  805741:	85 c0                	test   %eax,%eax
  805743:	75 12                	jne    805757 <sys_sem_wait+0x2f>
    sys_arch_sem_wait(sem, 0);
  805745:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80574c:	00 
  80574d:	89 34 24             	mov    %esi,(%esp)
  805750:	e8 20 52 00 00       	call   80a975 <sys_arch_sem_wait>
  805755:	eb 56                	jmp    8057ad <sys_sem_wait+0x85>
  } else {
    if (timeouts->next->time > 0) {
  805757:	8b 40 04             	mov    0x4(%eax),%eax
  80575a:	85 c0                	test   %eax,%eax
  80575c:	74 11                	je     80576f <sys_sem_wait+0x47>
      time_needed = sys_arch_sem_wait(sem, timeouts->next->time);
  80575e:	89 44 24 04          	mov    %eax,0x4(%esp)
  805762:	89 34 24             	mov    %esi,(%esp)
  805765:	e8 0b 52 00 00       	call   80a975 <sys_arch_sem_wait>
    } else {
      time_needed = SYS_ARCH_TIMEOUT;
    }

    if (time_needed == SYS_ARCH_TIMEOUT) {
  80576a:	83 f8 ff             	cmp    $0xffffffff,%eax
  80576d:	75 27                	jne    805796 <sys_sem_wait+0x6e>
      /* If time == SYS_ARCH_TIMEOUT, a timeout occured before a message
        could be fetched. We should now call the timeout handler and
        deallocate the memory allocated for the timeout. */
      tmptimeout = timeouts->next;
  80576f:	8b 03                	mov    (%ebx),%eax
      timeouts->next = tmptimeout->next;
  805771:	8b 10                	mov    (%eax),%edx
  805773:	89 13                	mov    %edx,(%ebx)
      h = tmptimeout->h;
  805775:	8b 58 08             	mov    0x8(%eax),%ebx
      arg = tmptimeout->arg;
  805778:	8b 78 0c             	mov    0xc(%eax),%edi
      memp_free(MEMP_SYS_TIMEOUT, tmptimeout);
  80577b:	89 44 24 04          	mov    %eax,0x4(%esp)
  80577f:	c7 04 24 0b 00 00 00 	movl   $0xb,(%esp)
  805786:	e8 b7 f2 ff ff       	call   804a42 <memp_free>
      if (h != NULL) {
  80578b:	85 db                	test   %ebx,%ebx
  80578d:	74 a5                	je     805734 <sys_sem_wait+0xc>
        LWIP_DEBUGF(SYS_DEBUG, ("ssw h=%p(%p)\n", (void*)&h, (void *)arg));
        h(arg);
  80578f:	89 3c 24             	mov    %edi,(%esp)
  805792:	ff d3                	call   *%ebx
  805794:	eb 9e                	jmp    805734 <sys_sem_wait+0xc>
      goto again;
    } else {
      /* If time != SYS_ARCH_TIMEOUT, a message was received before the timeout
         occured. The time variable is set to the number of
         milliseconds we waited for the message. */
      if (time_needed < timeouts->next->time) {
  805796:	8b 13                	mov    (%ebx),%edx
  805798:	8b 4a 04             	mov    0x4(%edx),%ecx
  80579b:	39 c8                	cmp    %ecx,%eax
  80579d:	73 07                	jae    8057a6 <sys_sem_wait+0x7e>
        timeouts->next->time -= time_needed;
  80579f:	29 c1                	sub    %eax,%ecx
  8057a1:	89 4a 04             	mov    %ecx,0x4(%edx)
  8057a4:	eb 07                	jmp    8057ad <sys_sem_wait+0x85>
      } else {
        timeouts->next->time = 0;
  8057a6:	c7 42 04 00 00 00 00 	movl   $0x0,0x4(%edx)
      }
    }
  }
}
  8057ad:	83 c4 1c             	add    $0x1c,%esp
  8057b0:	5b                   	pop    %ebx
  8057b1:	5e                   	pop    %esi
  8057b2:	5f                   	pop    %edi
  8057b3:	5d                   	pop    %ebp
  8057b4:	c3                   	ret    

008057b5 <sys_timeout>:
 * @param h callback function to call when msecs have elapsed
 * @param arg argument to pass to the callback function
 */
void
sys_timeout(u32_t msecs, sys_timeout_handler h, void *arg)
{
  8057b5:	55                   	push   %ebp
  8057b6:	89 e5                	mov    %esp,%ebp
  8057b8:	56                   	push   %esi
  8057b9:	53                   	push   %ebx
  8057ba:	83 ec 10             	sub    $0x10,%esp
  8057bd:	8b 75 08             	mov    0x8(%ebp),%esi
  struct sys_timeouts *timeouts;
  struct sys_timeo *timeout, *t;

  timeout = memp_malloc(MEMP_SYS_TIMEOUT);
  8057c0:	c7 04 24 0b 00 00 00 	movl   $0xb,(%esp)
  8057c7:	e8 16 f2 ff ff       	call   8049e2 <memp_malloc>
  8057cc:	89 c3                	mov    %eax,%ebx
  if (timeout == NULL) {
  8057ce:	85 c0                	test   %eax,%eax
  8057d0:	75 1c                	jne    8057ee <sys_timeout+0x39>
    LWIP_ASSERT("sys_timeout: timeout != NULL", timeout != NULL);
  8057d2:	c7 44 24 08 b9 29 81 	movl   $0x8129b9,0x8(%esp)
  8057d9:	00 
  8057da:	c7 44 24 04 c3 00 00 	movl   $0xc3,0x4(%esp)
  8057e1:	00 
  8057e2:	c7 04 24 d6 29 81 00 	movl   $0x8129d6,(%esp)
  8057e9:	e8 8c 98 00 00       	call   80f07a <_panic>
    return;
  }
  timeout->next = NULL;
  8057ee:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  timeout->h = h;
  8057f4:	8b 45 0c             	mov    0xc(%ebp),%eax
  8057f7:	89 43 08             	mov    %eax,0x8(%ebx)
  timeout->arg = arg;
  8057fa:	8b 45 10             	mov    0x10(%ebp),%eax
  8057fd:	89 43 0c             	mov    %eax,0xc(%ebx)
  timeout->time = msecs;
  805800:	89 73 04             	mov    %esi,0x4(%ebx)

  timeouts = sys_arch_timeouts();
  805803:	e8 64 55 00 00       	call   80ad6c <sys_arch_timeouts>

  LWIP_DEBUGF(SYS_DEBUG, ("sys_timeout: %p msecs=%"U32_F" h=%p arg=%p\n",
    (void *)timeout, msecs, (void*)&h, (void *)arg));

  if (timeouts == NULL) {
  805808:	85 c0                	test   %eax,%eax
  80580a:	75 1c                	jne    805828 <sys_timeout+0x73>
    LWIP_ASSERT("sys_timeout: timeouts != NULL", timeouts != NULL);
  80580c:	c7 44 24 08 ea 29 81 	movl   $0x8129ea,0x8(%esp)
  805813:	00 
  805814:	c7 44 24 04 d1 00 00 	movl   $0xd1,0x4(%esp)
  80581b:	00 
  80581c:	c7 04 24 d6 29 81 00 	movl   $0x8129d6,(%esp)
  805823:	e8 52 98 00 00       	call   80f07a <_panic>
    return;
  }

  if (timeouts->next == NULL) {
  805828:	8b 08                	mov    (%eax),%ecx
  80582a:	85 c9                	test   %ecx,%ecx
  80582c:	75 04                	jne    805832 <sys_timeout+0x7d>
    timeouts->next = timeout;
  80582e:	89 18                	mov    %ebx,(%eax)
    return;
  805830:	eb 35                	jmp    805867 <sys_timeout+0xb2>
  }

  if (timeouts->next->time > msecs) {
  805832:	8b 51 04             	mov    0x4(%ecx),%edx
  805835:	39 d6                	cmp    %edx,%esi
  805837:	73 0d                	jae    805846 <sys_timeout+0x91>
    timeouts->next->time -= msecs;
  805839:	29 f2                	sub    %esi,%edx
  80583b:	89 51 04             	mov    %edx,0x4(%ecx)
    timeout->next = timeouts->next;
  80583e:	8b 10                	mov    (%eax),%edx
  805840:	89 13                	mov    %edx,(%ebx)
    timeouts->next = timeout;
  805842:	89 18                	mov    %ebx,(%eax)
  805844:	eb 21                	jmp    805867 <sys_timeout+0xb2>
  } else {
    for(t = timeouts->next; t != NULL; t = t->next) {
      timeout->time -= t->time;
  805846:	8b 43 04             	mov    0x4(%ebx),%eax
  805849:	2b 41 04             	sub    0x4(%ecx),%eax
  80584c:	89 43 04             	mov    %eax,0x4(%ebx)
      if (t->next == NULL || t->next->time > timeout->time) {
  80584f:	8b 11                	mov    (%ecx),%edx
  805851:	85 d2                	test   %edx,%edx
  805853:	74 0c                	je     805861 <sys_timeout+0xac>
  805855:	3b 42 04             	cmp    0x4(%edx),%eax
  805858:	72 04                	jb     80585e <sys_timeout+0xa9>
  80585a:	89 d1                	mov    %edx,%ecx
  80585c:	eb e8                	jmp    805846 <sys_timeout+0x91>
        if (t->next != NULL) {
          t->next->time -= timeout->time;
  80585e:	29 42 04             	sub    %eax,0x4(%edx)
        }
        timeout->next = t->next;
  805861:	8b 01                	mov    (%ecx),%eax
  805863:	89 03                	mov    %eax,(%ebx)
        t->next = timeout;
  805865:	89 19                	mov    %ebx,(%ecx)
        break;
      }
    }
  }
}
  805867:	83 c4 10             	add    $0x10,%esp
  80586a:	5b                   	pop    %ebx
  80586b:	5e                   	pop    %esi
  80586c:	5d                   	pop    %ebp
  80586d:	c3                   	ret    

0080586e <sys_untimeout>:
 * @param h callback function that would be called by the timeout
 * @param arg callback argument that would be passed to h
*/
void
sys_untimeout(sys_timeout_handler h, void *arg)
{
  80586e:	55                   	push   %ebp
  80586f:	89 e5                	mov    %esp,%ebp
  805871:	57                   	push   %edi
  805872:	56                   	push   %esi
  805873:	53                   	push   %ebx
  805874:	83 ec 1c             	sub    $0x1c,%esp
  805877:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80587a:	8b 75 0c             	mov    0xc(%ebp),%esi
  struct sys_timeouts *timeouts;
  struct sys_timeo *prev_t, *t;

  timeouts = sys_arch_timeouts();
  80587d:	e8 ea 54 00 00       	call   80ad6c <sys_arch_timeouts>

  if (timeouts == NULL) {
  805882:	85 c0                	test   %eax,%eax
  805884:	75 1c                	jne    8058a2 <sys_untimeout+0x34>
    LWIP_ASSERT("sys_untimeout: timeouts != NULL", timeouts != NULL);
  805886:	c7 44 24 08 08 2a 81 	movl   $0x812a08,0x8(%esp)
  80588d:	00 
  80588e:	c7 44 24 04 00 01 00 	movl   $0x100,0x4(%esp)
  805895:	00 
  805896:	c7 04 24 d6 29 81 00 	movl   $0x8129d6,(%esp)
  80589d:	e8 d8 97 00 00       	call   80f07a <_panic>
    return;
  }
  if (timeouts->next == NULL) {
  8058a2:	8b 10                	mov    (%eax),%edx
  8058a4:	85 d2                	test   %edx,%edx
  8058a6:	74 4a                	je     8058f2 <sys_untimeout+0x84>
  8058a8:	bf 00 00 00 00       	mov    $0x0,%edi
    return;
  }

  for (t = timeouts->next, prev_t = NULL; t != NULL; prev_t = t, t = t->next) {
    if ((t->h == h) && (t->arg == arg)) {
  8058ad:	39 5a 08             	cmp    %ebx,0x8(%edx)
  8058b0:	75 32                	jne    8058e4 <sys_untimeout+0x76>
  8058b2:	39 72 0c             	cmp    %esi,0xc(%edx)
  8058b5:	75 2d                	jne    8058e4 <sys_untimeout+0x76>
      /* We have a match */
      /* Unlink from previous in list */
      if (prev_t == NULL)
  8058b7:	85 ff                	test   %edi,%edi
  8058b9:	75 07                	jne    8058c2 <sys_untimeout+0x54>
        timeouts->next = t->next;
  8058bb:	8b 0a                	mov    (%edx),%ecx
  8058bd:	89 08                	mov    %ecx,(%eax)
  8058bf:	90                   	nop
  8058c0:	eb 04                	jmp    8058c6 <sys_untimeout+0x58>
      else
        prev_t->next = t->next;
  8058c2:	8b 02                	mov    (%edx),%eax
  8058c4:	89 07                	mov    %eax,(%edi)
      /* If not the last one, add time of this one back to next */
      if (t->next != NULL)
  8058c6:	8b 02                	mov    (%edx),%eax
  8058c8:	85 c0                	test   %eax,%eax
  8058ca:	74 06                	je     8058d2 <sys_untimeout+0x64>
        t->next->time += t->time;
  8058cc:	8b 4a 04             	mov    0x4(%edx),%ecx
  8058cf:	01 48 04             	add    %ecx,0x4(%eax)
      memp_free(MEMP_SYS_TIMEOUT, t);
  8058d2:	89 54 24 04          	mov    %edx,0x4(%esp)
  8058d6:	c7 04 24 0b 00 00 00 	movl   $0xb,(%esp)
  8058dd:	e8 60 f1 ff ff       	call   804a42 <memp_free>
      return;
  8058e2:	eb 0e                	jmp    8058f2 <sys_untimeout+0x84>
  }
  if (timeouts->next == NULL) {
    return;
  }

  for (t = timeouts->next, prev_t = NULL; t != NULL; prev_t = t, t = t->next) {
  8058e4:	8b 0a                	mov    (%edx),%ecx
  8058e6:	85 c9                	test   %ecx,%ecx
  8058e8:	74 08                	je     8058f2 <sys_untimeout+0x84>
  8058ea:	89 d7                	mov    %edx,%edi
  8058ec:	89 ca                	mov    %ecx,%edx
  8058ee:	66 90                	xchg   %ax,%ax
  8058f0:	eb bb                	jmp    8058ad <sys_untimeout+0x3f>
      memp_free(MEMP_SYS_TIMEOUT, t);
      return;
    }
  }
  return;
}
  8058f2:	83 c4 1c             	add    $0x1c,%esp
  8058f5:	5b                   	pop    %ebx
  8058f6:	5e                   	pop    %esi
  8058f7:	5f                   	pop    %edi
  8058f8:	5d                   	pop    %ebp
  8058f9:	c3                   	ret    

008058fa <sys_sem_wait_timeout>:
 * @param timeout timeout in ms (0: wait forever)
 * @return 0 on timeout, 1 otherwise
 */
int
sys_sem_wait_timeout(sys_sem_t sem, u32_t timeout)
{
  8058fa:	55                   	push   %ebp
  8058fb:	89 e5                	mov    %esp,%ebp
  8058fd:	83 ec 28             	sub    $0x28,%esp
  805900:	8b 45 0c             	mov    0xc(%ebp),%eax
  struct sswt_cb sswt_cb;

  sswt_cb.psem = &sem;
  805903:	8d 4d 08             	lea    0x8(%ebp),%ecx
  805906:	89 4d f4             	mov    %ecx,-0xc(%ebp)
  sswt_cb.timeflag = 0;
  805909:	66 c7 45 f0 00 00    	movw   $0x0,-0x10(%ebp)

  /* If timeout is zero, then just wait forever */
  if (timeout > 0) {
  80590f:	85 c0                	test   %eax,%eax
  805911:	74 17                	je     80592a <sys_sem_wait_timeout+0x30>
    /* Create a timer and pass it the address of our flag */
    sys_timeout(timeout, sswt_handler, &sswt_cb);
  805913:	8d 55 f0             	lea    -0x10(%ebp),%edx
  805916:	89 54 24 08          	mov    %edx,0x8(%esp)
  80591a:	c7 44 24 04 70 56 80 	movl   $0x805670,0x4(%esp)
  805921:	00 
  805922:	89 04 24             	mov    %eax,(%esp)
  805925:	e8 8b fe ff ff       	call   8057b5 <sys_timeout>
  }
  sys_sem_wait(sem);
  80592a:	8b 45 08             	mov    0x8(%ebp),%eax
  80592d:	89 04 24             	mov    %eax,(%esp)
  805930:	e8 f3 fd ff ff       	call   805728 <sys_sem_wait>
  /* Was it a timeout? */
  if (sswt_cb.timeflag) {
    /* timeout */
    return 0;
  805935:	b8 00 00 00 00       	mov    $0x0,%eax
    /* Create a timer and pass it the address of our flag */
    sys_timeout(timeout, sswt_handler, &sswt_cb);
  }
  sys_sem_wait(sem);
  /* Was it a timeout? */
  if (sswt_cb.timeflag) {
  80593a:	66 83 7d f0 00       	cmpw   $0x0,-0x10(%ebp)
  80593f:	75 18                	jne    805959 <sys_sem_wait_timeout+0x5f>
    /* timeout */
    return 0;
  } else {
    /* Not a timeout. Remove timeout entry */
    sys_untimeout(sswt_handler, &sswt_cb);
  805941:	8d 45 f0             	lea    -0x10(%ebp),%eax
  805944:	89 44 24 04          	mov    %eax,0x4(%esp)
  805948:	c7 04 24 70 56 80 00 	movl   $0x805670,(%esp)
  80594f:	e8 1a ff ff ff       	call   80586e <sys_untimeout>
    return 1;
  805954:	b8 01 00 00 00       	mov    $0x1,%eax
  }
}
  805959:	c9                   	leave  
  80595a:	c3                   	ret    

0080595b <sys_msleep>:
 *
 * @param ms number of milliseconds to sleep
 */
void
sys_msleep(u32_t ms)
{
  80595b:	55                   	push   %ebp
  80595c:	89 e5                	mov    %esp,%ebp
  80595e:	53                   	push   %ebx
  80595f:	83 ec 14             	sub    $0x14,%esp
  sys_sem_t delaysem = sys_sem_new(0);
  805962:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  805969:	e8 b0 4c 00 00       	call   80a61e <sys_sem_new>
  80596e:	89 c3                	mov    %eax,%ebx

  sys_sem_wait_timeout(delaysem, ms);
  805970:	8b 45 08             	mov    0x8(%ebp),%eax
  805973:	89 44 24 04          	mov    %eax,0x4(%esp)
  805977:	89 1c 24             	mov    %ebx,(%esp)
  80597a:	e8 7b ff ff ff       	call   8058fa <sys_sem_wait_timeout>

  sys_sem_free(delaysem);
  80597f:	89 1c 24             	mov    %ebx,(%esp)
  805982:	e8 20 4d 00 00       	call   80a6a7 <sys_sem_free>
}
  805987:	83 c4 14             	add    $0x14,%esp
  80598a:	5b                   	pop    %ebx
  80598b:	5d                   	pop    %ebp
  80598c:	c3                   	ret    
  80598d:	66 90                	xchg   %ax,%ax
  80598f:	90                   	nop

00805990 <tcp_accept_null>:
/**
 * Default accept callback if no accept callback is specified by the user.
 */
static err_t
tcp_accept_null(void *arg, struct tcp_pcb *pcb, err_t err)
{
  805990:	55                   	push   %ebp
  805991:	89 e5                	mov    %esp,%ebp
  LWIP_UNUSED_ARG(arg);
  LWIP_UNUSED_ARG(pcb);
  LWIP_UNUSED_ARG(err);

  return ERR_ABRT;
}
  805993:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
  805998:	5d                   	pop    %ebp
  805999:	c3                   	ret    

0080599a <tcp_new_port>:
 *
 * @return a new (free) local TCP port number
 */
static u16_t
tcp_new_port(void)
{
  80599a:	55                   	push   %ebp
  80599b:	89 e5                	mov    %esp,%ebp
  80599d:	57                   	push   %edi
  80599e:	56                   	push   %esi
  80599f:	53                   	push   %ebx
 again:
  if (++port > TCP_LOCAL_PORT_RANGE_END) {
    port = TCP_LOCAL_PORT_RANGE_START;
  }
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  8059a0:	8b 1d 5c c2 b3 00    	mov    0xb3c25c,%ebx
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  8059a6:	8b 35 70 c2 b3 00    	mov    0xb3c270,%esi
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
  8059ac:	8b 3d 64 c2 b3 00    	mov    0xb3c264,%edi
  8059b2:	0f b7 05 0c 50 81 00 	movzwl 0x81500c,%eax
#endif
  static u16_t port = TCP_LOCAL_PORT_RANGE_START;
  
 again:
  if (++port > TCP_LOCAL_PORT_RANGE_END) {
    port = TCP_LOCAL_PORT_RANGE_START;
  8059b9:	b9 00 10 00 00       	mov    $0x1000,%ecx
#define TCP_LOCAL_PORT_RANGE_END   0x7fff
#endif
  static u16_t port = TCP_LOCAL_PORT_RANGE_START;
  
 again:
  if (++port > TCP_LOCAL_PORT_RANGE_END) {
  8059be:	66 83 c0 01          	add    $0x1,%ax
    port = TCP_LOCAL_PORT_RANGE_START;
  8059c2:	0f 48 c1             	cmovs  %ecx,%eax
  }
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  8059c5:	89 da                	mov    %ebx,%edx
  8059c7:	eb 09                	jmp    8059d2 <tcp_new_port+0x38>
    if (pcb->local_port == port) {
  8059c9:	66 3b 42 1c          	cmp    0x1c(%edx),%ax
  8059cd:	74 ef                	je     8059be <tcp_new_port+0x24>
 again:
  if (++port > TCP_LOCAL_PORT_RANGE_END) {
    port = TCP_LOCAL_PORT_RANGE_START;
  }
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  8059cf:	8b 52 0c             	mov    0xc(%edx),%edx
  8059d2:	85 d2                	test   %edx,%edx
  8059d4:	75 f3                	jne    8059c9 <tcp_new_port+0x2f>
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  8059d6:	89 f2                	mov    %esi,%edx
  8059d8:	eb 09                	jmp    8059e3 <tcp_new_port+0x49>
    if (pcb->local_port == port) {
  8059da:	66 3b 42 1c          	cmp    0x1c(%edx),%ax
  8059de:	74 de                	je     8059be <tcp_new_port+0x24>
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  8059e0:	8b 52 0c             	mov    0xc(%edx),%edx
  8059e3:	85 d2                	test   %edx,%edx
  8059e5:	75 f3                	jne    8059da <tcp_new_port+0x40>
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
  8059e7:	89 fa                	mov    %edi,%edx
  8059e9:	eb 09                	jmp    8059f4 <tcp_new_port+0x5a>
    if (pcb->local_port == port) {
  8059eb:	66 3b 42 1c          	cmp    0x1c(%edx),%ax
  8059ef:	74 cd                	je     8059be <tcp_new_port+0x24>
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
  8059f1:	8b 52 0c             	mov    0xc(%edx),%edx
  8059f4:	85 d2                	test   %edx,%edx
  8059f6:	75 f3                	jne    8059eb <tcp_new_port+0x51>
  8059f8:	66 a3 0c 50 81 00    	mov    %ax,0x81500c
    if (pcb->local_port == port) {
      goto again;
    }
  }
  return port;
}
  8059fe:	5b                   	pop    %ebx
  8059ff:	5e                   	pop    %esi
  805a00:	5f                   	pop    %edi
  805a01:	5d                   	pop    %ebp
  805a02:	c3                   	ret    

00805a03 <tcp_bind>:
 * @return ERR_USE if the port is already in use
 *         ERR_OK if bound
 */
err_t
tcp_bind(struct tcp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
{
  805a03:	55                   	push   %ebp
  805a04:	89 e5                	mov    %esp,%ebp
  805a06:	57                   	push   %edi
  805a07:	56                   	push   %esi
  805a08:	53                   	push   %ebx
  805a09:	83 ec 1c             	sub    $0x1c,%esp
  805a0c:	8b 75 08             	mov    0x8(%ebp),%esi
  805a0f:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  805a12:	8b 55 10             	mov    0x10(%ebp),%edx
  struct tcp_pcb *cpcb;

  LWIP_ERROR("tcp_connect: can only bind in state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
  805a15:	83 7e 10 00          	cmpl   $0x0,0x10(%esi)
  805a19:	74 1c                	je     805a37 <tcp_bind+0x34>
  805a1b:	c7 44 24 08 28 2a 81 	movl   $0x812a28,0x8(%esp)
  805a22:	00 
  805a23:	c7 44 24 04 05 01 00 	movl   $0x105,0x4(%esp)
  805a2a:	00 
  805a2b:	c7 04 24 0a 2c 81 00 	movl   $0x812c0a,(%esp)
  805a32:	e8 43 96 00 00       	call   80f07a <_panic>
  805a37:	89 d0                	mov    %edx,%eax

  if (port == 0) {
  805a39:	66 85 d2             	test   %dx,%dx
  805a3c:	75 05                	jne    805a43 <tcp_bind+0x40>
    port = tcp_new_port();
  805a3e:	e8 57 ff ff ff       	call   80599a <tcp_new_port>
  }
  /* Check if the address already is in use. */
  /* Check the listen pcbs. */
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
  805a43:	8b 15 64 c2 b3 00    	mov    0xb3c264,%edx
  805a49:	eb 35                	jmp    805a80 <tcp_bind+0x7d>
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
  805a4b:	66 39 42 1c          	cmp    %ax,0x1c(%edx)
  805a4f:	75 2c                	jne    805a7d <tcp_bind+0x7a>
      if (ip_addr_isany(&(cpcb->local_ip)) ||
  805a51:	85 d2                	test   %edx,%edx
  805a53:	0f 84 f7 00 00 00    	je     805b50 <tcp_bind+0x14d>
  805a59:	8b 0a                	mov    (%edx),%ecx
  805a5b:	85 c9                	test   %ecx,%ecx
  805a5d:	0f 84 f4 00 00 00    	je     805b57 <tcp_bind+0x154>
  805a63:	85 db                	test   %ebx,%ebx
  805a65:	0f 84 f3 00 00 00    	je     805b5e <tcp_bind+0x15b>
          ip_addr_isany(ipaddr) ||
  805a6b:	8b 3b                	mov    (%ebx),%edi
  805a6d:	85 ff                	test   %edi,%edi
  805a6f:	0f 84 f0 00 00 00    	je     805b65 <tcp_bind+0x162>
  805a75:	39 f9                	cmp    %edi,%ecx
  805a77:	0f 84 ef 00 00 00    	je     805b6c <tcp_bind+0x169>
    port = tcp_new_port();
  }
  /* Check if the address already is in use. */
  /* Check the listen pcbs. */
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
      cpcb != NULL; cpcb = cpcb->next) {
  805a7d:	8b 52 0c             	mov    0xc(%edx),%edx
  if (port == 0) {
    port = tcp_new_port();
  }
  /* Check if the address already is in use. */
  /* Check the listen pcbs. */
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
  805a80:	85 d2                	test   %edx,%edx
  805a82:	75 c7                	jne    805a4b <tcp_bind+0x48>
        return ERR_USE;
      }
    }
  }
  /* Check the connected pcbs. */
  for(cpcb = tcp_active_pcbs;
  805a84:	8b 15 5c c2 b3 00    	mov    0xb3c25c,%edx
  805a8a:	eb 35                	jmp    805ac1 <tcp_bind+0xbe>
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
  805a8c:	66 39 42 1c          	cmp    %ax,0x1c(%edx)
  805a90:	75 2c                	jne    805abe <tcp_bind+0xbb>
      if (ip_addr_isany(&(cpcb->local_ip)) ||
  805a92:	85 d2                	test   %edx,%edx
  805a94:	0f 84 d9 00 00 00    	je     805b73 <tcp_bind+0x170>
  805a9a:	8b 0a                	mov    (%edx),%ecx
  805a9c:	85 c9                	test   %ecx,%ecx
  805a9e:	0f 84 d6 00 00 00    	je     805b7a <tcp_bind+0x177>
  805aa4:	85 db                	test   %ebx,%ebx
  805aa6:	0f 84 d5 00 00 00    	je     805b81 <tcp_bind+0x17e>
          ip_addr_isany(ipaddr) ||
  805aac:	8b 3b                	mov    (%ebx),%edi
  805aae:	85 ff                	test   %edi,%edi
  805ab0:	0f 84 d2 00 00 00    	je     805b88 <tcp_bind+0x185>
  805ab6:	39 f9                	cmp    %edi,%ecx
  805ab8:	0f 84 d1 00 00 00    	je     805b8f <tcp_bind+0x18c>
      }
    }
  }
  /* Check the connected pcbs. */
  for(cpcb = tcp_active_pcbs;
      cpcb != NULL; cpcb = cpcb->next) {
  805abe:	8b 52 0c             	mov    0xc(%edx),%edx
        return ERR_USE;
      }
    }
  }
  /* Check the connected pcbs. */
  for(cpcb = tcp_active_pcbs;
  805ac1:	85 d2                	test   %edx,%edx
  805ac3:	75 c7                	jne    805a8c <tcp_bind+0x89>
        return ERR_USE;
      }
    }
  }
  /* Check the bound, not yet connected pcbs. */
  for(cpcb = tcp_bound_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  805ac5:	8b 15 6c c2 b3 00    	mov    0xb3c26c,%edx
  805acb:	eb 35                	jmp    805b02 <tcp_bind+0xff>
    if (cpcb->local_port == port) {
  805acd:	66 39 42 1c          	cmp    %ax,0x1c(%edx)
  805ad1:	75 2c                	jne    805aff <tcp_bind+0xfc>
      if (ip_addr_isany(&(cpcb->local_ip)) ||
  805ad3:	85 d2                	test   %edx,%edx
  805ad5:	0f 84 bb 00 00 00    	je     805b96 <tcp_bind+0x193>
  805adb:	8b 0a                	mov    (%edx),%ecx
  805add:	85 c9                	test   %ecx,%ecx
  805adf:	0f 84 b8 00 00 00    	je     805b9d <tcp_bind+0x19a>
  805ae5:	85 db                	test   %ebx,%ebx
  805ae7:	0f 84 b7 00 00 00    	je     805ba4 <tcp_bind+0x1a1>
          ip_addr_isany(ipaddr) ||
  805aed:	8b 3b                	mov    (%ebx),%edi
  805aef:	85 ff                	test   %edi,%edi
  805af1:	0f 84 b4 00 00 00    	je     805bab <tcp_bind+0x1a8>
  805af7:	39 f9                	cmp    %edi,%ecx
  805af9:	0f 84 b3 00 00 00    	je     805bb2 <tcp_bind+0x1af>
        return ERR_USE;
      }
    }
  }
  /* Check the bound, not yet connected pcbs. */
  for(cpcb = tcp_bound_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  805aff:	8b 52 0c             	mov    0xc(%edx),%edx
  805b02:	85 d2                	test   %edx,%edx
  805b04:	75 c7                	jne    805acd <tcp_bind+0xca>
      }
    }
  }
  /* @todo: until SO_REUSEADDR is implemented (see task #6995 on savannah),
   * we have to check the pcbs in TIME-WAIT state, also: */
  for(cpcb = tcp_tw_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  805b06:	8b 15 70 c2 b3 00    	mov    0xb3c270,%edx
  805b0c:	eb 13                	jmp    805b21 <tcp_bind+0x11e>
    if (cpcb->local_port == port) {
  805b0e:	66 39 42 1c          	cmp    %ax,0x1c(%edx)
  805b12:	75 0a                	jne    805b1e <tcp_bind+0x11b>
      if (ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
  805b14:	8b 3b                	mov    (%ebx),%edi
  805b16:	39 3a                	cmp    %edi,(%edx)
  805b18:	0f 84 9b 00 00 00    	je     805bb9 <tcp_bind+0x1b6>
      }
    }
  }
  /* @todo: until SO_REUSEADDR is implemented (see task #6995 on savannah),
   * we have to check the pcbs in TIME-WAIT state, also: */
  for(cpcb = tcp_tw_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  805b1e:	8b 52 0c             	mov    0xc(%edx),%edx
  805b21:	85 d2                	test   %edx,%edx
  805b23:	75 e9                	jne    805b0e <tcp_bind+0x10b>
        return ERR_USE;
      }
    }
  }

  if (!ip_addr_isany(ipaddr)) {
  805b25:	85 db                	test   %ebx,%ebx
  805b27:	74 09                	je     805b32 <tcp_bind+0x12f>
  805b29:	83 3b 00             	cmpl   $0x0,(%ebx)
  805b2c:	74 04                	je     805b32 <tcp_bind+0x12f>
    pcb->local_ip = *ipaddr;
  805b2e:	8b 13                	mov    (%ebx),%edx
  805b30:	89 16                	mov    %edx,(%esi)
  }
  pcb->local_port = port;
  805b32:	66 89 46 1c          	mov    %ax,0x1c(%esi)
  TCP_REG(&tcp_bound_pcbs, pcb);
  805b36:	a1 6c c2 b3 00       	mov    0xb3c26c,%eax
  805b3b:	89 46 0c             	mov    %eax,0xc(%esi)
  805b3e:	89 35 6c c2 b3 00    	mov    %esi,0xb3c26c
  805b44:	e8 29 ca ff ff       	call   802572 <tcp_timer_needed>
  LWIP_DEBUGF(TCP_DEBUG, ("tcp_bind: bind to port %"U16_F"\n", port));
  return ERR_OK;
  805b49:	b8 00 00 00 00       	mov    $0x0,%eax
  805b4e:	eb 6e                	jmp    805bbe <tcp_bind+0x1bb>
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
      if (ip_addr_isany(&(cpcb->local_ip)) ||
          ip_addr_isany(ipaddr) ||
          ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
        return ERR_USE;
  805b50:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  805b55:	eb 67                	jmp    805bbe <tcp_bind+0x1bb>
  805b57:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  805b5c:	eb 60                	jmp    805bbe <tcp_bind+0x1bb>
  805b5e:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  805b63:	eb 59                	jmp    805bbe <tcp_bind+0x1bb>
  805b65:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  805b6a:	eb 52                	jmp    805bbe <tcp_bind+0x1bb>
  805b6c:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  805b71:	eb 4b                	jmp    805bbe <tcp_bind+0x1bb>
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
      if (ip_addr_isany(&(cpcb->local_ip)) ||
          ip_addr_isany(ipaddr) ||
          ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
        return ERR_USE;
  805b73:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  805b78:	eb 44                	jmp    805bbe <tcp_bind+0x1bb>
  805b7a:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  805b7f:	eb 3d                	jmp    805bbe <tcp_bind+0x1bb>
  805b81:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  805b86:	eb 36                	jmp    805bbe <tcp_bind+0x1bb>
  805b88:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  805b8d:	eb 2f                	jmp    805bbe <tcp_bind+0x1bb>
  805b8f:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  805b94:	eb 28                	jmp    805bbe <tcp_bind+0x1bb>
  for(cpcb = tcp_bound_pcbs; cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
      if (ip_addr_isany(&(cpcb->local_ip)) ||
          ip_addr_isany(ipaddr) ||
          ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
        return ERR_USE;
  805b96:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  805b9b:	eb 21                	jmp    805bbe <tcp_bind+0x1bb>
  805b9d:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  805ba2:	eb 1a                	jmp    805bbe <tcp_bind+0x1bb>
  805ba4:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  805ba9:	eb 13                	jmp    805bbe <tcp_bind+0x1bb>
  805bab:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  805bb0:	eb 0c                	jmp    805bbe <tcp_bind+0x1bb>
  805bb2:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  805bb7:	eb 05                	jmp    805bbe <tcp_bind+0x1bb>
  /* @todo: until SO_REUSEADDR is implemented (see task #6995 on savannah),
   * we have to check the pcbs in TIME-WAIT state, also: */
  for(cpcb = tcp_tw_pcbs; cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
      if (ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
        return ERR_USE;
  805bb9:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  }
  pcb->local_port = port;
  TCP_REG(&tcp_bound_pcbs, pcb);
  LWIP_DEBUGF(TCP_DEBUG, ("tcp_bind: bind to port %"U16_F"\n", port));
  return ERR_OK;
}
  805bbe:	83 c4 1c             	add    $0x1c,%esp
  805bc1:	5b                   	pop    %ebx
  805bc2:	5e                   	pop    %esi
  805bc3:	5f                   	pop    %edi
  805bc4:	5d                   	pop    %ebp
  805bc5:	c3                   	ret    

00805bc6 <tcp_listen_with_backlog>:
 *       called like this:
 *             tpcb = tcp_listen(tpcb);
 */
struct tcp_pcb *
tcp_listen_with_backlog(struct tcp_pcb *pcb, u8_t backlog)
{
  805bc6:	55                   	push   %ebp
  805bc7:	89 e5                	mov    %esp,%ebp
  805bc9:	56                   	push   %esi
  805bca:	53                   	push   %ebx
  805bcb:	83 ec 10             	sub    $0x10,%esp
  805bce:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct tcp_pcb_listen *lpcb;

  LWIP_UNUSED_ARG(backlog);
  LWIP_ERROR("tcp_listen: pcb already connected", pcb->state == CLOSED, return NULL);
  805bd1:	83 7b 10 00          	cmpl   $0x0,0x10(%ebx)
  805bd5:	74 1c                	je     805bf3 <tcp_listen_with_backlog+0x2d>
  805bd7:	c7 44 24 08 54 2a 81 	movl   $0x812a54,0x8(%esp)
  805bde:	00 
  805bdf:	c7 44 24 04 60 01 00 	movl   $0x160,0x4(%esp)
  805be6:	00 
  805be7:	c7 04 24 0a 2c 81 00 	movl   $0x812c0a,(%esp)
  805bee:	e8 87 94 00 00       	call   80f07a <_panic>

  /* already listening? */
  if (pcb->state == LISTEN) {
    return pcb;
  }
  lpcb = memp_malloc(MEMP_TCP_PCB_LISTEN);
  805bf3:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  805bfa:	e8 e3 ed ff ff       	call   8049e2 <memp_malloc>
  805bff:	89 c6                	mov    %eax,%esi
  if (lpcb == NULL) {
  805c01:	85 c0                	test   %eax,%eax
  805c03:	0f 84 af 00 00 00    	je     805cb8 <tcp_listen_with_backlog+0xf2>
    return NULL;
  }
  lpcb->callback_arg = pcb->callback_arg;
  805c09:	8b 43 18             	mov    0x18(%ebx),%eax
  805c0c:	89 46 18             	mov    %eax,0x18(%esi)
  lpcb->local_port = pcb->local_port;
  805c0f:	0f b7 43 1c          	movzwl 0x1c(%ebx),%eax
  805c13:	66 89 46 1c          	mov    %ax,0x1c(%esi)
  lpcb->state = LISTEN;
  805c17:	c7 46 10 01 00 00 00 	movl   $0x1,0x10(%esi)
  lpcb->so_options = pcb->so_options;
  lpcb->so_options |= SOF_ACCEPTCONN;
  805c1e:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  805c22:	83 c8 02             	or     $0x2,%eax
  805c25:	66 89 46 08          	mov    %ax,0x8(%esi)
  lpcb->ttl = pcb->ttl;
  805c29:	0f b6 43 0b          	movzbl 0xb(%ebx),%eax
  805c2d:	88 46 0b             	mov    %al,0xb(%esi)
  lpcb->tos = pcb->tos;
  805c30:	0f b6 43 0a          	movzbl 0xa(%ebx),%eax
  805c34:	88 46 0a             	mov    %al,0xa(%esi)
  ip_addr_set(&lpcb->local_ip, &pcb->local_ip);
  805c37:	85 db                	test   %ebx,%ebx
  805c39:	74 04                	je     805c3f <tcp_listen_with_backlog+0x79>
  805c3b:	8b 03                	mov    (%ebx),%eax
  805c3d:	eb 05                	jmp    805c44 <tcp_listen_with_backlog+0x7e>
  805c3f:	b8 00 00 00 00       	mov    $0x0,%eax
  805c44:	89 06                	mov    %eax,(%esi)
  TCP_RMV(&tcp_bound_pcbs, pcb);
  805c46:	a1 6c c2 b3 00       	mov    0xb3c26c,%eax
  805c4b:	39 d8                	cmp    %ebx,%eax
  805c4d:	75 0a                	jne    805c59 <tcp_listen_with_backlog+0x93>
  805c4f:	8b 40 0c             	mov    0xc(%eax),%eax
  805c52:	a3 6c c2 b3 00       	mov    %eax,0xb3c26c
  805c57:	eb 2a                	jmp    805c83 <tcp_listen_with_backlog+0xbd>
  805c59:	a3 68 c2 b3 00       	mov    %eax,0xb3c268
  805c5e:	eb 1a                	jmp    805c7a <tcp_listen_with_backlog+0xb4>
  805c60:	8b 50 0c             	mov    0xc(%eax),%edx
  805c63:	85 d2                	test   %edx,%edx
  805c65:	74 11                	je     805c78 <tcp_listen_with_backlog+0xb2>
  805c67:	39 d3                	cmp    %edx,%ebx
  805c69:	75 0d                	jne    805c78 <tcp_listen_with_backlog+0xb2>
  805c6b:	a3 68 c2 b3 00       	mov    %eax,0xb3c268
  805c70:	8b 53 0c             	mov    0xc(%ebx),%edx
  805c73:	89 50 0c             	mov    %edx,0xc(%eax)
  805c76:	eb 0b                	jmp    805c83 <tcp_listen_with_backlog+0xbd>
  805c78:	89 d0                	mov    %edx,%eax
  805c7a:	85 c0                	test   %eax,%eax
  805c7c:	75 e2                	jne    805c60 <tcp_listen_with_backlog+0x9a>
  805c7e:	a3 68 c2 b3 00       	mov    %eax,0xb3c268
  805c83:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
  memp_free(MEMP_TCP_PCB, pcb);
  805c8a:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  805c8e:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  805c95:	e8 a8 ed ff ff       	call   804a42 <memp_free>
#if LWIP_CALLBACK_API
  lpcb->accept = tcp_accept_null;
  805c9a:	c7 46 20 90 59 80 00 	movl   $0x805990,0x20(%esi)
#endif /* LWIP_CALLBACK_API */
#if TCP_LISTEN_BACKLOG
  lpcb->accepts_pending = 0;
  lpcb->backlog = (backlog ? backlog : 1);
#endif /* TCP_LISTEN_BACKLOG */
  TCP_REG(&tcp_listen_pcbs.listen_pcbs, lpcb);
  805ca1:	a1 64 c2 b3 00       	mov    0xb3c264,%eax
  805ca6:	89 46 0c             	mov    %eax,0xc(%esi)
  805ca9:	89 35 64 c2 b3 00    	mov    %esi,0xb3c264
  805caf:	e8 be c8 ff ff       	call   802572 <tcp_timer_needed>
  return (struct tcp_pcb *)lpcb;
  805cb4:	89 f0                	mov    %esi,%eax
  805cb6:	eb 05                	jmp    805cbd <tcp_listen_with_backlog+0xf7>
  if (pcb->state == LISTEN) {
    return pcb;
  }
  lpcb = memp_malloc(MEMP_TCP_PCB_LISTEN);
  if (lpcb == NULL) {
    return NULL;
  805cb8:	b8 00 00 00 00       	mov    $0x0,%eax
  lpcb->accepts_pending = 0;
  lpcb->backlog = (backlog ? backlog : 1);
#endif /* TCP_LISTEN_BACKLOG */
  TCP_REG(&tcp_listen_pcbs.listen_pcbs, lpcb);
  return (struct tcp_pcb *)lpcb;
}
  805cbd:	83 c4 10             	add    $0x10,%esp
  805cc0:	5b                   	pop    %ebx
  805cc1:	5e                   	pop    %esi
  805cc2:	5d                   	pop    %ebp
  805cc3:	c3                   	ret    

00805cc4 <tcp_recved>:
 * @param pcb the tcp_pcb for which data is read
 * @param len the amount of bytes that have been read by the application
 */
void
tcp_recved(struct tcp_pcb *pcb, u16_t len)
{
  805cc4:	55                   	push   %ebp
  805cc5:	89 e5                	mov    %esp,%ebp
  805cc7:	56                   	push   %esi
  805cc8:	53                   	push   %ebx
  805cc9:	83 ec 10             	sub    $0x10,%esp
  805ccc:	8b 45 08             	mov    0x8(%ebp),%eax
  805ccf:	8b 55 0c             	mov    0xc(%ebp),%edx
  if ((u32_t)pcb->rcv_wnd + len > TCP_WND) {
  805cd2:	0f b7 48 28          	movzwl 0x28(%eax),%ecx
  805cd6:	0f b7 f2             	movzwl %dx,%esi
  805cd9:	0f b7 d9             	movzwl %cx,%ebx
  805cdc:	01 f3                	add    %esi,%ebx
  805cde:	81 fb c0 5d 00 00    	cmp    $0x5dc0,%ebx
  805ce4:	76 0e                	jbe    805cf4 <tcp_recved+0x30>
    pcb->rcv_wnd = TCP_WND;
  805ce6:	66 c7 40 28 c0 5d    	movw   $0x5dc0,0x28(%eax)
    pcb->rcv_ann_wnd = TCP_WND;
  805cec:	66 c7 40 2a c0 5d    	movw   $0x5dc0,0x2a(%eax)
  805cf2:	eb 10                	jmp    805d04 <tcp_recved+0x40>
  } else {
    pcb->rcv_wnd += len;
  805cf4:	01 ca                	add    %ecx,%edx
  805cf6:	66 89 50 28          	mov    %dx,0x28(%eax)
    if (pcb->rcv_wnd >= pcb->mss) {
  805cfa:	66 3b 50 34          	cmp    0x34(%eax),%dx
  805cfe:	72 04                	jb     805d04 <tcp_recved+0x40>
      pcb->rcv_ann_wnd = pcb->rcv_wnd;
  805d00:	66 89 50 2a          	mov    %dx,0x2a(%eax)
    }
  }

  if (!(pcb->flags & TF_ACK_DELAY) &&
  805d04:	0f b6 50 20          	movzbl 0x20(%eax),%edx
  805d08:	f6 c2 03             	test   $0x3,%dl
  805d0b:	75 20                	jne    805d2d <tcp_recved+0x69>
     * two ACKs being sent for each received packet in some limited cases
     * (where the application is only receiving data, and is slow to
     * process it) but it is necessary to guarantee that the sender can
     * continue to transmit.
     */
    tcp_ack(pcb);
  805d0d:	f6 c2 01             	test   $0x1,%dl
  805d10:	74 13                	je     805d25 <tcp_recved+0x61>
  805d12:	83 e2 fe             	and    $0xfffffffe,%edx
  805d15:	83 ca 02             	or     $0x2,%edx
  805d18:	88 50 20             	mov    %dl,0x20(%eax)
  805d1b:	89 04 24             	mov    %eax,(%esp)
  805d1e:	e8 3e 2a 00 00       	call   808761 <tcp_output>
  805d23:	eb 23                	jmp    805d48 <tcp_recved+0x84>
  805d25:	83 ca 01             	or     $0x1,%edx
  805d28:	88 50 20             	mov    %dl,0x20(%eax)
  805d2b:	eb 1b                	jmp    805d48 <tcp_recved+0x84>
  } 
  else if (pcb->flags & TF_ACK_DELAY && pcb->rcv_wnd >= TCP_WND/2) {
  805d2d:	f6 c2 01             	test   $0x1,%dl
  805d30:	74 16                	je     805d48 <tcp_recved+0x84>
  805d32:	66 81 78 28 df 2e    	cmpw   $0x2edf,0x28(%eax)
  805d38:	76 0e                	jbe    805d48 <tcp_recved+0x84>
     * nagle-like in its goals, and tries to hit a compromise between
     * sending acks each time the window is updated, and only sending
     * window updates when a timer expires.  The "threshold" used
     * above (currently TCP_WND/2) can be tuned to be more or less
     * aggressive  */
    tcp_ack_now(pcb);
  805d3a:	83 ca 02             	or     $0x2,%edx
  805d3d:	88 50 20             	mov    %dl,0x20(%eax)
  805d40:	89 04 24             	mov    %eax,(%esp)
  805d43:	e8 19 2a 00 00       	call   808761 <tcp_output>
  }

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_recved: recveived %"U16_F" bytes, wnd %"U16_F" (%"U16_F").\n",
         len, pcb->rcv_wnd, TCP_WND - pcb->rcv_wnd));
}
  805d48:	83 c4 10             	add    $0x10,%esp
  805d4b:	5b                   	pop    %ebx
  805d4c:	5e                   	pop    %esi
  805d4d:	5d                   	pop    %ebp
  805d4e:	c3                   	ret    

00805d4f <tcp_fasttmr>:
 *
 * Automatically called from tcp_tmr().
 */
void
tcp_fasttmr(void)
{
  805d4f:	55                   	push   %ebp
  805d50:	89 e5                	mov    %esp,%ebp
  805d52:	53                   	push   %ebx
  805d53:	83 ec 14             	sub    $0x14,%esp
  struct tcp_pcb *pcb;

  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  805d56:	8b 1d 5c c2 b3 00    	mov    0xb3c25c,%ebx
  805d5c:	eb 61                	jmp    805dbf <tcp_fasttmr+0x70>
    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
  805d5e:	8b 83 80 00 00 00    	mov    0x80(%ebx),%eax
  805d64:	85 c0                	test   %eax,%eax
  805d66:	74 3a                	je     805da2 <tcp_fasttmr+0x53>
      /* Notify again application with data previously received. */
      err_t err;
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_fasttmr: notify kept packet\n"));
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  805d68:	8b 93 88 00 00 00    	mov    0x88(%ebx),%edx
  805d6e:	85 d2                	test   %edx,%edx
  805d70:	74 1e                	je     805d90 <tcp_fasttmr+0x41>
  805d72:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  805d79:	00 
  805d7a:	89 44 24 08          	mov    %eax,0x8(%esp)
  805d7e:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  805d82:	8b 43 18             	mov    0x18(%ebx),%eax
  805d85:	89 04 24             	mov    %eax,(%esp)
  805d88:	ff d2                	call   *%edx
      if (err == ERR_OK) {
  805d8a:	84 c0                	test   %al,%al
  805d8c:	75 14                	jne    805da2 <tcp_fasttmr+0x53>
  805d8e:	eb 08                	jmp    805d98 <tcp_fasttmr+0x49>
    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
      /* Notify again application with data previously received. */
      err_t err;
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_fasttmr: notify kept packet\n"));
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  805d90:	89 04 24             	mov    %eax,(%esp)
  805d93:	e8 5c f0 ff ff       	call   804df4 <pbuf_free>
      if (err == ERR_OK) {
        pcb->refused_data = NULL;
  805d98:	c7 83 80 00 00 00 00 	movl   $0x0,0x80(%ebx)
  805d9f:	00 00 00 
      }
    }

    /* send delayed ACKs */  
    if (pcb->flags & TF_ACK_DELAY) {
  805da2:	0f b6 43 20          	movzbl 0x20(%ebx),%eax
  805da6:	a8 01                	test   $0x1,%al
  805da8:	74 12                	je     805dbc <tcp_fasttmr+0x6d>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_fasttmr: delayed ACK\n"));
      tcp_ack_now(pcb);
  805daa:	83 c8 02             	or     $0x2,%eax
  805dad:	88 43 20             	mov    %al,0x20(%ebx)
  805db0:	89 1c 24             	mov    %ebx,(%esp)
  805db3:	e8 a9 29 00 00       	call   808761 <tcp_output>
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
  805db8:	80 63 20 fc          	andb   $0xfc,0x20(%ebx)
void
tcp_fasttmr(void)
{
  struct tcp_pcb *pcb;

  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  805dbc:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  805dbf:	85 db                	test   %ebx,%ebx
  805dc1:	75 9b                	jne    805d5e <tcp_fasttmr+0xf>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_fasttmr: delayed ACK\n"));
      tcp_ack_now(pcb);
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
    }
  }
}
  805dc3:	83 c4 14             	add    $0x14,%esp
  805dc6:	5b                   	pop    %ebx
  805dc7:	5d                   	pop    %ebp
  805dc8:	c3                   	ret    

00805dc9 <tcp_seg_free>:
 * @param seg single tcp_seg to free
 * @return the number of pbufs that were deallocated
 */
u8_t
tcp_seg_free(struct tcp_seg *seg)
{
  805dc9:	55                   	push   %ebp
  805dca:	89 e5                	mov    %esp,%ebp
  805dcc:	56                   	push   %esi
  805dcd:	53                   	push   %ebx
  805dce:	83 ec 10             	sub    $0x10,%esp
  805dd1:	8b 5d 08             	mov    0x8(%ebp),%ebx
  u8_t count = 0;
  
  if (seg != NULL) {
  805dd4:	85 db                	test   %ebx,%ebx
  805dd6:	74 28                	je     805e00 <tcp_seg_free+0x37>
    if (seg->p != NULL) {
  805dd8:	8b 43 04             	mov    0x4(%ebx),%eax
 * @return the number of pbufs that were deallocated
 */
u8_t
tcp_seg_free(struct tcp_seg *seg)
{
  u8_t count = 0;
  805ddb:	be 00 00 00 00       	mov    $0x0,%esi
  
  if (seg != NULL) {
    if (seg->p != NULL) {
  805de0:	85 c0                	test   %eax,%eax
  805de2:	74 0a                	je     805dee <tcp_seg_free+0x25>
      count = pbuf_free(seg->p);
  805de4:	89 04 24             	mov    %eax,(%esp)
  805de7:	e8 08 f0 ff ff       	call   804df4 <pbuf_free>
  805dec:	89 c6                	mov    %eax,%esi
#if TCP_DEBUG
      seg->p = NULL;
#endif /* TCP_DEBUG */
    }
    memp_free(MEMP_TCP_SEG, seg);
  805dee:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  805df2:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
  805df9:	e8 44 ec ff ff       	call   804a42 <memp_free>
  805dfe:	eb 05                	jmp    805e05 <tcp_seg_free+0x3c>
 * @return the number of pbufs that were deallocated
 */
u8_t
tcp_seg_free(struct tcp_seg *seg)
{
  u8_t count = 0;
  805e00:	be 00 00 00 00       	mov    $0x0,%esi
#endif /* TCP_DEBUG */
    }
    memp_free(MEMP_TCP_SEG, seg);
  }
  return count;
}
  805e05:	89 f0                	mov    %esi,%eax
  805e07:	83 c4 10             	add    $0x10,%esp
  805e0a:	5b                   	pop    %ebx
  805e0b:	5e                   	pop    %esi
  805e0c:	5d                   	pop    %ebp
  805e0d:	c3                   	ret    

00805e0e <tcp_segs_free>:
 * @param seg tcp_seg list of TCP segments to free
 * @return the number of pbufs that were deallocated
 */
u8_t
tcp_segs_free(struct tcp_seg *seg)
{
  805e0e:	55                   	push   %ebp
  805e0f:	89 e5                	mov    %esp,%ebp
  805e11:	56                   	push   %esi
  805e12:	53                   	push   %ebx
  805e13:	83 ec 10             	sub    $0x10,%esp
  805e16:	8b 55 08             	mov    0x8(%ebp),%edx
  u8_t count = 0;
  805e19:	bb 00 00 00 00       	mov    $0x0,%ebx
  struct tcp_seg *next;
  while (seg != NULL) {
  805e1e:	eb 0e                	jmp    805e2e <tcp_segs_free+0x20>
    next = seg->next;
  805e20:	8b 32                	mov    (%edx),%esi
    count += tcp_seg_free(seg);
  805e22:	89 14 24             	mov    %edx,(%esp)
  805e25:	e8 9f ff ff ff       	call   805dc9 <tcp_seg_free>
  805e2a:	01 c3                	add    %eax,%ebx
    seg = next;
  805e2c:	89 f2                	mov    %esi,%edx
u8_t
tcp_segs_free(struct tcp_seg *seg)
{
  u8_t count = 0;
  struct tcp_seg *next;
  while (seg != NULL) {
  805e2e:	85 d2                	test   %edx,%edx
  805e30:	75 ee                	jne    805e20 <tcp_segs_free+0x12>
    next = seg->next;
    count += tcp_seg_free(seg);
    seg = next;
  }
  return count;
}
  805e32:	89 d8                	mov    %ebx,%eax
  805e34:	83 c4 10             	add    $0x10,%esp
  805e37:	5b                   	pop    %ebx
  805e38:	5e                   	pop    %esi
  805e39:	5d                   	pop    %ebp
  805e3a:	c3                   	ret    

00805e3b <tcp_setprio>:
 * @param pcb the tcp_pcb to manipulate
 * @param prio new priority
 */
void
tcp_setprio(struct tcp_pcb *pcb, u8_t prio)
{
  805e3b:	55                   	push   %ebp
  805e3c:	89 e5                	mov    %esp,%ebp
  pcb->prio = prio;
  805e3e:	8b 45 0c             	mov    0xc(%ebp),%eax
  805e41:	8b 55 08             	mov    0x8(%ebp),%edx
  805e44:	88 42 14             	mov    %al,0x14(%edx)
}
  805e47:	5d                   	pop    %ebp
  805e48:	c3                   	ret    

00805e49 <tcp_seg_copy>:
 * @param seg the old tcp_seg
 * @return a copy of seg
 */ 
struct tcp_seg *
tcp_seg_copy(struct tcp_seg *seg)
{
  805e49:	55                   	push   %ebp
  805e4a:	89 e5                	mov    %esp,%ebp
  805e4c:	53                   	push   %ebx
  805e4d:	83 ec 14             	sub    $0x14,%esp
  struct tcp_seg *cseg;

  cseg = memp_malloc(MEMP_TCP_SEG);
  805e50:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
  805e57:	e8 86 eb ff ff       	call   8049e2 <memp_malloc>
  805e5c:	89 c3                	mov    %eax,%ebx
  if (cseg == NULL) {
  805e5e:	85 c0                	test   %eax,%eax
  805e60:	74 22                	je     805e84 <tcp_seg_copy+0x3b>
    return NULL;
  }
  SMEMCPY((u8_t *)cseg, (const u8_t *)seg, sizeof(struct tcp_seg)); 
  805e62:	c7 44 24 08 14 00 00 	movl   $0x14,0x8(%esp)
  805e69:	00 
  805e6a:	8b 45 08             	mov    0x8(%ebp),%eax
  805e6d:	89 44 24 04          	mov    %eax,0x4(%esp)
  805e71:	89 1c 24             	mov    %ebx,(%esp)
  805e74:	e8 23 9b 00 00       	call   80f99c <memcpy>
  pbuf_ref(cseg->p);
  805e79:	8b 43 04             	mov    0x4(%ebx),%eax
  805e7c:	89 04 24             	mov    %eax,(%esp)
  805e7f:	e8 1e f4 ff ff       	call   8052a2 <pbuf_ref>
  return cseg;
}
  805e84:	89 d8                	mov    %ebx,%eax
  805e86:	83 c4 14             	add    $0x14,%esp
  805e89:	5b                   	pop    %ebx
  805e8a:	5d                   	pop    %ebp
  805e8b:	c3                   	ret    

00805e8c <tcp_arg>:
 * @param pcb tcp_pcb to set the callback argument
 * @param arg void pointer argument to pass to callback functions
 */ 
void
tcp_arg(struct tcp_pcb *pcb, void *arg)
{  
  805e8c:	55                   	push   %ebp
  805e8d:	89 e5                	mov    %esp,%ebp
  pcb->callback_arg = arg;
  805e8f:	8b 55 0c             	mov    0xc(%ebp),%edx
  805e92:	8b 45 08             	mov    0x8(%ebp),%eax
  805e95:	89 50 18             	mov    %edx,0x18(%eax)
}
  805e98:	5d                   	pop    %ebp
  805e99:	c3                   	ret    

00805e9a <tcp_recv>:
 * @param recv callback function to call for this pcb when data is received
 */ 
void
tcp_recv(struct tcp_pcb *pcb,
   err_t (* recv)(void *arg, struct tcp_pcb *tpcb, struct pbuf *p, err_t err))
{
  805e9a:	55                   	push   %ebp
  805e9b:	89 e5                	mov    %esp,%ebp
  pcb->recv = recv;
  805e9d:	8b 55 0c             	mov    0xc(%ebp),%edx
  805ea0:	8b 45 08             	mov    0x8(%ebp),%eax
  805ea3:	89 90 88 00 00 00    	mov    %edx,0x88(%eax)
}
  805ea9:	5d                   	pop    %ebp
  805eaa:	c3                   	ret    

00805eab <tcp_sent>:
 * @param sent callback function to call for this pcb when data is successfully sent
 */ 
void
tcp_sent(struct tcp_pcb *pcb,
   err_t (* sent)(void *arg, struct tcp_pcb *tpcb, u16_t len))
{
  805eab:	55                   	push   %ebp
  805eac:	89 e5                	mov    %esp,%ebp
  pcb->sent = sent;
  805eae:	8b 55 0c             	mov    0xc(%ebp),%edx
  805eb1:	8b 45 08             	mov    0x8(%ebp),%eax
  805eb4:	89 90 84 00 00 00    	mov    %edx,0x84(%eax)
}
  805eba:	5d                   	pop    %ebp
  805ebb:	c3                   	ret    

00805ebc <tcp_err>:
 *        has occured on the connection
 */ 
void
tcp_err(struct tcp_pcb *pcb,
   void (* errf)(void *arg, err_t err))
{
  805ebc:	55                   	push   %ebp
  805ebd:	89 e5                	mov    %esp,%ebp
  pcb->errf = errf;
  805ebf:	8b 55 0c             	mov    0xc(%ebp),%edx
  805ec2:	8b 45 08             	mov    0x8(%ebp),%eax
  805ec5:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
}
  805ecb:	5d                   	pop    %ebp
  805ecc:	c3                   	ret    

00805ecd <tcp_accept>:
 *        connection has been connected to another host
 */ 
void
tcp_accept(struct tcp_pcb *pcb,
     err_t (* accept)(void *arg, struct tcp_pcb *newpcb, err_t err))
{
  805ecd:	55                   	push   %ebp
  805ece:	89 e5                	mov    %esp,%ebp
  ((struct tcp_pcb_listen *)pcb)->accept = accept;
  805ed0:	8b 55 0c             	mov    0xc(%ebp),%edx
  805ed3:	8b 45 08             	mov    0x8(%ebp),%eax
  805ed6:	89 50 20             	mov    %edx,0x20(%eax)
}
  805ed9:	5d                   	pop    %ebp
  805eda:	c3                   	ret    

00805edb <tcp_poll>:
 *
 */ 
void
tcp_poll(struct tcp_pcb *pcb,
   err_t (* poll)(void *arg, struct tcp_pcb *tpcb), u8_t interval)
{
  805edb:	55                   	push   %ebp
  805edc:	89 e5                	mov    %esp,%ebp
  805ede:	8b 45 08             	mov    0x8(%ebp),%eax
  805ee1:	8b 55 10             	mov    0x10(%ebp),%edx
#if LWIP_CALLBACK_API
  pcb->poll = poll;
  805ee4:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  805ee7:	89 88 94 00 00 00    	mov    %ecx,0x94(%eax)
#endif /* LWIP_CALLBACK_API */  
  pcb->pollinterval = interval;
  805eed:	88 50 31             	mov    %dl,0x31(%eax)
}
  805ef0:	5d                   	pop    %ebp
  805ef1:	c3                   	ret    

00805ef2 <tcp_pcb_purge>:
 *
 * @param pcb tcp_pcb to purge. The pcb itself is not deallocated!
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
  805ef2:	55                   	push   %ebp
  805ef3:	89 e5                	mov    %esp,%ebp
  805ef5:	53                   	push   %ebx
  805ef6:	83 ec 14             	sub    $0x14,%esp
  805ef9:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (pcb->state != CLOSED &&
  805efc:	8b 43 10             	mov    0x10(%ebx),%eax
  805eff:	83 f8 01             	cmp    $0x1,%eax
  805f02:	76 5d                	jbe    805f61 <tcp_pcb_purge+0x6f>
  805f04:	83 f8 0a             	cmp    $0xa,%eax
  805f07:	74 58                	je     805f61 <tcp_pcb_purge+0x6f>
     pcb->state != TIME_WAIT &&
     pcb->state != LISTEN) {

    LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge\n"));

    if (pcb->refused_data != NULL) {
  805f09:	8b 83 80 00 00 00    	mov    0x80(%ebx),%eax
  805f0f:	85 c0                	test   %eax,%eax
  805f11:	74 12                	je     805f25 <tcp_pcb_purge+0x33>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->refused_data\n"));
      pbuf_free(pcb->refused_data);
  805f13:	89 04 24             	mov    %eax,(%esp)
  805f16:	e8 d9 ee ff ff       	call   804df4 <pbuf_free>
      pcb->refused_data = NULL;
  805f1b:	c7 83 80 00 00 00 00 	movl   $0x0,0x80(%ebx)
  805f22:	00 00 00 
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->ooseq\n"));
    }

    /* Stop the retransmission timer as it will expect data on unacked
       queue if it fires */
    pcb->rtime = -1;
  805f25:	66 c7 43 32 ff ff    	movw   $0xffff,0x32(%ebx)

    tcp_segs_free(pcb->ooseq);
  805f2b:	8b 43 7c             	mov    0x7c(%ebx),%eax
  805f2e:	89 04 24             	mov    %eax,(%esp)
  805f31:	e8 d8 fe ff ff       	call   805e0e <tcp_segs_free>
    pcb->ooseq = NULL;
  805f36:	c7 43 7c 00 00 00 00 	movl   $0x0,0x7c(%ebx)
#endif /* TCP_QUEUE_OOSEQ */
    tcp_segs_free(pcb->unsent);
  805f3d:	8b 43 74             	mov    0x74(%ebx),%eax
  805f40:	89 04 24             	mov    %eax,(%esp)
  805f43:	e8 c6 fe ff ff       	call   805e0e <tcp_segs_free>
    tcp_segs_free(pcb->unacked);
  805f48:	8b 43 78             	mov    0x78(%ebx),%eax
  805f4b:	89 04 24             	mov    %eax,(%esp)
  805f4e:	e8 bb fe ff ff       	call   805e0e <tcp_segs_free>
    pcb->unacked = pcb->unsent = NULL;
  805f53:	c7 43 74 00 00 00 00 	movl   $0x0,0x74(%ebx)
  805f5a:	c7 43 78 00 00 00 00 	movl   $0x0,0x78(%ebx)
  }
}
  805f61:	83 c4 14             	add    $0x14,%esp
  805f64:	5b                   	pop    %ebx
  805f65:	5d                   	pop    %ebp
  805f66:	c3                   	ret    

00805f67 <tcp_pcb_remove>:
 * @param pcblist PCB list to purge.
 * @param pcb tcp_pcb to purge. The pcb itself is also deallocated!
 */
void
tcp_pcb_remove(struct tcp_pcb **pcblist, struct tcp_pcb *pcb)
{
  805f67:	55                   	push   %ebp
  805f68:	89 e5                	mov    %esp,%ebp
  805f6a:	53                   	push   %ebx
  805f6b:	83 ec 14             	sub    $0x14,%esp
  805f6e:	8b 45 08             	mov    0x8(%ebp),%eax
  805f71:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  TCP_RMV(pcblist, pcb);
  805f74:	8b 10                	mov    (%eax),%edx
  805f76:	39 da                	cmp    %ebx,%edx
  805f78:	75 07                	jne    805f81 <tcp_pcb_remove+0x1a>
  805f7a:	8b 52 0c             	mov    0xc(%edx),%edx
  805f7d:	89 10                	mov    %edx,(%eax)
  805f7f:	eb 2d                	jmp    805fae <tcp_pcb_remove+0x47>
  805f81:	89 15 68 c2 b3 00    	mov    %edx,0xb3c268
  805f87:	eb 1b                	jmp    805fa4 <tcp_pcb_remove+0x3d>
  805f89:	8b 42 0c             	mov    0xc(%edx),%eax
  805f8c:	85 c0                	test   %eax,%eax
  805f8e:	74 12                	je     805fa2 <tcp_pcb_remove+0x3b>
  805f90:	39 c3                	cmp    %eax,%ebx
  805f92:	75 0e                	jne    805fa2 <tcp_pcb_remove+0x3b>
  805f94:	89 15 68 c2 b3 00    	mov    %edx,0xb3c268
  805f9a:	8b 43 0c             	mov    0xc(%ebx),%eax
  805f9d:	89 42 0c             	mov    %eax,0xc(%edx)
  805fa0:	eb 0c                	jmp    805fae <tcp_pcb_remove+0x47>
  805fa2:	89 c2                	mov    %eax,%edx
  805fa4:	85 d2                	test   %edx,%edx
  805fa6:	75 e1                	jne    805f89 <tcp_pcb_remove+0x22>
  805fa8:	89 15 68 c2 b3 00    	mov    %edx,0xb3c268
  805fae:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)

  tcp_pcb_purge(pcb);
  805fb5:	89 1c 24             	mov    %ebx,(%esp)
  805fb8:	e8 35 ff ff ff       	call   805ef2 <tcp_pcb_purge>
  
  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
  805fbd:	8b 43 10             	mov    0x10(%ebx),%eax
  805fc0:	83 f8 01             	cmp    $0x1,%eax
  805fc3:	74 1b                	je     805fe0 <tcp_pcb_remove+0x79>
  805fc5:	83 f8 0a             	cmp    $0xa,%eax
  805fc8:	74 16                	je     805fe0 <tcp_pcb_remove+0x79>
     pcb->state != LISTEN &&
     pcb->flags & TF_ACK_DELAY) {
  805fca:	0f b6 43 20          	movzbl 0x20(%ebx),%eax

  tcp_pcb_purge(pcb);
  
  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
     pcb->state != LISTEN &&
  805fce:	a8 01                	test   $0x1,%al
  805fd0:	74 0e                	je     805fe0 <tcp_pcb_remove+0x79>
     pcb->flags & TF_ACK_DELAY) {
    pcb->flags |= TF_ACK_NOW;
  805fd2:	83 c8 02             	or     $0x2,%eax
  805fd5:	88 43 20             	mov    %al,0x20(%ebx)
    tcp_output(pcb);
  805fd8:	89 1c 24             	mov    %ebx,(%esp)
  805fdb:	e8 81 27 00 00       	call   808761 <tcp_output>
  }

  if (pcb->state != LISTEN) {
  805fe0:	83 7b 10 01          	cmpl   $0x1,0x10(%ebx)
  805fe4:	74 66                	je     80604c <tcp_pcb_remove+0xe5>
    LWIP_ASSERT("unsent segments leaking", pcb->unsent == NULL);
  805fe6:	83 7b 74 00          	cmpl   $0x0,0x74(%ebx)
  805fea:	74 1c                	je     806008 <tcp_pcb_remove+0xa1>
  805fec:	c7 44 24 08 1e 2c 81 	movl   $0x812c1e,0x8(%esp)
  805ff3:	00 
  805ff4:	c7 44 24 04 b4 04 00 	movl   $0x4b4,0x4(%esp)
  805ffb:	00 
  805ffc:	c7 04 24 0a 2c 81 00 	movl   $0x812c0a,(%esp)
  806003:	e8 72 90 00 00       	call   80f07a <_panic>
    LWIP_ASSERT("unacked segments leaking", pcb->unacked == NULL);
  806008:	83 7b 78 00          	cmpl   $0x0,0x78(%ebx)
  80600c:	74 1c                	je     80602a <tcp_pcb_remove+0xc3>
  80600e:	c7 44 24 08 36 2c 81 	movl   $0x812c36,0x8(%esp)
  806015:	00 
  806016:	c7 44 24 04 b5 04 00 	movl   $0x4b5,0x4(%esp)
  80601d:	00 
  80601e:	c7 04 24 0a 2c 81 00 	movl   $0x812c0a,(%esp)
  806025:	e8 50 90 00 00       	call   80f07a <_panic>
#if TCP_QUEUE_OOSEQ
    LWIP_ASSERT("ooseq segments leaking", pcb->ooseq == NULL);
  80602a:	83 7b 7c 00          	cmpl   $0x0,0x7c(%ebx)
  80602e:	74 1c                	je     80604c <tcp_pcb_remove+0xe5>
  806030:	c7 44 24 08 4f 2c 81 	movl   $0x812c4f,0x8(%esp)
  806037:	00 
  806038:	c7 44 24 04 b7 04 00 	movl   $0x4b7,0x4(%esp)
  80603f:	00 
  806040:	c7 04 24 0a 2c 81 00 	movl   $0x812c0a,(%esp)
  806047:	e8 2e 90 00 00       	call   80f07a <_panic>
#endif /* TCP_QUEUE_OOSEQ */
  }

  pcb->state = CLOSED;
  80604c:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)

  LWIP_ASSERT("tcp_pcb_remove: tcp_pcbs_sane()", tcp_pcbs_sane());
}
  806053:	83 c4 14             	add    $0x14,%esp
  806056:	5b                   	pop    %ebx
  806057:	5d                   	pop    %ebp
  806058:	c3                   	ret    

00806059 <tcp_close>:
 * @return ERR_OK if connection has been closed
 *         another err_t if closing failed and pcb is not freed
 */
err_t
tcp_close(struct tcp_pcb *pcb)
{
  806059:	55                   	push   %ebp
  80605a:	89 e5                	mov    %esp,%ebp
  80605c:	53                   	push   %ebx
  80605d:	83 ec 14             	sub    $0x14,%esp
  806060:	8b 5d 08             	mov    0x8(%ebp),%ebx
#if TCP_DEBUG
  LWIP_DEBUGF(TCP_DEBUG, ("tcp_close: closing in "));
  tcp_debug_print_state(pcb->state);
#endif /* TCP_DEBUG */

  switch (pcb->state) {
  806063:	83 7b 10 07          	cmpl   $0x7,0x10(%ebx)
  806067:	0f 87 14 01 00 00    	ja     806181 <tcp_close+0x128>
  80606d:	8b 43 10             	mov    0x10(%ebx),%eax
  806070:	ff 24 85 68 2c 81 00 	jmp    *0x812c68(,%eax,4)
     * Calling tcp_close() with a pcb that has already been closed, (i.e. twice)
     * or for a pcb that has been used and then entered the CLOSED state 
     * is erroneous, but this should never happen as the pcb has in those cases
     * been freed, and so any remaining handles are bogus. */
    err = ERR_OK;
    TCP_RMV(&tcp_bound_pcbs, pcb);
  806077:	8b 15 6c c2 b3 00    	mov    0xb3c26c,%edx
  80607d:	39 da                	cmp    %ebx,%edx
  80607f:	75 0a                	jne    80608b <tcp_close+0x32>
  806081:	8b 42 0c             	mov    0xc(%edx),%eax
  806084:	a3 6c c2 b3 00       	mov    %eax,0xb3c26c
  806089:	eb 2d                	jmp    8060b8 <tcp_close+0x5f>
  80608b:	89 15 68 c2 b3 00    	mov    %edx,0xb3c268
  806091:	eb 1b                	jmp    8060ae <tcp_close+0x55>
  806093:	8b 42 0c             	mov    0xc(%edx),%eax
  806096:	85 c0                	test   %eax,%eax
  806098:	74 12                	je     8060ac <tcp_close+0x53>
  80609a:	39 c3                	cmp    %eax,%ebx
  80609c:	75 0e                	jne    8060ac <tcp_close+0x53>
  80609e:	89 15 68 c2 b3 00    	mov    %edx,0xb3c268
  8060a4:	8b 43 0c             	mov    0xc(%ebx),%eax
  8060a7:	89 42 0c             	mov    %eax,0xc(%edx)
  8060aa:	eb 0c                	jmp    8060b8 <tcp_close+0x5f>
  8060ac:	89 c2                	mov    %eax,%edx
  8060ae:	85 d2                	test   %edx,%edx
  8060b0:	75 e1                	jne    806093 <tcp_close+0x3a>
  8060b2:	89 15 68 c2 b3 00    	mov    %edx,0xb3c268
  8060b8:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
    memp_free(MEMP_TCP_PCB, pcb);
  8060bf:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8060c3:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  8060ca:	e8 73 e9 ff ff       	call   804a42 <memp_free>
     * and the user needs some way to free it should the need arise.
     * Calling tcp_close() with a pcb that has already been closed, (i.e. twice)
     * or for a pcb that has been used and then entered the CLOSED state 
     * is erroneous, but this should never happen as the pcb has in those cases
     * been freed, and so any remaining handles are bogus. */
    err = ERR_OK;
  8060cf:	b8 00 00 00 00       	mov    $0x0,%eax
    TCP_RMV(&tcp_bound_pcbs, pcb);
    memp_free(MEMP_TCP_PCB, pcb);
    pcb = NULL;
    break;
  8060d4:	e9 c5 00 00 00       	jmp    80619e <tcp_close+0x145>
  case LISTEN:
    err = ERR_OK;
    tcp_pcb_remove((struct tcp_pcb **)&tcp_listen_pcbs.pcbs, pcb);
  8060d9:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8060dd:	c7 04 24 64 c2 b3 00 	movl   $0xb3c264,(%esp)
  8060e4:	e8 7e fe ff ff       	call   805f67 <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB_LISTEN, pcb);
  8060e9:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8060ed:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  8060f4:	e8 49 e9 ff ff       	call   804a42 <memp_free>
    TCP_RMV(&tcp_bound_pcbs, pcb);
    memp_free(MEMP_TCP_PCB, pcb);
    pcb = NULL;
    break;
  case LISTEN:
    err = ERR_OK;
  8060f9:	b8 00 00 00 00       	mov    $0x0,%eax
    tcp_pcb_remove((struct tcp_pcb **)&tcp_listen_pcbs.pcbs, pcb);
    memp_free(MEMP_TCP_PCB_LISTEN, pcb);
    pcb = NULL;
    break;
  8060fe:	e9 9b 00 00 00       	jmp    80619e <tcp_close+0x145>
  case SYN_SENT:
    err = ERR_OK;
    tcp_pcb_remove(&tcp_active_pcbs, pcb);
  806103:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  806107:	c7 04 24 5c c2 b3 00 	movl   $0xb3c25c,(%esp)
  80610e:	e8 54 fe ff ff       	call   805f67 <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB, pcb);
  806113:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  806117:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  80611e:	e8 1f e9 ff ff       	call   804a42 <memp_free>
    tcp_pcb_remove((struct tcp_pcb **)&tcp_listen_pcbs.pcbs, pcb);
    memp_free(MEMP_TCP_PCB_LISTEN, pcb);
    pcb = NULL;
    break;
  case SYN_SENT:
    err = ERR_OK;
  806123:	b8 00 00 00 00       	mov    $0x0,%eax
    tcp_pcb_remove(&tcp_active_pcbs, pcb);
    memp_free(MEMP_TCP_PCB, pcb);
    pcb = NULL;
    snmp_inc_tcpattemptfails();
    break;
  806128:	eb 74                	jmp    80619e <tcp_close+0x145>
  case SYN_RCVD:
    err = tcp_send_ctrl(pcb, TCP_FIN);
  80612a:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  806131:	00 
  806132:	89 1c 24             	mov    %ebx,(%esp)
  806135:	e8 78 25 00 00       	call   8086b2 <tcp_send_ctrl>
    if (err == ERR_OK) {
  80613a:	84 c0                	test   %al,%al
  80613c:	75 60                	jne    80619e <tcp_close+0x145>
      snmp_inc_tcpattemptfails();
      pcb->state = FIN_WAIT_1;
  80613e:	c7 43 10 05 00 00 00 	movl   $0x5,0x10(%ebx)
  806145:	eb 3f                	jmp    806186 <tcp_close+0x12d>
    }
    break;
  case ESTABLISHED:
    err = tcp_send_ctrl(pcb, TCP_FIN);
  806147:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  80614e:	00 
  80614f:	89 1c 24             	mov    %ebx,(%esp)
  806152:	e8 5b 25 00 00       	call   8086b2 <tcp_send_ctrl>
    if (err == ERR_OK) {
  806157:	84 c0                	test   %al,%al
  806159:	75 43                	jne    80619e <tcp_close+0x145>
      snmp_inc_tcpestabresets();
      pcb->state = FIN_WAIT_1;
  80615b:	c7 43 10 05 00 00 00 	movl   $0x5,0x10(%ebx)
  806162:	eb 22                	jmp    806186 <tcp_close+0x12d>
    }
    break;
  case CLOSE_WAIT:
    err = tcp_send_ctrl(pcb, TCP_FIN);
  806164:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  80616b:	00 
  80616c:	89 1c 24             	mov    %ebx,(%esp)
  80616f:	e8 3e 25 00 00       	call   8086b2 <tcp_send_ctrl>
    if (err == ERR_OK) {
  806174:	84 c0                	test   %al,%al
  806176:	75 26                	jne    80619e <tcp_close+0x145>
      snmp_inc_tcpestabresets();
      pcb->state = LAST_ACK;
  806178:	c7 43 10 09 00 00 00 	movl   $0x9,0x10(%ebx)
  80617f:	eb 05                	jmp    806186 <tcp_close+0x12d>
    }
    break;
  default:
    /* Has already been closed, do nothing. */
    err = ERR_OK;
    pcb = NULL;
  806181:	bb 00 00 00 00       	mov    $0x0,%ebx
    break;
  }

  if (pcb != NULL && err == ERR_OK) {
  806186:	85 db                	test   %ebx,%ebx
  806188:	74 0f                	je     806199 <tcp_close+0x140>
       Since we don't really have to ensure all data has been sent when tcp_close
       returns (unsent data is sent from tcp timer functions, also), we don't care
       for the return value of tcp_output for now. */
    /* @todo: When implementing SO_LINGER, this must be changed somehow:
       If SOF_LINGER is set, the data should be sent when tcp_close returns. */
    tcp_output(pcb);
  80618a:	89 1c 24             	mov    %ebx,(%esp)
  80618d:	e8 cf 25 00 00       	call   808761 <tcp_output>
  806192:	b8 00 00 00 00       	mov    $0x0,%eax
  806197:	eb 05                	jmp    80619e <tcp_close+0x145>
  806199:	b8 00 00 00 00       	mov    $0x0,%eax
  }
  return err;
}
  80619e:	83 c4 14             	add    $0x14,%esp
  8061a1:	5b                   	pop    %ebx
  8061a2:	5d                   	pop    %ebp
  8061a3:	c3                   	ret    

008061a4 <tcp_recv_null>:
 * Default receive callback that is called if the user didn't register
 * a recv callback for the pcb.
 */
static err_t
tcp_recv_null(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
{
  8061a4:	55                   	push   %ebp
  8061a5:	89 e5                	mov    %esp,%ebp
  8061a7:	83 ec 18             	sub    $0x18,%esp
  8061aa:	8b 45 10             	mov    0x10(%ebp),%eax
  8061ad:	8b 55 14             	mov    0x14(%ebp),%edx
  arg = arg;
  if (p != NULL) {
  8061b0:	85 c0                	test   %eax,%eax
  8061b2:	74 0f                	je     8061c3 <tcp_recv_null+0x1f>
    pbuf_free(p);
  8061b4:	89 04 24             	mov    %eax,(%esp)
  8061b7:	e8 38 ec ff ff       	call   804df4 <pbuf_free>
  } else if (err == ERR_OK) {
    return tcp_close(pcb);
  }
  return ERR_OK;
  8061bc:	b8 00 00 00 00       	mov    $0x0,%eax
  8061c1:	eb 14                	jmp    8061d7 <tcp_recv_null+0x33>
  8061c3:	b8 00 00 00 00       	mov    $0x0,%eax
tcp_recv_null(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
{
  arg = arg;
  if (p != NULL) {
    pbuf_free(p);
  } else if (err == ERR_OK) {
  8061c8:	84 d2                	test   %dl,%dl
  8061ca:	75 0b                	jne    8061d7 <tcp_recv_null+0x33>
    return tcp_close(pcb);
  8061cc:	8b 45 0c             	mov    0xc(%ebp),%eax
  8061cf:	89 04 24             	mov    %eax,(%esp)
  8061d2:	e8 82 fe ff ff       	call   806059 <tcp_close>
  }
  return ERR_OK;
}
  8061d7:	c9                   	leave  
  8061d8:	c3                   	ret    

008061d9 <tcp_abort>:
 *
 * @param pcb the tcp_pcb to abort
 */
void
tcp_abort(struct tcp_pcb *pcb)
{
  8061d9:	55                   	push   %ebp
  8061da:	89 e5                	mov    %esp,%ebp
  8061dc:	57                   	push   %edi
  8061dd:	56                   	push   %esi
  8061de:	53                   	push   %ebx
  8061df:	83 ec 4c             	sub    $0x4c,%esp
  8061e2:	8b 5d 08             	mov    0x8(%ebp),%ebx

  
  /* Figure out on which TCP PCB list we are, and remove us. If we
     are in an active state, call the receive function associated with
     the PCB with a NULL argument, and send an RST to the remote end. */
  if (pcb->state == TIME_WAIT) {
  8061e5:	83 7b 10 0a          	cmpl   $0xa,0x10(%ebx)
  8061e9:	75 25                	jne    806210 <tcp_abort+0x37>
    tcp_pcb_remove(&tcp_tw_pcbs, pcb);
  8061eb:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8061ef:	c7 04 24 70 c2 b3 00 	movl   $0xb3c270,(%esp)
  8061f6:	e8 6c fd ff ff       	call   805f67 <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB, pcb);
  8061fb:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8061ff:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  806206:	e8 37 e8 ff ff       	call   804a42 <memp_free>
  80620b:	e9 d5 00 00 00       	jmp    8062e5 <tcp_abort+0x10c>
  } else {
    seqno = pcb->snd_nxt;
  806210:	8b 43 54             	mov    0x54(%ebx),%eax
  806213:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    ackno = pcb->rcv_nxt;
  806216:	8b 7b 24             	mov    0x24(%ebx),%edi
    ip_addr_set(&local_ip, &(pcb->local_ip));
  806219:	85 db                	test   %ebx,%ebx
  80621b:	74 04                	je     806221 <tcp_abort+0x48>
  80621d:	8b 03                	mov    (%ebx),%eax
  80621f:	eb 05                	jmp    806226 <tcp_abort+0x4d>
  806221:	b8 00 00 00 00       	mov    $0x0,%eax
  806226:	89 45 e0             	mov    %eax,-0x20(%ebp)
    ip_addr_set(&remote_ip, &(pcb->remote_ip));
  806229:	83 fb fc             	cmp    $0xfffffffc,%ebx
  80622c:	74 05                	je     806233 <tcp_abort+0x5a>
  80622e:	8b 43 04             	mov    0x4(%ebx),%eax
  806231:	eb 05                	jmp    806238 <tcp_abort+0x5f>
  806233:	b8 00 00 00 00       	mov    $0x0,%eax
  806238:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    local_port = pcb->local_port;
  80623b:	0f b7 43 1c          	movzwl 0x1c(%ebx),%eax
  80623f:	66 89 45 d2          	mov    %ax,-0x2e(%ebp)
    remote_port = pcb->remote_port;
  806243:	0f b7 43 1e          	movzwl 0x1e(%ebx),%eax
  806247:	66 89 45 d0          	mov    %ax,-0x30(%ebp)
#if LWIP_CALLBACK_API
    errf = pcb->errf;
  80624b:	8b b3 98 00 00 00    	mov    0x98(%ebx),%esi
#endif /* LWIP_CALLBACK_API */
    errf_arg = pcb->callback_arg;
  806251:	8b 43 18             	mov    0x18(%ebx),%eax
  806254:	89 45 cc             	mov    %eax,-0x34(%ebp)
    tcp_pcb_remove(&tcp_active_pcbs, pcb);
  806257:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80625b:	c7 04 24 5c c2 b3 00 	movl   $0xb3c25c,(%esp)
  806262:	e8 00 fd ff ff       	call   805f67 <tcp_pcb_remove>
    if (pcb->unacked != NULL) {
  806267:	8b 43 78             	mov    0x78(%ebx),%eax
  80626a:	85 c0                	test   %eax,%eax
  80626c:	74 08                	je     806276 <tcp_abort+0x9d>
      tcp_segs_free(pcb->unacked);
  80626e:	89 04 24             	mov    %eax,(%esp)
  806271:	e8 98 fb ff ff       	call   805e0e <tcp_segs_free>
    }
    if (pcb->unsent != NULL) {
  806276:	8b 43 74             	mov    0x74(%ebx),%eax
  806279:	85 c0                	test   %eax,%eax
  80627b:	74 08                	je     806285 <tcp_abort+0xac>
      tcp_segs_free(pcb->unsent);
  80627d:	89 04 24             	mov    %eax,(%esp)
  806280:	e8 89 fb ff ff       	call   805e0e <tcp_segs_free>
    }
#if TCP_QUEUE_OOSEQ    
    if (pcb->ooseq != NULL) {
  806285:	8b 43 7c             	mov    0x7c(%ebx),%eax
  806288:	85 c0                	test   %eax,%eax
  80628a:	74 08                	je     806294 <tcp_abort+0xbb>
      tcp_segs_free(pcb->ooseq);
  80628c:	89 04 24             	mov    %eax,(%esp)
  80628f:	e8 7a fb ff ff       	call   805e0e <tcp_segs_free>
    }
#endif /* TCP_QUEUE_OOSEQ */
    memp_free(MEMP_TCP_PCB, pcb);
  806294:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  806298:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  80629f:	e8 9e e7 ff ff       	call   804a42 <memp_free>
    TCP_EVENT_ERR(errf, errf_arg, ERR_ABRT);
  8062a4:	85 f6                	test   %esi,%esi
  8062a6:	74 10                	je     8062b8 <tcp_abort+0xdf>
  8062a8:	c7 44 24 04 fb ff ff 	movl   $0xfffffffb,0x4(%esp)
  8062af:	ff 
  8062b0:	8b 45 cc             	mov    -0x34(%ebp),%eax
  8062b3:	89 04 24             	mov    %eax,(%esp)
  8062b6:	ff d6                	call   *%esi
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_abort: sending RST\n"));
    tcp_rst(seqno, ackno, &local_ip, &remote_ip, local_port, remote_port);
  8062b8:	0f b7 45 d0          	movzwl -0x30(%ebp),%eax
  8062bc:	89 44 24 14          	mov    %eax,0x14(%esp)
  8062c0:	0f b7 45 d2          	movzwl -0x2e(%ebp),%eax
  8062c4:	89 44 24 10          	mov    %eax,0x10(%esp)
  8062c8:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  8062cb:	89 44 24 0c          	mov    %eax,0xc(%esp)
  8062cf:	8d 45 e0             	lea    -0x20(%ebp),%eax
  8062d2:	89 44 24 08          	mov    %eax,0x8(%esp)
  8062d6:	89 7c 24 04          	mov    %edi,0x4(%esp)
  8062da:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  8062dd:	89 04 24             	mov    %eax,(%esp)
  8062e0:	e8 10 29 00 00       	call   808bf5 <tcp_rst>
  }
}
  8062e5:	83 c4 4c             	add    $0x4c,%esp
  8062e8:	5b                   	pop    %ebx
  8062e9:	5e                   	pop    %esi
  8062ea:	5f                   	pop    %edi
  8062eb:	5d                   	pop    %ebp
  8062ec:	c3                   	ret    

008062ed <tcp_slowtmr>:
 *
 * Automatically called from tcp_tmr().
 */
void
tcp_slowtmr(void)
{
  8062ed:	55                   	push   %ebp
  8062ee:	89 e5                	mov    %esp,%ebp
  8062f0:	57                   	push   %edi
  8062f1:	56                   	push   %esi
  8062f2:	53                   	push   %ebx
  8062f3:	83 ec 2c             	sub    $0x2c,%esp
  u8_t pcb_remove;      /* flag if a PCB should be removed */
  err_t err;

  err = ERR_OK;

  ++tcp_ticks;
  8062f6:	83 05 60 c2 b3 00 01 	addl   $0x1,0xb3c260

  /* Steps through all of the active PCBs. */
  prev = NULL;
  pcb = tcp_active_pcbs;
  8062fd:	8b 1d 5c c2 b3 00    	mov    0xb3c25c,%ebx
  struct tcp_pcb *pcb, *pcb2, *prev;
  u16_t eff_wnd;
  u8_t pcb_remove;      /* flag if a PCB should be removed */
  err_t err;

  err = ERR_OK;
  806303:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)

  ++tcp_ticks;

  /* Steps through all of the active PCBs. */
  prev = NULL;
  806307:	bf 00 00 00 00       	mov    $0x0,%edi
  80630c:	e9 3a 03 00 00       	jmp    80664b <tcp_slowtmr+0x35e>
  if (pcb == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: no active pcbs\n"));
  }
  while (pcb != NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: processing active pcb\n"));
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
  806311:	8b 43 10             	mov    0x10(%ebx),%eax
  806314:	85 c0                	test   %eax,%eax
  806316:	75 1c                	jne    806334 <tcp_slowtmr+0x47>
  806318:	c7 44 24 08 78 2a 81 	movl   $0x812a78,0x8(%esp)
  80631f:	00 
  806320:	c7 44 24 04 36 02 00 	movl   $0x236,0x4(%esp)
  806327:	00 
  806328:	c7 04 24 0a 2c 81 00 	movl   $0x812c0a,(%esp)
  80632f:	e8 46 8d 00 00       	call   80f07a <_panic>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
  806334:	83 f8 01             	cmp    $0x1,%eax
  806337:	75 1c                	jne    806355 <tcp_slowtmr+0x68>
  806339:	c7 44 24 08 a4 2a 81 	movl   $0x812aa4,0x8(%esp)
  806340:	00 
  806341:	c7 44 24 04 37 02 00 	movl   $0x237,0x4(%esp)
  806348:	00 
  806349:	c7 04 24 0a 2c 81 00 	movl   $0x812c0a,(%esp)
  806350:	e8 25 8d 00 00       	call   80f07a <_panic>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);
  806355:	83 f8 0a             	cmp    $0xa,%eax
  806358:	75 1c                	jne    806376 <tcp_slowtmr+0x89>
  80635a:	c7 44 24 08 d0 2a 81 	movl   $0x812ad0,0x8(%esp)
  806361:	00 
  806362:	c7 44 24 04 38 02 00 	movl   $0x238,0x4(%esp)
  806369:	00 
  80636a:	c7 04 24 0a 2c 81 00 	movl   $0x812c0a,(%esp)
  806371:	e8 04 8d 00 00       	call   80f07a <_panic>

    pcb_remove = 0;

    if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
  806376:	83 f8 02             	cmp    $0x2,%eax
  806379:	75 0f                	jne    80638a <tcp_slowtmr+0x9d>
      ++pcb_remove;
  80637b:	be 01 00 00 00       	mov    $0x1,%esi
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);

    pcb_remove = 0;

    if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
  806380:	80 7b 46 06          	cmpb   $0x6,0x46(%ebx)
  806384:	0f 84 16 01 00 00    	je     8064a0 <tcp_slowtmr+0x1b3>
      ++pcb_remove;
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max SYN retries reached\n"));
    }
    else if (pcb->nrtx == TCP_MAXRTX) {
  80638a:	0f b6 53 46          	movzbl 0x46(%ebx),%edx
      ++pcb_remove;
  80638e:	be 01 00 00 00       	mov    $0x1,%esi

    if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
      ++pcb_remove;
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max SYN retries reached\n"));
    }
    else if (pcb->nrtx == TCP_MAXRTX) {
  806393:	80 fa 0c             	cmp    $0xc,%dl
  806396:	0f 84 e9 00 00 00    	je     806485 <tcp_slowtmr+0x198>
      ++pcb_remove;
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max DATA retries reached\n"));
    } else {
      if (pcb->persist_backoff > 0) {
  80639c:	0f b6 8b a4 00 00 00 	movzbl 0xa4(%ebx),%ecx
  8063a3:	84 c9                	test   %cl,%cl
  8063a5:	74 50                	je     8063f7 <tcp_slowtmr+0x10a>
        /* If snd_wnd is zero, use persist timer to send 1 byte probes
         * instead of using the standard retransmission mechanism. */
        pcb->persist_cnt++;
  8063a7:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
  8063ad:	83 c0 01             	add    $0x1,%eax
  8063b0:	89 83 a0 00 00 00    	mov    %eax,0xa0(%ebx)
        if (pcb->persist_cnt >= tcp_persist_backoff[pcb->persist_backoff-1]) {
  8063b6:	0f b6 d1             	movzbl %cl,%edx
  8063b9:	0f b6 92 87 2c 81 00 	movzbl 0x812c87(%edx),%edx
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: processing active pcb\n"));
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);

    pcb_remove = 0;
  8063c0:	be 00 00 00 00       	mov    $0x0,%esi
    } else {
      if (pcb->persist_backoff > 0) {
        /* If snd_wnd is zero, use persist timer to send 1 byte probes
         * instead of using the standard retransmission mechanism. */
        pcb->persist_cnt++;
        if (pcb->persist_cnt >= tcp_persist_backoff[pcb->persist_backoff-1]) {
  8063c5:	39 d0                	cmp    %edx,%eax
  8063c7:	0f 82 b8 00 00 00    	jb     806485 <tcp_slowtmr+0x198>
          pcb->persist_cnt = 0;
  8063cd:	c7 83 a0 00 00 00 00 	movl   $0x0,0xa0(%ebx)
  8063d4:	00 00 00 
          if (pcb->persist_backoff < sizeof(tcp_persist_backoff)) {
  8063d7:	80 f9 06             	cmp    $0x6,%cl
  8063da:	77 09                	ja     8063e5 <tcp_slowtmr+0xf8>
            pcb->persist_backoff++;
  8063dc:	83 c1 01             	add    $0x1,%ecx
  8063df:	88 8b a4 00 00 00    	mov    %cl,0xa4(%ebx)
          }
          tcp_zero_window_probe(pcb);
  8063e5:	89 1c 24             	mov    %ebx,(%esp)
  8063e8:	e8 58 2b 00 00       	call   808f45 <tcp_zero_window_probe>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: processing active pcb\n"));
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);

    pcb_remove = 0;
  8063ed:	be 00 00 00 00       	mov    $0x0,%esi
  8063f2:	e9 8e 00 00 00       	jmp    806485 <tcp_slowtmr+0x198>
          }
          tcp_zero_window_probe(pcb);
        }
      } else {
        /* Increase the retransmission timer if it is running */
        if(pcb->rtime >= 0)
  8063f7:	0f b7 4b 32          	movzwl 0x32(%ebx),%ecx
  8063fb:	66 85 c9             	test   %cx,%cx
  8063fe:	78 07                	js     806407 <tcp_slowtmr+0x11a>
          ++pcb->rtime;
  806400:	83 c1 01             	add    $0x1,%ecx
  806403:	66 89 4b 32          	mov    %cx,0x32(%ebx)

        if (pcb->unacked != NULL && pcb->rtime >= pcb->rto) {
  806407:	83 7b 78 00          	cmpl   $0x0,0x78(%ebx)
  80640b:	74 73                	je     806480 <tcp_slowtmr+0x193>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: processing active pcb\n"));
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);

    pcb_remove = 0;
  80640d:	be 00 00 00 00       	mov    $0x0,%esi
      } else {
        /* Increase the retransmission timer if it is running */
        if(pcb->rtime >= 0)
          ++pcb->rtime;

        if (pcb->unacked != NULL && pcb->rtime >= pcb->rto) {
  806412:	0f b7 4b 44          	movzwl 0x44(%ebx),%ecx
  806416:	66 39 4b 32          	cmp    %cx,0x32(%ebx)
  80641a:	7c 69                	jl     806485 <tcp_slowtmr+0x198>
                                      " pcb->rto %"S16_F"\n",
                                      pcb->rtime, pcb->rto));

          /* Double retransmission time-out unless we are trying to
           * connect to somebody (i.e., we are in SYN_SENT). */
          if (pcb->state != SYN_SENT) {
  80641c:	83 f8 02             	cmp    $0x2,%eax
  80641f:	74 1f                	je     806440 <tcp_slowtmr+0x153>
            pcb->rto = ((pcb->sa >> 3) + pcb->sv) << tcp_backoff[pcb->nrtx];
  806421:	0f b7 43 40          	movzwl 0x40(%ebx),%eax
  806425:	66 c1 f8 03          	sar    $0x3,%ax
  806429:	98                   	cwtl   
  80642a:	0f bf 4b 42          	movswl 0x42(%ebx),%ecx
  80642e:	01 c8                	add    %ecx,%eax
  806430:	0f b6 d2             	movzbl %dl,%edx
  806433:	0f b6 8a 8f 2c 81 00 	movzbl 0x812c8f(%edx),%ecx
  80643a:	d3 e0                	shl    %cl,%eax
  80643c:	66 89 43 44          	mov    %ax,0x44(%ebx)
          }

          /* Reset the retransmission timer. */
          pcb->rtime = 0;
  806440:	66 c7 43 32 00 00    	movw   $0x0,0x32(%ebx)

          /* Reduce congestion window and ssthresh. */
          eff_wnd = LWIP_MIN(pcb->cwnd, pcb->snd_wnd);
  806446:	0f b7 43 5c          	movzwl 0x5c(%ebx),%eax
  80644a:	66 39 43 4e          	cmp    %ax,0x4e(%ebx)
  80644e:	66 0f 46 43 4e       	cmovbe 0x4e(%ebx),%ax
          pcb->ssthresh = eff_wnd >> 1;
  806453:	66 d1 e8             	shr    %ax
  806456:	66 89 43 50          	mov    %ax,0x50(%ebx)
          if (pcb->ssthresh < pcb->mss) {
  80645a:	0f b7 53 34          	movzwl 0x34(%ebx),%edx
  80645e:	66 39 d0             	cmp    %dx,%ax
  806461:	73 06                	jae    806469 <tcp_slowtmr+0x17c>
            pcb->ssthresh = pcb->mss * 2;
  806463:	01 d2                	add    %edx,%edx
  806465:	66 89 53 50          	mov    %dx,0x50(%ebx)
          }
          pcb->cwnd = pcb->mss;
  806469:	0f b7 43 34          	movzwl 0x34(%ebx),%eax
  80646d:	66 89 43 4e          	mov    %ax,0x4e(%ebx)
                                       " ssthresh %"U16_F"\n",
                                       pcb->cwnd, pcb->ssthresh));
 
          /* The following needs to be called AFTER cwnd is set to one
             mss - STJ */
          tcp_rexmit_rto(pcb);
  806471:	89 1c 24             	mov    %ebx,(%esp)
  806474:	e8 d6 28 00 00       	call   808d4f <tcp_rexmit_rto>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: processing active pcb\n"));
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);

    pcb_remove = 0;
  806479:	be 00 00 00 00       	mov    $0x0,%esi
  80647e:	eb 05                	jmp    806485 <tcp_slowtmr+0x198>
  806480:	be 00 00 00 00       	mov    $0x0,%esi
          tcp_rexmit_rto(pcb);
        }
      }
    }
    /* Check if this PCB has stayed too long in FIN-WAIT-2 */
    if (pcb->state == FIN_WAIT_2) {
  806485:	8b 43 10             	mov    0x10(%ebx),%eax
  806488:	83 f8 06             	cmp    $0x6,%eax
  80648b:	75 13                	jne    8064a0 <tcp_slowtmr+0x1b3>
      if ((u32_t)(tcp_ticks - pcb->tmr) >
  80648d:	8b 15 60 c2 b3 00    	mov    0xb3c260,%edx
  806493:	2b 53 2c             	sub    0x2c(%ebx),%edx
          TCP_FIN_WAIT_TIMEOUT / TCP_SLOW_INTERVAL) {
        ++pcb_remove;
  806496:	83 fa 29             	cmp    $0x29,%edx
  806499:	89 f1                	mov    %esi,%ecx
  80649b:	80 d9 ff             	sbb    $0xff,%cl
  80649e:	89 ce                	mov    %ecx,%esi
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in FIN-WAIT-2\n"));
      }
    }

    /* Check if KEEPALIVE should be sent */
    if((pcb->so_options & SOF_KEEPALIVE) && 
  8064a0:	f6 43 08 08          	testb  $0x8,0x8(%ebx)
  8064a4:	74 67                	je     80650d <tcp_slowtmr+0x220>
  8064a6:	83 f8 07             	cmp    $0x7,%eax
  8064a9:	74 05                	je     8064b0 <tcp_slowtmr+0x1c3>
  8064ab:	83 f8 04             	cmp    $0x4,%eax
  8064ae:	75 5d                	jne    80650d <tcp_slowtmr+0x220>
#if LWIP_TCP_KEEPALIVE
      if((u32_t)(tcp_ticks - pcb->tmr) > 
         (pcb->keep_idle + (pcb->keep_cnt*pcb->keep_intvl))
         / TCP_SLOW_INTERVAL)
#else      
      if((u32_t)(tcp_ticks - pcb->tmr) > 
  8064b0:	a1 60 c2 b3 00       	mov    0xb3c260,%eax
  8064b5:	2b 43 2c             	sub    0x2c(%ebx),%eax
  8064b8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
         (pcb->keep_idle + TCP_MAXIDLE) / TCP_SLOW_INTERVAL)
  8064bb:	8b 8b 9c 00 00 00    	mov    0x9c(%ebx),%ecx
  8064c1:	8d 91 b8 4c 0a 00    	lea    0xa4cb8(%ecx),%edx
  8064c7:	b8 d3 4d 62 10       	mov    $0x10624dd3,%eax
  8064cc:	f7 e2                	mul    %edx
  8064ce:	c1 ea 05             	shr    $0x5,%edx
#if LWIP_TCP_KEEPALIVE
      if((u32_t)(tcp_ticks - pcb->tmr) > 
         (pcb->keep_idle + (pcb->keep_cnt*pcb->keep_intvl))
         / TCP_SLOW_INTERVAL)
#else      
      if((u32_t)(tcp_ticks - pcb->tmr) > 
  8064d1:	39 55 e4             	cmp    %edx,-0x1c(%ebp)
  8064d4:	76 0a                	jbe    8064e0 <tcp_slowtmr+0x1f3>
      {
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: KEEPALIVE timeout. Aborting connection to %"U16_F".%"U16_F".%"U16_F".%"U16_F".\n",
                                ip4_addr1(&pcb->remote_ip), ip4_addr2(&pcb->remote_ip),
                                ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip)));
        
        tcp_abort(pcb);
  8064d6:	89 1c 24             	mov    %ebx,(%esp)
  8064d9:	e8 fb fc ff ff       	call   8061d9 <tcp_abort>
  8064de:	eb 2d                	jmp    80650d <tcp_slowtmr+0x220>
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
              (pcb->keep_idle + pcb->keep_cnt_sent * pcb->keep_intvl)
              / TCP_SLOW_INTERVAL)
#else
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
              (pcb->keep_idle + pcb->keep_cnt_sent * TCP_KEEPINTVL_DEFAULT) 
  8064e0:	0f b6 93 a5 00 00 00 	movzbl 0xa5(%ebx),%edx
  8064e7:	69 d2 f8 24 01 00    	imul   $0x124f8,%edx,%edx
  8064ed:	01 d1                	add    %edx,%ecx
              / TCP_SLOW_INTERVAL)
  8064ef:	b8 d3 4d 62 10       	mov    $0x10624dd3,%eax
  8064f4:	f7 e1                	mul    %ecx
  8064f6:	c1 ea 05             	shr    $0x5,%edx
#if LWIP_TCP_KEEPALIVE
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
              (pcb->keep_idle + pcb->keep_cnt_sent * pcb->keep_intvl)
              / TCP_SLOW_INTERVAL)
#else
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
  8064f9:	39 55 e4             	cmp    %edx,-0x1c(%ebp)
  8064fc:	76 0f                	jbe    80650d <tcp_slowtmr+0x220>
              (pcb->keep_idle + pcb->keep_cnt_sent * TCP_KEEPINTVL_DEFAULT) 
              / TCP_SLOW_INTERVAL)
#endif /* LWIP_TCP_KEEPALIVE */
      {
        tcp_keepalive(pcb);
  8064fe:	89 1c 24             	mov    %ebx,(%esp)
  806501:	e8 eb 28 00 00       	call   808df1 <tcp_keepalive>
        pcb->keep_cnt_sent++;
  806506:	80 83 a5 00 00 00 01 	addb   $0x1,0xa5(%ebx)

    /* If this PCB has queued out of sequence data, but has been
       inactive for too long, will drop the data (it will eventually
       be retransmitted). */
#if TCP_QUEUE_OOSEQ    
    if (pcb->ooseq != NULL &&
  80650d:	8b 53 7c             	mov    0x7c(%ebx),%edx
  806510:	85 d2                	test   %edx,%edx
  806512:	74 25                	je     806539 <tcp_slowtmr+0x24c>
        (u32_t)tcp_ticks - pcb->tmr >= pcb->rto * TCP_OOSEQ_TIMEOUT) {
  806514:	8b 0d 60 c2 b3 00    	mov    0xb3c260,%ecx
  80651a:	2b 4b 2c             	sub    0x2c(%ebx),%ecx
  80651d:	0f bf 43 44          	movswl 0x44(%ebx),%eax
  806521:	8d 04 40             	lea    (%eax,%eax,2),%eax
  806524:	01 c0                	add    %eax,%eax

    /* If this PCB has queued out of sequence data, but has been
       inactive for too long, will drop the data (it will eventually
       be retransmitted). */
#if TCP_QUEUE_OOSEQ    
    if (pcb->ooseq != NULL &&
  806526:	39 c1                	cmp    %eax,%ecx
  806528:	72 0f                	jb     806539 <tcp_slowtmr+0x24c>
        (u32_t)tcp_ticks - pcb->tmr >= pcb->rto * TCP_OOSEQ_TIMEOUT) {
      tcp_segs_free(pcb->ooseq);
  80652a:	89 14 24             	mov    %edx,(%esp)
  80652d:	e8 dc f8 ff ff       	call   805e0e <tcp_segs_free>
      pcb->ooseq = NULL;
  806532:	c7 43 7c 00 00 00 00 	movl   $0x0,0x7c(%ebx)
      LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_slowtmr: dropping OOSEQ queued data\n"));
    }
#endif /* TCP_QUEUE_OOSEQ */

    /* Check if this PCB has stayed too long in SYN-RCVD */
    if (pcb->state == SYN_RCVD) {
  806539:	8b 43 10             	mov    0x10(%ebx),%eax
  80653c:	83 f8 03             	cmp    $0x3,%eax
  80653f:	75 13                	jne    806554 <tcp_slowtmr+0x267>
      if ((u32_t)(tcp_ticks - pcb->tmr) >
  806541:	a1 60 c2 b3 00       	mov    0xb3c260,%eax
  806546:	2b 43 2c             	sub    0x2c(%ebx),%eax
          TCP_SYN_RCVD_TIMEOUT / TCP_SLOW_INTERVAL) {
        ++pcb_remove;
  806549:	83 f8 29             	cmp    $0x29,%eax
  80654c:	89 f0                	mov    %esi,%eax
  80654e:	1c ff                	sbb    $0xff,%al
  806550:	89 c6                	mov    %eax,%esi
  806552:	eb 18                	jmp    80656c <tcp_slowtmr+0x27f>
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in SYN-RCVD\n"));
      }
    }

    /* Check if this PCB has stayed too long in LAST-ACK */
    if (pcb->state == LAST_ACK) {
  806554:	83 f8 09             	cmp    $0x9,%eax
  806557:	75 13                	jne    80656c <tcp_slowtmr+0x27f>
      if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
  806559:	a1 60 c2 b3 00       	mov    0xb3c260,%eax
  80655e:	2b 43 2c             	sub    0x2c(%ebx),%eax
        ++pcb_remove;
  806561:	3d f1 00 00 00       	cmp    $0xf1,%eax
  806566:	89 f0                	mov    %esi,%eax
  806568:	1c ff                	sbb    $0xff,%al
  80656a:	89 c6                	mov    %eax,%esi
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in LAST-ACK\n"));
      }
    }

    /* If the PCB should be removed, do it. */
    if (pcb_remove) {
  80656c:	89 f0                	mov    %esi,%eax
  80656e:	84 c0                	test   %al,%al
  806570:	0f 84 96 00 00 00    	je     80660c <tcp_slowtmr+0x31f>
      tcp_pcb_purge(pcb);      
  806576:	89 1c 24             	mov    %ebx,(%esp)
  806579:	e8 74 f9 ff ff       	call   805ef2 <tcp_pcb_purge>
      /* Remove PCB from tcp_active_pcbs list. */
      if (prev != NULL) {
  80657e:	85 ff                	test   %edi,%edi
  806580:	74 2c                	je     8065ae <tcp_slowtmr+0x2c1>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_active_pcbs", pcb != tcp_active_pcbs);
  806582:	3b 1d 5c c2 b3 00    	cmp    0xb3c25c,%ebx
  806588:	75 1c                	jne    8065a6 <tcp_slowtmr+0x2b9>
  80658a:	c7 44 24 08 00 2b 81 	movl   $0x812b00,0x8(%esp)
  806591:	00 
  806592:	c7 44 24 04 c1 02 00 	movl   $0x2c1,0x4(%esp)
  806599:	00 
  80659a:	c7 04 24 0a 2c 81 00 	movl   $0x812c0a,(%esp)
  8065a1:	e8 d4 8a 00 00       	call   80f07a <_panic>
        prev->next = pcb->next;
  8065a6:	8b 43 0c             	mov    0xc(%ebx),%eax
  8065a9:	89 47 0c             	mov    %eax,0xc(%edi)
  8065ac:	eb 2d                	jmp    8065db <tcp_slowtmr+0x2ee>
      } else {
        /* This PCB was the first. */
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_active_pcbs", tcp_active_pcbs == pcb);
  8065ae:	a1 5c c2 b3 00       	mov    0xb3c25c,%eax
  8065b3:	39 d8                	cmp    %ebx,%eax
  8065b5:	74 1c                	je     8065d3 <tcp_slowtmr+0x2e6>
  8065b7:	c7 44 24 08 2c 2b 81 	movl   $0x812b2c,0x8(%esp)
  8065be:	00 
  8065bf:	c7 44 24 04 c5 02 00 	movl   $0x2c5,0x4(%esp)
  8065c6:	00 
  8065c7:	c7 04 24 0a 2c 81 00 	movl   $0x812c0a,(%esp)
  8065ce:	e8 a7 8a 00 00       	call   80f07a <_panic>
        tcp_active_pcbs = pcb->next;
  8065d3:	8b 40 0c             	mov    0xc(%eax),%eax
  8065d6:	a3 5c c2 b3 00       	mov    %eax,0xb3c25c
      }

      TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_ABRT);
  8065db:	8b 83 98 00 00 00    	mov    0x98(%ebx),%eax
  8065e1:	85 c0                	test   %eax,%eax
  8065e3:	74 10                	je     8065f5 <tcp_slowtmr+0x308>
  8065e5:	c7 44 24 04 fb ff ff 	movl   $0xfffffffb,0x4(%esp)
  8065ec:	ff 
  8065ed:	8b 53 18             	mov    0x18(%ebx),%edx
  8065f0:	89 14 24             	mov    %edx,(%esp)
  8065f3:	ff d0                	call   *%eax

      pcb2 = pcb->next;
  8065f5:	8b 73 0c             	mov    0xc(%ebx),%esi
      memp_free(MEMP_TCP_PCB, pcb);
  8065f8:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8065fc:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  806603:	e8 3a e4 ff ff       	call   804a42 <memp_free>
      pcb = pcb2;
  806608:	89 f3                	mov    %esi,%ebx
  80660a:	eb 3f                	jmp    80664b <tcp_slowtmr+0x35e>
    } else {

      /* We check if we should poll the connection. */
      ++pcb->polltmr;
  80660c:	0f b6 43 30          	movzbl 0x30(%ebx),%eax
  806610:	83 c0 01             	add    $0x1,%eax
  806613:	88 43 30             	mov    %al,0x30(%ebx)
      if (pcb->polltmr >= pcb->pollinterval) {
  806616:	3a 43 31             	cmp    0x31(%ebx),%al
  806619:	72 2b                	jb     806646 <tcp_slowtmr+0x359>
        pcb->polltmr = 0;
  80661b:	c6 43 30 00          	movb   $0x0,0x30(%ebx)
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: polling application\n"));
        TCP_EVENT_POLL(pcb, err);
  80661f:	8b 83 94 00 00 00    	mov    0x94(%ebx),%eax
  806625:	85 c0                	test   %eax,%eax
  806627:	74 0f                	je     806638 <tcp_slowtmr+0x34b>
  806629:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80662d:	8b 53 18             	mov    0x18(%ebx),%edx
  806630:	89 14 24             	mov    %edx,(%esp)
  806633:	ff d0                	call   *%eax
  806635:	88 45 e3             	mov    %al,-0x1d(%ebp)
        if (err == ERR_OK) {
  806638:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
  80663c:	75 08                	jne    806646 <tcp_slowtmr+0x359>
          tcp_output(pcb);
  80663e:	89 1c 24             	mov    %ebx,(%esp)
  806641:	e8 1b 21 00 00       	call   808761 <tcp_output>
        }
      }
      
      prev = pcb;
  806646:	89 df                	mov    %ebx,%edi
      pcb = pcb->next;
  806648:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  prev = NULL;
  pcb = tcp_active_pcbs;
  if (pcb == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: no active pcbs\n"));
  }
  while (pcb != NULL) {
  80664b:	85 db                	test   %ebx,%ebx
  80664d:	0f 85 be fc ff ff    	jne    806311 <tcp_slowtmr+0x24>
  }

  
  /* Steps through all of the TIME-WAIT PCBs. */
  prev = NULL;    
  pcb = tcp_tw_pcbs;
  806653:	8b 35 70 c2 b3 00    	mov    0xb3c270,%esi
  while (pcb != NULL) {
  806659:	e9 b2 00 00 00       	jmp    806710 <tcp_slowtmr+0x423>
    LWIP_ASSERT("tcp_slowtmr: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
  80665e:	83 7e 10 0a          	cmpl   $0xa,0x10(%esi)
  806662:	74 1c                	je     806680 <tcp_slowtmr+0x393>
  806664:	c7 44 24 08 58 2b 81 	movl   $0x812b58,0x8(%esp)
  80666b:	00 
  80666c:	c7 44 24 04 e5 02 00 	movl   $0x2e5,0x4(%esp)
  806673:	00 
  806674:	c7 04 24 0a 2c 81 00 	movl   $0x812c0a,(%esp)
  80667b:	e8 fa 89 00 00       	call   80f07a <_panic>
    pcb_remove = 0;

    /* Check if this PCB has stayed long enough in TIME-WAIT */
    if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
  806680:	a1 60 c2 b3 00       	mov    0xb3c260,%eax
  806685:	2b 46 2c             	sub    0x2c(%esi),%eax
    }
    


    /* If the PCB should be removed, do it. */
    if (pcb_remove) {
  806688:	3d f0 00 00 00       	cmp    $0xf0,%eax
  80668d:	76 7c                	jbe    80670b <tcp_slowtmr+0x41e>
      tcp_pcb_purge(pcb);      
  80668f:	89 34 24             	mov    %esi,(%esp)
  806692:	e8 5b f8 ff ff       	call   805ef2 <tcp_pcb_purge>
      /* Remove PCB from tcp_tw_pcbs list. */
      if (prev != NULL) {
  806697:	85 db                	test   %ebx,%ebx
  806699:	74 2c                	je     8066c7 <tcp_slowtmr+0x3da>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_tw_pcbs", pcb != tcp_tw_pcbs);
  80669b:	3b 35 70 c2 b3 00    	cmp    0xb3c270,%esi
  8066a1:	75 1c                	jne    8066bf <tcp_slowtmr+0x3d2>
  8066a3:	c7 44 24 08 88 2b 81 	movl   $0x812b88,0x8(%esp)
  8066aa:	00 
  8066ab:	c7 44 24 04 f4 02 00 	movl   $0x2f4,0x4(%esp)
  8066b2:	00 
  8066b3:	c7 04 24 0a 2c 81 00 	movl   $0x812c0a,(%esp)
  8066ba:	e8 bb 89 00 00       	call   80f07a <_panic>
        prev->next = pcb->next;
  8066bf:	8b 46 0c             	mov    0xc(%esi),%eax
  8066c2:	89 43 0c             	mov    %eax,0xc(%ebx)
  8066c5:	eb 2d                	jmp    8066f4 <tcp_slowtmr+0x407>
      } else {
        /* This PCB was the first. */
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_tw_pcbs", tcp_tw_pcbs == pcb);
  8066c7:	a1 70 c2 b3 00       	mov    0xb3c270,%eax
  8066cc:	39 f0                	cmp    %esi,%eax
  8066ce:	74 1c                	je     8066ec <tcp_slowtmr+0x3ff>
  8066d0:	c7 44 24 08 b0 2b 81 	movl   $0x812bb0,0x8(%esp)
  8066d7:	00 
  8066d8:	c7 44 24 04 f8 02 00 	movl   $0x2f8,0x4(%esp)
  8066df:	00 
  8066e0:	c7 04 24 0a 2c 81 00 	movl   $0x812c0a,(%esp)
  8066e7:	e8 8e 89 00 00       	call   80f07a <_panic>
        tcp_tw_pcbs = pcb->next;
  8066ec:	8b 40 0c             	mov    0xc(%eax),%eax
  8066ef:	a3 70 c2 b3 00       	mov    %eax,0xb3c270
      }
      pcb2 = pcb->next;
  8066f4:	8b 7e 0c             	mov    0xc(%esi),%edi
      memp_free(MEMP_TCP_PCB, pcb);
  8066f7:	89 74 24 04          	mov    %esi,0x4(%esp)
  8066fb:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  806702:	e8 3b e3 ff ff       	call   804a42 <memp_free>
      pcb = pcb2;
  806707:	89 fe                	mov    %edi,%esi
  806709:	eb 05                	jmp    806710 <tcp_slowtmr+0x423>
    } else {
      prev = pcb;
  80670b:	89 f3                	mov    %esi,%ebx
      pcb = pcb->next;
  80670d:	8b 76 0c             	mov    0xc(%esi),%esi

  
  /* Steps through all of the TIME-WAIT PCBs. */
  prev = NULL;    
  pcb = tcp_tw_pcbs;
  while (pcb != NULL) {
  806710:	85 f6                	test   %esi,%esi
  806712:	0f 85 46 ff ff ff    	jne    80665e <tcp_slowtmr+0x371>
    } else {
      prev = pcb;
      pcb = pcb->next;
    }
  }
}
  806718:	83 c4 2c             	add    $0x2c,%esp
  80671b:	5b                   	pop    %ebx
  80671c:	5e                   	pop    %esi
  80671d:	5f                   	pop    %edi
  80671e:	5d                   	pop    %ebp
  80671f:	c3                   	ret    

00806720 <tcp_tmr>:
 * Called periodically to dispatch TCP timers.
 *
 */
void
tcp_tmr(void)
{
  806720:	55                   	push   %ebp
  806721:	89 e5                	mov    %esp,%ebp
  806723:	83 ec 08             	sub    $0x8,%esp
  /* Call tcp_fasttmr() every 250 ms */
  tcp_fasttmr();
  806726:	e8 24 f6 ff ff       	call   805d4f <tcp_fasttmr>

  if (++tcp_timer & 1) {
  80672b:	0f b6 05 19 54 b3 00 	movzbl 0xb35419,%eax
  806732:	83 c0 01             	add    $0x1,%eax
  806735:	a2 19 54 b3 00       	mov    %al,0xb35419
  80673a:	a8 01                	test   $0x1,%al
  80673c:	74 05                	je     806743 <tcp_tmr+0x23>
    /* Call tcp_tmr() every 500 ms, i.e., every other timer
       tcp_tmr() is called. */
    tcp_slowtmr();
  80673e:	e8 aa fb ff ff       	call   8062ed <tcp_slowtmr>
  }
}
  806743:	c9                   	leave  
  806744:	c3                   	ret    

00806745 <tcp_next_iss>:
 *
 * @return u32_t pseudo random sequence number
 */
u32_t
tcp_next_iss(void)
{
  806745:	55                   	push   %ebp
  806746:	89 e5                	mov    %esp,%ebp
  static u32_t iss = 6510;
  
  iss += tcp_ticks;       /* XXX */
  806748:	a1 60 c2 b3 00       	mov    0xb3c260,%eax
  80674d:	03 05 08 50 81 00    	add    0x815008,%eax
  806753:	a3 08 50 81 00       	mov    %eax,0x815008
  return iss;
}
  806758:	5d                   	pop    %ebp
  806759:	c3                   	ret    

0080675a <tcp_alloc>:
 * @param prio priority for the new pcb
 * @return a new tcp_pcb that initially is in state CLOSED
 */
struct tcp_pcb *
tcp_alloc(u8_t prio)
{
  80675a:	55                   	push   %ebp
  80675b:	89 e5                	mov    %esp,%ebp
  80675d:	57                   	push   %edi
  80675e:	56                   	push   %esi
  80675f:	53                   	push   %ebx
  806760:	83 ec 2c             	sub    $0x2c,%esp
  806763:	0f b6 5d 08          	movzbl 0x8(%ebp),%ebx
  struct tcp_pcb *pcb;
  u32_t iss;
  
  pcb = memp_malloc(MEMP_TCP_PCB);
  806767:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  80676e:	e8 6f e2 ff ff       	call   8049e2 <memp_malloc>
  806773:	89 c6                	mov    %eax,%esi
  if (pcb == NULL) {
  806775:	85 c0                	test   %eax,%eax
  806777:	0f 85 b3 00 00 00    	jne    806830 <tcp_alloc+0xd6>
  u32_t inactivity;

  inactivity = 0;
  inactive = NULL;
  /* Go through the list of TIME_WAIT pcbs and get the oldest pcb. */
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  80677d:	a1 70 c2 b3 00       	mov    0xb3c270,%eax
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
  806782:	8b 35 60 c2 b3 00    	mov    0xb3c260,%esi
tcp_kill_timewait(void)
{
  struct tcp_pcb *pcb, *inactive;
  u32_t inactivity;

  inactivity = 0;
  806788:	b9 00 00 00 00       	mov    $0x0,%ecx
  inactive = NULL;
  80678d:	bf 00 00 00 00       	mov    $0x0,%edi
  806792:	eb 10                	jmp    8067a4 <tcp_alloc+0x4a>
  /* Go through the list of TIME_WAIT pcbs and get the oldest pcb. */
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
  806794:	89 f2                	mov    %esi,%edx
  806796:	2b 50 2c             	sub    0x2c(%eax),%edx
  806799:	39 ca                	cmp    %ecx,%edx
  80679b:	72 04                	jb     8067a1 <tcp_alloc+0x47>
      inactivity = tcp_ticks - pcb->tmr;
  80679d:	89 d1                	mov    %edx,%ecx
      inactive = pcb;
  80679f:	89 c7                	mov    %eax,%edi
  u32_t inactivity;

  inactivity = 0;
  inactive = NULL;
  /* Go through the list of TIME_WAIT pcbs and get the oldest pcb. */
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  8067a1:	8b 40 0c             	mov    0xc(%eax),%eax
  8067a4:	85 c0                	test   %eax,%eax
  8067a6:	75 ec                	jne    806794 <tcp_alloc+0x3a>
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
      inactivity = tcp_ticks - pcb->tmr;
      inactive = pcb;
    }
  }
  if (inactive != NULL) {
  8067a8:	85 ff                	test   %edi,%edi
  8067aa:	74 08                	je     8067b4 <tcp_alloc+0x5a>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_timewait: killing oldest TIME-WAIT PCB %p (%"S32_F")\n",
           (void *)inactive, inactivity));
    tcp_abort(inactive);
  8067ac:	89 3c 24             	mov    %edi,(%esp)
  8067af:	e8 25 fa ff ff       	call   8061d9 <tcp_abort>
  if (pcb == NULL) {
    /* Try killing oldest connection in TIME-WAIT. */
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_alloc: killing off oldest TIME-WAIT connection\n"));
    tcp_kill_timewait();
    /* Try to allocate a tcp_pcb again. */
    pcb = memp_malloc(MEMP_TCP_PCB);
  8067b4:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  8067bb:	e8 22 e2 ff ff       	call   8049e2 <memp_malloc>
  8067c0:	89 c6                	mov    %eax,%esi
    if (pcb == NULL) {
  8067c2:	85 c0                	test   %eax,%eax
  8067c4:	75 6a                	jne    806830 <tcp_alloc+0xd6>
  mprio = TCP_PRIO_MAX;
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  8067c6:	a1 5c c2 b3 00       	mov    0xb3c25c,%eax
    if (pcb->prio <= prio &&
       pcb->prio <= mprio &&
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
  8067cb:	8b 3d 60 c2 b3 00    	mov    0xb3c260,%edi
  8067d1:	89 7d e4             	mov    %edi,-0x1c(%ebp)
  struct tcp_pcb *pcb, *inactive;
  u32_t inactivity;
  u8_t mprio;


  mprio = TCP_PRIO_MAX;
  8067d4:	b9 7f 00 00 00       	mov    $0x7f,%ecx
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  8067d9:	bf 00 00 00 00       	mov    $0x0,%edi
  inactive = NULL;
  8067de:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  8067e5:	eb 20                	jmp    806807 <tcp_alloc+0xad>
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->prio <= prio &&
  8067e7:	0f b6 50 14          	movzbl 0x14(%eax),%edx
  8067eb:	38 d3                	cmp    %dl,%bl
  8067ed:	72 15                	jb     806804 <tcp_alloc+0xaa>
  8067ef:	38 ca                	cmp    %cl,%dl
  8067f1:	77 11                	ja     806804 <tcp_alloc+0xaa>
       pcb->prio <= mprio &&
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
  8067f3:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  8067f6:	2b 70 2c             	sub    0x2c(%eax),%esi
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->prio <= prio &&
       pcb->prio <= mprio &&
  8067f9:	39 fe                	cmp    %edi,%esi
  8067fb:	72 07                	jb     806804 <tcp_alloc+0xaa>
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
      inactivity = tcp_ticks - pcb->tmr;
      inactive = pcb;
      mprio = pcb->prio;
  8067fd:	89 d1                	mov    %edx,%ecx
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->prio <= prio &&
       pcb->prio <= mprio &&
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
      inactivity = tcp_ticks - pcb->tmr;
  8067ff:	89 f7                	mov    %esi,%edi
      inactive = pcb;
  806801:	89 45 e0             	mov    %eax,-0x20(%ebp)
  mprio = TCP_PRIO_MAX;
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  806804:	8b 40 0c             	mov    0xc(%eax),%eax
  806807:	85 c0                	test   %eax,%eax
  806809:	75 dc                	jne    8067e7 <tcp_alloc+0x8d>
      inactivity = tcp_ticks - pcb->tmr;
      inactive = pcb;
      mprio = pcb->prio;
    }
  }
  if (inactive != NULL) {
  80680b:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80680e:	85 c0                	test   %eax,%eax
  806810:	74 08                	je     80681a <tcp_alloc+0xc0>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_prio: killing oldest PCB %p (%"S32_F")\n",
           (void *)inactive, inactivity));
    tcp_abort(inactive);
  806812:	89 04 24             	mov    %eax,(%esp)
  806815:	e8 bf f9 ff ff       	call   8061d9 <tcp_abort>
    pcb = memp_malloc(MEMP_TCP_PCB);
    if (pcb == NULL) {
      /* Try killing active connections with lower priority than the new one. */
      tcp_kill_prio(prio);
      /* Try to allocate a tcp_pcb again. */
      pcb = memp_malloc(MEMP_TCP_PCB);
  80681a:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  806821:	e8 bc e1 ff ff       	call   8049e2 <memp_malloc>
  806826:	89 c6                	mov    %eax,%esi
    }
  }
  if (pcb != NULL) {
  806828:	85 c0                	test   %eax,%eax
  80682a:	0f 84 9b 00 00 00    	je     8068cb <tcp_alloc+0x171>
    memset(pcb, 0, sizeof(struct tcp_pcb));
  806830:	c7 44 24 08 a8 00 00 	movl   $0xa8,0x8(%esp)
  806837:	00 
  806838:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80683f:	00 
  806840:	89 34 24             	mov    %esi,(%esp)
  806843:	e8 9f 90 00 00       	call   80f8e7 <memset>
    pcb->prio = TCP_PRIO_NORMAL;
  806848:	c6 46 14 40          	movb   $0x40,0x14(%esi)
    pcb->snd_buf = TCP_SND_BUF;
  80684c:	66 c7 46 6e 40 5b    	movw   $0x5b40,0x6e(%esi)
    pcb->snd_queuelen = 0;
  806852:	66 c7 46 70 00 00    	movw   $0x0,0x70(%esi)
    pcb->rcv_wnd = TCP_WND;
  806858:	66 c7 46 28 c0 5d    	movw   $0x5dc0,0x28(%esi)
    pcb->rcv_ann_wnd = TCP_WND;
  80685e:	66 c7 46 2a c0 5d    	movw   $0x5dc0,0x2a(%esi)
    pcb->tos = 0;
  806864:	c6 46 0a 00          	movb   $0x0,0xa(%esi)
    pcb->ttl = TCP_TTL;
  806868:	c6 46 0b ff          	movb   $0xff,0xb(%esi)
    /* As initial send MSS, we use TCP_MSS but limit it to 536.
       The send MSS is updated when an MSS option is received. */
    pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
  80686c:	66 c7 46 34 18 02    	movw   $0x218,0x34(%esi)
    pcb->rto = 3000 / TCP_SLOW_INTERVAL;
  806872:	66 c7 46 44 06 00    	movw   $0x6,0x44(%esi)
    pcb->sa = 0;
  806878:	66 c7 46 40 00 00    	movw   $0x0,0x40(%esi)
    pcb->sv = 3000 / TCP_SLOW_INTERVAL;
  80687e:	66 c7 46 42 06 00    	movw   $0x6,0x42(%esi)
    pcb->rtime = -1;
  806884:	66 c7 46 32 ff ff    	movw   $0xffff,0x32(%esi)
    pcb->cwnd = 1;
  80688a:	66 c7 46 4e 01 00    	movw   $0x1,0x4e(%esi)
    iss = tcp_next_iss();
  806890:	e8 b0 fe ff ff       	call   806745 <tcp_next_iss>
    pcb->snd_wl2 = iss;
  806895:	89 46 64             	mov    %eax,0x64(%esi)
    pcb->snd_nxt = iss;
  806898:	89 46 54             	mov    %eax,0x54(%esi)
    pcb->snd_max = iss;
  80689b:	89 46 58             	mov    %eax,0x58(%esi)
    pcb->lastack = iss;
  80689e:	89 46 48             	mov    %eax,0x48(%esi)
    pcb->snd_lbb = iss;   
  8068a1:	89 46 68             	mov    %eax,0x68(%esi)
    pcb->tmr = tcp_ticks;
  8068a4:	a1 60 c2 b3 00       	mov    0xb3c260,%eax
  8068a9:	89 46 2c             	mov    %eax,0x2c(%esi)

    pcb->polltmr = 0;
  8068ac:	c6 46 30 00          	movb   $0x0,0x30(%esi)

#if LWIP_CALLBACK_API
    pcb->recv = tcp_recv_null;
  8068b0:	c7 86 88 00 00 00 a4 	movl   $0x8061a4,0x88(%esi)
  8068b7:	61 80 00 
#endif /* LWIP_CALLBACK_API */  
    
    /* Init KEEPALIVE timer */
    pcb->keep_idle  = TCP_KEEPIDLE_DEFAULT;
  8068ba:	c7 86 9c 00 00 00 00 	movl   $0x6ddd00,0x9c(%esi)
  8068c1:	dd 6d 00 
#if LWIP_TCP_KEEPALIVE
    pcb->keep_intvl = TCP_KEEPINTVL_DEFAULT;
    pcb->keep_cnt   = TCP_KEEPCNT_DEFAULT;
#endif /* LWIP_TCP_KEEPALIVE */

    pcb->keep_cnt_sent = 0;
  8068c4:	c6 86 a5 00 00 00 00 	movb   $0x0,0xa5(%esi)
  }
  return pcb;
}
  8068cb:	89 f0                	mov    %esi,%eax
  8068cd:	83 c4 2c             	add    $0x2c,%esp
  8068d0:	5b                   	pop    %ebx
  8068d1:	5e                   	pop    %esi
  8068d2:	5f                   	pop    %edi
  8068d3:	5d                   	pop    %ebp
  8068d4:	c3                   	ret    

008068d5 <tcp_new>:
 *
 * @return a new tcp_pcb that initially is in state CLOSED
 */
struct tcp_pcb *
tcp_new(void)
{
  8068d5:	55                   	push   %ebp
  8068d6:	89 e5                	mov    %esp,%ebp
  8068d8:	83 ec 18             	sub    $0x18,%esp
  return tcp_alloc(TCP_PRIO_NORMAL);
  8068db:	c7 04 24 40 00 00 00 	movl   $0x40,(%esp)
  8068e2:	e8 73 fe ff ff       	call   80675a <tcp_alloc>
}
  8068e7:	c9                   	leave  
  8068e8:	c3                   	ret    

008068e9 <tcp_eff_send_mss>:
 * by using ip_route to determin the netif used to send to the address and
 * calculating the minimum of TCP_MSS and that netif's mtu (if set).
 */
u16_t
tcp_eff_send_mss(u16_t sendmss, struct ip_addr *addr)
{
  8068e9:	55                   	push   %ebp
  8068ea:	89 e5                	mov    %esp,%ebp
  8068ec:	56                   	push   %esi
  8068ed:	53                   	push   %ebx
  8068ee:	83 ec 10             	sub    $0x10,%esp
  8068f1:	8b 5d 08             	mov    0x8(%ebp),%ebx
  8068f4:	89 de                	mov    %ebx,%esi
  u16_t mss_s;
  struct netif *outif;

  outif = ip_route(addr);
  8068f6:	8b 45 0c             	mov    0xc(%ebp),%eax
  8068f9:	89 04 24             	mov    %eax,(%esp)
  8068fc:	e8 df 01 00 00       	call   806ae0 <ip_route>
  if ((outif != NULL) && (outif->mtu != 0)) {
  806901:	85 c0                	test   %eax,%eax
  806903:	74 12                	je     806917 <tcp_eff_send_mss+0x2e>
  806905:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
  806909:	66 85 c0             	test   %ax,%ax
  80690c:	74 09                	je     806917 <tcp_eff_send_mss+0x2e>
    mss_s = outif->mtu - IP_HLEN - TCP_HLEN;
  80690e:	8d 70 d8             	lea    -0x28(%eax),%esi
    /* RFC 1122, chap 4.2.2.6:
     * Eff.snd.MSS = min(SendMSS+20, MMS_S) - TCPhdrsize - IPoptionsize
     * but we only send options with SYN and that is never filled with data! */
    sendmss = LWIP_MIN(sendmss, mss_s);
  806911:	66 39 f3             	cmp    %si,%bx
  806914:	0f 46 f3             	cmovbe %ebx,%esi
  }
  return sendmss;
}
  806917:	89 f0                	mov    %esi,%eax
  806919:	83 c4 10             	add    $0x10,%esp
  80691c:	5b                   	pop    %ebx
  80691d:	5e                   	pop    %esi
  80691e:	5d                   	pop    %ebp
  80691f:	c3                   	ret    

00806920 <tcp_connect>:
 *         other err_t values if connect request couldn't be sent
 */
err_t
tcp_connect(struct tcp_pcb *pcb, struct ip_addr *ipaddr, u16_t port,
      err_t (* connected)(void *arg, struct tcp_pcb *tpcb, err_t err))
{
  806920:	55                   	push   %ebp
  806921:	89 e5                	mov    %esp,%ebp
  806923:	56                   	push   %esi
  806924:	53                   	push   %ebx
  806925:	83 ec 30             	sub    $0x30,%esp
  806928:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80692b:	8b 75 0c             	mov    0xc(%ebp),%esi
  80692e:	8b 45 10             	mov    0x10(%ebp),%eax
  u32_t optdata;
  err_t ret;
  u32_t iss;

  LWIP_ERROR("tcp_connect: can only connected from state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
  806931:	83 7b 10 00          	cmpl   $0x0,0x10(%ebx)
  806935:	74 1c                	je     806953 <tcp_connect+0x33>
  806937:	c7 44 24 08 d8 2b 81 	movl   $0x812bd8,0x8(%esp)
  80693e:	00 
  80693f:	c7 44 24 04 ec 01 00 	movl   $0x1ec,0x4(%esp)
  806946:	00 
  806947:	c7 04 24 0a 2c 81 00 	movl   $0x812c0a,(%esp)
  80694e:	e8 27 87 00 00       	call   80f07a <_panic>

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_connect to port %"U16_F"\n", port));
  if (ipaddr != NULL) {
  806953:	85 f6                	test   %esi,%esi
  806955:	0f 84 2a 01 00 00    	je     806a85 <tcp_connect+0x165>
    pcb->remote_ip = *ipaddr;
  80695b:	8b 16                	mov    (%esi),%edx
  80695d:	89 53 04             	mov    %edx,0x4(%ebx)
  } else {
    return ERR_VAL;
  }
  pcb->remote_port = port;
  806960:	66 89 43 1e          	mov    %ax,0x1e(%ebx)
  if (pcb->local_port == 0) {
  806964:	66 83 7b 1c 00       	cmpw   $0x0,0x1c(%ebx)
  806969:	75 09                	jne    806974 <tcp_connect+0x54>
    pcb->local_port = tcp_new_port();
  80696b:	e8 2a f0 ff ff       	call   80599a <tcp_new_port>
  806970:	66 89 43 1c          	mov    %ax,0x1c(%ebx)
  }
  iss = tcp_next_iss();
  806974:	e8 cc fd ff ff       	call   806745 <tcp_next_iss>
  pcb->rcv_nxt = 0;
  806979:	c7 43 24 00 00 00 00 	movl   $0x0,0x24(%ebx)
  pcb->snd_nxt = iss;
  806980:	89 43 54             	mov    %eax,0x54(%ebx)
  pcb->lastack = iss - 1;
  806983:	83 e8 01             	sub    $0x1,%eax
  806986:	89 43 48             	mov    %eax,0x48(%ebx)
  pcb->snd_lbb = iss - 1;
  806989:	89 43 68             	mov    %eax,0x68(%ebx)
  pcb->rcv_wnd = TCP_WND;
  80698c:	66 c7 43 28 c0 5d    	movw   $0x5dc0,0x28(%ebx)
  pcb->rcv_ann_wnd = TCP_WND;
  806992:	66 c7 43 2a c0 5d    	movw   $0x5dc0,0x2a(%ebx)
  pcb->snd_wnd = TCP_WND;
  806998:	66 c7 43 5c c0 5d    	movw   $0x5dc0,0x5c(%ebx)
  /* As initial send MSS, we use TCP_MSS but limit it to 536.
     The send MSS is updated when an MSS option is received. */
  pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
  80699e:	66 c7 43 34 18 02    	movw   $0x218,0x34(%ebx)
#if TCP_CALCULATE_EFF_SEND_MSS
  pcb->mss = tcp_eff_send_mss(pcb->mss, ipaddr);
  8069a4:	89 74 24 04          	mov    %esi,0x4(%esp)
  8069a8:	c7 04 24 18 02 00 00 	movl   $0x218,(%esp)
  8069af:	e8 35 ff ff ff       	call   8068e9 <tcp_eff_send_mss>
  8069b4:	66 89 43 34          	mov    %ax,0x34(%ebx)
#endif /* TCP_CALCULATE_EFF_SEND_MSS */
  pcb->cwnd = 1;
  8069b8:	66 c7 43 4e 01 00    	movw   $0x1,0x4e(%ebx)
  pcb->ssthresh = pcb->mss * 10;
  8069be:	8d 04 80             	lea    (%eax,%eax,4),%eax
  8069c1:	01 c0                	add    %eax,%eax
  8069c3:	66 89 43 50          	mov    %ax,0x50(%ebx)
  pcb->state = SYN_SENT;
  8069c7:	c7 43 10 02 00 00 00 	movl   $0x2,0x10(%ebx)
#if LWIP_CALLBACK_API  
  pcb->connected = connected;
  8069ce:	8b 45 14             	mov    0x14(%ebp),%eax
  8069d1:	89 83 8c 00 00 00    	mov    %eax,0x8c(%ebx)
#endif /* LWIP_CALLBACK_API */
  TCP_RMV(&tcp_bound_pcbs, pcb);
  8069d7:	8b 15 6c c2 b3 00    	mov    0xb3c26c,%edx
  8069dd:	39 da                	cmp    %ebx,%edx
  8069df:	75 0a                	jne    8069eb <tcp_connect+0xcb>
  8069e1:	8b 42 0c             	mov    0xc(%edx),%eax
  8069e4:	a3 6c c2 b3 00       	mov    %eax,0xb3c26c
  8069e9:	eb 2d                	jmp    806a18 <tcp_connect+0xf8>
  8069eb:	89 15 68 c2 b3 00    	mov    %edx,0xb3c268
  8069f1:	eb 1b                	jmp    806a0e <tcp_connect+0xee>
  8069f3:	8b 42 0c             	mov    0xc(%edx),%eax
  8069f6:	85 c0                	test   %eax,%eax
  8069f8:	74 12                	je     806a0c <tcp_connect+0xec>
  8069fa:	39 c3                	cmp    %eax,%ebx
  8069fc:	75 0e                	jne    806a0c <tcp_connect+0xec>
  8069fe:	89 15 68 c2 b3 00    	mov    %edx,0xb3c268
  806a04:	8b 43 0c             	mov    0xc(%ebx),%eax
  806a07:	89 42 0c             	mov    %eax,0xc(%edx)
  806a0a:	eb 0c                	jmp    806a18 <tcp_connect+0xf8>
  806a0c:	89 c2                	mov    %eax,%edx
  806a0e:	85 d2                	test   %edx,%edx
  806a10:	75 e1                	jne    8069f3 <tcp_connect+0xd3>
  806a12:	89 15 68 c2 b3 00    	mov    %edx,0xb3c268
  TCP_REG(&tcp_active_pcbs, pcb);
  806a18:	a1 5c c2 b3 00       	mov    0xb3c25c,%eax
  806a1d:	89 43 0c             	mov    %eax,0xc(%ebx)
  806a20:	89 1d 5c c2 b3 00    	mov    %ebx,0xb3c25c
  806a26:	e8 47 bb ff ff       	call   802572 <tcp_timer_needed>

  snmp_inc_tcpactiveopens();
  
  /* Build an MSS option */
  optdata = TCP_BUILD_MSS_OPTION();
  806a2b:	c7 04 24 b4 05 04 02 	movl   $0x20405b4,(%esp)
  806a32:	e8 59 13 00 00       	call   807d90 <htonl>
  806a37:	89 45 f4             	mov    %eax,-0xc(%ebp)

  ret = tcp_enqueue(pcb, NULL, 0, TCP_SYN, 0, (u8_t *)&optdata, 4);
  806a3a:	c7 44 24 18 04 00 00 	movl   $0x4,0x18(%esp)
  806a41:	00 
  806a42:	8d 45 f4             	lea    -0xc(%ebp),%eax
  806a45:	89 44 24 14          	mov    %eax,0x14(%esp)
  806a49:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  806a50:	00 
  806a51:	c7 44 24 0c 02 00 00 	movl   $0x2,0xc(%esp)
  806a58:	00 
  806a59:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  806a60:	00 
  806a61:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  806a68:	00 
  806a69:	89 1c 24             	mov    %ebx,(%esp)
  806a6c:	e8 6f 15 00 00       	call   807fe0 <tcp_enqueue>
  806a71:	89 c6                	mov    %eax,%esi
  if (ret == ERR_OK) { 
  806a73:	89 f1                	mov    %esi,%ecx
  806a75:	84 c9                	test   %cl,%cl
  806a77:	75 11                	jne    806a8a <tcp_connect+0x16a>
    tcp_output(pcb);
  806a79:	89 1c 24             	mov    %ebx,(%esp)
  806a7c:	e8 e0 1c 00 00       	call   808761 <tcp_output>
  }
  return ret;
  806a81:	89 f0                	mov    %esi,%eax
  806a83:	eb 05                	jmp    806a8a <tcp_connect+0x16a>

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_connect to port %"U16_F"\n", port));
  if (ipaddr != NULL) {
    pcb->remote_ip = *ipaddr;
  } else {
    return ERR_VAL;
  806a85:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  ret = tcp_enqueue(pcb, NULL, 0, TCP_SYN, 0, (u8_t *)&optdata, 4);
  if (ret == ERR_OK) { 
    tcp_output(pcb);
  }
  return ret;
} 
  806a8a:	83 c4 30             	add    $0x30,%esp
  806a8d:	5b                   	pop    %ebx
  806a8e:	5e                   	pop    %esi
  806a8f:	5d                   	pop    %ebp
  806a90:	c3                   	ret    

00806a91 <ip_addr_isbroadcast>:
 * @param addr address to be checked
 * @param netif the network interface against which the address is checked
 * @return returns non-zero if the address is a broadcast address
 */
u8_t ip_addr_isbroadcast(struct ip_addr *addr, struct netif *netif)
{
  806a91:	55                   	push   %ebp
  806a92:	89 e5                	mov    %esp,%ebp
  806a94:	53                   	push   %ebx
  806a95:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  u32_t addr2test;

  addr2test = addr->addr;
  806a98:	8b 45 08             	mov    0x8(%ebp),%eax
  806a9b:	8b 10                	mov    (%eax),%edx
  /* all ones (broadcast) or all zeroes (old skool broadcast) */
  if ((~addr2test == IP_ADDR_ANY_VALUE) ||
  806a9d:	8d 5a ff             	lea    -0x1(%edx),%ebx
      (addr2test == IP_ADDR_ANY_VALUE))
    return 1;
  806aa0:	b8 01 00 00 00       	mov    $0x1,%eax
{
  u32_t addr2test;

  addr2test = addr->addr;
  /* all ones (broadcast) or all zeroes (old skool broadcast) */
  if ((~addr2test == IP_ADDR_ANY_VALUE) ||
  806aa5:	83 fb fd             	cmp    $0xfffffffd,%ebx
  806aa8:	77 32                	ja     806adc <ip_addr_isbroadcast+0x4b>
    return 1;
  /* no broadcast support on this network interface? */
  else if ((netif->flags & NETIF_FLAG_BROADCAST) == 0)
    /* the given address cannot be a broadcast address
     * nor can we check against any broadcast addresses */
    return 0;
  806aaa:	b8 00 00 00 00       	mov    $0x0,%eax
  /* all ones (broadcast) or all zeroes (old skool broadcast) */
  if ((~addr2test == IP_ADDR_ANY_VALUE) ||
      (addr2test == IP_ADDR_ANY_VALUE))
    return 1;
  /* no broadcast support on this network interface? */
  else if ((netif->flags & NETIF_FLAG_BROADCAST) == 0)
  806aaf:	f6 41 2e 02          	testb  $0x2,0x2e(%ecx)
  806ab3:	74 27                	je     806adc <ip_addr_isbroadcast+0x4b>
    /* the given address cannot be a broadcast address
     * nor can we check against any broadcast addresses */
    return 0;
  /* address matches network interface address exactly? => no broadcast */
  else if (addr2test == netif->ip_addr.addr)
  806ab5:	8b 41 04             	mov    0x4(%ecx),%eax
  806ab8:	39 d0                	cmp    %edx,%eax
  806aba:	74 1b                	je     806ad7 <ip_addr_isbroadcast+0x46>
    return 0;
  /*  on the same (sub) network... */
  else if (ip_addr_netcmp(addr, &(netif->ip_addr), &(netif->netmask))
  806abc:	8b 49 08             	mov    0x8(%ecx),%ecx
  806abf:	31 d0                	xor    %edx,%eax
  806ac1:	89 c3                	mov    %eax,%ebx
          && ((addr2test & ~netif->netmask.addr) ==
           (IP_ADDR_BROADCAST_VALUE & ~netif->netmask.addr)))
    /* => network broadcast address */
    return 1;
  else
    return 0;
  806ac3:	b8 00 00 00 00       	mov    $0x0,%eax
    return 0;
  /* address matches network interface address exactly? => no broadcast */
  else if (addr2test == netif->ip_addr.addr)
    return 0;
  /*  on the same (sub) network... */
  else if (ip_addr_netcmp(addr, &(netif->ip_addr), &(netif->netmask))
  806ac8:	85 cb                	test   %ecx,%ebx
  806aca:	75 10                	jne    806adc <ip_addr_isbroadcast+0x4b>
         /* ...and host identifier bits are all ones? =>... */
          && ((addr2test & ~netif->netmask.addr) ==
  806acc:	f7 d1                	not    %ecx
  806ace:	21 ca                	and    %ecx,%edx
  806ad0:	39 d1                	cmp    %edx,%ecx
  806ad2:	0f 94 c0             	sete   %al
  806ad5:	eb 05                	jmp    806adc <ip_addr_isbroadcast+0x4b>
    /* the given address cannot be a broadcast address
     * nor can we check against any broadcast addresses */
    return 0;
  /* address matches network interface address exactly? => no broadcast */
  else if (addr2test == netif->ip_addr.addr)
    return 0;
  806ad7:	b8 00 00 00 00       	mov    $0x0,%eax
           (IP_ADDR_BROADCAST_VALUE & ~netif->netmask.addr)))
    /* => network broadcast address */
    return 1;
  else
    return 0;
}
  806adc:	5b                   	pop    %ebx
  806add:	5d                   	pop    %ebp
  806ade:	c3                   	ret    
  806adf:	90                   	nop

00806ae0 <ip_route>:
 * @param dest the destination IP address for which to find the route
 * @return the netif on which to send to reach dest
 */
struct netif *
ip_route(struct ip_addr *dest)
{
  806ae0:	55                   	push   %ebp
  806ae1:	89 e5                	mov    %esp,%ebp
  806ae3:	56                   	push   %esi
  806ae4:	53                   	push   %ebx
  806ae5:	83 ec 10             	sub    $0x10,%esp
  806ae8:	8b 75 08             	mov    0x8(%ebp),%esi
  struct netif *netif;

  /* iterate through netifs */
  for(netif = netif_list; netif != NULL; netif = netif->next) {
  806aeb:	8b 1d 54 c2 b3 00    	mov    0xb3c254,%ebx
  806af1:	eb 18                	jmp    806b0b <ip_route+0x2b>
    /* network mask matches? */
    if (netif_is_up(netif)) {
  806af3:	89 1c 24             	mov    %ebx,(%esp)
  806af6:	e8 02 e2 ff ff       	call   804cfd <netif_is_up>
  806afb:	84 c0                	test   %al,%al
  806afd:	74 0a                	je     806b09 <ip_route+0x29>
      if (ip_addr_netcmp(dest, &(netif->ip_addr), &(netif->netmask))) {
  806aff:	8b 43 04             	mov    0x4(%ebx),%eax
  806b02:	33 06                	xor    (%esi),%eax
  806b04:	85 43 08             	test   %eax,0x8(%ebx)
  806b07:	74 27                	je     806b30 <ip_route+0x50>
ip_route(struct ip_addr *dest)
{
  struct netif *netif;

  /* iterate through netifs */
  for(netif = netif_list; netif != NULL; netif = netif->next) {
  806b09:	8b 1b                	mov    (%ebx),%ebx
  806b0b:	85 db                	test   %ebx,%ebx
  806b0d:	75 e4                	jne    806af3 <ip_route+0x13>
        /* return netif on which to forward IP packet */
        return netif;
      }
    }
  }
  if ((netif_default == NULL) || (!netif_is_up(netif_default))) {
  806b0f:	a1 58 c2 b3 00       	mov    0xb3c258,%eax
  806b14:	85 c0                	test   %eax,%eax
  806b16:	74 1c                	je     806b34 <ip_route+0x54>
  806b18:	89 04 24             	mov    %eax,(%esp)
  806b1b:	e8 dd e1 ff ff       	call   804cfd <netif_is_up>
    IP_STATS_INC(ip.rterr);
    snmp_inc_ipoutnoroutes();
    return NULL;
  }
  /* no matching netif found, use default netif */
  return netif_default;
  806b20:	84 c0                	test   %al,%al
  806b22:	b8 00 00 00 00       	mov    $0x0,%eax
  806b27:	0f 45 05 58 c2 b3 00 	cmovne 0xb3c258,%eax
  806b2e:	eb 09                	jmp    806b39 <ip_route+0x59>
  806b30:	89 d8                	mov    %ebx,%eax
  806b32:	eb 05                	jmp    806b39 <ip_route+0x59>
  }
  if ((netif_default == NULL) || (!netif_is_up(netif_default))) {
    LWIP_DEBUGF(IP_DEBUG | 2, ("ip_route: No route to 0x%"X32_F"\n", dest->addr));
    IP_STATS_INC(ip.rterr);
    snmp_inc_ipoutnoroutes();
    return NULL;
  806b34:	b8 00 00 00 00       	mov    $0x0,%eax
  }
  /* no matching netif found, use default netif */
  return netif_default;
}
  806b39:	83 c4 10             	add    $0x10,%esp
  806b3c:	5b                   	pop    %ebx
  806b3d:	5e                   	pop    %esi
  806b3e:	5d                   	pop    %ebp
  806b3f:	c3                   	ret    

00806b40 <ip_input>:
 * @return ERR_OK if the packet was processed (could return ERR_* if it wasn't
 *         processed, but currently always returns ERR_OK)
 */
err_t
ip_input(struct pbuf *p, struct netif *inp)
{
  806b40:	55                   	push   %ebp
  806b41:	89 e5                	mov    %esp,%ebp
  806b43:	57                   	push   %edi
  806b44:	56                   	push   %esi
  806b45:	53                   	push   %ebx
  806b46:	83 ec 2c             	sub    $0x2c,%esp

  IP_STATS_INC(ip.recv);
  snmp_inc_ipinreceives();

  /* identify the IP header */
  iphdr = p->payload;
  806b49:	8b 45 08             	mov    0x8(%ebp),%eax
  806b4c:	8b 70 04             	mov    0x4(%eax),%esi
  if (IPH_V(iphdr) != 4) {
  806b4f:	0f b7 06             	movzwl (%esi),%eax
  806b52:	89 04 24             	mov    %eax,(%esp)
  806b55:	e8 29 12 00 00       	call   807d83 <ntohs>
  806b5a:	66 c1 e8 0c          	shr    $0xc,%ax
  806b5e:	66 83 f8 04          	cmp    $0x4,%ax
  806b62:	74 10                	je     806b74 <ip_input+0x34>
    LWIP_DEBUGF(IP_DEBUG | 1, ("IP packet dropped due to bad version number %"U16_F"\n", IPH_V(iphdr)));
    ip_debug_print(p);
    pbuf_free(p);
  806b64:	8b 45 08             	mov    0x8(%ebp),%eax
  806b67:	89 04 24             	mov    %eax,(%esp)
  806b6a:	e8 85 e2 ff ff       	call   804df4 <pbuf_free>
    IP_STATS_INC(ip.err);
    IP_STATS_INC(ip.drop);
    snmp_inc_ipinhdrerrors();
    return ERR_OK;
  806b6f:	e9 9d 02 00 00       	jmp    806e11 <ip_input+0x2d1>
  }

  /* obtain IP header length in number of 32-bit words */
  iphdr_hlen = IPH_HL(iphdr);
  806b74:	0f b7 06             	movzwl (%esi),%eax
  806b77:	89 04 24             	mov    %eax,(%esp)
  806b7a:	e8 04 12 00 00       	call   807d83 <ntohs>
  806b7f:	66 c1 e8 06          	shr    $0x6,%ax
  /* calculate IP header length in bytes */
  iphdr_hlen *= 4;
  806b83:	83 e0 3c             	and    $0x3c,%eax
  806b86:	89 c7                	mov    %eax,%edi
  806b88:	66 89 45 e2          	mov    %ax,-0x1e(%ebp)
  /* obtain ip length in bytes */
  iphdr_len = ntohs(IPH_LEN(iphdr));
  806b8c:	0f b7 46 02          	movzwl 0x2(%esi),%eax
  806b90:	89 04 24             	mov    %eax,(%esp)
  806b93:	e8 eb 11 00 00       	call   807d83 <ntohs>
  806b98:	89 c3                	mov    %eax,%ebx

  /* header length exceeds first pbuf length, or ip length exceeds total pbuf length? */
  if ((iphdr_hlen > p->len) || (iphdr_len > p->tot_len)) {
  806b9a:	8b 55 08             	mov    0x8(%ebp),%edx
  806b9d:	66 3b 7a 0a          	cmp    0xa(%edx),%di
  806ba1:	77 06                	ja     806ba9 <ip_input+0x69>
  806ba3:	66 3b 5a 08          	cmp    0x8(%edx),%bx
  806ba7:	76 10                	jbe    806bb9 <ip_input+0x79>
    if (iphdr_len > p->tot_len)
    LWIP_DEBUGF(IP_DEBUG | 2, ("IP (len %"U16_F") is longer than pbuf (len %"U16_F"), "
                               "IP packet dropped.\n",
                               iphdr_len, p->tot_len));
    /* free (drop) packet pbufs */
    pbuf_free(p);
  806ba9:	8b 45 08             	mov    0x8(%ebp),%eax
  806bac:	89 04 24             	mov    %eax,(%esp)
  806baf:	e8 40 e2 ff ff       	call   804df4 <pbuf_free>
    IP_STATS_INC(ip.lenerr);
    IP_STATS_INC(ip.drop);
    snmp_inc_ipindiscards();
    return ERR_OK;
  806bb4:	e9 58 02 00 00       	jmp    806e11 <ip_input+0x2d1>
  }

  /* verify checksum */
#if CHECKSUM_CHECK_IP
  if (inet_chksum(iphdr, iphdr_hlen) != 0) {
  806bb9:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  806bbd:	89 44 24 04          	mov    %eax,0x4(%esp)
  806bc1:	89 34 24             	mov    %esi,(%esp)
  806bc4:	e8 58 10 00 00       	call   807c21 <inet_chksum>
  806bc9:	66 85 c0             	test   %ax,%ax
  806bcc:	74 10                	je     806bde <ip_input+0x9e>

    LWIP_DEBUGF(IP_DEBUG | 2, ("Checksum (0x%"X16_F") failed, IP packet dropped.\n", inet_chksum(iphdr, iphdr_hlen)));
    ip_debug_print(p);
    pbuf_free(p);
  806bce:	8b 45 08             	mov    0x8(%ebp),%eax
  806bd1:	89 04 24             	mov    %eax,(%esp)
  806bd4:	e8 1b e2 ff ff       	call   804df4 <pbuf_free>
    IP_STATS_INC(ip.chkerr);
    IP_STATS_INC(ip.drop);
    snmp_inc_ipinhdrerrors();
    return ERR_OK;
  806bd9:	e9 33 02 00 00       	jmp    806e11 <ip_input+0x2d1>
  }
#endif

  /* Trim pbuf. This should have been done at the netif layer,
   * but we'll do it anyway just to be sure that its done. */
  pbuf_realloc(p, iphdr_len);
  806bde:	0f b7 db             	movzwl %bx,%ebx
  806be1:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  806be5:	8b 45 08             	mov    0x8(%ebp),%eax
  806be8:	89 04 24             	mov    %eax,(%esp)
  806beb:	e8 76 e5 ff ff       	call   805166 <pbuf_realloc>
  {
    /* start trying with inp. if that's not acceptable, start walking the
       list of configured netifs.
       'first' is used as a boolean to mark whether we started walking the list */
    int first = 1;
    netif = inp;
  806bf0:	8b 5d 0c             	mov    0xc(%ebp),%ebx
#endif /* LWIP_IGMP */
  {
    /* start trying with inp. if that's not acceptable, start walking the
       list of configured netifs.
       'first' is used as a boolean to mark whether we started walking the list */
    int first = 1;
  806bf3:	bf 01 00 00 00       	mov    $0x1,%edi
      /* interface is up and configured? */
      if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
        /* unicast to this interface address? */
        if (ip_addr_cmp(&(iphdr->dest), &(netif->ip_addr)) ||
            /* or broadcast on this interface network address? */
            ip_addr_isbroadcast(&(iphdr->dest), netif)) {
  806bf8:	8d 46 10             	lea    0x10(%esi),%eax
  806bfb:	89 45 dc             	mov    %eax,-0x24(%ebp)
  806bfe:	89 75 e4             	mov    %esi,-0x1c(%ebp)
  806c01:	89 de                	mov    %ebx,%esi
          iphdr->dest.addr & netif->netmask.addr,
          netif->ip_addr.addr & netif->netmask.addr,
          iphdr->dest.addr & ~(netif->netmask.addr)));

      /* interface is up and configured? */
      if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
  806c03:	89 1c 24             	mov    %ebx,(%esp)
  806c06:	e8 f2 e0 ff ff       	call   804cfd <netif_is_up>
  806c0b:	84 c0                	test   %al,%al
  806c0d:	74 27                	je     806c36 <ip_input+0xf6>
  806c0f:	83 fb fc             	cmp    $0xfffffffc,%ebx
  806c12:	74 22                	je     806c36 <ip_input+0xf6>
  806c14:	8b 43 04             	mov    0x4(%ebx),%eax
  806c17:	85 c0                	test   %eax,%eax
  806c19:	74 1b                	je     806c36 <ip_input+0xf6>
        /* unicast to this interface address? */
        if (ip_addr_cmp(&(iphdr->dest), &(netif->ip_addr)) ||
  806c1b:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  806c1e:	3b 41 10             	cmp    0x10(%ecx),%eax
  806c21:	74 32                	je     806c55 <ip_input+0x115>
            /* or broadcast on this interface network address? */
            ip_addr_isbroadcast(&(iphdr->dest), netif)) {
  806c23:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  806c27:	8b 45 dc             	mov    -0x24(%ebp),%eax
  806c2a:	89 04 24             	mov    %eax,(%esp)
  806c2d:	e8 5f fe ff ff       	call   806a91 <ip_addr_isbroadcast>
          iphdr->dest.addr & ~(netif->netmask.addr)));

      /* interface is up and configured? */
      if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
        /* unicast to this interface address? */
        if (ip_addr_cmp(&(iphdr->dest), &(netif->ip_addr)) ||
  806c32:	84 c0                	test   %al,%al
  806c34:	75 26                	jne    806c5c <ip_input+0x11c>
              netif->name[0], netif->name[1]));
          /* break out of for loop */
          break;
        }
      }
      if (first) {
  806c36:	85 ff                	test   %edi,%edi
  806c38:	74 08                	je     806c42 <ip_input+0x102>
        first = 0;
        netif = netif_list;
  806c3a:	8b 1d 54 c2 b3 00    	mov    0xb3c254,%ebx
  806c40:	eb 02                	jmp    806c44 <ip_input+0x104>
      } else {
        netif = netif->next;
  806c42:	8b 1b                	mov    (%ebx),%ebx
      }
      if (netif == inp) {
  806c44:	39 f3                	cmp    %esi,%ebx
  806c46:	75 02                	jne    806c4a <ip_input+0x10a>
        netif = netif->next;
  806c48:	8b 1e                	mov    (%esi),%ebx
      }
    } while(netif != NULL);
  806c4a:	85 db                	test   %ebx,%ebx
  806c4c:	74 1d                	je     806c6b <ip_input+0x12b>
  806c4e:	bf 00 00 00 00       	mov    $0x0,%edi
  806c53:	eb ae                	jmp    806c03 <ip_input+0xc3>
  806c55:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  806c58:	89 d8                	mov    %ebx,%eax
  806c5a:	eb 05                	jmp    806c61 <ip_input+0x121>
  806c5c:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  806c5f:	89 d8                	mov    %ebx,%eax
#if LWIP_DHCP
  /* Pass DHCP messages regardless of destination address. DHCP traffic is addressed
   * using link layer addressing (such as Ethernet MAC) so we must not filter on IP.
   * According to RFC 1542 section 3.1.1, referred by RFC 2131).
   */
  if (netif == NULL) {
  806c61:	85 c0                	test   %eax,%eax
  806c63:	0f 85 89 01 00 00    	jne    806df2 <ip_input+0x2b2>
  806c69:	eb 03                	jmp    806c6e <ip_input+0x12e>
  806c6b:	8b 75 e4             	mov    -0x1c(%ebp),%esi
    /* remote port is DHCP server? */
    if (IPH_PROTO(iphdr) == IP_PROTO_UDP) {
  806c6e:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  806c72:	89 04 24             	mov    %eax,(%esp)
  806c75:	e8 09 11 00 00       	call   807d83 <ntohs>
  806c7a:	bb 00 00 00 00       	mov    $0x0,%ebx
  806c7f:	3c 11                	cmp    $0x11,%al
  806c81:	0f 85 6b 01 00 00    	jne    806df2 <ip_input+0x2b2>
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE | 1, ("ip_input: UDP packet to DHCP client port %"U16_F"\n",
        ntohs(((struct udp_hdr *)((u8_t *)iphdr + iphdr_hlen))->dest)));
      if (ntohs(((struct udp_hdr *)((u8_t *)iphdr + iphdr_hlen))->dest) == DHCP_CLIENT_PORT) {
  806c87:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  806c8b:	0f b7 44 06 02       	movzwl 0x2(%esi,%eax,1),%eax
  806c90:	89 04 24             	mov    %eax,(%esp)
  806c93:	e8 eb 10 00 00       	call   807d83 <ntohs>
  806c98:	66 83 f8 44          	cmp    $0x44,%ax
  806c9c:	74 36                	je     806cd4 <ip_input+0x194>
  806c9e:	e9 4f 01 00 00       	jmp    806df2 <ip_input+0x2b2>
  /* broadcast or multicast packet source address? Compliant with RFC 1122: 3.2.1.3 */
#if LWIP_DHCP
  if (check_ip_src)
#endif /* LWIP_DHCP */
  {  if ((ip_addr_isbroadcast(&(iphdr->src), inp)) ||
         (ip_addr_ismulticast(&(iphdr->src)))) {
  806ca3:	8b 7e 0c             	mov    0xc(%esi),%edi
  806ca6:	c7 04 24 00 00 00 f0 	movl   $0xf0000000,(%esp)
  806cad:	e8 18 13 00 00       	call   807fca <ntohl>
  806cb2:	21 c7                	and    %eax,%edi
  806cb4:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  806cbb:	e8 0a 13 00 00       	call   807fca <ntohl>

  /* broadcast or multicast packet source address? Compliant with RFC 1122: 3.2.1.3 */
#if LWIP_DHCP
  if (check_ip_src)
#endif /* LWIP_DHCP */
  {  if ((ip_addr_isbroadcast(&(iphdr->src), inp)) ||
  806cc0:	39 c7                	cmp    %eax,%edi
  806cc2:	75 13                	jne    806cd7 <ip_input+0x197>
         (ip_addr_ismulticast(&(iphdr->src)))) {
      /* packet source is not valid */
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE | 1, ("ip_input: packet source is not valid.\n"));
      /* free (drop) packet pbufs */
      pbuf_free(p);
  806cc4:	8b 45 08             	mov    0x8(%ebp),%eax
  806cc7:	89 04 24             	mov    %eax,(%esp)
  806cca:	e8 25 e1 ff ff       	call   804df4 <pbuf_free>
      IP_STATS_INC(ip.drop);
      snmp_inc_ipinaddrerrors();
      snmp_inc_ipindiscards();
      return ERR_OK;
  806ccf:	e9 3d 01 00 00       	jmp    806e11 <ip_input+0x2d1>
    if (IPH_PROTO(iphdr) == IP_PROTO_UDP) {
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE | 1, ("ip_input: UDP packet to DHCP client port %"U16_F"\n",
        ntohs(((struct udp_hdr *)((u8_t *)iphdr + iphdr_hlen))->dest)));
      if (ntohs(((struct udp_hdr *)((u8_t *)iphdr + iphdr_hlen))->dest) == DHCP_CLIENT_PORT) {
        LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE | 1, ("ip_input: DHCP packet accepted.\n"));
        netif = inp;
  806cd4:	8b 5d 0c             	mov    0xc(%ebp),%ebx
      return ERR_OK;
    }
  }

  /* packet not for us? */
  if (netif == NULL) {
  806cd7:	85 db                	test   %ebx,%ebx
  806cd9:	75 10                	jne    806ceb <ip_input+0x1ab>
#endif /* IP_FORWARD */
    {
      snmp_inc_ipinaddrerrors();
      snmp_inc_ipindiscards();
    }
    pbuf_free(p);
  806cdb:	8b 45 08             	mov    0x8(%ebp),%eax
  806cde:	89 04 24             	mov    %eax,(%esp)
  806ce1:	e8 0e e1 ff ff       	call   804df4 <pbuf_free>
    return ERR_OK;
  806ce6:	e9 26 01 00 00       	jmp    806e11 <ip_input+0x2d1>
  }
  /* packet consists of multiple fragments? */
  if ((IPH_OFFSET(iphdr) & htons(IP_OFFMASK | IP_MF)) != 0) {
  806ceb:	0f b7 5e 06          	movzwl 0x6(%esi),%ebx
  806cef:	c7 04 24 ff 3f 00 00 	movl   $0x3fff,(%esp)
  806cf6:	e8 7b 10 00 00       	call   807d76 <htons>
  806cfb:	66 85 d8             	test   %bx,%ax
  806cfe:	74 19                	je     806d19 <ip_input+0x1d9>
#if IP_REASSEMBLY /* packet fragment reassembly code present? */
    LWIP_DEBUGF(IP_DEBUG, ("IP packet is a fragment (id=0x%04"X16_F" tot_len=%"U16_F" len=%"U16_F" MF=%"U16_F" offset=%"U16_F"), calling ip_reass()\n",
      ntohs(IPH_ID(iphdr)), p->tot_len, ntohs(IPH_LEN(iphdr)), !!(IPH_OFFSET(iphdr) & htons(IP_MF)), (ntohs(IPH_OFFSET(iphdr)) & IP_OFFMASK)*8));
    /* reassemble the packet*/
    p = ip_reass(p);
  806d00:	8b 45 08             	mov    0x8(%ebp),%eax
  806d03:	89 04 24             	mov    %eax,(%esp)
  806d06:	e8 52 05 00 00       	call   80725d <ip_reass>
  806d0b:	89 45 08             	mov    %eax,0x8(%ebp)
    /* packet not fully reassembled yet? */
    if (p == NULL) {
  806d0e:	85 c0                	test   %eax,%eax
  806d10:	0f 84 fb 00 00 00    	je     806e11 <ip_input+0x2d1>
      return ERR_OK;
    }
    iphdr = p->payload;
  806d16:	8b 70 04             	mov    0x4(%eax),%esi
  ip_debug_print(p);
  LWIP_DEBUGF(IP_DEBUG, ("ip_input: p->len %"U16_F" p->tot_len %"U16_F"\n", p->len, p->tot_len));

#if LWIP_RAW
  /* raw input did not eat the packet? */
  if (raw_input(p, inp) == 0)
  806d19:	8b 45 0c             	mov    0xc(%ebp),%eax
  806d1c:	89 44 24 04          	mov    %eax,0x4(%esp)
  806d20:	8b 45 08             	mov    0x8(%ebp),%eax
  806d23:	89 04 24             	mov    %eax,(%esp)
  806d26:	e8 8e 7a 00 00       	call   80e7b9 <raw_input>
  806d2b:	84 c0                	test   %al,%al
  806d2d:	0f 85 de 00 00 00    	jne    806e11 <ip_input+0x2d1>
#endif /* LWIP_RAW */
  {

    switch (IPH_PROTO(iphdr)) {
  806d33:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  806d37:	89 04 24             	mov    %eax,(%esp)
  806d3a:	e8 44 10 00 00       	call   807d83 <ntohs>
  806d3f:	0f b6 c0             	movzbl %al,%eax
  806d42:	66 83 f8 06          	cmp    $0x6,%ax
  806d46:	74 25                	je     806d6d <ip_input+0x22d>
  806d48:	66 83 f8 11          	cmp    $0x11,%ax
  806d4c:	74 08                	je     806d56 <ip_input+0x216>
  806d4e:	66 83 f8 01          	cmp    $0x1,%ax
  806d52:	75 44                	jne    806d98 <ip_input+0x258>
  806d54:	eb 2e                	jmp    806d84 <ip_input+0x244>
    case IP_PROTO_UDP:
#if LWIP_UDPLITE
    case IP_PROTO_UDPLITE:
#endif /* LWIP_UDPLITE */
      snmp_inc_ipindelivers();
      udp_input(p, inp);
  806d56:	8b 45 0c             	mov    0xc(%ebp),%eax
  806d59:	89 44 24 04          	mov    %eax,0x4(%esp)
  806d5d:	8b 45 08             	mov    0x8(%ebp),%eax
  806d60:	89 04 24             	mov    %eax,(%esp)
  806d63:	e8 58 23 00 00       	call   8090c0 <udp_input>
      break;
  806d68:	e9 a4 00 00 00       	jmp    806e11 <ip_input+0x2d1>
#endif /* LWIP_UDP */
#if LWIP_TCP
    case IP_PROTO_TCP:
      snmp_inc_ipindelivers();
      tcp_input(p, inp);
  806d6d:	8b 45 0c             	mov    0xc(%ebp),%eax
  806d70:	89 44 24 04          	mov    %eax,0x4(%esp)
  806d74:	8b 45 08             	mov    0x8(%ebp),%eax
  806d77:	89 04 24             	mov    %eax,(%esp)
  806d7a:	e8 f9 6c 00 00       	call   80da78 <tcp_input>
      break;
  806d7f:	e9 8d 00 00 00       	jmp    806e11 <ip_input+0x2d1>
#endif /* LWIP_TCP */
#if LWIP_ICMP
    case IP_PROTO_ICMP:
      snmp_inc_ipindelivers();
      icmp_input(p, inp);
  806d84:	8b 45 0c             	mov    0xc(%ebp),%eax
  806d87:	89 44 24 04          	mov    %eax,0x4(%esp)
  806d8b:	8b 45 08             	mov    0x8(%ebp),%eax
  806d8e:	89 04 24             	mov    %eax,(%esp)
  806d91:	e8 1a 7d 00 00       	call   80eab0 <icmp_input>
      break;
  806d96:	eb 79                	jmp    806e11 <ip_input+0x2d1>
      break;
#endif /* LWIP_IGMP */
    default:
#if LWIP_ICMP
      /* send ICMP destination protocol unreachable unless is was a broadcast */
      if (!ip_addr_isbroadcast(&(iphdr->dest), inp) &&
  806d98:	8b 45 0c             	mov    0xc(%ebp),%eax
  806d9b:	89 44 24 04          	mov    %eax,0x4(%esp)
  806d9f:	8d 46 10             	lea    0x10(%esi),%eax
  806da2:	89 04 24             	mov    %eax,(%esp)
  806da5:	e8 e7 fc ff ff       	call   806a91 <ip_addr_isbroadcast>
  806daa:	84 c0                	test   %al,%al
  806dac:	75 37                	jne    806de5 <ip_input+0x2a5>
          !ip_addr_ismulticast(&(iphdr->dest))) {
  806dae:	8b 5e 10             	mov    0x10(%esi),%ebx
  806db1:	c7 04 24 00 00 00 f0 	movl   $0xf0000000,(%esp)
  806db8:	e8 0d 12 00 00       	call   807fca <ntohl>
  806dbd:	21 c3                	and    %eax,%ebx
  806dbf:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  806dc6:	e8 ff 11 00 00       	call   807fca <ntohl>
      break;
#endif /* LWIP_IGMP */
    default:
#if LWIP_ICMP
      /* send ICMP destination protocol unreachable unless is was a broadcast */
      if (!ip_addr_isbroadcast(&(iphdr->dest), inp) &&
  806dcb:	39 c3                	cmp    %eax,%ebx
  806dcd:	74 16                	je     806de5 <ip_input+0x2a5>
          !ip_addr_ismulticast(&(iphdr->dest))) {
        p->payload = iphdr;
  806dcf:	8b 45 08             	mov    0x8(%ebp),%eax
  806dd2:	89 70 04             	mov    %esi,0x4(%eax)
        icmp_dest_unreach(p, ICMP_DUR_PROTO);
  806dd5:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
  806ddc:	00 
  806ddd:	89 04 24             	mov    %eax,(%esp)
  806de0:	e8 10 80 00 00       	call   80edf5 <icmp_dest_unreach>
      }
#endif /* LWIP_ICMP */
      pbuf_free(p);
  806de5:	8b 45 08             	mov    0x8(%ebp),%eax
  806de8:	89 04 24             	mov    %eax,(%esp)
  806deb:	e8 04 e0 ff ff       	call   804df4 <pbuf_free>
  806df0:	eb 1f                	jmp    806e11 <ip_input+0x2d1>

  /* broadcast or multicast packet source address? Compliant with RFC 1122: 3.2.1.3 */
#if LWIP_DHCP
  if (check_ip_src)
#endif /* LWIP_DHCP */
  {  if ((ip_addr_isbroadcast(&(iphdr->src), inp)) ||
  806df2:	8b 45 0c             	mov    0xc(%ebp),%eax
  806df5:	89 44 24 04          	mov    %eax,0x4(%esp)
  806df9:	8d 46 0c             	lea    0xc(%esi),%eax
  806dfc:	89 04 24             	mov    %eax,(%esp)
  806dff:	e8 8d fc ff ff       	call   806a91 <ip_addr_isbroadcast>
  806e04:	84 c0                	test   %al,%al
  806e06:	0f 84 97 fe ff ff    	je     806ca3 <ip_input+0x163>
  806e0c:	e9 b3 fe ff ff       	jmp    806cc4 <ip_input+0x184>
      snmp_inc_ipinunknownprotos();
    }
  }

  return ERR_OK;
}
  806e11:	b8 00 00 00 00       	mov    $0x0,%eax
  806e16:	83 c4 2c             	add    $0x2c,%esp
  806e19:	5b                   	pop    %ebx
  806e1a:	5e                   	pop    %esi
  806e1b:	5f                   	pop    %edi
  806e1c:	5d                   	pop    %ebp
  806e1d:	c3                   	ret    

00806e1e <ip_output_if>:
 */
err_t
ip_output_if(struct pbuf *p, struct ip_addr *src, struct ip_addr *dest,
             u8_t ttl, u8_t tos,
             u8_t proto, struct netif *netif)
{
  806e1e:	55                   	push   %ebp
  806e1f:	89 e5                	mov    %esp,%ebp
  806e21:	57                   	push   %edi
  806e22:	56                   	push   %esi
  806e23:	53                   	push   %ebx
  806e24:	83 ec 2c             	sub    $0x2c,%esp
  806e27:	8b 75 08             	mov    0x8(%ebp),%esi
  806e2a:	8b 7d 14             	mov    0x14(%ebp),%edi
  806e2d:	8b 45 18             	mov    0x18(%ebp),%eax
  806e30:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  806e33:	8b 45 1c             	mov    0x1c(%ebp),%eax
  806e36:	89 45 e0             	mov    %eax,-0x20(%ebp)
  static u16_t ip_id = 0;

  snmp_inc_ipoutrequests();

  /* Should the IP header be generated or is it already included in p? */
  if (dest != IP_HDRINCL) {
  806e39:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  806e3d:	0f 84 17 01 00 00    	je     806f5a <ip_output_if+0x13c>
    /* generate IP header */
    if (pbuf_header(p, IP_HLEN)) {
  806e43:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  806e4a:	00 
  806e4b:	89 34 24             	mov    %esi,(%esp)
  806e4e:	e8 bd de ff ff       	call   804d10 <pbuf_header>
  806e53:	84 c0                	test   %al,%al
  806e55:	0f 85 48 01 00 00    	jne    806fa3 <ip_output_if+0x185>
      IP_STATS_INC(ip.err);
      snmp_inc_ipoutdiscards();
      return ERR_BUF;
    }

    iphdr = p->payload;
  806e5b:	8b 5e 04             	mov    0x4(%esi),%ebx
    LWIP_ASSERT("check that first pbuf can hold struct ip_hdr",
  806e5e:	66 83 7e 0a 13       	cmpw   $0x13,0xa(%esi)
  806e63:	77 1c                	ja     806e81 <ip_output_if+0x63>
  806e65:	c7 44 24 08 a4 2c 81 	movl   $0x812ca4,0x8(%esp)
  806e6c:	00 
  806e6d:	c7 44 24 04 ee 01 00 	movl   $0x1ee,0x4(%esp)
  806e74:	00 
  806e75:	c7 04 24 d1 2c 81 00 	movl   $0x812cd1,(%esp)
  806e7c:	e8 f9 81 00 00       	call   80f07a <_panic>
               (p->len >= sizeof(struct ip_hdr)));

    IPH_TTL_SET(iphdr, ttl);
  806e81:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  806e85:	89 04 24             	mov    %eax,(%esp)
  806e88:	e8 f6 0e 00 00       	call   807d83 <ntohs>
  806e8d:	0f b6 c0             	movzbl %al,%eax
  806e90:	c1 e7 08             	shl    $0x8,%edi
  806e93:	09 c7                	or     %eax,%edi
  806e95:	0f b7 ff             	movzwl %di,%edi
  806e98:	89 3c 24             	mov    %edi,(%esp)
  806e9b:	e8 d6 0e 00 00       	call   807d76 <htons>
  806ea0:	66 89 43 08          	mov    %ax,0x8(%ebx)
    IPH_PROTO_SET(iphdr, proto);
  806ea4:	0f b7 c0             	movzwl %ax,%eax
  806ea7:	89 04 24             	mov    %eax,(%esp)
  806eaa:	e8 d4 0e 00 00       	call   807d83 <ntohs>
  806eaf:	25 00 ff 00 00       	and    $0xff00,%eax
  806eb4:	0f b6 55 e0          	movzbl -0x20(%ebp),%edx
  806eb8:	09 d0                	or     %edx,%eax
  806eba:	0f b7 c0             	movzwl %ax,%eax
  806ebd:	89 04 24             	mov    %eax,(%esp)
  806ec0:	e8 b1 0e 00 00       	call   807d76 <htons>
  806ec5:	66 89 43 08          	mov    %ax,0x8(%ebx)

    ip_addr_set(&(iphdr->dest), dest);
  806ec9:	8b 45 10             	mov    0x10(%ebp),%eax
  806ecc:	8b 00                	mov    (%eax),%eax
  806ece:	89 43 10             	mov    %eax,0x10(%ebx)

    IPH_VHLTOS_SET(iphdr, 4, IP_HLEN / 4, tos);
  806ed1:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
  806ed5:	80 cc 45             	or     $0x45,%ah
  806ed8:	89 04 24             	mov    %eax,(%esp)
  806edb:	e8 96 0e 00 00       	call   807d76 <htons>
  806ee0:	66 89 03             	mov    %ax,(%ebx)
    IPH_LEN_SET(iphdr, htons(p->tot_len));
  806ee3:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  806ee7:	89 04 24             	mov    %eax,(%esp)
  806eea:	e8 87 0e 00 00       	call   807d76 <htons>
  806eef:	66 89 43 02          	mov    %ax,0x2(%ebx)
    IPH_OFFSET_SET(iphdr, 0);
  806ef3:	66 c7 43 06 00 00    	movw   $0x0,0x6(%ebx)
    IPH_ID_SET(iphdr, htons(ip_id));
  806ef9:	0f b7 05 1a 54 b3 00 	movzwl 0xb3541a,%eax
  806f00:	89 04 24             	mov    %eax,(%esp)
  806f03:	e8 6e 0e 00 00       	call   807d76 <htons>
  806f08:	66 89 43 04          	mov    %ax,0x4(%ebx)
    ++ip_id;
  806f0c:	66 83 05 1a 54 b3 00 	addw   $0x1,0xb3541a
  806f13:	01 

    if (ip_addr_isany(src)) {
  806f14:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  806f18:	74 09                	je     806f23 <ip_output_if+0x105>
  806f1a:	8b 45 0c             	mov    0xc(%ebp),%eax
  806f1d:	8b 00                	mov    (%eax),%eax
  806f1f:	85 c0                	test   %eax,%eax
  806f21:	75 18                	jne    806f3b <ip_output_if+0x11d>
      ip_addr_set(&(iphdr->src), &(netif->ip_addr));
  806f23:	83 7d 20 fc          	cmpl   $0xfffffffc,0x20(%ebp)
  806f27:	74 08                	je     806f31 <ip_output_if+0x113>
  806f29:	8b 45 20             	mov    0x20(%ebp),%eax
  806f2c:	8b 40 04             	mov    0x4(%eax),%eax
  806f2f:	eb 05                	jmp    806f36 <ip_output_if+0x118>
  806f31:	b8 00 00 00 00       	mov    $0x0,%eax
  806f36:	89 43 0c             	mov    %eax,0xc(%ebx)
  806f39:	eb 03                	jmp    806f3e <ip_output_if+0x120>
    } else {
      ip_addr_set(&(iphdr->src), src);
  806f3b:	89 43 0c             	mov    %eax,0xc(%ebx)
    }

    IPH_CHKSUM_SET(iphdr, 0);
  806f3e:	66 c7 43 0a 00 00    	movw   $0x0,0xa(%ebx)
#if CHECKSUM_GEN_IP
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
  806f44:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  806f4b:	00 
  806f4c:	89 1c 24             	mov    %ebx,(%esp)
  806f4f:	e8 cd 0c 00 00       	call   807c21 <inet_chksum>
  806f54:	66 89 43 0a          	mov    %ax,0xa(%ebx)
  806f58:	eb 09                	jmp    806f63 <ip_output_if+0x145>
#endif
  } else {
    /* IP header already included in p */
    iphdr = p->payload;
    dest = &(iphdr->dest);
  806f5a:	8b 46 04             	mov    0x4(%esi),%eax
  806f5d:	83 c0 10             	add    $0x10,%eax
  806f60:	89 45 10             	mov    %eax,0x10(%ebp)
  }

#if IP_FRAG
  /* don't fragment if interface has mtu set to 0 [loopif] */
  if (netif->mtu && (p->tot_len > netif->mtu))
  806f63:	8b 45 20             	mov    0x20(%ebp),%eax
  806f66:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
  806f6a:	66 85 c0             	test   %ax,%ax
  806f6d:	74 1e                	je     806f8d <ip_output_if+0x16f>
  806f6f:	66 3b 46 08          	cmp    0x8(%esi),%ax
  806f73:	73 18                	jae    806f8d <ip_output_if+0x16f>
    return ip_frag(p,netif,dest);
  806f75:	8b 45 10             	mov    0x10(%ebp),%eax
  806f78:	89 44 24 08          	mov    %eax,0x8(%esp)
  806f7c:	8b 45 20             	mov    0x20(%ebp),%eax
  806f7f:	89 44 24 04          	mov    %eax,0x4(%esp)
  806f83:	89 34 24             	mov    %esi,(%esp)
  806f86:	e8 07 08 00 00       	call   807792 <ip_frag>
  806f8b:	eb 1b                	jmp    806fa8 <ip_output_if+0x18a>
  } else
#endif /* (LWIP_NETIF_LOOPBACK || LWIP_HAVE_LOOPIF) */
  {
    LWIP_DEBUGF(IP_DEBUG, ("netif->output()"));

    return netif->output(netif, p, dest);
  806f8d:	8b 45 10             	mov    0x10(%ebp),%eax
  806f90:	89 44 24 08          	mov    %eax,0x8(%esp)
  806f94:	89 74 24 04          	mov    %esi,0x4(%esp)
  806f98:	8b 45 20             	mov    0x20(%ebp),%eax
  806f9b:	89 04 24             	mov    %eax,(%esp)
  806f9e:	ff 50 14             	call   *0x14(%eax)
  806fa1:	eb 05                	jmp    806fa8 <ip_output_if+0x18a>
    if (pbuf_header(p, IP_HLEN)) {
      LWIP_DEBUGF(IP_DEBUG | 2, ("ip_output: not enough room for IP header in pbuf\n"));

      IP_STATS_INC(ip.err);
      snmp_inc_ipoutdiscards();
      return ERR_BUF;
  806fa3:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  {
    LWIP_DEBUGF(IP_DEBUG, ("netif->output()"));

    return netif->output(netif, p, dest);
  }
}
  806fa8:	83 c4 2c             	add    $0x2c,%esp
  806fab:	5b                   	pop    %ebx
  806fac:	5e                   	pop    %esi
  806fad:	5f                   	pop    %edi
  806fae:	5d                   	pop    %ebp
  806faf:	c3                   	ret    

00806fb0 <ip_output>:
 *         see ip_output_if() for more return values
 */
err_t
ip_output(struct pbuf *p, struct ip_addr *src, struct ip_addr *dest,
          u8_t ttl, u8_t tos, u8_t proto)
{
  806fb0:	55                   	push   %ebp
  806fb1:	89 e5                	mov    %esp,%ebp
  806fb3:	57                   	push   %edi
  806fb4:	56                   	push   %esi
  806fb5:	53                   	push   %ebx
  806fb6:	83 ec 2c             	sub    $0x2c,%esp
  806fb9:	8b 5d 14             	mov    0x14(%ebp),%ebx
  806fbc:	8b 75 18             	mov    0x18(%ebp),%esi
  806fbf:	8b 7d 1c             	mov    0x1c(%ebp),%edi
  struct netif *netif;

  if ((netif = ip_route(dest)) == NULL) {
  806fc2:	8b 45 10             	mov    0x10(%ebp),%eax
  806fc5:	89 04 24             	mov    %eax,(%esp)
  806fc8:	e8 13 fb ff ff       	call   806ae0 <ip_route>
  806fcd:	85 c0                	test   %eax,%eax
  806fcf:	74 38                	je     807009 <ip_output+0x59>
    return ERR_RTE;
  }

  return ip_output_if(p, src, dest, ttl, tos, proto, netif);
  806fd1:	89 44 24 18          	mov    %eax,0x18(%esp)
  806fd5:	89 f8                	mov    %edi,%eax
  806fd7:	0f b6 f8             	movzbl %al,%edi
  806fda:	89 7c 24 14          	mov    %edi,0x14(%esp)
  806fde:	89 f0                	mov    %esi,%eax
  806fe0:	0f b6 f0             	movzbl %al,%esi
  806fe3:	89 74 24 10          	mov    %esi,0x10(%esp)
  806fe7:	0f b6 db             	movzbl %bl,%ebx
  806fea:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
  806fee:	8b 45 10             	mov    0x10(%ebp),%eax
  806ff1:	89 44 24 08          	mov    %eax,0x8(%esp)
  806ff5:	8b 45 0c             	mov    0xc(%ebp),%eax
  806ff8:	89 44 24 04          	mov    %eax,0x4(%esp)
  806ffc:	8b 45 08             	mov    0x8(%ebp),%eax
  806fff:	89 04 24             	mov    %eax,(%esp)
  807002:	e8 17 fe ff ff       	call   806e1e <ip_output_if>
  807007:	eb 05                	jmp    80700e <ip_output+0x5e>
          u8_t ttl, u8_t tos, u8_t proto)
{
  struct netif *netif;

  if ((netif = ip_route(dest)) == NULL) {
    return ERR_RTE;
  807009:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  }

  return ip_output_if(p, src, dest, ttl, tos, proto, netif);
}
  80700e:	83 c4 2c             	add    $0x2c,%esp
  807011:	5b                   	pop    %ebx
  807012:	5e                   	pop    %esi
  807013:	5f                   	pop    %edi
  807014:	5d                   	pop    %ebp
  807015:	c3                   	ret    
  807016:	66 90                	xchg   %ax,%ax
  807018:	66 90                	xchg   %ax,%ax
  80701a:	66 90                	xchg   %ax,%ax
  80701c:	66 90                	xchg   %ax,%ax
  80701e:	66 90                	xchg   %ax,%ax

00807020 <ip_reass_dequeue_datagram>:
 * Dequeues a datagram from the datagram queue. Doesn't deallocate the pbufs.
 * @param ipr points to the queue entry to dequeue
 */
static void
ip_reass_dequeue_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
  807020:	55                   	push   %ebp
  807021:	89 e5                	mov    %esp,%ebp
  807023:	83 ec 18             	sub    $0x18,%esp
  
  /* dequeue the reass struct  */
  if (reassdatagrams == ipr) {
  807026:	8b 0d 00 5a b3 00    	mov    0xb35a00,%ecx
  80702c:	39 c1                	cmp    %eax,%ecx
  80702e:	75 0a                	jne    80703a <ip_reass_dequeue_datagram+0x1a>
    /* it was the first in the list */
    reassdatagrams = ipr->next;
  807030:	8b 11                	mov    (%ecx),%edx
  807032:	89 15 00 5a b3 00    	mov    %edx,0xb35a00
  807038:	eb 24                	jmp    80705e <ip_reass_dequeue_datagram+0x3e>
  } else {
    /* it wasn't the first, so it must have a valid 'prev' */
    LWIP_ASSERT("sanity check linked list", prev != NULL);
  80703a:	85 d2                	test   %edx,%edx
  80703c:	75 1c                	jne    80705a <ip_reass_dequeue_datagram+0x3a>
  80703e:	c7 44 24 08 e9 2c 81 	movl   $0x812ce9,0x8(%esp)
  807045:	00 
  807046:	c7 44 24 04 29 01 00 	movl   $0x129,0x4(%esp)
  80704d:	00 
  80704e:	c7 04 24 02 2d 81 00 	movl   $0x812d02,(%esp)
  807055:	e8 20 80 00 00       	call   80f07a <_panic>
    prev->next = ipr->next;
  80705a:	8b 08                	mov    (%eax),%ecx
  80705c:	89 0a                	mov    %ecx,(%edx)
  }

  /* now we can free the ip_reass struct */
  memp_free(MEMP_REASSDATA, ipr);
  80705e:	89 44 24 04          	mov    %eax,0x4(%esp)
  807062:	c7 04 24 05 00 00 00 	movl   $0x5,(%esp)
  807069:	e8 d4 d9 ff ff       	call   804a42 <memp_free>
}
  80706e:	c9                   	leave  
  80706f:	c3                   	ret    

00807070 <ip_reass_free_complete_datagram>:
 * @param prev the previous datagram in the linked list
 * @return the number of pbufs freed
 */
static int
ip_reass_free_complete_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
  807070:	55                   	push   %ebp
  807071:	89 e5                	mov    %esp,%ebp
  807073:	57                   	push   %edi
  807074:	56                   	push   %esi
  807075:	53                   	push   %ebx
  807076:	83 ec 2c             	sub    $0x2c,%esp
  807079:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80707c:	89 55 e0             	mov    %edx,-0x20(%ebp)
  int pbufs_freed = 0;
  struct pbuf *p;
  struct ip_reass_helper *iprh;

  LWIP_ASSERT("prev != ipr", prev != ipr);
  80707f:	39 c2                	cmp    %eax,%edx
  807081:	75 1c                	jne    80709f <ip_reass_free_complete_datagram+0x2f>
  807083:	c7 44 24 08 1f 2d 81 	movl   $0x812d1f,0x8(%esp)
  80708a:	00 
  80708b:	c7 44 24 04 99 00 00 	movl   $0x99,0x4(%esp)
  807092:	00 
  807093:	c7 04 24 02 2d 81 00 	movl   $0x812d02,(%esp)
  80709a:	e8 db 7f 00 00       	call   80f07a <_panic>
  if (prev != NULL) {
  80709f:	8b 45 e0             	mov    -0x20(%ebp),%eax
  8070a2:	85 c0                	test   %eax,%eax
  8070a4:	74 23                	je     8070c9 <ip_reass_free_complete_datagram+0x59>
    LWIP_ASSERT("prev->next == ipr", prev->next == ipr);
  8070a6:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  8070a9:	39 08                	cmp    %ecx,(%eax)
  8070ab:	74 1c                	je     8070c9 <ip_reass_free_complete_datagram+0x59>
  8070ad:	c7 44 24 08 2b 2d 81 	movl   $0x812d2b,0x8(%esp)
  8070b4:	00 
  8070b5:	c7 44 24 04 9b 00 00 	movl   $0x9b,0x4(%esp)
  8070bc:	00 
  8070bd:	c7 04 24 02 2d 81 00 	movl   $0x812d02,(%esp)
  8070c4:	e8 b1 7f 00 00       	call   80f07a <_panic>
  }

  snmp_inc_ipreasmfails();
#if LWIP_ICMP
  iprh = (struct ip_reass_helper *)ipr->p->payload;
  8070c9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8070cc:	8b 58 04             	mov    0x4(%eax),%ebx
  8070cf:	8b 43 04             	mov    0x4(%ebx),%eax
 * @return the number of pbufs freed
 */
static int
ip_reass_free_complete_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
  int pbufs_freed = 0;
  8070d2:	be 00 00 00 00       	mov    $0x0,%esi
  }

  snmp_inc_ipreasmfails();
#if LWIP_ICMP
  iprh = (struct ip_reass_helper *)ipr->p->payload;
  if (iprh->start == 0) {
  8070d7:	66 83 78 04 00       	cmpw   $0x0,0x4(%eax)
  8070dc:	75 45                	jne    807123 <ip_reass_free_complete_datagram+0xb3>
    /* The first fragment was received, send ICMP time exceeded. */
    /* First, de-queue the first pbuf from r->p. */
    p = ipr->p;
    ipr->p = iprh->next_pbuf;
  8070de:	8b 00                	mov    (%eax),%eax
  8070e0:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  8070e3:	89 41 04             	mov    %eax,0x4(%ecx)
    /* Then, copy the original header into it. */
    SMEMCPY(p->payload, &ipr->iphdr, IP_HLEN);
  8070e6:	c7 44 24 08 14 00 00 	movl   $0x14,0x8(%esp)
  8070ed:	00 
  8070ee:	8d 41 08             	lea    0x8(%ecx),%eax
  8070f1:	89 44 24 04          	mov    %eax,0x4(%esp)
  8070f5:	8b 43 04             	mov    0x4(%ebx),%eax
  8070f8:	89 04 24             	mov    %eax,(%esp)
  8070fb:	e8 9c 88 00 00       	call   80f99c <memcpy>
    icmp_time_exceeded(p, ICMP_TE_FRAG);
  807100:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  807107:	00 
  807108:	89 1c 24             	mov    %ebx,(%esp)
  80710b:	e8 f7 7d 00 00       	call   80ef07 <icmp_time_exceeded>
    pbufs_freed += pbuf_clen(p);
  807110:	89 1c 24             	mov    %ebx,(%esp)
  807113:	e8 72 e1 ff ff       	call   80528a <pbuf_clen>
  807118:	0f b6 f0             	movzbl %al,%esi
    pbuf_free(p);
  80711b:	89 1c 24             	mov    %ebx,(%esp)
  80711e:	e8 d1 dc ff ff       	call   804df4 <pbuf_free>
  }
#endif /* LWIP_ICMP */

  /* First, free all received pbufs.  The individual pbufs need to be released 
     separately as they have not yet been chained */
  p = ipr->p;
  807123:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  807126:	8b 58 04             	mov    0x4(%eax),%ebx
  while (p != NULL) {
  807129:	eb 1c                	jmp    807147 <ip_reass_free_complete_datagram+0xd7>
    struct pbuf *pcur;
    iprh = (struct ip_reass_helper *)p->payload;
  80712b:	8b 43 04             	mov    0x4(%ebx),%eax
    pcur = p;
    /* get the next pointer before freeing */
    p = iprh->next_pbuf;
  80712e:	8b 38                	mov    (%eax),%edi
    pbufs_freed += pbuf_clen(pcur);
  807130:	89 1c 24             	mov    %ebx,(%esp)
  807133:	e8 52 e1 ff ff       	call   80528a <pbuf_clen>
  807138:	0f b6 c0             	movzbl %al,%eax
  80713b:	01 c6                	add    %eax,%esi
    pbuf_free(pcur);    
  80713d:	89 1c 24             	mov    %ebx,(%esp)
  807140:	e8 af dc ff ff       	call   804df4 <pbuf_free>
  while (p != NULL) {
    struct pbuf *pcur;
    iprh = (struct ip_reass_helper *)p->payload;
    pcur = p;
    /* get the next pointer before freeing */
    p = iprh->next_pbuf;
  807145:	89 fb                	mov    %edi,%ebx
#endif /* LWIP_ICMP */

  /* First, free all received pbufs.  The individual pbufs need to be released 
     separately as they have not yet been chained */
  p = ipr->p;
  while (p != NULL) {
  807147:	85 db                	test   %ebx,%ebx
  807149:	75 e0                	jne    80712b <ip_reass_free_complete_datagram+0xbb>
    p = iprh->next_pbuf;
    pbufs_freed += pbuf_clen(pcur);
    pbuf_free(pcur);    
  }
  /* Then, unchain the struct ip_reassdata from the list and free it. */
  ip_reass_dequeue_datagram(ipr, prev);
  80714b:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80714e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  807151:	e8 ca fe ff ff       	call   807020 <ip_reass_dequeue_datagram>
  LWIP_ASSERT("ip_reass_pbufcount >= clen", ip_reass_pbufcount >= pbufs_freed);
  807156:	0f b7 05 fc 59 b3 00 	movzwl 0xb359fc,%eax
  80715d:	0f b7 d0             	movzwl %ax,%edx
  807160:	39 f2                	cmp    %esi,%edx
  807162:	7d 1c                	jge    807180 <ip_reass_free_complete_datagram+0x110>
  807164:	c7 44 24 08 3d 2d 81 	movl   $0x812d3d,0x8(%esp)
  80716b:	00 
  80716c:	c7 44 24 04 bc 00 00 	movl   $0xbc,0x4(%esp)
  807173:	00 
  807174:	c7 04 24 02 2d 81 00 	movl   $0x812d02,(%esp)
  80717b:	e8 fa 7e 00 00       	call   80f07a <_panic>
  ip_reass_pbufcount -= pbufs_freed;
  807180:	29 f0                	sub    %esi,%eax
  807182:	66 a3 fc 59 b3 00    	mov    %ax,0xb359fc

  return pbufs_freed;
}
  807188:	89 f0                	mov    %esi,%eax
  80718a:	83 c4 2c             	add    $0x2c,%esp
  80718d:	5b                   	pop    %ebx
  80718e:	5e                   	pop    %esi
  80718f:	5f                   	pop    %edi
  807190:	5d                   	pop    %ebp
  807191:	c3                   	ret    

00807192 <ip_reass_remove_oldest_datagram>:
 *        (used for freeing other datagrams if not enough space)
 * @return the number of pbufs freed
 */
static int
ip_reass_remove_oldest_datagram(struct ip_hdr *fraghdr, int pbufs_needed)
{
  807192:	55                   	push   %ebp
  807193:	89 e5                	mov    %esp,%ebp
  807195:	57                   	push   %edi
  807196:	56                   	push   %esi
  807197:	53                   	push   %ebx
  807198:	83 ec 1c             	sub    $0x1c,%esp
  80719b:	89 c6                	mov    %eax,%esi
  80719d:	89 55 dc             	mov    %edx,-0x24(%ebp)
  /* @todo Can't we simply remove the last datagram in the
   *       linked list behind reassdatagrams?
   */
  struct ip_reassdata *r, *oldest, *prev;
  int pbufs_freed = 0, pbufs_freed_current;
  8071a0:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
   * but don't free the datagram that 'fraghdr' belongs to! */
  do {
    oldest = NULL;
    prev = NULL;
    other_datagrams = 0;
    r = reassdatagrams;
  8071a7:	8b 0d 00 5a b3 00    	mov    0xb35a00,%ecx
  /* Free datagrams until being allowed to enqueue 'pbufs_needed' pbufs,
   * but don't free the datagram that 'fraghdr' belongs to! */
  do {
    oldest = NULL;
    prev = NULL;
    other_datagrams = 0;
  8071ad:	bb 00 00 00 00       	mov    $0x0,%ebx

  /* Free datagrams until being allowed to enqueue 'pbufs_needed' pbufs,
   * but don't free the datagram that 'fraghdr' belongs to! */
  do {
    oldest = NULL;
    prev = NULL;
  8071b2:	ba 00 00 00 00       	mov    $0x0,%edx
  int other_datagrams;

  /* Free datagrams until being allowed to enqueue 'pbufs_needed' pbufs,
   * but don't free the datagram that 'fraghdr' belongs to! */
  do {
    oldest = NULL;
  8071b7:	b8 00 00 00 00       	mov    $0x0,%eax
  8071bc:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
    prev = NULL;
    other_datagrams = 0;
    r = reassdatagrams;
    while (r != NULL) {
  8071bf:	eb 39                	jmp    8071fa <ip_reass_remove_oldest_datagram+0x68>
      if (!IP_ADDRESSES_AND_ID_MATCH(&r->iphdr, fraghdr)) {
  8071c1:	8b 5e 0c             	mov    0xc(%esi),%ebx
  8071c4:	39 59 14             	cmp    %ebx,0x14(%ecx)
  8071c7:	75 12                	jne    8071db <ip_reass_remove_oldest_datagram+0x49>
  8071c9:	8b 7e 10             	mov    0x10(%esi),%edi
  8071cc:	39 79 18             	cmp    %edi,0x18(%ecx)
  8071cf:	75 0a                	jne    8071db <ip_reass_remove_oldest_datagram+0x49>
  8071d1:	0f b7 7e 04          	movzwl 0x4(%esi),%edi
  8071d5:	66 39 79 0c          	cmp    %di,0xc(%ecx)
  8071d9:	74 16                	je     8071f1 <ip_reass_remove_oldest_datagram+0x5f>
        /* Not the same datagram as fraghdr */
        other_datagrams++;
  8071db:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
        if (oldest == NULL) {
  8071df:	85 c0                	test   %eax,%eax
  8071e1:	74 0c                	je     8071ef <ip_reass_remove_oldest_datagram+0x5d>
          oldest = r;
        } else if (r->timer <= oldest->timer) {
          /* older than the previous oldest */
          oldest = r;
  8071e3:	0f b6 58 1f          	movzbl 0x1f(%eax),%ebx
  8071e7:	38 59 1f             	cmp    %bl,0x1f(%ecx)
  8071ea:	0f 46 c1             	cmovbe %ecx,%eax
  8071ed:	eb 02                	jmp    8071f1 <ip_reass_remove_oldest_datagram+0x5f>
    while (r != NULL) {
      if (!IP_ADDRESSES_AND_ID_MATCH(&r->iphdr, fraghdr)) {
        /* Not the same datagram as fraghdr */
        other_datagrams++;
        if (oldest == NULL) {
          oldest = r;
  8071ef:	89 c8                	mov    %ecx,%eax
        } else if (r->timer <= oldest->timer) {
          /* older than the previous oldest */
          oldest = r;
        }
      }
      if (r->next != NULL) {
  8071f1:	8b 39                	mov    (%ecx),%edi
  8071f3:	85 ff                	test   %edi,%edi
  8071f5:	0f 45 d1             	cmovne %ecx,%edx
  8071f8:	89 f9                	mov    %edi,%ecx
  do {
    oldest = NULL;
    prev = NULL;
    other_datagrams = 0;
    r = reassdatagrams;
    while (r != NULL) {
  8071fa:	85 c9                	test   %ecx,%ecx
  8071fc:	75 c3                	jne    8071c1 <ip_reass_remove_oldest_datagram+0x2f>
  8071fe:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
      if (r->next != NULL) {
        prev = r;
      }
      r = r->next;
    }
    if (oldest != NULL) {
  807201:	85 c0                	test   %eax,%eax
  807203:	74 08                	je     80720d <ip_reass_remove_oldest_datagram+0x7b>
      pbufs_freed_current = ip_reass_free_complete_datagram(oldest, prev);
  807205:	e8 66 fe ff ff       	call   807070 <ip_reass_free_complete_datagram>
      pbufs_freed += pbufs_freed_current;
  80720a:	01 45 e0             	add    %eax,-0x20(%ebp)
    }
  } while ((pbufs_freed < pbufs_needed) && (other_datagrams > 1));
  80720d:	8b 45 dc             	mov    -0x24(%ebp),%eax
  807210:	39 45 e0             	cmp    %eax,-0x20(%ebp)
  807213:	7d 05                	jge    80721a <ip_reass_remove_oldest_datagram+0x88>
  807215:	83 fb 01             	cmp    $0x1,%ebx
  807218:	7f 8d                	jg     8071a7 <ip_reass_remove_oldest_datagram+0x15>
  return pbufs_freed;
}
  80721a:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80721d:	83 c4 1c             	add    $0x1c,%esp
  807220:	5b                   	pop    %ebx
  807221:	5e                   	pop    %esi
  807222:	5f                   	pop    %edi
  807223:	5d                   	pop    %ebp
  807224:	c3                   	ret    

00807225 <ip_reass_tmr>:
 *
 * Should be called every 1000 msec (defined by IP_TMR_INTERVAL).
 */
void
ip_reass_tmr(void)
{
  807225:	55                   	push   %ebp
  807226:	89 e5                	mov    %esp,%ebp
  807228:	56                   	push   %esi
  807229:	53                   	push   %ebx
  struct ip_reassdata *r, *prev = NULL;

  r = reassdatagrams;
  80722a:	a1 00 5a b3 00       	mov    0xb35a00,%eax
 * Should be called every 1000 msec (defined by IP_TMR_INTERVAL).
 */
void
ip_reass_tmr(void)
{
  struct ip_reassdata *r, *prev = NULL;
  80722f:	bb 00 00 00 00       	mov    $0x0,%ebx

  r = reassdatagrams;
  while (r != NULL) {
  807234:	eb 1f                	jmp    807255 <ip_reass_tmr+0x30>
    /* Decrement the timer. Once it reaches 0,
     * clean up the incomplete fragment assembly */
    if (r->timer > 0) {
  807236:	0f b6 48 1f          	movzbl 0x1f(%eax),%ecx
  80723a:	84 c9                	test   %cl,%cl
  80723c:	74 0c                	je     80724a <ip_reass_tmr+0x25>
      r->timer--;
  80723e:	83 e9 01             	sub    $0x1,%ecx
  807241:	88 48 1f             	mov    %cl,0x1f(%eax)
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_tmr: timer dec %"U16_F"\n",(u16_t)r->timer));
      prev = r;
  807244:	89 c3                	mov    %eax,%ebx
      r = r->next;
  807246:	8b 00                	mov    (%eax),%eax
  807248:	eb 0b                	jmp    807255 <ip_reass_tmr+0x30>
      /* reassembly timed out */
      struct ip_reassdata *tmp;
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_tmr: timer timed out\n"));
      tmp = r;
      /* get the next pointer before freeing */
      r = r->next;
  80724a:	8b 30                	mov    (%eax),%esi
      /* free the helper struct and all enqueued pbufs */
      ip_reass_free_complete_datagram(tmp, prev);
  80724c:	89 da                	mov    %ebx,%edx
  80724e:	e8 1d fe ff ff       	call   807070 <ip_reass_free_complete_datagram>
      /* reassembly timed out */
      struct ip_reassdata *tmp;
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_tmr: timer timed out\n"));
      tmp = r;
      /* get the next pointer before freeing */
      r = r->next;
  807253:	89 f0                	mov    %esi,%eax
ip_reass_tmr(void)
{
  struct ip_reassdata *r, *prev = NULL;

  r = reassdatagrams;
  while (r != NULL) {
  807255:	85 c0                	test   %eax,%eax
  807257:	75 dd                	jne    807236 <ip_reass_tmr+0x11>
      r = r->next;
      /* free the helper struct and all enqueued pbufs */
      ip_reass_free_complete_datagram(tmp, prev);
     }
   }
}
  807259:	5b                   	pop    %ebx
  80725a:	5e                   	pop    %esi
  80725b:	5d                   	pop    %ebp
  80725c:	c3                   	ret    

0080725d <ip_reass>:
 * @param p points to a pbuf chain of the fragment
 * @return NULL if reassembly is incomplete, ? otherwise
 */
struct pbuf *
ip_reass(struct pbuf *p)
{
  80725d:	55                   	push   %ebp
  80725e:	89 e5                	mov    %esp,%ebp
  807260:	57                   	push   %edi
  807261:	56                   	push   %esi
  807262:	53                   	push   %ebx
  807263:	83 ec 3c             	sub    $0x3c,%esp
  struct ip_reassdata *ipr_prev = NULL;

  IPFRAG_STATS_INC(ip_frag.recv);
  snmp_inc_ipreasmreqds();

  fraghdr = (struct ip_hdr*)p->payload;
  807266:	8b 45 08             	mov    0x8(%ebp),%eax
  807269:	8b 58 04             	mov    0x4(%eax),%ebx

  if ((IPH_HL(fraghdr) * 4) != IP_HLEN) {
  80726c:	0f b7 03             	movzwl (%ebx),%eax
  80726f:	89 04 24             	mov    %eax,(%esp)
  807272:	e8 0c 0b 00 00       	call   807d83 <ntohs>
  807277:	66 c1 e8 08          	shr    $0x8,%ax
  80727b:	83 e0 0f             	and    $0xf,%eax
  80727e:	83 f8 05             	cmp    $0x5,%eax
  807281:	0f 85 14 04 00 00    	jne    80769b <ip_reass+0x43e>
    LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: IP options currently not supported!\n"));
    IPFRAG_STATS_INC(ip_frag.err);
    goto nullreturn;
  }

  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
  807287:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
  80728b:	89 04 24             	mov    %eax,(%esp)
  80728e:	e8 f0 0a 00 00       	call   807d83 <ntohs>
  807293:	66 89 45 dc          	mov    %ax,-0x24(%ebp)
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
  807297:	0f b7 43 02          	movzwl 0x2(%ebx),%eax
  80729b:	89 04 24             	mov    %eax,(%esp)
  80729e:	e8 e0 0a 00 00       	call   807d83 <ntohs>
  8072a3:	66 89 45 da          	mov    %ax,-0x26(%ebp)
  8072a7:	0f b7 03             	movzwl (%ebx),%eax
  8072aa:	89 04 24             	mov    %eax,(%esp)
  8072ad:	e8 d1 0a 00 00       	call   807d83 <ntohs>
  8072b2:	66 89 45 d4          	mov    %ax,-0x2c(%ebp)

  /* Check if we are allowed to enqueue more datagrams. */
  clen = pbuf_clen(p);
  8072b6:	8b 45 08             	mov    0x8(%ebp),%eax
  8072b9:	89 04 24             	mov    %eax,(%esp)
  8072bc:	e8 c9 df ff ff       	call   80528a <pbuf_clen>
  8072c1:	88 45 e4             	mov    %al,-0x1c(%ebp)
  if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
  8072c4:	0f b6 f0             	movzbl %al,%esi
  8072c7:	0f b7 05 fc 59 b3 00 	movzwl 0xb359fc,%eax
  8072ce:	01 f0                	add    %esi,%eax
  8072d0:	83 f8 0a             	cmp    $0xa,%eax
  8072d3:	7e 23                	jle    8072f8 <ip_reass+0x9b>
#if IP_REASS_FREE_OLDEST
    if (!ip_reass_remove_oldest_datagram(fraghdr, clen) ||
  8072d5:	89 f2                	mov    %esi,%edx
  8072d7:	89 d8                	mov    %ebx,%eax
  8072d9:	e8 b4 fe ff ff       	call   807192 <ip_reass_remove_oldest_datagram>
  8072de:	85 c0                	test   %eax,%eax
  8072e0:	0f 84 b5 03 00 00    	je     80769b <ip_reass+0x43e>
        ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS))
  8072e6:	0f b7 05 fc 59 b3 00 	movzwl 0xb359fc,%eax
  8072ed:	01 f0                	add    %esi,%eax

  /* Check if we are allowed to enqueue more datagrams. */
  clen = pbuf_clen(p);
  if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
#if IP_REASS_FREE_OLDEST
    if (!ip_reass_remove_oldest_datagram(fraghdr, clen) ||
  8072ef:	83 f8 0a             	cmp    $0xa,%eax
  8072f2:	0f 8f a3 03 00 00    	jg     80769b <ip_reass+0x43e>
    }
  }

  /* Look for the datagram the fragment belongs to in the current datagram queue,
   * remembering the previous in the queue for later dequeueing. */
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
  8072f8:	8b 3d 00 5a b3 00    	mov    0xb35a00,%edi
  struct ip_hdr *fraghdr;
  struct ip_reassdata *ipr;
  struct ip_reass_helper *iprh;
  u16_t offset, len;
  u8_t clen;
  struct ip_reassdata *ipr_prev = NULL;
  8072fe:	b8 00 00 00 00       	mov    $0x0,%eax
    }
  }

  /* Look for the datagram the fragment belongs to in the current datagram queue,
   * remembering the previous in the queue for later dequeueing. */
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
  807303:	eb 1e                	jmp    807323 <ip_reass+0xc6>
    /* Check if the incoming fragment matches the one currently present
       in the reassembly buffer. If so, we proceed with copying the
       fragment into the buffer. */
    if (IP_ADDRESSES_AND_ID_MATCH(&ipr->iphdr, fraghdr)) {
  807305:	8b 4b 0c             	mov    0xc(%ebx),%ecx
  807308:	39 4f 14             	cmp    %ecx,0x14(%edi)
  80730b:	75 12                	jne    80731f <ip_reass+0xc2>
  80730d:	8b 53 10             	mov    0x10(%ebx),%edx
  807310:	39 57 18             	cmp    %edx,0x18(%edi)
  807313:	75 0a                	jne    80731f <ip_reass+0xc2>
  807315:	0f b7 4b 04          	movzwl 0x4(%ebx),%ecx
  807319:	66 39 4f 0c          	cmp    %cx,0xc(%edi)
  80731d:	74 4d                	je     80736c <ip_reass+0x10f>
    }
  }

  /* Look for the datagram the fragment belongs to in the current datagram queue,
   * remembering the previous in the queue for later dequeueing. */
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
  80731f:	89 f8                	mov    %edi,%eax
  807321:	8b 3f                	mov    (%edi),%edi
  807323:	85 ff                	test   %edi,%edi
  807325:	75 de                	jne    807305 <ip_reass+0xa8>
  807327:	89 45 e0             	mov    %eax,-0x20(%ebp)
static struct ip_reassdata*
ip_reass_enqueue_new_datagram(struct ip_hdr *fraghdr, int clen)
{
  struct ip_reassdata* ipr;
  /* No matching previous fragment found, allocate a new reassdata struct */
  ipr = memp_malloc(MEMP_REASSDATA);
  80732a:	c7 04 24 05 00 00 00 	movl   $0x5,(%esp)
  807331:	e8 ac d6 ff ff       	call   8049e2 <memp_malloc>
  807336:	89 c7                	mov    %eax,%edi
  if (ipr == NULL) {
  807338:	85 c0                	test   %eax,%eax
  80733a:	0f 85 05 04 00 00    	jne    807745 <ip_reass+0x4e8>
#if IP_REASS_FREE_OLDEST
    if (ip_reass_remove_oldest_datagram(fraghdr, clen) >= clen) {
  807340:	89 f2                	mov    %esi,%edx
  807342:	89 d8                	mov    %ebx,%eax
  807344:	e8 49 fe ff ff       	call   807192 <ip_reass_remove_oldest_datagram>
  807349:	39 c6                	cmp    %eax,%esi
  80734b:	0f 8f 4a 03 00 00    	jg     80769b <ip_reass+0x43e>
      ipr = memp_malloc(MEMP_REASSDATA);
  807351:	c7 04 24 05 00 00 00 	movl   $0x5,(%esp)
  807358:	e8 85 d6 ff ff       	call   8049e2 <memp_malloc>
  80735d:	89 c7                	mov    %eax,%edi
    }
    if (ipr == NULL)
  80735f:	85 c0                	test   %eax,%eax
  807361:	0f 85 de 03 00 00    	jne    807745 <ip_reass+0x4e8>
  807367:	e9 2f 03 00 00       	jmp    80769b <ip_reass+0x43e>
  80736c:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80736f:	89 fe                	mov    %edi,%esi
    /* Bail if unable to enqueue */
    if(ipr == NULL) {
      goto nullreturn;
    }
  } else {
    if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && 
  807371:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
  807375:	89 04 24             	mov    %eax,(%esp)
  807378:	e8 06 0a 00 00       	call   807d83 <ntohs>
  80737d:	66 a9 ff 1f          	test   $0x1fff,%ax
  807381:	75 29                	jne    8073ac <ip_reass+0x14f>
      ((ntohs(IPH_OFFSET(&ipr->iphdr)) & IP_OFFMASK) != 0)) {
  807383:	0f b7 47 0e          	movzwl 0xe(%edi),%eax
  807387:	89 04 24             	mov    %eax,(%esp)
  80738a:	e8 f4 09 00 00       	call   807d83 <ntohs>
    /* Bail if unable to enqueue */
    if(ipr == NULL) {
      goto nullreturn;
    }
  } else {
    if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && 
  80738f:	66 a9 ff 1f          	test   $0x1fff,%ax
  807393:	74 17                	je     8073ac <ip_reass+0x14f>
      ((ntohs(IPH_OFFSET(&ipr->iphdr)) & IP_OFFMASK) != 0)) {
      /* ipr->iphdr is not the header from the first fragment, but fraghdr is
       * -> copy fraghdr into ipr->iphdr since we want to have the header
       * of the first fragment (for ICMP time exceeded and later, for copying
       * all options, if supported)*/
      SMEMCPY(&ipr->iphdr, fraghdr, IP_HLEN);
  807395:	c7 44 24 08 14 00 00 	movl   $0x14,0x8(%esp)
  80739c:	00 
  80739d:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8073a1:	83 c6 08             	add    $0x8,%esi
  8073a4:	89 34 24             	mov    %esi,(%esp)
  8073a7:	e8 f0 85 00 00       	call   80f99c <memcpy>
    }
  }
  /* Track the current number of pbufs current 'in-flight', in order to limit 
  the number of fragments that may be enqueued at any one time */
  ip_reass_pbufcount += clen;
  8073ac:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
  8073b0:	66 01 05 fc 59 b3 00 	add    %ax,0xb359fc

  /* At this point, we have either created a new entry or pointing 
   * to an existing one */

  /* check for 'no more fragments', and update queue entry*/
  if ((ntohs(IPH_OFFSET(fraghdr)) & IP_MF) == 0) {
  8073b7:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
  8073bb:	89 04 24             	mov    %eax,(%esp)
  8073be:	e8 c0 09 00 00       	call   807d83 <ntohs>
  8073c3:	f6 c4 20             	test   $0x20,%ah
  8073c6:	75 20                	jne    8073e8 <ip_reass+0x18b>
    ipr->flags |= IP_REASS_FLAG_LASTFRAG;
  8073c8:	80 4f 1e 01          	orb    $0x1,0x1e(%edi)
    IPFRAG_STATS_INC(ip_frag.err);
    goto nullreturn;
  }

  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
  8073cc:	0f b7 45 dc          	movzwl -0x24(%ebp),%eax
  8073d0:	0f b7 75 da          	movzwl -0x26(%ebp),%esi
  8073d4:	8d 04 c6             	lea    (%esi,%eax,8),%eax
  8073d7:	0f b7 55 d4          	movzwl -0x2c(%ebp),%edx
  8073db:	66 c1 ea 06          	shr    $0x6,%dx
  8073df:	83 e2 3c             	and    $0x3c,%edx
   * to an existing one */

  /* check for 'no more fragments', and update queue entry*/
  if ((ntohs(IPH_OFFSET(fraghdr)) & IP_MF) == 0) {
    ipr->flags |= IP_REASS_FLAG_LASTFRAG;
    ipr->datagram_len = offset + len;
  8073e2:	29 d0                	sub    %edx,%eax
  8073e4:	66 89 47 1c          	mov    %ax,0x1c(%edi)
  u16_t offset,len;
  struct ip_hdr *fraghdr;
  int valid = 1;

  /* Extract length and fragment offset from current fragment */
  fraghdr = (struct ip_hdr*)new_p->payload; 
  8073e8:	8b 45 08             	mov    0x8(%ebp),%eax
  8073eb:	8b 58 04             	mov    0x4(%eax),%ebx
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
  8073ee:	0f b7 43 02          	movzwl 0x2(%ebx),%eax
  8073f2:	89 04 24             	mov    %eax,(%esp)
  8073f5:	e8 89 09 00 00       	call   807d83 <ntohs>
  8073fa:	89 c6                	mov    %eax,%esi
  8073fc:	0f b7 03             	movzwl (%ebx),%eax
  8073ff:	89 04 24             	mov    %eax,(%esp)
  807402:	e8 7c 09 00 00       	call   807d83 <ntohs>
  807407:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
  80740b:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
  80740f:	89 04 24             	mov    %eax,(%esp)
  807412:	e8 6c 09 00 00       	call   807d83 <ntohs>
  807417:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
  /* overwrite the fragment's ip header from the pbuf with our helper struct,
   * and setup the embedded helper structure. */
  /* make sure the struct ip_reass_helper fits into the IP header */
  LWIP_ASSERT("sizeof(struct ip_reass_helper) <= IP_HLEN",
              sizeof(struct ip_reass_helper) <= IP_HLEN);
  iprh = (struct ip_reass_helper*)new_p->payload;
  80741e:	8b 4d 08             	mov    0x8(%ebp),%ecx
  807421:	8b 51 04             	mov    0x4(%ecx),%edx
  807424:	89 55 dc             	mov    %edx,-0x24(%ebp)
  iprh->next_pbuf = NULL;
  807427:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
  iprh->start = offset;
  80742d:	66 89 5a 04          	mov    %bx,0x4(%edx)
  struct ip_hdr *fraghdr;
  int valid = 1;

  /* Extract length and fragment offset from current fragment */
  fraghdr = (struct ip_hdr*)new_p->payload; 
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
  807431:	01 de                	add    %ebx,%esi
  807433:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  807437:	66 c1 e8 06          	shr    $0x6,%ax
  80743b:	83 e0 3c             	and    $0x3c,%eax
  LWIP_ASSERT("sizeof(struct ip_reass_helper) <= IP_HLEN",
              sizeof(struct ip_reass_helper) <= IP_HLEN);
  iprh = (struct ip_reass_helper*)new_p->payload;
  iprh->next_pbuf = NULL;
  iprh->start = offset;
  iprh->end = offset + len;
  80743e:	29 c6                	sub    %eax,%esi
  807440:	66 89 75 da          	mov    %si,-0x26(%ebp)
  807444:	66 89 72 06          	mov    %si,0x6(%edx)

  /* Iterate through until we either get to the end of the list (append),
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
  807448:	8b 47 04             	mov    0x4(%edi),%eax
  80744b:	89 45 d4             	mov    %eax,-0x2c(%ebp)
{
  struct ip_reass_helper *iprh, *iprh_tmp, *iprh_prev=NULL;
  struct pbuf *q;
  u16_t offset,len;
  struct ip_hdr *fraghdr;
  int valid = 1;
  80744e:	b9 01 00 00 00       	mov    $0x1,%ecx
 * @return 0 if invalid, >0 otherwise
 */
static int
ip_reass_chain_frag_into_datagram_and_validate(struct ip_reassdata *ipr, struct pbuf *new_p)
{
  struct ip_reass_helper *iprh, *iprh_tmp, *iprh_prev=NULL;
  807453:	be 00 00 00 00       	mov    $0x0,%esi
  807458:	89 7d e4             	mov    %edi,-0x1c(%ebp)
  80745b:	89 cf                	mov    %ecx,%edi
  80745d:	eb 6f                	jmp    8074ce <ip_reass+0x271>
  iprh->end = offset + len;

  /* Iterate through until we either get to the end of the list (append),
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
    iprh_tmp = (struct ip_reass_helper*)q->payload;
  80745f:	8b 50 04             	mov    0x4(%eax),%edx
    if (iprh->start < iprh_tmp->start) {
  807462:	0f b7 4a 04          	movzwl 0x4(%edx),%ecx
  807466:	66 39 cb             	cmp    %cx,%bx
  807469:	73 3c                	jae    8074a7 <ip_reass+0x24a>
  80746b:	89 7d d0             	mov    %edi,-0x30(%ebp)
  80746e:	8b 7d e4             	mov    -0x1c(%ebp),%edi
      /* the new pbuf should be inserted before this */
      iprh->next_pbuf = q;
  807471:	8b 4d dc             	mov    -0x24(%ebp),%ecx
  807474:	89 01                	mov    %eax,(%ecx)
      if (iprh_prev != NULL) {
  807476:	85 f6                	test   %esi,%esi
  807478:	74 22                	je     80749c <ip_reass+0x23f>
        /* not the fragment with the lowest offset */
#if IP_REASS_CHECK_OVERLAP
        if ((iprh->start < iprh_prev->end) || (iprh->end > iprh_tmp->start)) {
  80747a:	66 3b 5e 06          	cmp    0x6(%esi),%bx
  80747e:	0f 82 92 01 00 00    	jb     807616 <ip_reass+0x3b9>
  807484:	0f b7 45 da          	movzwl -0x26(%ebp),%eax
  807488:	66 3b 42 04          	cmp    0x4(%edx),%ax
  80748c:	0f 87 84 01 00 00    	ja     807616 <ip_reass+0x3b9>
          /* fragment overlaps with previous or following, throw away */
          goto freepbuf;
        }
#endif /* IP_REASS_CHECK_OVERLAP */
        iprh_prev->next_pbuf = new_p;
  807492:	8b 45 08             	mov    0x8(%ebp),%eax
  807495:	89 06                	mov    %eax,(%esi)
  807497:	e9 a0 00 00 00       	jmp    80753c <ip_reass+0x2df>
      } else {
        /* fragment with the lowest offset */
        ipr->p = new_p;
  80749c:	8b 45 08             	mov    0x8(%ebp),%eax
  80749f:	89 47 04             	mov    %eax,0x4(%edi)
  8074a2:	e9 95 00 00 00       	jmp    80753c <ip_reass+0x2df>
      }
      break;
    } else if(iprh->start == iprh_tmp->start) {
  8074a7:	66 39 cb             	cmp    %cx,%bx
  8074aa:	0f 84 66 01 00 00    	je     807616 <ip_reass+0x3b9>
      /* received the same datagram twice: no need to keep the datagram */
      goto freepbuf;
#if IP_REASS_CHECK_OVERLAP
    } else if(iprh->start < iprh_tmp->end) {
  8074b0:	66 3b 5a 06          	cmp    0x6(%edx),%bx
  8074b4:	0f 82 5c 01 00 00    	jb     807616 <ip_reass+0x3b9>
      /* overlap: no need to keep the new datagram */
      goto freepbuf;
#endif /* IP_REASS_CHECK_OVERLAP */
    } else {
      /* Check if the fragments received so far have no wholes. */
      if (iprh_prev != NULL) {
  8074ba:	85 f6                	test   %esi,%esi
  8074bc:	74 0c                	je     8074ca <ip_reass+0x26d>
        if (iprh_prev->end != iprh_tmp->start) {
          /* There is a fragment missing between the current
           * and the previous fragment */
          valid = 0;
  8074be:	66 3b 4e 06          	cmp    0x6(%esi),%cx
  8074c2:	b8 00 00 00 00       	mov    $0x0,%eax
  8074c7:	0f 45 f8             	cmovne %eax,%edi
        }
      }
    }
    q = iprh_tmp->next_pbuf;
  8074ca:	8b 02                	mov    (%edx),%eax
  iprh->end = offset + len;

  /* Iterate through until we either get to the end of the list (append),
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
    iprh_tmp = (struct ip_reass_helper*)q->payload;
  8074cc:	89 d6                	mov    %edx,%esi
  iprh->start = offset;
  iprh->end = offset + len;

  /* Iterate through until we either get to the end of the list (append),
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
  8074ce:	85 c0                	test   %eax,%eax
  8074d0:	75 8d                	jne    80745f <ip_reass+0x202>
  8074d2:	e9 d9 01 00 00       	jmp    8076b0 <ip_reass+0x453>
  if (q == NULL) {
    if (iprh_prev != NULL) {
      /* this is (for now), the fragment with the highest offset:
       * chain it to the last fragment */
#if IP_REASS_CHECK_OVERLAP
      LWIP_ASSERT("check fragments don't overlap", iprh_prev->end <= iprh->start);
  8074d7:	0f b7 46 06          	movzwl 0x6(%esi),%eax
  8074db:	8b 4d dc             	mov    -0x24(%ebp),%ecx
  8074de:	66 3b 41 04          	cmp    0x4(%ecx),%ax
  8074e2:	76 1c                	jbe    807500 <ip_reass+0x2a3>
  8074e4:	c7 44 24 08 58 2d 81 	movl   $0x812d58,0x8(%esp)
  8074eb:	00 
  8074ec:	c7 44 24 04 83 01 00 	movl   $0x183,0x4(%esp)
  8074f3:	00 
  8074f4:	c7 04 24 02 2d 81 00 	movl   $0x812d02,(%esp)
  8074fb:	e8 7a 7b 00 00       	call   80f07a <_panic>
#endif /* IP_REASS_CHECK_OVERLAP */
      iprh_prev->next_pbuf = new_p;
  807500:	8b 4d 08             	mov    0x8(%ebp),%ecx
  807503:	89 0e                	mov    %ecx,(%esi)
      if (iprh_prev->end != iprh->start) {
  807505:	8b 75 dc             	mov    -0x24(%ebp),%esi
  807508:	66 3b 46 04          	cmp    0x4(%esi),%ax
  80750c:	0f 85 c3 01 00 00    	jne    8076d5 <ip_reass+0x478>
  807512:	eb 28                	jmp    80753c <ip_reass+0x2df>
        valid = 0;
      }
    } else {
#if IP_REASS_CHECK_OVERLAP
      LWIP_ASSERT("no previous fragment, this must be the first fragment!",
  807514:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
  807518:	74 1c                	je     807536 <ip_reass+0x2d9>
  80751a:	c7 44 24 08 84 2d 81 	movl   $0x812d84,0x8(%esp)
  807521:	00 
  807522:	c7 44 24 04 8c 01 00 	movl   $0x18c,0x4(%esp)
  807529:	00 
  80752a:	c7 04 24 02 2d 81 00 	movl   $0x812d02,(%esp)
  807531:	e8 44 7b 00 00       	call   80f07a <_panic>
        ipr->p == NULL);
#endif /* IP_REASS_CHECK_OVERLAP */
      /* this is the first fragment we ever received for this ip datagram */
      ipr->p = new_p;
  807536:	8b 45 08             	mov    0x8(%ebp),%eax
  807539:	89 47 04             	mov    %eax,0x4(%edi)
    }
  }

  /* At this point, the validation part begins: */
  /* If we already received the last fragment */
  if ((ipr->flags & IP_REASS_FLAG_LASTFRAG) != 0) {
  80753c:	f6 47 1e 01          	testb  $0x1,0x1e(%edi)
  807540:	0f 84 8f 01 00 00    	je     8076d5 <ip_reass+0x478>
    /* and had no wholes so far */
    if (valid) {
  807546:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
  80754a:	0f 84 85 01 00 00    	je     8076d5 <ip_reass+0x478>
      /* then check if the rest of the fragments is here */
      /* Check if the queue starts with the first datagram */
      if (((struct ip_reass_helper*)ipr->p->payload)->start != 0) {
  807550:	8b 4f 04             	mov    0x4(%edi),%ecx
  807553:	8b 59 04             	mov    0x4(%ecx),%ebx
  807556:	66 83 7b 04 00       	cmpw   $0x0,0x4(%ebx)
  80755b:	0f 85 74 01 00 00    	jne    8076d5 <ip_reass+0x478>
        valid = 0;
      } else {
        /* and check that there are no wholes after this datagram */
        iprh_prev = iprh;
        q = iprh->next_pbuf;
  807561:	8b 45 dc             	mov    -0x24(%ebp),%eax
  807564:	8b 10                	mov    (%eax),%edx
  807566:	89 c6                	mov    %eax,%esi
  807568:	eb 15                	jmp    80757f <ip_reass+0x322>
        while (q != NULL) {
          iprh = (struct ip_reass_helper*)q->payload;
  80756a:	8b 42 04             	mov    0x4(%edx),%eax
          if (iprh_prev->end != iprh->start) {
  80756d:	0f b7 50 04          	movzwl 0x4(%eax),%edx
  807571:	66 39 56 06          	cmp    %dx,0x6(%esi)
  807575:	0f 85 5a 01 00 00    	jne    8076d5 <ip_reass+0x478>
            valid = 0;
            break;
          }
          iprh_prev = iprh;
          q = iprh->next_pbuf;
  80757b:	8b 10                	mov    (%eax),%edx
      } else {
        /* and check that there are no wholes after this datagram */
        iprh_prev = iprh;
        q = iprh->next_pbuf;
        while (q != NULL) {
          iprh = (struct ip_reass_helper*)q->payload;
  80757d:	89 c6                	mov    %eax,%esi
        valid = 0;
      } else {
        /* and check that there are no wholes after this datagram */
        iprh_prev = iprh;
        q = iprh->next_pbuf;
        while (q != NULL) {
  80757f:	85 d2                	test   %edx,%edx
  807581:	75 e7                	jne    80756a <ip_reass+0x30d>
  807583:	e9 3b 01 00 00       	jmp    8076c3 <ip_reass+0x466>
          q = iprh->next_pbuf;
        }
        /* if still valid, all fragments are received
         * (because to the MF==0 already arrived */
        if (valid) {
          LWIP_ASSERT("sanity check", ipr->p != NULL);
  807588:	c7 44 24 08 76 2d 81 	movl   $0x812d76,0x8(%esp)
  80758f:	00 
  807590:	c7 44 24 04 ac 01 00 	movl   $0x1ac,0x4(%esp)
  807597:	00 
  807598:	c7 04 24 02 2d 81 00 	movl   $0x812d02,(%esp)
  80759f:	e8 d6 7a 00 00       	call   80f07a <_panic>
          LWIP_ASSERT("sanity check",
  8075a4:	3b 5d dc             	cmp    -0x24(%ebp),%ebx
  8075a7:	75 1c                	jne    8075c5 <ip_reass+0x368>
  8075a9:	c7 44 24 08 76 2d 81 	movl   $0x812d76,0x8(%esp)
  8075b0:	00 
  8075b1:	c7 44 24 04 ae 01 00 	movl   $0x1ae,0x4(%esp)
  8075b8:	00 
  8075b9:	c7 04 24 02 2d 81 00 	movl   $0x812d02,(%esp)
  8075c0:	e8 b5 7a 00 00       	call   80f07a <_panic>
            ((struct ip_reass_helper*)ipr->p->payload) != iprh);
          LWIP_ASSERT("validate_datagram:next_pbuf!=NULL",
  8075c5:	8b 45 dc             	mov    -0x24(%ebp),%eax
  8075c8:	83 38 00             	cmpl   $0x0,(%eax)
  8075cb:	74 1c                	je     8075e9 <ip_reass+0x38c>
  8075cd:	c7 44 24 08 bc 2d 81 	movl   $0x812dbc,0x8(%esp)
  8075d4:	00 
  8075d5:	c7 44 24 04 b0 01 00 	movl   $0x1b0,0x4(%esp)
  8075dc:	00 
  8075dd:	c7 04 24 02 2d 81 00 	movl   $0x812d02,(%esp)
  8075e4:	e8 91 7a 00 00       	call   80f07a <_panic>
            iprh->next_pbuf == NULL);
          LWIP_ASSERT("validate_datagram:datagram end!=datagram len",
  8075e9:	8b 45 dc             	mov    -0x24(%ebp),%eax
  8075ec:	0f b7 40 06          	movzwl 0x6(%eax),%eax
  8075f0:	66 3b 47 1c          	cmp    0x1c(%edi),%ax
  8075f4:	0f 84 e5 00 00 00    	je     8076df <ip_reass+0x482>
  8075fa:	c7 44 24 08 e0 2d 81 	movl   $0x812de0,0x8(%esp)
  807601:	00 
  807602:	c7 44 24 04 b2 01 00 	movl   $0x1b2,0x4(%esp)
  807609:	00 
  80760a:	c7 04 24 02 2d 81 00 	movl   $0x812d02,(%esp)
  807611:	e8 64 7a 00 00       	call   80f07a <_panic>
  }
  /* If we come here, not all fragments were received, yet! */
  return 0; /* not yet valid! */
#if IP_REASS_CHECK_OVERLAP
freepbuf:
  ip_reass_pbufcount -= pbuf_clen(new_p);
  807616:	0f b7 1d fc 59 b3 00 	movzwl 0xb359fc,%ebx
  80761d:	8b 45 08             	mov    0x8(%ebp),%eax
  807620:	89 04 24             	mov    %eax,(%esp)
  807623:	e8 62 dc ff ff       	call   80528a <pbuf_clen>
  807628:	0f b6 c0             	movzbl %al,%eax
  80762b:	29 c3                	sub    %eax,%ebx
  80762d:	66 89 1d fc 59 b3 00 	mov    %bx,0xb359fc
  pbuf_free(new_p);
  807634:	8b 45 08             	mov    0x8(%ebp),%eax
  807637:	89 04 24             	mov    %eax,(%esp)
  80763a:	e8 b5 d7 ff ff       	call   804df4 <pbuf_free>
  80763f:	e9 91 00 00 00       	jmp    8076d5 <ip_reass+0x478>

    p = ipr->p;

    /* chain together the pbufs contained within the reass_data list. */
    while(r != NULL) {
      iprh = (struct ip_reass_helper*)r->payload;
  807644:	8b 73 04             	mov    0x4(%ebx),%esi

      /* hide the ip header for every succeding fragment */
      pbuf_header(r, -IP_HLEN);
  807647:	c7 44 24 04 ec ff ff 	movl   $0xffffffec,0x4(%esp)
  80764e:	ff 
  80764f:	89 1c 24             	mov    %ebx,(%esp)
  807652:	e8 b9 d6 ff ff       	call   804d10 <pbuf_header>
      pbuf_cat(p, r);
  807657:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80765b:	89 3c 24             	mov    %edi,(%esp)
  80765e:	e8 50 dc ff ff       	call   8052b3 <pbuf_cat>
      r = iprh->next_pbuf;
  807663:	8b 1e                	mov    (%esi),%ebx
    IPH_CHKSUM_SET(fraghdr, inet_chksum(fraghdr, IP_HLEN));

    p = ipr->p;

    /* chain together the pbufs contained within the reass_data list. */
    while(r != NULL) {
  807665:	85 db                	test   %ebx,%ebx
  807667:	75 db                	jne    807644 <ip_reass+0x3e7>
  807669:	8b 7d dc             	mov    -0x24(%ebp),%edi
      pbuf_header(r, -IP_HLEN);
      pbuf_cat(p, r);
      r = iprh->next_pbuf;
    }
    /* release the sources allocate for the fragment queue entry */
    ip_reass_dequeue_datagram(ipr, ipr_prev);
  80766c:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80766f:	89 f8                	mov    %edi,%eax
  807671:	e8 aa f9 ff ff       	call   807020 <ip_reass_dequeue_datagram>

    /* and adjust the number of pbufs currently queued for reassembly. */
    ip_reass_pbufcount -= pbuf_clen(p);
  807676:	0f b7 1d fc 59 b3 00 	movzwl 0xb359fc,%ebx
  80767d:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  807680:	89 34 24             	mov    %esi,(%esp)
  807683:	e8 02 dc ff ff       	call   80528a <pbuf_clen>
  807688:	0f b6 c0             	movzbl %al,%eax
  80768b:	29 c3                	sub    %eax,%ebx
  80768d:	66 89 1d fc 59 b3 00 	mov    %bx,0xb359fc

    /* Return the pbuf chain */
    return p;
  807694:	89 f0                	mov    %esi,%eax
  807696:	e9 ef 00 00 00       	jmp    80778a <ip_reass+0x52d>
  return NULL;

nullreturn:
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: nullreturn\n"));
  IPFRAG_STATS_INC(ip_frag.drop);
  pbuf_free(p);
  80769b:	8b 45 08             	mov    0x8(%ebp),%eax
  80769e:	89 04 24             	mov    %eax,(%esp)
  8076a1:	e8 4e d7 ff ff       	call   804df4 <pbuf_free>
  return NULL;
  8076a6:	b8 00 00 00 00       	mov    $0x0,%eax
  8076ab:	e9 da 00 00 00       	jmp    80778a <ip_reass+0x52d>
  8076b0:	89 7d d0             	mov    %edi,-0x30(%ebp)
  8076b3:	8b 7d e4             	mov    -0x1c(%ebp),%edi
    iprh_prev = iprh_tmp;
  }

  /* If q is NULL, then we made it to the end of the list. Determine what to do now */
  if (q == NULL) {
    if (iprh_prev != NULL) {
  8076b6:	85 f6                	test   %esi,%esi
  8076b8:	0f 85 19 fe ff ff    	jne    8074d7 <ip_reass+0x27a>
  8076be:	e9 51 fe ff ff       	jmp    807514 <ip_reass+0x2b7>
  8076c3:	89 75 dc             	mov    %esi,-0x24(%ebp)
          q = iprh->next_pbuf;
        }
        /* if still valid, all fragments are received
         * (because to the MF==0 already arrived */
        if (valid) {
          LWIP_ASSERT("sanity check", ipr->p != NULL);
  8076c6:	85 c9                	test   %ecx,%ecx
  8076c8:	0f 85 d6 fe ff ff    	jne    8075a4 <ip_reass+0x347>
  8076ce:	66 90                	xchg   %ax,%ax
  8076d0:	e9 b3 fe ff ff       	jmp    807588 <ip_reass+0x32b>
    /* Return the pbuf chain */
    return p;
  }
  /* the datagram is not (yet?) reassembled completely */
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass_pbufcount: %d out\n", ip_reass_pbufcount));
  return NULL;
  8076d5:	b8 00 00 00 00       	mov    $0x0,%eax
  8076da:	e9 ab 00 00 00       	jmp    80778a <ip_reass+0x52d>
  /* find the right place to insert this pbuf */
  /* @todo: trim pbufs if fragments are overlapping */
  if (ip_reass_chain_frag_into_datagram_and_validate(ipr, p)) {
    /* the totally last fragment (flag more fragments = 0) was received at least
     * once AND all fragments are received */
    ipr->datagram_len += IP_HLEN;
  8076df:	83 c0 14             	add    $0x14,%eax
  8076e2:	66 89 47 1c          	mov    %ax,0x1c(%edi)

    /* save the second pbuf before copying the header over the pointer */
    r = ((struct ip_reass_helper*)ipr->p->payload)->next_pbuf;
  8076e6:	8b 47 04             	mov    0x4(%edi),%eax
  8076e9:	8b 70 04             	mov    0x4(%eax),%esi
  8076ec:	8b 1e                	mov    (%esi),%ebx

    /* copy the original ip header back to the first pbuf */
    fraghdr = (struct ip_hdr*)(ipr->p->payload);
    SMEMCPY(fraghdr, &ipr->iphdr, IP_HLEN);
  8076ee:	c7 44 24 08 14 00 00 	movl   $0x14,0x8(%esp)
  8076f5:	00 
  8076f6:	8d 47 08             	lea    0x8(%edi),%eax
  8076f9:	89 44 24 04          	mov    %eax,0x4(%esp)
  8076fd:	89 34 24             	mov    %esi,(%esp)
  807700:	e8 97 82 00 00       	call   80f99c <memcpy>
    IPH_LEN_SET(fraghdr, htons(ipr->datagram_len));
  807705:	0f b7 47 1c          	movzwl 0x1c(%edi),%eax
  807709:	89 04 24             	mov    %eax,(%esp)
  80770c:	e8 65 06 00 00       	call   807d76 <htons>
  807711:	66 89 46 02          	mov    %ax,0x2(%esi)
    IPH_OFFSET_SET(fraghdr, 0);
  807715:	66 c7 46 06 00 00    	movw   $0x0,0x6(%esi)
    IPH_CHKSUM_SET(fraghdr, 0);
  80771b:	66 c7 46 0a 00 00    	movw   $0x0,0xa(%esi)
    /* @todo: do we need to set calculate the correct checksum? */
    IPH_CHKSUM_SET(fraghdr, inet_chksum(fraghdr, IP_HLEN));
  807721:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  807728:	00 
  807729:	89 34 24             	mov    %esi,(%esp)
  80772c:	e8 f0 04 00 00       	call   807c21 <inet_chksum>
  807731:	66 89 46 0a          	mov    %ax,0xa(%esi)

    p = ipr->p;
  807735:	8b 47 04             	mov    0x4(%edi),%eax
  807738:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80773b:	89 7d dc             	mov    %edi,-0x24(%ebp)
  80773e:	89 c7                	mov    %eax,%edi

    /* chain together the pbufs contained within the reass_data list. */
    while(r != NULL) {
  807740:	e9 20 ff ff ff       	jmp    807665 <ip_reass+0x408>
      IPFRAG_STATS_INC(ip_frag.memerr);
      LWIP_DEBUGF(IP_REASS_DEBUG,("Failed to alloc reassdata struct\n"));
      return NULL;
    }
  }
  memset(ipr, 0, sizeof(struct ip_reassdata));
  807745:	c7 44 24 08 20 00 00 	movl   $0x20,0x8(%esp)
  80774c:	00 
  80774d:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  807754:	00 
  807755:	89 3c 24             	mov    %edi,(%esp)
  807758:	e8 8a 81 00 00       	call   80f8e7 <memset>
  ipr->timer = IP_REASS_MAXAGE;
  80775d:	c6 47 1f 03          	movb   $0x3,0x1f(%edi)

  /* enqueue the new structure to the front of the list */
  ipr->next = reassdatagrams;
  807761:	a1 00 5a b3 00       	mov    0xb35a00,%eax
  807766:	89 07                	mov    %eax,(%edi)
  reassdatagrams = ipr;
  807768:	89 3d 00 5a b3 00    	mov    %edi,0xb35a00
  /* copy the ip header for later tests and input */
  /* @todo: no ip options supported? */
  SMEMCPY(&(ipr->iphdr), fraghdr, IP_HLEN);
  80776e:	c7 44 24 08 14 00 00 	movl   $0x14,0x8(%esp)
  807775:	00 
  807776:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80777a:	8d 47 08             	lea    0x8(%edi),%eax
  80777d:	89 04 24             	mov    %eax,(%esp)
  807780:	e8 17 82 00 00       	call   80f99c <memcpy>
  807785:	e9 22 fc ff ff       	jmp    8073ac <ip_reass+0x14f>
nullreturn:
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: nullreturn\n"));
  IPFRAG_STATS_INC(ip_frag.drop);
  pbuf_free(p);
  return NULL;
}
  80778a:	83 c4 3c             	add    $0x3c,%esp
  80778d:	5b                   	pop    %ebx
  80778e:	5e                   	pop    %esi
  80778f:	5f                   	pop    %edi
  807790:	5d                   	pop    %ebp
  807791:	c3                   	ret    

00807792 <ip_frag>:
 *
 * @return ERR_OK if sent successfully, err_t otherwise
 */
err_t 
ip_frag(struct pbuf *p, struct netif *netif, struct ip_addr *dest)
{
  807792:	55                   	push   %ebp
  807793:	89 e5                	mov    %esp,%ebp
  807795:	57                   	push   %edi
  807796:	56                   	push   %esi
  807797:	53                   	push   %ebx
  807798:	83 ec 3c             	sub    $0x3c,%esp
  struct ip_hdr *original_iphdr;
#endif
  struct ip_hdr *iphdr;
  u16_t nfb;
  u16_t left, cop;
  u16_t mtu = netif->mtu;
  80779b:	8b 45 0c             	mov    0xc(%ebp),%eax
  80779e:	0f b7 70 2c          	movzwl 0x2c(%eax),%esi
#if IP_FRAG_USES_STATIC_BUF
  /* When using a static buffer, we use a PBUF_REF, which we will
   * use to reference the packet (without link header).
   * Layer and length is irrelevant.
   */
  rambuf = pbuf_alloc(PBUF_LINK, 0, PBUF_REF);
  8077a2:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
  8077a9:	00 
  8077aa:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8077b1:	00 
  8077b2:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  8077b9:	e8 17 d7 ff ff       	call   804ed5 <pbuf_alloc>
  8077be:	89 45 dc             	mov    %eax,-0x24(%ebp)
  if (rambuf == NULL) {
  8077c1:	89 c1                	mov    %eax,%ecx
  8077c3:	85 c0                	test   %eax,%eax
  8077c5:	0f 84 d2 01 00 00    	je     80799d <ip_frag+0x20b>
    LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_frag: pbuf_alloc(PBUF_LINK, 0, PBUF_REF) failed\n"));
    return ERR_MEM;
  }
  rambuf->tot_len = rambuf->len = mtu;
  8077cb:	66 89 70 0a          	mov    %si,0xa(%eax)
  8077cf:	66 89 70 08          	mov    %si,0x8(%eax)
  rambuf->payload = LWIP_MEM_ALIGN((void *)buf);
  8077d3:	b8 23 54 b3 00       	mov    $0xb35423,%eax
  8077d8:	83 e0 fc             	and    $0xfffffffc,%eax
  8077db:	89 c3                	mov    %eax,%ebx
  8077dd:	89 59 04             	mov    %ebx,0x4(%ecx)

  /* Copy the IP header in it */
  iphdr = rambuf->payload;
  SMEMCPY(iphdr, p->payload, IP_HLEN);
  8077e0:	c7 44 24 08 14 00 00 	movl   $0x14,0x8(%esp)
  8077e7:	00 
  8077e8:	8b 45 08             	mov    0x8(%ebp),%eax
  8077eb:	8b 40 04             	mov    0x4(%eax),%eax
  8077ee:	89 44 24 04          	mov    %eax,0x4(%esp)
  8077f2:	89 1c 24             	mov    %ebx,(%esp)
  8077f5:	e8 a2 81 00 00       	call   80f99c <memcpy>
  original_iphdr = p->payload;
  iphdr = original_iphdr;
#endif /* IP_FRAG_USES_STATIC_BUF */

  /* Save original offset */
  tmp = ntohs(IPH_OFFSET(iphdr));
  8077fa:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
  8077fe:	89 04 24             	mov    %eax,(%esp)
  807801:	e8 7d 05 00 00       	call   807d83 <ntohs>
  ofo = tmp & IP_OFFMASK;
  807806:	89 c1                	mov    %eax,%ecx
  807808:	66 81 e1 ff 1f       	and    $0x1fff,%cx
  80780d:	66 89 4d e0          	mov    %cx,-0x20(%ebp)
  omf = tmp & IP_MF;
  807811:	66 25 00 20          	and    $0x2000,%ax
  807815:	66 89 45 da          	mov    %ax,-0x26(%ebp)

  left = p->tot_len - IP_HLEN;
  807819:	8b 45 08             	mov    0x8(%ebp),%eax
  80781c:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  807820:	66 89 45 e6          	mov    %ax,-0x1a(%ebp)
  807824:	83 e8 14             	sub    $0x14,%eax
  807827:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)

  nfb = (mtu - IP_HLEN) / 8;
  80782b:	0f b7 d6             	movzwl %si,%edx
  80782e:	8d 42 f3             	lea    -0xd(%edx),%eax
  807831:	83 ea 14             	sub    $0x14,%edx
  807834:	89 55 d4             	mov    %edx,-0x2c(%ebp)
  807837:	0f 49 c2             	cmovns %edx,%eax
  80783a:	c1 f8 03             	sar    $0x3,%eax
  80783d:	66 89 45 d8          	mov    %ax,-0x28(%ebp)
  u16_t nfb;
  u16_t left, cop;
  u16_t mtu = netif->mtu;
  u16_t ofo, omf;
  u16_t last;
  u16_t poff = IP_HLEN;
  807841:	66 c7 45 e2 14 00    	movw   $0x14,-0x1e(%ebp)
    tmp = omf | (IP_OFFMASK & (ofo));
    if (!last)
      tmp = tmp | IP_MF;

    /* Fill this fragment */
    cop = last ? left : nfb * 8;
  807847:	c1 e0 03             	shl    $0x3,%eax
  80784a:	66 89 45 ce          	mov    %ax,-0x32(%ebp)

#if IP_FRAG_USES_STATIC_BUF
    poff += pbuf_copy_partial(p, (u8_t*)iphdr + IP_HLEN, cop, poff);
  80784e:	8d 43 14             	lea    0x14(%ebx),%eax
  807851:	89 45 d0             	mov    %eax,-0x30(%ebp)

  left = p->tot_len - IP_HLEN;

  nfb = (mtu - IP_HLEN) / 8;

  while (left) {
  807854:	e9 27 01 00 00       	jmp    807980 <ip_frag+0x1ee>
    last = (left <= mtu - IP_HLEN);
  807859:	0f b7 4d e4          	movzwl -0x1c(%ebp),%ecx
  80785d:	0f b7 c1             	movzwl %cx,%eax
  807860:	39 45 d4             	cmp    %eax,-0x2c(%ebp)
  807863:	0f 9d c0             	setge  %al
  807866:	0f b6 f0             	movzbl %al,%esi

    /* Set new offset and MF flag */
    tmp = omf | (IP_OFFMASK & (ofo));
  807869:	0f b7 7d e0          	movzwl -0x20(%ebp),%edi
  80786d:	66 81 e7 ff 1f       	and    $0x1fff,%di
  807872:	66 0b 7d da          	or     -0x26(%ebp),%di
    if (!last)
      tmp = tmp | IP_MF;

    /* Fill this fragment */
    cop = last ? left : nfb * 8;
  807876:	66 89 4d e6          	mov    %cx,-0x1a(%ebp)
  while (left) {
    last = (left <= mtu - IP_HLEN);

    /* Set new offset and MF flag */
    tmp = omf | (IP_OFFMASK & (ofo));
    if (!last)
  80787a:	66 85 f6             	test   %si,%si
  80787d:	75 0d                	jne    80788c <ip_frag+0xfa>
      tmp = tmp | IP_MF;
  80787f:	66 81 cf 00 20       	or     $0x2000,%di

    /* Fill this fragment */
    cop = last ? left : nfb * 8;
  807884:	0f b7 45 ce          	movzwl -0x32(%ebp),%eax
  807888:	66 89 45 e6          	mov    %ax,-0x1a(%ebp)

#if IP_FRAG_USES_STATIC_BUF
    poff += pbuf_copy_partial(p, (u8_t*)iphdr + IP_HLEN, cop, poff);
  80788c:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  807890:	89 44 24 0c          	mov    %eax,0xc(%esp)
  807894:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  807898:	89 44 24 08          	mov    %eax,0x8(%esp)
  80789c:	8b 55 d0             	mov    -0x30(%ebp),%edx
  80789f:	89 54 24 04          	mov    %edx,0x4(%esp)
  8078a3:	8b 55 08             	mov    0x8(%ebp),%edx
  8078a6:	89 14 24             	mov    %edx,(%esp)
  8078a9:	e8 f1 dc ff ff       	call   80559f <pbuf_copy_partial>
  8078ae:	66 01 45 e2          	add    %ax,-0x1e(%ebp)
    }
    poff = newpbuflen;
#endif /* IP_FRAG_USES_STATIC_BUF */

    /* Correct header */
    IPH_OFFSET_SET(iphdr, htons(tmp));
  8078b2:	0f b7 ff             	movzwl %di,%edi
  8078b5:	89 3c 24             	mov    %edi,(%esp)
  8078b8:	e8 b9 04 00 00       	call   807d76 <htons>
  8078bd:	66 89 43 06          	mov    %ax,0x6(%ebx)
    IPH_LEN_SET(iphdr, htons(cop + IP_HLEN));
  8078c1:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  8078c5:	83 c0 14             	add    $0x14,%eax
  8078c8:	0f b7 c0             	movzwl %ax,%eax
  8078cb:	89 04 24             	mov    %eax,(%esp)
  8078ce:	e8 a3 04 00 00       	call   807d76 <htons>
  8078d3:	66 89 43 02          	mov    %ax,0x2(%ebx)
    IPH_CHKSUM_SET(iphdr, 0);
  8078d7:	66 c7 43 0a 00 00    	movw   $0x0,0xa(%ebx)
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
  8078dd:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  8078e4:	00 
  8078e5:	89 1c 24             	mov    %ebx,(%esp)
  8078e8:	e8 34 03 00 00       	call   807c21 <inet_chksum>
  8078ed:	66 89 43 0a          	mov    %ax,0xa(%ebx)

#if IP_FRAG_USES_STATIC_BUF
    if (last)
  8078f1:	66 85 f6             	test   %si,%si
  8078f4:	74 19                	je     80790f <ip_frag+0x17d>
      pbuf_realloc(rambuf, left + IP_HLEN);
  8078f6:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  8078fa:	83 c0 14             	add    $0x14,%eax
  8078fd:	0f b7 c0             	movzwl %ax,%eax
  807900:	89 44 24 04          	mov    %eax,0x4(%esp)
  807904:	8b 45 dc             	mov    -0x24(%ebp),%eax
  807907:	89 04 24             	mov    %eax,(%esp)
  80790a:	e8 57 d8 ff ff       	call   805166 <pbuf_realloc>
    /* This part is ugly: we alloc a RAM based pbuf for 
     * the link level header for each chunk and then 
     * free it.A PBUF_ROM style pbuf for which pbuf_header
     * worked would make things simpler.
     */
    header = pbuf_alloc(PBUF_LINK, 0, PBUF_RAM);
  80790f:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  807916:	00 
  807917:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80791e:	00 
  80791f:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  807926:	e8 aa d5 ff ff       	call   804ed5 <pbuf_alloc>
  80792b:	89 c6                	mov    %eax,%esi
    if (header != NULL) {
  80792d:	85 c0                	test   %eax,%eax
  80792f:	74 3d                	je     80796e <ip_frag+0x1dc>
      pbuf_chain(header, rambuf);
  807931:	8b 45 dc             	mov    -0x24(%ebp),%eax
  807934:	89 44 24 04          	mov    %eax,0x4(%esp)
  807938:	89 34 24             	mov    %esi,(%esp)
  80793b:	e8 ea d9 ff ff       	call   80532a <pbuf_chain>
      netif->output(netif, header, dest);
  807940:	8b 45 10             	mov    0x10(%ebp),%eax
  807943:	89 44 24 08          	mov    %eax,0x8(%esp)
  807947:	89 74 24 04          	mov    %esi,0x4(%esp)
  80794b:	8b 45 0c             	mov    0xc(%ebp),%eax
  80794e:	89 04 24             	mov    %eax,(%esp)
  807951:	ff 50 14             	call   *0x14(%eax)
      IPFRAG_STATS_INC(ip_frag.xmit);
      snmp_inc_ipfragcreates();
      pbuf_free(header);
  807954:	89 34 24             	mov    %esi,(%esp)
  807957:	e8 98 d4 ff ff       	call   804df4 <pbuf_free>
     * there will be zero memory penalty.
     */
    
    pbuf_free(rambuf);
#endif /* IP_FRAG_USES_STATIC_BUF */
    left -= cop;
  80795c:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  807960:	66 29 45 e4          	sub    %ax,-0x1c(%ebp)
    ofo += nfb;
  807964:	0f b7 45 d8          	movzwl -0x28(%ebp),%eax
  807968:	66 01 45 e0          	add    %ax,-0x20(%ebp)
  80796c:	eb 12                	jmp    807980 <ip_frag+0x1ee>
      IPFRAG_STATS_INC(ip_frag.xmit);
      snmp_inc_ipfragcreates();
      pbuf_free(header);
    } else {
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_frag: pbuf_alloc() for header failed\n"));
      pbuf_free(rambuf);
  80796e:	8b 45 dc             	mov    -0x24(%ebp),%eax
  807971:	89 04 24             	mov    %eax,(%esp)
  807974:	e8 7b d4 ff ff       	call   804df4 <pbuf_free>
      return ERR_MEM;
  807979:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80797e:	eb 22                	jmp    8079a2 <ip_frag+0x210>

  left = p->tot_len - IP_HLEN;

  nfb = (mtu - IP_HLEN) / 8;

  while (left) {
  807980:	66 83 7d e4 00       	cmpw   $0x0,-0x1c(%ebp)
  807985:	0f 85 ce fe ff ff    	jne    807859 <ip_frag+0xc7>
#endif /* IP_FRAG_USES_STATIC_BUF */
    left -= cop;
    ofo += nfb;
  }
#if IP_FRAG_USES_STATIC_BUF
  pbuf_free(rambuf);
  80798b:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80798e:	89 04 24             	mov    %eax,(%esp)
  807991:	e8 5e d4 ff ff       	call   804df4 <pbuf_free>
#endif /* IP_FRAG_USES_STATIC_BUF */
  snmp_inc_ipfragoks();
  return ERR_OK;
  807996:	b8 00 00 00 00       	mov    $0x0,%eax
  80799b:	eb 05                	jmp    8079a2 <ip_frag+0x210>
   * Layer and length is irrelevant.
   */
  rambuf = pbuf_alloc(PBUF_LINK, 0, PBUF_REF);
  if (rambuf == NULL) {
    LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_frag: pbuf_alloc(PBUF_LINK, 0, PBUF_REF) failed\n"));
    return ERR_MEM;
  80799d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
#if IP_FRAG_USES_STATIC_BUF
  pbuf_free(rambuf);
#endif /* IP_FRAG_USES_STATIC_BUF */
  snmp_inc_ipfragoks();
  return ERR_OK;
}
  8079a2:	83 c4 3c             	add    $0x3c,%esp
  8079a5:	5b                   	pop    %ebx
  8079a6:	5e                   	pop    %esi
  8079a7:	5f                   	pop    %edi
  8079a8:	5d                   	pop    %ebp
  8079a9:	c3                   	ret    

008079aa <lwip_standard_chksum>:
 * @note accumulator size limits summable length to 64k
 * @note host endianess is irrelevant (p3 RFC1071)
 */
static u16_t
lwip_standard_chksum(void *dataptr, u16_t len)
{
  8079aa:	55                   	push   %ebp
  8079ab:	89 e5                	mov    %esp,%ebp
  8079ad:	57                   	push   %edi
  8079ae:	56                   	push   %esi
  8079af:	53                   	push   %ebx
  8079b0:	83 ec 1c             	sub    $0x1c,%esp
  8079b3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  u8_t *octetptr;

  acc = 0;
  /* dataptr may be at odd or even addresses */
  octetptr = (u8_t*)dataptr;
  while (len > 1) {
  8079b6:	89 d1                	mov    %edx,%ecx
{
  u32_t acc;
  u16_t src;
  u8_t *octetptr;

  acc = 0;
  8079b8:	bb 00 00 00 00       	mov    $0x0,%ebx
  /* dataptr may be at odd or even addresses */
  octetptr = (u8_t*)dataptr;
  while (len > 1) {
  8079bd:	eb 17                	jmp    8079d6 <lwip_standard_chksum+0x2c>
    /* declare first octet as most significant
       thus assume network order, ignoring host order */
    src = (*octetptr) << 8;
  8079bf:	0f b6 30             	movzbl (%eax),%esi
  8079c2:	c1 e6 08             	shl    $0x8,%esi
    octetptr++;
    /* declare second octet as least significant */
    src |= (*octetptr);
  8079c5:	0f b6 78 01          	movzbl 0x1(%eax),%edi
  8079c9:	09 fe                	or     %edi,%esi
  8079cb:	83 c0 02             	add    $0x2,%eax
    octetptr++;
    acc += src;
  8079ce:	0f b7 f6             	movzwl %si,%esi
  8079d1:	01 f3                	add    %esi,%ebx
    len -= 2;
  8079d3:	83 e9 02             	sub    $0x2,%ecx
  u8_t *octetptr;

  acc = 0;
  /* dataptr may be at odd or even addresses */
  octetptr = (u8_t*)dataptr;
  while (len > 1) {
  8079d6:	66 83 f9 01          	cmp    $0x1,%cx
  8079da:	77 e3                	ja     8079bf <lwip_standard_chksum+0x15>
  8079dc:	89 d0                	mov    %edx,%eax
  8079de:	66 d1 e8             	shr    %ax
  8079e1:	0f b7 c8             	movzwl %ax,%ecx
  8079e4:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  8079e7:	8d 0c 4f             	lea    (%edi,%ecx,2),%ecx
  8079ea:	f7 d8                	neg    %eax
  8079ec:	8d 14 42             	lea    (%edx,%eax,2),%edx
    src |= (*octetptr);
    octetptr++;
    acc += src;
    len -= 2;
  }
  if (len > 0) {
  8079ef:	66 85 d2             	test   %dx,%dx
  8079f2:	74 0b                	je     8079ff <lwip_standard_chksum+0x55>
    /* accumulate remaining octet */
    src = (*octetptr) << 8;
  8079f4:	0f b6 01             	movzbl (%ecx),%eax
  8079f7:	c1 e0 08             	shl    $0x8,%eax
    acc += src;
  8079fa:	0f b7 c0             	movzwl %ax,%eax
  8079fd:	01 c3                	add    %eax,%ebx
  }
  /* add deferred carry bits */
  acc = (acc >> 16) + (acc & 0x0000ffffUL);
  8079ff:	89 d8                	mov    %ebx,%eax
  807a01:	c1 e8 10             	shr    $0x10,%eax
  807a04:	0f b7 db             	movzwl %bx,%ebx
  807a07:	01 c3                	add    %eax,%ebx
  if ((acc & 0xffff0000) != 0) {
  807a09:	f7 c3 00 00 ff ff    	test   $0xffff0000,%ebx
  807a0f:	74 0a                	je     807a1b <lwip_standard_chksum+0x71>
    acc = (acc >> 16) + (acc & 0x0000ffffUL);
  807a11:	89 d8                	mov    %ebx,%eax
  807a13:	c1 e8 10             	shr    $0x10,%eax
  807a16:	0f b7 db             	movzwl %bx,%ebx
  807a19:	01 c3                	add    %eax,%ebx
  807a1b:	0f b7 db             	movzwl %bx,%ebx
  }
  /* This maybe a little confusing: reorder sum using htons()
     instead of ntohs() since it has a little less call overhead.
     The caller must invert bits for Internet sum ! */
  return htons((u16_t)acc);
  807a1e:	89 1c 24             	mov    %ebx,(%esp)
  807a21:	e8 50 03 00 00       	call   807d76 <htons>
}
  807a26:	83 c4 1c             	add    $0x1c,%esp
  807a29:	5b                   	pop    %ebx
  807a2a:	5e                   	pop    %esi
  807a2b:	5f                   	pop    %edi
  807a2c:	5d                   	pop    %ebp
  807a2d:	c3                   	ret    

00807a2e <inet_chksum_pseudo>:
 */
u16_t
inet_chksum_pseudo(struct pbuf *p,
       struct ip_addr *src, struct ip_addr *dest,
       u8_t proto, u16_t proto_len)
{
  807a2e:	55                   	push   %ebp
  807a2f:	89 e5                	mov    %esp,%ebp
  807a31:	57                   	push   %edi
  807a32:	56                   	push   %esi
  807a33:	53                   	push   %ebx
  807a34:	83 ec 1c             	sub    $0x1c,%esp
  807a37:	8b 5d 08             	mov    0x8(%ebp),%ebx
  807a3a:	8b 45 14             	mov    0x14(%ebp),%eax
  807a3d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  807a40:	8b 45 18             	mov    0x18(%ebp),%eax
  807a43:	89 45 e0             	mov    %eax,-0x20(%ebp)
  u32_t acc;
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  swapped = 0;
  807a46:	bf 00 00 00 00       	mov    $0x0,%edi
{
  u32_t acc;
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  807a4b:	be 00 00 00 00       	mov    $0x0,%esi
  swapped = 0;
  /* iterate through all pbuf in chain */
  for(q = p; q != NULL; q = q->next) {
  807a50:	eb 3d                	jmp    807a8f <inet_chksum_pseudo+0x61>
    LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): checksumming pbuf %p (has next %p) \n",
      (void *)q, (void *)q->next));
    acc += LWIP_CHKSUM(q->payload, q->len);
  807a52:	0f b7 53 0a          	movzwl 0xa(%ebx),%edx
  807a56:	8b 43 04             	mov    0x4(%ebx),%eax
  807a59:	e8 4c ff ff ff       	call   8079aa <lwip_standard_chksum>
  807a5e:	0f b7 c0             	movzwl %ax,%eax
  807a61:	01 c6                	add    %eax,%esi
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* just executing this next line is probably faster that the if statement needed
       to check whether we really need to execute it, and does no harm */
    acc = FOLD_U32T(acc);
  807a63:	89 f0                	mov    %esi,%eax
  807a65:	c1 e8 10             	shr    $0x10,%eax
  807a68:	0f b7 f6             	movzwl %si,%esi
  807a6b:	01 c6                	add    %eax,%esi
    if (q->len % 2 != 0) {
  807a6d:	f6 43 0a 01          	testb  $0x1,0xa(%ebx)
  807a71:	74 1a                	je     807a8d <inet_chksum_pseudo+0x5f>
      swapped = 1 - swapped;
  807a73:	b8 01 00 00 00       	mov    $0x1,%eax
  807a78:	89 f9                	mov    %edi,%ecx
  807a7a:	29 c8                	sub    %ecx,%eax
  807a7c:	89 c7                	mov    %eax,%edi
      acc = SWAP_BYTES_IN_WORD(acc);
  807a7e:	89 f0                	mov    %esi,%eax
  807a80:	c1 e0 08             	shl    $0x8,%eax
  807a83:	0f b7 c0             	movzwl %ax,%eax
  807a86:	89 f1                	mov    %esi,%ecx
  807a88:	0f b6 f5             	movzbl %ch,%esi
  807a8b:	09 c6                	or     %eax,%esi
  u8_t swapped;

  acc = 0;
  swapped = 0;
  /* iterate through all pbuf in chain */
  for(q = p; q != NULL; q = q->next) {
  807a8d:	8b 1b                	mov    (%ebx),%ebx
  807a8f:	85 db                	test   %ebx,%ebx
  807a91:	75 bf                	jne    807a52 <inet_chksum_pseudo+0x24>
      acc = SWAP_BYTES_IN_WORD(acc);
    }
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): wrapped lwip_chksum()=%"X32_F" \n", acc));*/
  }

  if (swapped) {
  807a93:	89 f8                	mov    %edi,%eax
  807a95:	84 c0                	test   %al,%al
  807a97:	74 0f                	je     807aa8 <inet_chksum_pseudo+0x7a>
    acc = SWAP_BYTES_IN_WORD(acc);
  807a99:	89 f0                	mov    %esi,%eax
  807a9b:	c1 e0 08             	shl    $0x8,%eax
  807a9e:	0f b7 c0             	movzwl %ax,%eax
  807aa1:	89 f1                	mov    %esi,%ecx
  807aa3:	0f b6 f5             	movzbl %ch,%esi
  807aa6:	09 c6                	or     %eax,%esi
  }
  acc += (src->addr & 0xffffUL);
  807aa8:	8b 45 0c             	mov    0xc(%ebp),%eax
  807aab:	8b 10                	mov    (%eax),%edx
  acc += ((src->addr >> 16) & 0xffffUL);
  acc += (dest->addr & 0xffffUL);
  807aad:	8b 45 10             	mov    0x10(%ebp),%eax
  807ab0:	8b 00                	mov    (%eax),%eax

  if (swapped) {
    acc = SWAP_BYTES_IN_WORD(acc);
  }
  acc += (src->addr & 0xffffUL);
  acc += ((src->addr >> 16) & 0xffffUL);
  807ab2:	89 d1                	mov    %edx,%ecx
  807ab4:	c1 e9 10             	shr    $0x10,%ecx
  }

  if (swapped) {
    acc = SWAP_BYTES_IN_WORD(acc);
  }
  acc += (src->addr & 0xffffUL);
  807ab7:	0f b7 d2             	movzwl %dx,%edx
  807aba:	01 ca                	add    %ecx,%edx
  acc += ((src->addr >> 16) & 0xffffUL);
  acc += (dest->addr & 0xffffUL);
  807abc:	0f b7 c8             	movzwl %ax,%ecx

  if (swapped) {
    acc = SWAP_BYTES_IN_WORD(acc);
  }
  acc += (src->addr & 0xffffUL);
  acc += ((src->addr >> 16) & 0xffffUL);
  807abf:	01 ca                	add    %ecx,%edx
  acc += (dest->addr & 0xffffUL);
  acc += ((dest->addr >> 16) & 0xffffUL);
  807ac1:	c1 e8 10             	shr    $0x10,%eax
  if (swapped) {
    acc = SWAP_BYTES_IN_WORD(acc);
  }
  acc += (src->addr & 0xffffUL);
  acc += ((src->addr >> 16) & 0xffffUL);
  acc += (dest->addr & 0xffffUL);
  807ac4:	01 d0                	add    %edx,%eax
  acc += ((dest->addr >> 16) & 0xffffUL);
  807ac6:	01 c6                	add    %eax,%esi
  acc += (u32_t)htons((u16_t)proto);
  807ac8:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
  807acc:	89 04 24             	mov    %eax,(%esp)
  807acf:	e8 a2 02 00 00       	call   807d76 <htons>
  807ad4:	0f b7 c0             	movzwl %ax,%eax
  807ad7:	01 c6                	add    %eax,%esi
  acc += (u32_t)htons(proto_len);
  807ad9:	0f b7 45 e0          	movzwl -0x20(%ebp),%eax
  807add:	89 04 24             	mov    %eax,(%esp)
  807ae0:	e8 91 02 00 00       	call   807d76 <htons>
  807ae5:	0f b7 c0             	movzwl %ax,%eax
  807ae8:	01 c6                	add    %eax,%esi

  /* Fold 32-bit sum to 16 bits
     calling this twice is propably faster than if statements... */
  acc = FOLD_U32T(acc);
  807aea:	89 f2                	mov    %esi,%edx
  807aec:	c1 ea 10             	shr    $0x10,%edx
  807aef:	0f b7 c6             	movzwl %si,%eax
  807af2:	01 d0                	add    %edx,%eax
  acc = FOLD_U32T(acc);
  807af4:	89 c2                	mov    %eax,%edx
  807af6:	c1 ea 10             	shr    $0x10,%edx
  807af9:	01 d0                	add    %edx,%eax
  LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%"X32_F"\n", acc));
  return (u16_t)~(acc & 0xffffUL);
  807afb:	f7 d0                	not    %eax
}
  807afd:	83 c4 1c             	add    $0x1c,%esp
  807b00:	5b                   	pop    %ebx
  807b01:	5e                   	pop    %esi
  807b02:	5f                   	pop    %edi
  807b03:	5d                   	pop    %ebp
  807b04:	c3                   	ret    

00807b05 <inet_chksum_pseudo_partial>:
 */
u16_t
inet_chksum_pseudo_partial(struct pbuf *p,
       struct ip_addr *src, struct ip_addr *dest,
       u8_t proto, u16_t proto_len, u16_t chksum_len)
{
  807b05:	55                   	push   %ebp
  807b06:	89 e5                	mov    %esp,%ebp
  807b08:	57                   	push   %edi
  807b09:	56                   	push   %esi
  807b0a:	53                   	push   %ebx
  807b0b:	83 ec 2c             	sub    $0x2c,%esp
  807b0e:	8b 75 08             	mov    0x8(%ebp),%esi
  807b11:	8b 45 14             	mov    0x14(%ebp),%eax
  807b14:	89 45 dc             	mov    %eax,-0x24(%ebp)
  807b17:	8b 45 18             	mov    0x18(%ebp),%eax
  807b1a:	89 45 d8             	mov    %eax,-0x28(%ebp)
  807b1d:	0f b7 5d 1c          	movzwl 0x1c(%ebp),%ebx
  struct pbuf *q;
  u8_t swapped;
  u16_t chklen;

  acc = 0;
  swapped = 0;
  807b21:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
  u32_t acc;
  struct pbuf *q;
  u8_t swapped;
  u16_t chklen;

  acc = 0;
  807b25:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  swapped = 0;
  /* iterate through all pbuf in chain */
  for(q = p; (q != NULL) && (chksum_len > 0); q = q->next) {
  807b2c:	eb 73                	jmp    807ba1 <inet_chksum_pseudo_partial+0x9c>
    LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): checksumming pbuf %p (has next %p) \n",
      (void *)q, (void *)q->next));
    chklen = q->len;
  807b2e:	0f b7 7e 0a          	movzwl 0xa(%esi),%edi
  807b32:	66 39 fb             	cmp    %di,%bx
  807b35:	0f 46 fb             	cmovbe %ebx,%edi
    if (chklen > chksum_len) {
      chklen = chksum_len;
    }
    acc += LWIP_CHKSUM(q->payload, chklen);
  807b38:	0f b7 d7             	movzwl %di,%edx
  807b3b:	8b 46 04             	mov    0x4(%esi),%eax
  807b3e:	e8 67 fe ff ff       	call   8079aa <lwip_standard_chksum>
  807b43:	0f b7 c0             	movzwl %ax,%eax
  807b46:	03 45 e4             	add    -0x1c(%ebp),%eax
    chksum_len -= chklen;
  807b49:	29 fb                	sub    %edi,%ebx
    LWIP_ASSERT("delete me", chksum_len < 0x7fff);
  807b4b:	66 81 fb fe 7f       	cmp    $0x7ffe,%bx
  807b50:	76 1c                	jbe    807b6e <inet_chksum_pseudo_partial+0x69>
  807b52:	c7 44 24 08 0d 2e 81 	movl   $0x812e0d,0x8(%esp)
  807b59:	00 
  807b5a:	c7 44 24 04 60 01 00 	movl   $0x160,0x4(%esp)
  807b61:	00 
  807b62:	c7 04 24 18 2e 81 00 	movl   $0x812e18,(%esp)
  807b69:	e8 0c 75 00 00       	call   80f07a <_panic>
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* fold the upper bit down */
    acc = FOLD_U32T(acc);
  807b6e:	89 c2                	mov    %eax,%edx
  807b70:	c1 ea 10             	shr    $0x10,%edx
  807b73:	0f b7 c0             	movzwl %ax,%eax
  807b76:	01 d0                	add    %edx,%eax
  807b78:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if (q->len % 2 != 0) {
  807b7b:	f6 46 0a 01          	testb  $0x1,0xa(%esi)
  807b7f:	74 1e                	je     807b9f <inet_chksum_pseudo_partial+0x9a>
      swapped = 1 - swapped;
  807b81:	b8 01 00 00 00       	mov    $0x1,%eax
  807b86:	2a 45 e3             	sub    -0x1d(%ebp),%al
  807b89:	88 45 e3             	mov    %al,-0x1d(%ebp)
      acc = SWAP_BYTES_IN_WORD(acc);
  807b8c:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  807b8f:	89 c8                	mov    %ecx,%eax
  807b91:	c1 e0 08             	shl    $0x8,%eax
  807b94:	0f b7 c0             	movzwl %ax,%eax
  807b97:	0f b6 d5             	movzbl %ch,%edx
  807b9a:	09 c2                	or     %eax,%edx
  807b9c:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  u16_t chklen;

  acc = 0;
  swapped = 0;
  /* iterate through all pbuf in chain */
  for(q = p; (q != NULL) && (chksum_len > 0); q = q->next) {
  807b9f:	8b 36                	mov    (%esi),%esi
  807ba1:	66 85 db             	test   %bx,%bx
  807ba4:	74 04                	je     807baa <inet_chksum_pseudo_partial+0xa5>
  807ba6:	85 f6                	test   %esi,%esi
  807ba8:	75 84                	jne    807b2e <inet_chksum_pseudo_partial+0x29>
      acc = SWAP_BYTES_IN_WORD(acc);
    }
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): wrapped lwip_chksum()=%"X32_F" \n", acc));*/
  }

  if (swapped) {
  807baa:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
  807bae:	74 13                	je     807bc3 <inet_chksum_pseudo_partial+0xbe>
    acc = SWAP_BYTES_IN_WORD(acc);
  807bb0:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  807bb3:	89 c8                	mov    %ecx,%eax
  807bb5:	c1 e0 08             	shl    $0x8,%eax
  807bb8:	0f b7 c0             	movzwl %ax,%eax
  807bbb:	0f b6 d5             	movzbl %ch,%edx
  807bbe:	09 c2                	or     %eax,%edx
  807bc0:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  }
  acc += (src->addr & 0xffffUL);
  807bc3:	8b 45 0c             	mov    0xc(%ebp),%eax
  807bc6:	8b 10                	mov    (%eax),%edx
  acc += ((src->addr >> 16) & 0xffffUL);
  acc += (dest->addr & 0xffffUL);
  807bc8:	8b 45 10             	mov    0x10(%ebp),%eax
  807bcb:	8b 00                	mov    (%eax),%eax

  if (swapped) {
    acc = SWAP_BYTES_IN_WORD(acc);
  }
  acc += (src->addr & 0xffffUL);
  acc += ((src->addr >> 16) & 0xffffUL);
  807bcd:	89 d1                	mov    %edx,%ecx
  807bcf:	c1 e9 10             	shr    $0x10,%ecx
  }

  if (swapped) {
    acc = SWAP_BYTES_IN_WORD(acc);
  }
  acc += (src->addr & 0xffffUL);
  807bd2:	0f b7 f2             	movzwl %dx,%esi
  807bd5:	01 ce                	add    %ecx,%esi
  acc += ((src->addr >> 16) & 0xffffUL);
  acc += (dest->addr & 0xffffUL);
  807bd7:	0f b7 c8             	movzwl %ax,%ecx

  if (swapped) {
    acc = SWAP_BYTES_IN_WORD(acc);
  }
  acc += (src->addr & 0xffffUL);
  acc += ((src->addr >> 16) & 0xffffUL);
  807bda:	01 ce                	add    %ecx,%esi
  acc += (dest->addr & 0xffffUL);
  acc += ((dest->addr >> 16) & 0xffffUL);
  807bdc:	c1 e8 10             	shr    $0x10,%eax
  if (swapped) {
    acc = SWAP_BYTES_IN_WORD(acc);
  }
  acc += (src->addr & 0xffffUL);
  acc += ((src->addr >> 16) & 0xffffUL);
  acc += (dest->addr & 0xffffUL);
  807bdf:	01 c6                	add    %eax,%esi
  acc += ((dest->addr >> 16) & 0xffffUL);
  807be1:	03 75 e4             	add    -0x1c(%ebp),%esi
  acc += (u32_t)htons((u16_t)proto);
  807be4:	0f b6 45 dc          	movzbl -0x24(%ebp),%eax
  807be8:	89 04 24             	mov    %eax,(%esp)
  807beb:	e8 86 01 00 00       	call   807d76 <htons>
  807bf0:	0f b7 d8             	movzwl %ax,%ebx
  807bf3:	01 f3                	add    %esi,%ebx
  acc += (u32_t)htons(proto_len);
  807bf5:	0f b7 45 d8          	movzwl -0x28(%ebp),%eax
  807bf9:	89 04 24             	mov    %eax,(%esp)
  807bfc:	e8 75 01 00 00       	call   807d76 <htons>
  807c01:	0f b7 d0             	movzwl %ax,%edx
  807c04:	01 da                	add    %ebx,%edx

  /* Fold 32-bit sum to 16 bits
     calling this twice is propably faster than if statements... */
  acc = FOLD_U32T(acc);
  807c06:	89 d0                	mov    %edx,%eax
  807c08:	c1 e8 10             	shr    $0x10,%eax
  807c0b:	0f b7 d2             	movzwl %dx,%edx
  807c0e:	01 d0                	add    %edx,%eax
  acc = FOLD_U32T(acc);
  807c10:	89 c2                	mov    %eax,%edx
  807c12:	c1 ea 10             	shr    $0x10,%edx
  807c15:	01 d0                	add    %edx,%eax
  LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%"X32_F"\n", acc));
  return (u16_t)~(acc & 0xffffUL);
  807c17:	f7 d0                	not    %eax
}
  807c19:	83 c4 2c             	add    $0x2c,%esp
  807c1c:	5b                   	pop    %ebx
  807c1d:	5e                   	pop    %esi
  807c1e:	5f                   	pop    %edi
  807c1f:	5d                   	pop    %ebp
  807c20:	c3                   	ret    

00807c21 <inet_chksum>:
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */

u16_t
inet_chksum(void *dataptr, u16_t len)
{
  807c21:	55                   	push   %ebp
  807c22:	89 e5                	mov    %esp,%ebp
  807c24:	83 ec 08             	sub    $0x8,%esp
  return ~LWIP_CHKSUM(dataptr, len);
  807c27:	0f b7 55 0c          	movzwl 0xc(%ebp),%edx
  807c2b:	8b 45 08             	mov    0x8(%ebp),%eax
  807c2e:	e8 77 fd ff ff       	call   8079aa <lwip_standard_chksum>
  807c33:	f7 d0                	not    %eax
}
  807c35:	c9                   	leave  
  807c36:	c3                   	ret    

00807c37 <inet_chksum_pbuf>:
 * @param p pbuf chain over that the checksum should be calculated
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */
u16_t
inet_chksum_pbuf(struct pbuf *p)
{
  807c37:	55                   	push   %ebp
  807c38:	89 e5                	mov    %esp,%ebp
  807c3a:	57                   	push   %edi
  807c3b:	56                   	push   %esi
  807c3c:	53                   	push   %ebx
  807c3d:	83 ec 0c             	sub    $0xc,%esp
  807c40:	8b 5d 08             	mov    0x8(%ebp),%ebx
  u32_t acc;
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  swapped = 0;
  807c43:	bf 00 00 00 00       	mov    $0x0,%edi
{
  u32_t acc;
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  807c48:	be 00 00 00 00       	mov    $0x0,%esi
  swapped = 0;
  for(q = p; q != NULL; q = q->next) {
  807c4d:	eb 3d                	jmp    807c8c <inet_chksum_pbuf+0x55>
    acc += LWIP_CHKSUM(q->payload, q->len);
  807c4f:	0f b7 53 0a          	movzwl 0xa(%ebx),%edx
  807c53:	8b 43 04             	mov    0x4(%ebx),%eax
  807c56:	e8 4f fd ff ff       	call   8079aa <lwip_standard_chksum>
  807c5b:	0f b7 c0             	movzwl %ax,%eax
  807c5e:	01 c6                	add    %eax,%esi
    acc = FOLD_U32T(acc);
  807c60:	89 f0                	mov    %esi,%eax
  807c62:	c1 e8 10             	shr    $0x10,%eax
  807c65:	0f b7 f6             	movzwl %si,%esi
  807c68:	01 c6                	add    %eax,%esi
    if (q->len % 2 != 0) {
  807c6a:	f6 43 0a 01          	testb  $0x1,0xa(%ebx)
  807c6e:	74 1a                	je     807c8a <inet_chksum_pbuf+0x53>
      swapped = 1 - swapped;
  807c70:	b8 01 00 00 00       	mov    $0x1,%eax
  807c75:	89 f9                	mov    %edi,%ecx
  807c77:	29 c8                	sub    %ecx,%eax
  807c79:	89 c7                	mov    %eax,%edi
      acc = SWAP_BYTES_IN_WORD(acc);
  807c7b:	89 f0                	mov    %esi,%eax
  807c7d:	c1 e0 08             	shl    $0x8,%eax
  807c80:	0f b7 c0             	movzwl %ax,%eax
  807c83:	89 f1                	mov    %esi,%ecx
  807c85:	0f b6 f5             	movzbl %ch,%esi
  807c88:	09 c6                	or     %eax,%esi
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  swapped = 0;
  for(q = p; q != NULL; q = q->next) {
  807c8a:	8b 1b                	mov    (%ebx),%ebx
  807c8c:	85 db                	test   %ebx,%ebx
  807c8e:	75 bf                	jne    807c4f <inet_chksum_pbuf+0x18>
      swapped = 1 - swapped;
      acc = SWAP_BYTES_IN_WORD(acc);
    }
  }

  if (swapped) {
  807c90:	89 f8                	mov    %edi,%eax
  807c92:	84 c0                	test   %al,%al
  807c94:	74 0f                	je     807ca5 <inet_chksum_pbuf+0x6e>
    acc = SWAP_BYTES_IN_WORD(acc);
  807c96:	89 f0                	mov    %esi,%eax
  807c98:	c1 e0 08             	shl    $0x8,%eax
  807c9b:	0f b7 c0             	movzwl %ax,%eax
  807c9e:	89 f1                	mov    %esi,%ecx
  807ca0:	0f b6 f5             	movzbl %ch,%esi
  807ca3:	09 c6                	or     %eax,%esi
  }
  return (u16_t)~(acc & 0xffffUL);
  807ca5:	89 f0                	mov    %esi,%eax
  807ca7:	f7 d0                	not    %eax
}
  807ca9:	83 c4 0c             	add    $0xc,%esp
  807cac:	5b                   	pop    %ebx
  807cad:	5e                   	pop    %esi
  807cae:	5f                   	pop    %edi
  807caf:	5d                   	pop    %ebp
  807cb0:	c3                   	ret    
  807cb1:	66 90                	xchg   %ax,%ax
  807cb3:	66 90                	xchg   %ax,%ax
  807cb5:	66 90                	xchg   %ax,%ax
  807cb7:	66 90                	xchg   %ax,%ax
  807cb9:	66 90                	xchg   %ax,%ax
  807cbb:	66 90                	xchg   %ax,%ax
  807cbd:	66 90                	xchg   %ax,%ax
  807cbf:	90                   	nop

00807cc0 <inet_ntoa>:
 * @return pointer to a global static (!) buffer that holds the ASCII
 *         represenation of addr
 */
char *
inet_ntoa(struct in_addr addr)
{
  807cc0:	55                   	push   %ebp
  807cc1:	89 e5                	mov    %esp,%ebp
  807cc3:	57                   	push   %edi
  807cc4:	56                   	push   %esi
  807cc5:	53                   	push   %ebx
  807cc6:	83 ec 19             	sub    $0x19,%esp
  static char str[16];
  u32_t s_addr = addr.s_addr;
  807cc9:	8b 45 08             	mov    0x8(%ebp),%eax
  807ccc:	89 45 f0             	mov    %eax,-0x10(%ebp)
  u8_t n;
  u8_t i;

  rp = str;
  ap = (u8_t *)&s_addr;
  for(n = 0; n < 4; n++) {
  807ccf:	c6 45 db 00          	movb   $0x0,-0x25(%ebp)
  u8_t rem;
  u8_t n;
  u8_t i;

  rp = str;
  ap = (u8_t *)&s_addr;
  807cd3:	8d 5d f0             	lea    -0x10(%ebp),%ebx
  u8_t *ap;
  u8_t rem;
  u8_t n;
  u8_t i;

  rp = str;
  807cd6:	c7 45 dc 04 5a b3 00 	movl   $0xb35a04,-0x24(%ebp)
 */
char *
inet_ntoa(struct in_addr addr)
{
  static char str[16];
  u32_t s_addr = addr.s_addr;
  807cdd:	be 00 00 00 00       	mov    $0x0,%esi
  807ce2:	89 5d e0             	mov    %ebx,-0x20(%ebp)
  807ce5:	eb 02                	jmp    807ce9 <inet_ntoa+0x29>
      *ap /= (u8_t)10;
      inv[i++] = '0' + rem;
    } while(*ap);
    while(i--)
      *rp++ = inv[i];
    *rp++ = '.';
  807ce7:	89 ce                	mov    %ecx,%esi
  rp = str;
  ap = (u8_t *)&s_addr;
  for(n = 0; n < 4; n++) {
    i = 0;
    do {
      rem = *ap % (u8_t)10;
  807ce9:	8b 7d e0             	mov    -0x20(%ebp),%edi
  807cec:	0f b6 17             	movzbl (%edi),%edx
      *ap /= (u8_t)10;
  807cef:	0f b6 c2             	movzbl %dl,%eax
  807cf2:	8d 0c 80             	lea    (%eax,%eax,4),%ecx
  807cf5:	8d 04 c8             	lea    (%eax,%ecx,8),%eax
  807cf8:	8d 04 80             	lea    (%eax,%eax,4),%eax
  807cfb:	66 c1 e8 0b          	shr    $0xb,%ax
  807cff:	88 07                	mov    %al,(%edi)
      inv[i++] = '0' + rem;
  807d01:	8d 4e 01             	lea    0x1(%esi),%ecx
  807d04:	89 f3                	mov    %esi,%ebx
  807d06:	0f b6 f3             	movzbl %bl,%esi
  rp = str;
  ap = (u8_t *)&s_addr;
  for(n = 0; n < 4; n++) {
    i = 0;
    do {
      rem = *ap % (u8_t)10;
  807d09:	8d 3c 80             	lea    (%eax,%eax,4),%edi
  807d0c:	01 ff                	add    %edi,%edi
  807d0e:	89 fb                	mov    %edi,%ebx
  807d10:	29 da                	sub    %ebx,%edx
      *ap /= (u8_t)10;
      inv[i++] = '0' + rem;
  807d12:	83 c2 30             	add    $0x30,%edx
  807d15:	88 54 35 ed          	mov    %dl,-0x13(%ebp,%esi,1)
    } while(*ap);
  807d19:	84 c0                	test   %al,%al
  807d1b:	75 ca                	jne    807ce7 <inet_ntoa+0x27>
  807d1d:	8b 55 dc             	mov    -0x24(%ebp),%edx
  807d20:	89 c8                	mov    %ecx,%eax
  807d22:	8b 5d e0             	mov    -0x20(%ebp),%ebx
  807d25:	89 cf                	mov    %ecx,%edi
  807d27:	eb 0d                	jmp    807d36 <inet_ntoa+0x76>
    while(i--)
      *rp++ = inv[i];
  807d29:	0f b6 f0             	movzbl %al,%esi
  807d2c:	0f b6 4c 35 ed       	movzbl -0x13(%ebp,%esi,1),%ecx
  807d31:	88 0a                	mov    %cl,(%edx)
  807d33:	83 c2 01             	add    $0x1,%edx
    do {
      rem = *ap % (u8_t)10;
      *ap /= (u8_t)10;
      inv[i++] = '0' + rem;
    } while(*ap);
    while(i--)
  807d36:	83 e8 01             	sub    $0x1,%eax
  807d39:	3c ff                	cmp    $0xff,%al
  807d3b:	75 ec                	jne    807d29 <inet_ntoa+0x69>
  807d3d:	89 5d e0             	mov    %ebx,-0x20(%ebp)
  807d40:	89 f9                	mov    %edi,%ecx
  807d42:	0f b6 c9             	movzbl %cl,%ecx
  807d45:	03 4d dc             	add    -0x24(%ebp),%ecx
      *rp++ = inv[i];
    *rp++ = '.';
  807d48:	8d 41 01             	lea    0x1(%ecx),%eax
  807d4b:	89 45 dc             	mov    %eax,-0x24(%ebp)
    ap++;
  807d4e:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
  u8_t n;
  u8_t i;

  rp = str;
  ap = (u8_t *)&s_addr;
  for(n = 0; n < 4; n++) {
  807d52:	80 45 db 01          	addb   $0x1,-0x25(%ebp)
  807d56:	80 7d db 03          	cmpb   $0x3,-0x25(%ebp)
  807d5a:	77 0a                	ja     807d66 <inet_ntoa+0xa6>
      *ap /= (u8_t)10;
      inv[i++] = '0' + rem;
    } while(*ap);
    while(i--)
      *rp++ = inv[i];
    *rp++ = '.';
  807d5c:	c6 01 2e             	movb   $0x2e,(%ecx)
  807d5f:	b9 00 00 00 00       	mov    $0x0,%ecx
  807d64:	eb 81                	jmp    807ce7 <inet_ntoa+0x27>
    ap++;
  }
  *--rp = 0;
  807d66:	c6 01 00             	movb   $0x0,(%ecx)
  return str;
}
  807d69:	b8 04 5a b3 00       	mov    $0xb35a04,%eax
  807d6e:	83 c4 19             	add    $0x19,%esp
  807d71:	5b                   	pop    %ebx
  807d72:	5e                   	pop    %esi
  807d73:	5f                   	pop    %edi
  807d74:	5d                   	pop    %ebp
  807d75:	c3                   	ret    

00807d76 <htons>:
 * @param n u16_t in host byte order
 * @return n in network byte order
 */
u16_t
htons(u16_t n)
{
  807d76:	55                   	push   %ebp
  807d77:	89 e5                	mov    %esp,%ebp
  return ((n & 0xff) << 8) | ((n & 0xff00) >> 8);
  807d79:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
  807d7d:	66 c1 c0 08          	rol    $0x8,%ax
}
  807d81:	5d                   	pop    %ebp
  807d82:	c3                   	ret    

00807d83 <ntohs>:
 * @param n u16_t in network byte order
 * @return n in host byte order
 */
u16_t
ntohs(u16_t n)
{
  807d83:	55                   	push   %ebp
  807d84:	89 e5                	mov    %esp,%ebp
 * @return n in network byte order
 */
u16_t
htons(u16_t n)
{
  return ((n & 0xff) << 8) | ((n & 0xff00) >> 8);
  807d86:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
  807d8a:	66 c1 c0 08          	rol    $0x8,%ax
 */
u16_t
ntohs(u16_t n)
{
  return htons(n);
}
  807d8e:	5d                   	pop    %ebp
  807d8f:	c3                   	ret    

00807d90 <htonl>:
 * @param n u32_t in host byte order
 * @return n in network byte order
 */
u32_t
htonl(u32_t n)
{
  807d90:	55                   	push   %ebp
  807d91:	89 e5                	mov    %esp,%ebp
  807d93:	8b 55 08             	mov    0x8(%ebp),%edx
  return ((n & 0xff) << 24) |
    ((n & 0xff00) << 8) |
    ((n & 0xff0000UL) >> 8) |
    ((n & 0xff000000UL) >> 24);
  807d96:	89 d1                	mov    %edx,%ecx
  807d98:	c1 e9 18             	shr    $0x18,%ecx
 * @return n in network byte order
 */
u32_t
htonl(u32_t n)
{
  return ((n & 0xff) << 24) |
  807d9b:	89 d0                	mov    %edx,%eax
  807d9d:	c1 e0 18             	shl    $0x18,%eax
  807da0:	09 c8                	or     %ecx,%eax
    ((n & 0xff00) << 8) |
  807da2:	89 d1                	mov    %edx,%ecx
  807da4:	81 e1 00 ff 00 00    	and    $0xff00,%ecx
  807daa:	c1 e1 08             	shl    $0x8,%ecx
  807dad:	09 c8                	or     %ecx,%eax
    ((n & 0xff0000UL) >> 8) |
  807daf:	81 e2 00 00 ff 00    	and    $0xff0000,%edx
  807db5:	c1 ea 08             	shr    $0x8,%edx
 * @return n in network byte order
 */
u32_t
htonl(u32_t n)
{
  return ((n & 0xff) << 24) |
  807db8:	09 d0                	or     %edx,%eax
    ((n & 0xff00) << 8) |
    ((n & 0xff0000UL) >> 8) |
    ((n & 0xff000000UL) >> 24);
}
  807dba:	5d                   	pop    %ebp
  807dbb:	c3                   	ret    

00807dbc <inet_aton>:
 * @param addr pointer to which to save the ip address in network order
 * @return 1 if cp could be converted to addr, 0 on failure
 */
int
inet_aton(const char *cp, struct in_addr *addr)
{
  807dbc:	55                   	push   %ebp
  807dbd:	89 e5                	mov    %esp,%ebp
  807dbf:	57                   	push   %edi
  807dc0:	56                   	push   %esi
  807dc1:	53                   	push   %ebx
  807dc2:	83 ec 20             	sub    $0x20,%esp
  807dc5:	8b 45 08             	mov    0x8(%ebp),%eax
  u32_t val;
  int base, n, c;
  u32_t parts[4];
  u32_t *pp = parts;

  c = *cp;
  807dc8:	0f be 10             	movsbl (%eax),%edx
inet_aton(const char *cp, struct in_addr *addr)
{
  u32_t val;
  int base, n, c;
  u32_t parts[4];
  u32_t *pp = parts;
  807dcb:	8d 75 e4             	lea    -0x1c(%ebp),%esi
  807dce:	89 75 d8             	mov    %esi,-0x28(%ebp)
    /*
     * Collect number up to ``.''.
     * Values are specified as for C:
     * 0x=hex, 0=octal, 1-9=decimal.
     */
    if (!isdigit(c))
  807dd1:	8d 4a d0             	lea    -0x30(%edx),%ecx
  807dd4:	80 f9 09             	cmp    $0x9,%cl
  807dd7:	0f 87 a6 01 00 00    	ja     807f83 <inet_aton+0x1c7>
      return (0);
    val = 0;
    base = 10;
  807ddd:	c7 45 e0 0a 00 00 00 	movl   $0xa,-0x20(%ebp)
    if (c == '0') {
  807de4:	83 fa 30             	cmp    $0x30,%edx
  807de7:	75 2b                	jne    807e14 <inet_aton+0x58>
      c = *++cp;
  807de9:	0f b6 50 01          	movzbl 0x1(%eax),%edx
      if (c == 'x' || c == 'X') {
  807ded:	89 d1                	mov    %edx,%ecx
  807def:	83 e1 df             	and    $0xffffffdf,%ecx
  807df2:	80 f9 58             	cmp    $0x58,%cl
  807df5:	74 0f                	je     807e06 <inet_aton+0x4a>
    if (!isdigit(c))
      return (0);
    val = 0;
    base = 10;
    if (c == '0') {
      c = *++cp;
  807df7:	83 c0 01             	add    $0x1,%eax
  807dfa:	0f be d2             	movsbl %dl,%edx
      if (c == 'x' || c == 'X') {
        base = 16;
        c = *++cp;
      } else
        base = 8;
  807dfd:	c7 45 e0 08 00 00 00 	movl   $0x8,-0x20(%ebp)
  807e04:	eb 0e                	jmp    807e14 <inet_aton+0x58>
    base = 10;
    if (c == '0') {
      c = *++cp;
      if (c == 'x' || c == 'X') {
        base = 16;
        c = *++cp;
  807e06:	0f be 50 02          	movsbl 0x2(%eax),%edx
  807e0a:	8d 40 02             	lea    0x2(%eax),%eax
    val = 0;
    base = 10;
    if (c == '0') {
      c = *++cp;
      if (c == 'x' || c == 'X') {
        base = 16;
  807e0d:	c7 45 e0 10 00 00 00 	movl   $0x10,-0x20(%ebp)
  807e14:	83 c0 01             	add    $0x1,%eax
  807e17:	bf 00 00 00 00       	mov    $0x0,%edi
  807e1c:	eb 03                	jmp    807e21 <inet_aton+0x65>
  807e1e:	83 c0 01             	add    $0x1,%eax
  807e21:	8d 70 ff             	lea    -0x1(%eax),%esi
        c = *++cp;
      } else
        base = 8;
    }
    for (;;) {
      if (isdigit(c)) {
  807e24:	89 d3                	mov    %edx,%ebx
  807e26:	8d 4a d0             	lea    -0x30(%edx),%ecx
  807e29:	80 f9 09             	cmp    $0x9,%cl
  807e2c:	77 0d                	ja     807e3b <inet_aton+0x7f>
        val = (val * base) + (int)(c - '0');
  807e2e:	0f af 7d e0          	imul   -0x20(%ebp),%edi
  807e32:	8d 7c 3a d0          	lea    -0x30(%edx,%edi,1),%edi
        c = *++cp;
  807e36:	0f be 10             	movsbl (%eax),%edx
  807e39:	eb e3                	jmp    807e1e <inet_aton+0x62>
      } else if (base == 16 && isxdigit(c)) {
  807e3b:	83 7d e0 10          	cmpl   $0x10,-0x20(%ebp)
  807e3f:	75 30                	jne    807e71 <inet_aton+0xb5>
  807e41:	8d 4b 9f             	lea    -0x61(%ebx),%ecx
  807e44:	88 4d df             	mov    %cl,-0x21(%ebp)
  807e47:	89 d1                	mov    %edx,%ecx
  807e49:	83 e1 df             	and    $0xffffffdf,%ecx
  807e4c:	83 e9 41             	sub    $0x41,%ecx
  807e4f:	80 f9 05             	cmp    $0x5,%cl
  807e52:	77 23                	ja     807e77 <inet_aton+0xbb>
        val = (val << 4) | (int)(c + 10 - (islower(c) ? 'a' : 'A'));
  807e54:	89 fb                	mov    %edi,%ebx
  807e56:	c1 e3 04             	shl    $0x4,%ebx
  807e59:	8d 7a 0a             	lea    0xa(%edx),%edi
  807e5c:	80 7d df 1a          	cmpb   $0x1a,-0x21(%ebp)
  807e60:	19 c9                	sbb    %ecx,%ecx
  807e62:	83 e1 20             	and    $0x20,%ecx
  807e65:	83 c1 41             	add    $0x41,%ecx
  807e68:	29 cf                	sub    %ecx,%edi
  807e6a:	09 df                	or     %ebx,%edi
        c = *++cp;
  807e6c:	0f be 10             	movsbl (%eax),%edx
  807e6f:	eb ad                	jmp    807e1e <inet_aton+0x62>
  807e71:	89 d0                	mov    %edx,%eax
  807e73:	89 f9                	mov    %edi,%ecx
  807e75:	eb 04                	jmp    807e7b <inet_aton+0xbf>
  807e77:	89 d0                	mov    %edx,%eax
  807e79:	89 f9                	mov    %edi,%ecx
      } else
        break;
    }
    if (c == '.') {
  807e7b:	83 f8 2e             	cmp    $0x2e,%eax
  807e7e:	75 22                	jne    807ea2 <inet_aton+0xe6>
       * Internet format:
       *  a.b.c.d
       *  a.b.c   (with c treated as 16 bits)
       *  a.b (with b treated as 24 bits)
       */
      if (pp >= parts + 3)
  807e80:	8d 45 f0             	lea    -0x10(%ebp),%eax
  807e83:	39 45 d8             	cmp    %eax,-0x28(%ebp)
  807e86:	0f 84 fe 00 00 00    	je     807f8a <inet_aton+0x1ce>
        return (0);
      *pp++ = val;
  807e8c:	83 45 d8 04          	addl   $0x4,-0x28(%ebp)
  807e90:	8b 45 d8             	mov    -0x28(%ebp),%eax
  807e93:	89 48 fc             	mov    %ecx,-0x4(%eax)
      c = *++cp;
  807e96:	8d 46 01             	lea    0x1(%esi),%eax
  807e99:	0f be 56 01          	movsbl 0x1(%esi),%edx
    } else
      break;
  }
  807e9d:	e9 2f ff ff ff       	jmp    807dd1 <inet_aton+0x15>
  807ea2:	89 f9                	mov    %edi,%ecx
  /*
   * Check for trailing characters.
   */
  if (c != '\0' && (!isprint(c) || !isspace(c)))
  807ea4:	85 d2                	test   %edx,%edx
  807ea6:	74 27                	je     807ecf <inet_aton+0x113>
    return (0);
  807ea8:	b8 00 00 00 00       	mov    $0x0,%eax
      break;
  }
  /*
   * Check for trailing characters.
   */
  if (c != '\0' && (!isprint(c) || !isspace(c)))
  807ead:	80 fb 1f             	cmp    $0x1f,%bl
  807eb0:	0f 86 e7 00 00 00    	jbe    807f9d <inet_aton+0x1e1>
  807eb6:	84 d2                	test   %dl,%dl
  807eb8:	0f 88 d3 00 00 00    	js     807f91 <inet_aton+0x1d5>
  807ebe:	83 fa 20             	cmp    $0x20,%edx
  807ec1:	74 0c                	je     807ecf <inet_aton+0x113>
  807ec3:	83 ea 09             	sub    $0x9,%edx
  807ec6:	83 fa 04             	cmp    $0x4,%edx
  807ec9:	0f 87 ce 00 00 00    	ja     807f9d <inet_aton+0x1e1>
    return (0);
  /*
   * Concoct the address according to
   * the number of parts specified.
   */
  n = pp - parts + 1;
  807ecf:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  807ed2:	8b 55 d8             	mov    -0x28(%ebp),%edx
  807ed5:	29 c2                	sub    %eax,%edx
  807ed7:	c1 fa 02             	sar    $0x2,%edx
  807eda:	83 c2 01             	add    $0x1,%edx
  switch (n) {
  807edd:	83 fa 02             	cmp    $0x2,%edx
  807ee0:	74 22                	je     807f04 <inet_aton+0x148>
  807ee2:	83 fa 02             	cmp    $0x2,%edx
  807ee5:	7f 0f                	jg     807ef6 <inet_aton+0x13a>

  case 0:
    return (0);       /* initial nondigit */
  807ee7:	b8 00 00 00 00       	mov    $0x0,%eax
  /*
   * Concoct the address according to
   * the number of parts specified.
   */
  n = pp - parts + 1;
  switch (n) {
  807eec:	85 d2                	test   %edx,%edx
  807eee:	0f 84 a9 00 00 00    	je     807f9d <inet_aton+0x1e1>
  807ef4:	eb 73                	jmp    807f69 <inet_aton+0x1ad>
  807ef6:	83 fa 03             	cmp    $0x3,%edx
  807ef9:	74 26                	je     807f21 <inet_aton+0x165>
  807efb:	83 fa 04             	cmp    $0x4,%edx
  807efe:	66 90                	xchg   %ax,%ax
  807f00:	74 40                	je     807f42 <inet_aton+0x186>
  807f02:	eb 65                	jmp    807f69 <inet_aton+0x1ad>
  case 1:             /* a -- 32 bits */
    break;

  case 2:             /* a.b -- 8.24 bits */
    if (val > 0xffffffUL)
      return (0);
  807f04:	b8 00 00 00 00       	mov    $0x0,%eax

  case 1:             /* a -- 32 bits */
    break;

  case 2:             /* a.b -- 8.24 bits */
    if (val > 0xffffffUL)
  807f09:	81 f9 ff ff ff 00    	cmp    $0xffffff,%ecx
  807f0f:	0f 87 88 00 00 00    	ja     807f9d <inet_aton+0x1e1>
      return (0);
    val |= parts[0] << 24;
  807f15:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  807f18:	c1 e0 18             	shl    $0x18,%eax
  807f1b:	89 cf                	mov    %ecx,%edi
  807f1d:	09 c7                	or     %eax,%edi
    break;
  807f1f:	eb 48                	jmp    807f69 <inet_aton+0x1ad>

  case 3:             /* a.b.c -- 8.8.16 bits */
    if (val > 0xffff)
      return (0);
  807f21:	b8 00 00 00 00       	mov    $0x0,%eax
      return (0);
    val |= parts[0] << 24;
    break;

  case 3:             /* a.b.c -- 8.8.16 bits */
    if (val > 0xffff)
  807f26:	81 f9 ff ff 00 00    	cmp    $0xffff,%ecx
  807f2c:	77 6f                	ja     807f9d <inet_aton+0x1e1>
      return (0);
    val |= (parts[0] << 24) | (parts[1] << 16);
  807f2e:	8b 55 e8             	mov    -0x18(%ebp),%edx
  807f31:	c1 e2 10             	shl    $0x10,%edx
  807f34:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  807f37:	c1 e0 18             	shl    $0x18,%eax
  807f3a:	09 d0                	or     %edx,%eax
  807f3c:	09 c8                	or     %ecx,%eax
  807f3e:	89 c7                	mov    %eax,%edi
    break;
  807f40:	eb 27                	jmp    807f69 <inet_aton+0x1ad>

  case 4:             /* a.b.c.d -- 8.8.8.8 bits */
    if (val > 0xff)
      return (0);
  807f42:	b8 00 00 00 00       	mov    $0x0,%eax
      return (0);
    val |= (parts[0] << 24) | (parts[1] << 16);
    break;

  case 4:             /* a.b.c.d -- 8.8.8.8 bits */
    if (val > 0xff)
  807f47:	81 f9 ff 00 00 00    	cmp    $0xff,%ecx
  807f4d:	77 4e                	ja     807f9d <inet_aton+0x1e1>
      return (0);
    val |= (parts[0] << 24) | (parts[1] << 16) | (parts[2] << 8);
  807f4f:	8b 55 e8             	mov    -0x18(%ebp),%edx
  807f52:	c1 e2 10             	shl    $0x10,%edx
  807f55:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  807f58:	c1 e0 18             	shl    $0x18,%eax
  807f5b:	09 c2                	or     %eax,%edx
  807f5d:	8b 45 ec             	mov    -0x14(%ebp),%eax
  807f60:	c1 e0 08             	shl    $0x8,%eax
  807f63:	09 d0                	or     %edx,%eax
  807f65:	09 c8                	or     %ecx,%eax
  807f67:	89 c7                	mov    %eax,%edi
    break;
  }
  if (addr)
  807f69:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  807f6d:	74 29                	je     807f98 <inet_aton+0x1dc>
    addr->s_addr = htonl(val);
  807f6f:	89 3c 24             	mov    %edi,(%esp)
  807f72:	e8 19 fe ff ff       	call   807d90 <htonl>
  807f77:	8b 75 0c             	mov    0xc(%ebp),%esi
  807f7a:	89 06                	mov    %eax,(%esi)
  return (1);
  807f7c:	b8 01 00 00 00       	mov    $0x1,%eax
  807f81:	eb 1a                	jmp    807f9d <inet_aton+0x1e1>
     * Collect number up to ``.''.
     * Values are specified as for C:
     * 0x=hex, 0=octal, 1-9=decimal.
     */
    if (!isdigit(c))
      return (0);
  807f83:	b8 00 00 00 00       	mov    $0x0,%eax
  807f88:	eb 13                	jmp    807f9d <inet_aton+0x1e1>
       *  a.b.c.d
       *  a.b.c   (with c treated as 16 bits)
       *  a.b (with b treated as 24 bits)
       */
      if (pp >= parts + 3)
        return (0);
  807f8a:	b8 00 00 00 00       	mov    $0x0,%eax
  807f8f:	eb 0c                	jmp    807f9d <inet_aton+0x1e1>
  }
  /*
   * Check for trailing characters.
   */
  if (c != '\0' && (!isprint(c) || !isspace(c)))
    return (0);
  807f91:	b8 00 00 00 00       	mov    $0x0,%eax
  807f96:	eb 05                	jmp    807f9d <inet_aton+0x1e1>
    val |= (parts[0] << 24) | (parts[1] << 16) | (parts[2] << 8);
    break;
  }
  if (addr)
    addr->s_addr = htonl(val);
  return (1);
  807f98:	b8 01 00 00 00       	mov    $0x1,%eax
}
  807f9d:	83 c4 20             	add    $0x20,%esp
  807fa0:	5b                   	pop    %ebx
  807fa1:	5e                   	pop    %esi
  807fa2:	5f                   	pop    %edi
  807fa3:	5d                   	pop    %ebp
  807fa4:	c3                   	ret    

00807fa5 <inet_addr>:
 * @param cp IP address in ascii represenation (e.g. "127.0.0.1")
 * @return ip address in network order
 */
u32_t
inet_addr(const char *cp)
{
  807fa5:	55                   	push   %ebp
  807fa6:	89 e5                	mov    %esp,%ebp
  807fa8:	83 ec 18             	sub    $0x18,%esp
  struct in_addr val;

  if (inet_aton(cp, &val)) {
  807fab:	8d 45 fc             	lea    -0x4(%ebp),%eax
  807fae:	89 44 24 04          	mov    %eax,0x4(%esp)
  807fb2:	8b 45 08             	mov    0x8(%ebp),%eax
  807fb5:	89 04 24             	mov    %eax,(%esp)
  807fb8:	e8 ff fd ff ff       	call   807dbc <inet_aton>
  807fbd:	85 c0                	test   %eax,%eax
    return (val.s_addr);
  807fbf:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  807fc4:	0f 45 45 fc          	cmovne -0x4(%ebp),%eax
  }
  return (INADDR_NONE);
}
  807fc8:	c9                   	leave  
  807fc9:	c3                   	ret    

00807fca <ntohl>:
 * @param n u32_t in network byte order
 * @return n in host byte order
 */
u32_t
ntohl(u32_t n)
{
  807fca:	55                   	push   %ebp
  807fcb:	89 e5                	mov    %esp,%ebp
  807fcd:	83 ec 04             	sub    $0x4,%esp
  return htonl(n);
  807fd0:	8b 45 08             	mov    0x8(%ebp),%eax
  807fd3:	89 04 24             	mov    %eax,(%esp)
  807fd6:	e8 b5 fd ff ff       	call   807d90 <htonl>
}
  807fdb:	c9                   	leave  
  807fdc:	c3                   	ret    
  807fdd:	66 90                	xchg   %ax,%ax
  807fdf:	90                   	nop

00807fe0 <tcp_enqueue>:
 */
err_t
tcp_enqueue(struct tcp_pcb *pcb, void *arg, u16_t len,
  u8_t flags, u8_t apiflags,
  u8_t *optdata, u8_t optlen)
{
  807fe0:	55                   	push   %ebp
  807fe1:	89 e5                	mov    %esp,%ebp
  807fe3:	57                   	push   %edi
  807fe4:	56                   	push   %esi
  807fe5:	53                   	push   %ebx
  807fe6:	83 ec 4c             	sub    $0x4c,%esp
  807fe9:	8b 7d 08             	mov    0x8(%ebp),%edi
  807fec:	8b 45 10             	mov    0x10(%ebp),%eax
  807fef:	89 c6                	mov    %eax,%esi
  807ff1:	89 45 c4             	mov    %eax,-0x3c(%ebp)
  807ff4:	8b 45 14             	mov    0x14(%ebp),%eax
  807ff7:	89 c1                	mov    %eax,%ecx
  807ff9:	89 45 bc             	mov    %eax,-0x44(%ebp)
  807ffc:	8b 45 18             	mov    0x18(%ebp),%eax
  807fff:	89 c2                	mov    %eax,%edx
  808001:	89 45 b8             	mov    %eax,-0x48(%ebp)
  808004:	8b 45 20             	mov    0x20(%ebp),%eax
  808007:	66 89 75 c2          	mov    %si,-0x3e(%ebp)
  80800b:	88 4d ce             	mov    %cl,-0x32(%ebp)
  80800e:	88 45 cb             	mov    %al,-0x35(%ebp)
  void *ptr;
  u16_t queuelen;

  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_enqueue(pcb=%p, arg=%p, len=%"U16_F", flags=%"X16_F", apiflags=%"U16_F")\n",
    (void *)pcb, arg, len, (u16_t)flags, (u16_t)apiflags));
  LWIP_ERROR("tcp_enqueue: len == 0 || optlen == 0 (programmer violates API)",
  808011:	66 85 f6             	test   %si,%si
  808014:	74 20                	je     808036 <tcp_enqueue+0x56>
  808016:	84 c0                	test   %al,%al
  808018:	74 1c                	je     808036 <tcp_enqueue+0x56>
  80801a:	c7 44 24 08 3c 2e 81 	movl   $0x812e3c,0x8(%esp)
  808021:	00 
  808022:	c7 44 24 04 90 00 00 	movl   $0x90,0x4(%esp)
  808029:	00 
  80802a:	c7 04 24 de 2f 81 00 	movl   $0x812fde,(%esp)
  808031:	e8 44 70 00 00       	call   80f07a <_panic>
      ((len == 0) || (optlen == 0)), return ERR_ARG;);
  LWIP_ERROR("tcp_enqueue: arg == NULL || optdata == NULL (programmer violates API)",
  808036:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  80803a:	0f 95 c1             	setne  %cl
  80803d:	88 4d c9             	mov    %cl,-0x37(%ebp)
  808040:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  808044:	0f 95 45 cf          	setne  -0x31(%ebp)
  808048:	84 c9                	test   %cl,%cl
  80804a:	74 22                	je     80806e <tcp_enqueue+0x8e>
  80804c:	80 7d cf 00          	cmpb   $0x0,-0x31(%ebp)
  808050:	74 1c                	je     80806e <tcp_enqueue+0x8e>
  808052:	c7 44 24 08 7c 2e 81 	movl   $0x812e7c,0x8(%esp)
  808059:	00 
  80805a:	c7 44 24 04 92 00 00 	movl   $0x92,0x4(%esp)
  808061:	00 
  808062:	c7 04 24 de 2f 81 00 	movl   $0x812fde,(%esp)
  808069:	e8 0c 70 00 00       	call   80f07a <_panic>
      ((arg == NULL) || (optdata == NULL)), return ERR_ARG;);
  /* fail on too much data */
  if (len > pcb->snd_buf) {
  80806e:	0f b7 4d c4          	movzwl -0x3c(%ebp),%ecx
  808072:	66 3b 4f 6e          	cmp    0x6e(%edi),%cx
  808076:	76 0e                	jbe    808086 <tcp_enqueue+0xa6>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_enqueue: too much data (len=%"U16_F" > snd_buf=%"U16_F")\n", len, pcb->snd_buf));
    pcb->flags |= TF_NAGLEMEMERR;
  808078:	80 4f 20 80          	orb    $0x80,0x20(%edi)
    return ERR_MEM;
  80807c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  808081:	e9 24 06 00 00       	jmp    8086aa <tcp_enqueue+0x6ca>
  left = len;
  ptr = arg;

  /* seqno will be the sequence number of the first segment enqueued
   * by the call to this function. */
  seqno = pcb->snd_lbb;
  808086:	8b 4f 68             	mov    0x68(%edi),%ecx
  808089:	89 4d d8             	mov    %ecx,-0x28(%ebp)

  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue: queuelen: %"U16_F"\n", (u16_t)pcb->snd_queuelen));

  /* If total number of pbufs on the unsent/unacked queues exceeds the
   * configured maximum, return an error */
  queuelen = pcb->snd_queuelen;
  80808c:	0f b7 4f 70          	movzwl 0x70(%edi),%ecx
  808090:	66 89 4d e4          	mov    %cx,-0x1c(%ebp)
  /* check for configured max queuelen and possible overflow */
  if ((queuelen >= TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
  808094:	66 83 f9 1f          	cmp    $0x1f,%cx
  808098:	76 0e                	jbe    8080a8 <tcp_enqueue+0xc8>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_enqueue: too long queue %"U16_F" (max %"U16_F")\n", queuelen, TCP_SND_QUEUELEN));
    TCP_STATS_INC(tcp.memerr);
    pcb->flags |= TF_NAGLEMEMERR;
  80809a:	80 4f 20 80          	orb    $0x80,0x20(%edi)
    return ERR_MEM;
  80809e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8080a3:	e9 02 06 00 00       	jmp    8086aa <tcp_enqueue+0x6ca>
  }
  if (queuelen != 0) {
  8080a8:	66 83 7d e4 00       	cmpw   $0x0,-0x1c(%ebp)
  8080ad:	74 30                	je     8080df <tcp_enqueue+0xff>
    LWIP_ASSERT("tcp_enqueue: pbufs on queue => at least one queue non-empty",
  8080af:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  8080b3:	0f 85 b9 05 00 00    	jne    808672 <tcp_enqueue+0x692>
  8080b9:	83 7f 74 00          	cmpl   $0x0,0x74(%edi)
  8080bd:	0f 85 af 05 00 00    	jne    808672 <tcp_enqueue+0x692>
  8080c3:	c7 44 24 08 c4 2e 81 	movl   $0x812ec4,0x8(%esp)
  8080ca:	00 
  8080cb:	c7 44 24 04 ae 00 00 	movl   $0xae,0x4(%esp)
  8080d2:	00 
  8080d3:	c7 04 24 de 2f 81 00 	movl   $0x812fde,(%esp)
  8080da:	e8 9b 6f 00 00       	call   80f07a <_panic>
      pcb->unacked != NULL || pcb->unsent != NULL);
  } else {
    LWIP_ASSERT("tcp_enqueue: no pbufs on queue => both queues empty",
  8080df:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  8080e3:	75 0a                	jne    8080ef <tcp_enqueue+0x10f>
  8080e5:	83 7f 74 00          	cmpl   $0x0,0x74(%edi)
  8080e9:	0f 84 83 05 00 00    	je     808672 <tcp_enqueue+0x692>
  8080ef:	c7 44 24 08 00 2f 81 	movl   $0x812f00,0x8(%esp)
  8080f6:	00 
  8080f7:	c7 44 24 04 b1 00 00 	movl   $0xb1,0x4(%esp)
  8080fe:	00 
  8080ff:	c7 04 24 de 2f 81 00 	movl   $0x812fde,(%esp)
  808106:	e8 6f 6f 00 00       	call   80f07a <_panic>
    /* The segment length should be the MSS if the data to be enqueued
     * is larger than the MSS. */
    seglen = left > pcb->mss? pcb->mss: left;

    /* Allocate memory for tcp_seg, and fill in fields. */
    seg = memp_malloc(MEMP_TCP_SEG);
  80810b:	89 de                	mov    %ebx,%esi
  seglen = 0;
  while (queue == NULL || left > 0) {

    /* The segment length should be the MSS if the data to be enqueued
     * is larger than the MSS. */
    seglen = left > pcb->mss? pcb->mss: left;
  80810d:	0f b7 47 34          	movzwl 0x34(%edi),%eax
  808111:	0f b7 4d e0          	movzwl -0x20(%ebp),%ecx
  808115:	66 39 c1             	cmp    %ax,%cx
  808118:	0f 46 c1             	cmovbe %ecx,%eax
  80811b:	66 89 45 e6          	mov    %ax,-0x1a(%ebp)

    /* Allocate memory for tcp_seg, and fill in fields. */
    seg = memp_malloc(MEMP_TCP_SEG);
  80811f:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
  808126:	e8 b7 c8 ff ff       	call   8049e2 <memp_malloc>
  80812b:	89 c3                	mov    %eax,%ebx
    if (seg == NULL) {
  80812d:	85 c0                	test   %eax,%eax
  80812f:	0f 84 c3 04 00 00    	je     8085f8 <tcp_enqueue+0x618>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: could not allocate memory for tcp_seg\n"));
      goto memerr;
    }
    seg->next = NULL;
  808135:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    seg->p = NULL;
  80813b:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)

    /* first segment of to-be-queued data? */
    if (queue == NULL) {
  808142:	80 7d dc 00          	cmpb   $0x0,-0x24(%ebp)
  808146:	75 24                	jne    80816c <tcp_enqueue+0x18c>
      queue = seg;
    }
    /* subsequent segments of to-be-queued data */
    else {
      /* Attach the segment to the end of the queued segments */
      LWIP_ASSERT("useg != NULL", useg != NULL);
  808148:	85 f6                	test   %esi,%esi
  80814a:	75 1c                	jne    808168 <tcp_enqueue+0x188>
  80814c:	c7 44 24 08 f6 2f 81 	movl   $0x812ff6,0x8(%esp)
  808153:	00 
  808154:	c7 44 24 04 ce 00 00 	movl   $0xce,0x4(%esp)
  80815b:	00 
  80815c:	c7 04 24 de 2f 81 00 	movl   $0x812fde,(%esp)
  808163:	e8 12 6f 00 00       	call   80f07a <_panic>
      useg->next = seg;
  808168:	89 06                	mov    %eax,(%esi)
  80816a:	eb 03                	jmp    80816f <tcp_enqueue+0x18f>
    /* The segment length should be the MSS if the data to be enqueued
     * is larger than the MSS. */
    seglen = left > pcb->mss? pcb->mss: left;

    /* Allocate memory for tcp_seg, and fill in fields. */
    seg = memp_malloc(MEMP_TCP_SEG);
  80816c:	89 45 d0             	mov    %eax,-0x30(%ebp)
     * and data copied into pbuf, otherwise data comes from
     * ROM or other static memory, and need not be copied. If
     * optdata is != NULL, we have options instead of data. */
     
    /* options? */
    if (optdata != NULL) {
  80816f:	80 7d cf 00          	cmpb   $0x0,-0x31(%ebp)
  808173:	74 69                	je     8081de <tcp_enqueue+0x1fe>
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
  808175:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80817c:	00 
  80817d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  808180:	89 44 24 04          	mov    %eax,0x4(%esp)
  808184:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80818b:	e8 45 cd ff ff       	call   804ed5 <pbuf_alloc>
  808190:	89 43 04             	mov    %eax,0x4(%ebx)
  808193:	85 c0                	test   %eax,%eax
  808195:	0f 84 5d 04 00 00    	je     8085f8 <tcp_enqueue+0x618>
        goto memerr;
      }
      LWIP_ASSERT("check that first pbuf can hold optlen",
  80819b:	0f b6 55 cb          	movzbl -0x35(%ebp),%edx
  80819f:	66 39 50 0a          	cmp    %dx,0xa(%eax)
  8081a3:	73 1c                	jae    8081c1 <tcp_enqueue+0x1e1>
  8081a5:	c7 44 24 08 34 2f 81 	movl   $0x812f34,0x8(%esp)
  8081ac:	00 
  8081ad:	c7 44 24 04 df 00 00 	movl   $0xdf,0x4(%esp)
  8081b4:	00 
  8081b5:	c7 04 24 de 2f 81 00 	movl   $0x812fde,(%esp)
  8081bc:	e8 b9 6e 00 00       	call   80f07a <_panic>
                  (seg->p->len >= optlen));
      queuelen += pbuf_clen(seg->p);
  8081c1:	89 04 24             	mov    %eax,(%esp)
  8081c4:	e8 c1 d0 ff ff       	call   80528a <pbuf_clen>
  8081c9:	0f b6 c0             	movzbl %al,%eax
  8081cc:	66 01 45 e4          	add    %ax,-0x1c(%ebp)
      seg->dataptr = seg->p->payload;
  8081d0:	8b 43 04             	mov    0x4(%ebx),%eax
  8081d3:	8b 40 04             	mov    0x4(%eax),%eax
  8081d6:	89 43 08             	mov    %eax,0x8(%ebx)
  8081d9:	e9 22 01 00 00       	jmp    808300 <tcp_enqueue+0x320>
    }
    /* copy from volatile memory? */
    else if (apiflags & TCP_WRITE_FLAG_COPY) {
  8081de:	80 7d ca 00          	cmpb   $0x0,-0x36(%ebp)
  8081e2:	0f 84 8c 00 00 00    	je     808274 <tcp_enqueue+0x294>
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_RAM)) == NULL) {
  8081e8:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8081ef:	00 
  8081f0:	0f b7 75 e6          	movzwl -0x1a(%ebp),%esi
  8081f4:	0f b7 c6             	movzwl %si,%eax
  8081f7:	89 44 24 04          	mov    %eax,0x4(%esp)
  8081fb:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  808202:	e8 ce cc ff ff       	call   804ed5 <pbuf_alloc>
  808207:	89 43 04             	mov    %eax,0x4(%ebx)
  80820a:	85 c0                	test   %eax,%eax
  80820c:	0f 84 e6 03 00 00    	je     8085f8 <tcp_enqueue+0x618>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue : could not allocate memory for pbuf copy size %"U16_F"\n", seglen));
        goto memerr;
      }
      LWIP_ASSERT("check that first pbuf can hold the complete seglen",
  808212:	66 3b 70 0a          	cmp    0xa(%eax),%si
  808216:	76 1c                	jbe    808234 <tcp_enqueue+0x254>
  808218:	c7 44 24 08 5c 2f 81 	movl   $0x812f5c,0x8(%esp)
  80821f:	00 
  808220:	c7 44 24 04 ea 00 00 	movl   $0xea,0x4(%esp)
  808227:	00 
  808228:	c7 04 24 de 2f 81 00 	movl   $0x812fde,(%esp)
  80822f:	e8 46 6e 00 00       	call   80f07a <_panic>
                  (seg->p->len >= seglen));
      queuelen += pbuf_clen(seg->p);
  808234:	89 04 24             	mov    %eax,(%esp)
  808237:	e8 4e d0 ff ff       	call   80528a <pbuf_clen>
  80823c:	0f b6 c0             	movzbl %al,%eax
  80823f:	66 01 45 e4          	add    %ax,-0x1c(%ebp)
      if (arg != NULL) {
  808243:	80 7d c9 00          	cmpb   $0x0,-0x37(%ebp)
  808247:	74 1d                	je     808266 <tcp_enqueue+0x286>
        MEMCPY(seg->p->payload, ptr, seglen);
  808249:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  80824d:	89 44 24 08          	mov    %eax,0x8(%esp)
  808251:	8b 45 0c             	mov    0xc(%ebp),%eax
  808254:	89 44 24 04          	mov    %eax,0x4(%esp)
  808258:	8b 43 04             	mov    0x4(%ebx),%eax
  80825b:	8b 40 04             	mov    0x4(%eax),%eax
  80825e:	89 04 24             	mov    %eax,(%esp)
  808261:	e8 36 77 00 00       	call   80f99c <memcpy>
      }
      seg->dataptr = seg->p->payload;
  808266:	8b 43 04             	mov    0x4(%ebx),%eax
  808269:	8b 40 04             	mov    0x4(%eax),%eax
  80826c:	89 43 08             	mov    %eax,0x8(%ebx)
  80826f:	e9 8c 00 00 00       	jmp    808300 <tcp_enqueue+0x320>
      /* First, allocate a pbuf for holding the data.
       * since the referenced data is available at least until it is sent out on the
       * link (as it has to be ACKed by the remote party) we can safely use PBUF_ROM
       * instead of PBUF_REF here.
       */
      if ((p = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_ROM)) == NULL) {
  808274:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  80827b:	00 
  80827c:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  808280:	89 44 24 04          	mov    %eax,0x4(%esp)
  808284:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80828b:	e8 45 cc ff ff       	call   804ed5 <pbuf_alloc>
  808290:	89 c6                	mov    %eax,%esi
  808292:	85 c0                	test   %eax,%eax
  808294:	0f 84 5e 03 00 00    	je     8085f8 <tcp_enqueue+0x618>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: could not allocate memory for zero-copy pbuf\n"));
        goto memerr;
      }
      ++queuelen;
  80829a:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  80829e:	83 c0 01             	add    $0x1,%eax
  8082a1:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
      /* reference the non-volatile payload data */
      p->payload = ptr;
  8082a5:	8b 45 0c             	mov    0xc(%ebp),%eax
  8082a8:	89 46 04             	mov    %eax,0x4(%esi)
      seg->dataptr = ptr;
  8082ab:	89 43 08             	mov    %eax,0x8(%ebx)

      /* Second, allocate a pbuf for the headers. */
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, 0, PBUF_RAM)) == NULL) {
  8082ae:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8082b5:	00 
  8082b6:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8082bd:	00 
  8082be:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8082c5:	e8 0b cc ff ff       	call   804ed5 <pbuf_alloc>
  8082ca:	89 43 04             	mov    %eax,0x4(%ebx)
  8082cd:	85 c0                	test   %eax,%eax
  8082cf:	75 0d                	jne    8082de <tcp_enqueue+0x2fe>
        /* If allocation fails, we have to deallocate the data pbuf as
         * well. */
        pbuf_free(p);
  8082d1:	89 34 24             	mov    %esi,(%esp)
  8082d4:	e8 1b cb ff ff       	call   804df4 <pbuf_free>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: could not allocate memory for header pbuf\n"));
        goto memerr;
  8082d9:	e9 1a 03 00 00       	jmp    8085f8 <tcp_enqueue+0x618>
      }
      queuelen += pbuf_clen(seg->p);
  8082de:	89 04 24             	mov    %eax,(%esp)
  8082e1:	e8 a4 cf ff ff       	call   80528a <pbuf_clen>
  8082e6:	0f b6 c0             	movzbl %al,%eax
  8082e9:	66 03 45 e4          	add    -0x1c(%ebp),%ax
  8082ed:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)

      /* Concatenate the headers and data pbufs together. */
      pbuf_cat(seg->p/*header*/, p/*data*/);
  8082f1:	89 74 24 04          	mov    %esi,0x4(%esp)
  8082f5:	8b 43 04             	mov    0x4(%ebx),%eax
  8082f8:	89 04 24             	mov    %eax,(%esp)
  8082fb:	e8 b3 cf ff ff       	call   8052b3 <pbuf_cat>
      p = NULL;
    }

    /* Now that there are more segments queued, we check again if the
    length of the queue exceeds the configured maximum or overflows. */
    if ((queuelen > TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
  808300:	66 83 7d e4 20       	cmpw   $0x20,-0x1c(%ebp)
  808305:	0f 87 ed 02 00 00    	ja     8085f8 <tcp_enqueue+0x618>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: queue too long %"U16_F" (%"U16_F")\n", queuelen, TCP_SND_QUEUELEN));
      goto memerr;
    }

    seg->len = seglen;
  80830b:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  80830f:	66 89 43 0c          	mov    %ax,0xc(%ebx)

    /* build TCP header */
    if (pbuf_header(seg->p, TCP_HLEN)) {
  808313:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  80831a:	00 
  80831b:	8b 43 04             	mov    0x4(%ebx),%eax
  80831e:	89 04 24             	mov    %eax,(%esp)
  808321:	e8 ea c9 ff ff       	call   804d10 <pbuf_header>
  808326:	84 c0                	test   %al,%al
  808328:	0f 85 ca 02 00 00    	jne    8085f8 <tcp_enqueue+0x618>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: no room for TCP header in pbuf.\n"));
      TCP_STATS_INC(tcp.err);
      goto memerr;
    }
    seg->tcphdr = seg->p->payload;
  80832e:	8b 43 04             	mov    0x4(%ebx),%eax
  808331:	8b 70 04             	mov    0x4(%eax),%esi
  808334:	89 73 10             	mov    %esi,0x10(%ebx)
    seg->tcphdr->src = htons(pcb->local_port);
  808337:	0f b7 47 1c          	movzwl 0x1c(%edi),%eax
  80833b:	89 04 24             	mov    %eax,(%esp)
  80833e:	e8 33 fa ff ff       	call   807d76 <htons>
  808343:	66 89 06             	mov    %ax,(%esi)
    seg->tcphdr->dest = htons(pcb->remote_port);
  808346:	8b 73 10             	mov    0x10(%ebx),%esi
  808349:	0f b7 47 1e          	movzwl 0x1e(%edi),%eax
  80834d:	89 04 24             	mov    %eax,(%esp)
  808350:	e8 21 fa ff ff       	call   807d76 <htons>
  808355:	66 89 46 02          	mov    %ax,0x2(%esi)
    seg->tcphdr->seqno = htonl(seqno);
  808359:	8b 73 10             	mov    0x10(%ebx),%esi
  80835c:	8b 45 d8             	mov    -0x28(%ebp),%eax
  80835f:	89 04 24             	mov    %eax,(%esp)
  808362:	e8 29 fa ff ff       	call   807d90 <htonl>
  808367:	89 46 04             	mov    %eax,0x4(%esi)
    seg->tcphdr->urgp = 0;
  80836a:	8b 43 10             	mov    0x10(%ebx),%eax
  80836d:	66 c7 40 12 00 00    	movw   $0x0,0x12(%eax)
    TCPH_FLAGS_SET(seg->tcphdr, flags);
  808373:	8b 73 10             	mov    0x10(%ebx),%esi
  808376:	0f b7 46 0c          	movzwl 0xc(%esi),%eax
  80837a:	89 04 24             	mov    %eax,(%esp)
  80837d:	e8 01 fa ff ff       	call   807d83 <ntohs>
  808382:	83 e0 c0             	and    $0xffffffc0,%eax
  808385:	0f b6 55 ce          	movzbl -0x32(%ebp),%edx
  808389:	09 d0                	or     %edx,%eax
  80838b:	0f b7 c0             	movzwl %ax,%eax
  80838e:	89 04 24             	mov    %eax,(%esp)
  808391:	e8 e0 f9 ff ff       	call   807d76 <htons>
  808396:	66 89 46 0c          	mov    %ax,0xc(%esi)
    /* don't fill in tcphdr->ackno and tcphdr->wnd until later */

    /* Copy the options into the header, if they are present. */
    if (optdata == NULL) {
  80839a:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  80839e:	75 23                	jne    8083c3 <tcp_enqueue+0x3e3>
      TCPH_HDRLEN_SET(seg->tcphdr, 5);
  8083a0:	8b 73 10             	mov    0x10(%ebx),%esi
  8083a3:	0f b7 46 0c          	movzwl 0xc(%esi),%eax
  8083a7:	89 04 24             	mov    %eax,(%esp)
  8083aa:	e8 d4 f9 ff ff       	call   807d83 <ntohs>
  8083af:	83 e0 3f             	and    $0x3f,%eax
  8083b2:	80 cc 50             	or     $0x50,%ah
  8083b5:	89 04 24             	mov    %eax,(%esp)
  8083b8:	e8 b9 f9 ff ff       	call   807d76 <htons>
  8083bd:	66 89 46 0c          	mov    %ax,0xc(%esi)
  8083c1:	eb 3e                	jmp    808401 <tcp_enqueue+0x421>
    }
    else {
      TCPH_HDRLEN_SET(seg->tcphdr, (5 + optlen / 4));
  8083c3:	8b 73 10             	mov    0x10(%ebx),%esi
  8083c6:	0f b7 46 0c          	movzwl 0xc(%esi),%eax
  8083ca:	89 04 24             	mov    %eax,(%esp)
  8083cd:	e8 b1 f9 ff ff       	call   807d83 <ntohs>
  8083d2:	83 e0 3f             	and    $0x3f,%eax
  8083d5:	66 0b 45 cc          	or     -0x34(%ebp),%ax
  8083d9:	0f b7 c0             	movzwl %ax,%eax
  8083dc:	89 04 24             	mov    %eax,(%esp)
  8083df:	e8 92 f9 ff ff       	call   807d76 <htons>
  8083e4:	66 89 46 0c          	mov    %ax,0xc(%esi)
      /* Copy options into data portion of segment.
       Options can thus only be sent in non data carrying
       segments such as SYN|ACK. */
      SMEMCPY(seg->dataptr, optdata, optlen);
  8083e8:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  8083eb:	89 44 24 08          	mov    %eax,0x8(%esp)
  8083ef:	8b 45 1c             	mov    0x1c(%ebp),%eax
  8083f2:	89 44 24 04          	mov    %eax,0x4(%esp)
  8083f6:	8b 43 08             	mov    0x8(%ebx),%eax
  8083f9:	89 04 24             	mov    %eax,(%esp)
  8083fc:	e8 9b 75 00 00       	call   80f99c <memcpy>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_TRACE, ("tcp_enqueue: queueing %"U32_F":%"U32_F" (0x%"X16_F")\n",
      ntohl(seg->tcphdr->seqno),
      ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg),
      (u16_t)flags));

    left -= seglen;
  808401:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  808405:	66 29 45 e0          	sub    %ax,-0x20(%ebp)
    seqno += seglen;
  808409:	0f b7 c0             	movzwl %ax,%eax
  80840c:	01 45 d8             	add    %eax,-0x28(%ebp)
    ptr = (void *)((u8_t *)ptr + seglen);
  80840f:	01 45 0c             	add    %eax,0xc(%ebp)

  /* First, break up the data into segments and tuck them together in
   * the local "queue" variable. */
  useg = queue = seg = NULL;
  seglen = 0;
  while (queue == NULL || left > 0) {
  808412:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
  808416:	0f 94 45 dc          	sete   -0x24(%ebp)
  80841a:	0f 84 eb fc ff ff    	je     80810b <tcp_enqueue+0x12b>
  808420:	66 83 7d e0 00       	cmpw   $0x0,-0x20(%ebp)
  808425:	0f 85 e0 fc ff ff    	jne    80810b <tcp_enqueue+0x12b>
    /* The segment length should be the MSS if the data to be enqueued
     * is larger than the MSS. */
    seglen = left > pcb->mss? pcb->mss: left;

    /* Allocate memory for tcp_seg, and fill in fields. */
    seg = memp_malloc(MEMP_TCP_SEG);
  80842b:	89 5d dc             	mov    %ebx,-0x24(%ebp)
  }

  /* Now that the data to be enqueued has been broken up into TCP
  segments in the queue variable, we add them to the end of the
  pcb->unsent queue. */
  if (pcb->unsent == NULL) {
  80842e:	8b 77 74             	mov    0x74(%edi),%esi
  808431:	85 f6                	test   %esi,%esi
  808433:	0f 84 24 02 00 00    	je     80865d <tcp_enqueue+0x67d>
    useg = NULL;
  }
  else {
    for (useg = pcb->unsent; useg->next != NULL; useg = useg->next);
  808439:	8b 06                	mov    (%esi),%eax
  80843b:	85 c0                	test   %eax,%eax
  80843d:	74 04                	je     808443 <tcp_enqueue+0x463>
  80843f:	89 c6                	mov    %eax,%esi
  808441:	eb f6                	jmp    808439 <tcp_enqueue+0x459>
  }
  /* { useg is last segment on the unsent queue, NULL if list is empty } */

  /* If there is room in the last pbuf on the unsent queue,
  chain the first pbuf on the queue together with that. */
  if (useg != NULL &&
  808443:	85 f6                	test   %esi,%esi
  808445:	0f 84 12 02 00 00    	je     80865d <tcp_enqueue+0x67d>
    TCP_TCPLEN(useg) != 0 &&
  80844b:	0f b7 46 0c          	movzwl 0xc(%esi),%eax
  80844f:	89 45 e0             	mov    %eax,-0x20(%ebp)
  808452:	8b 46 10             	mov    0x10(%esi),%eax
  808455:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  808459:	89 04 24             	mov    %eax,(%esp)
  80845c:	e8 22 f9 ff ff       	call   807d83 <ntohs>
  808461:	ba 01 00 00 00       	mov    $0x1,%edx
  808466:	a8 01                	test   $0x1,%al
  808468:	75 17                	jne    808481 <tcp_enqueue+0x4a1>
  80846a:	8b 46 10             	mov    0x10(%esi),%eax
  80846d:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  808471:	89 04 24             	mov    %eax,(%esp)
  808474:	e8 0a f9 ff ff       	call   807d83 <ntohs>
  808479:	66 d1 e8             	shr    %ax
  80847c:	89 c2                	mov    %eax,%edx
  80847e:	83 e2 01             	and    $0x1,%edx
  808481:	03 55 e0             	add    -0x20(%ebp),%edx
  }
  /* { useg is last segment on the unsent queue, NULL if list is empty } */

  /* If there is room in the last pbuf on the unsent queue,
  chain the first pbuf on the queue together with that. */
  if (useg != NULL &&
  808484:	85 d2                	test   %edx,%edx
  808486:	0f 84 dc 01 00 00    	je     808668 <tcp_enqueue+0x688>
    TCP_TCPLEN(useg) != 0 &&
    !(TCPH_FLAGS(useg->tcphdr) & (TCP_SYN | TCP_FIN)) &&
  80848c:	8b 46 10             	mov    0x10(%esi),%eax
  80848f:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  808493:	89 04 24             	mov    %eax,(%esp)
  808496:	e8 e8 f8 ff ff       	call   807d83 <ntohs>
  /* { useg is last segment on the unsent queue, NULL if list is empty } */

  /* If there is room in the last pbuf on the unsent queue,
  chain the first pbuf on the queue together with that. */
  if (useg != NULL &&
    TCP_TCPLEN(useg) != 0 &&
  80849b:	a8 03                	test   $0x3,%al
  80849d:	0f 85 c5 01 00 00    	jne    808668 <tcp_enqueue+0x688>
    !(TCPH_FLAGS(useg->tcphdr) & (TCP_SYN | TCP_FIN)) &&
  8084a3:	f6 45 bc 03          	testb  $0x3,-0x44(%ebp)
  8084a7:	0f 85 bb 01 00 00    	jne    808668 <tcp_enqueue+0x688>
    !(flags & (TCP_SYN | TCP_FIN)) &&
    /* fit within max seg size */
    useg->len + queue->len <= pcb->mss) {
  8084ad:	0f b7 56 0c          	movzwl 0xc(%esi),%edx
  8084b1:	8b 45 d0             	mov    -0x30(%ebp),%eax
  8084b4:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  8084b8:	01 c2                	add    %eax,%edx
  8084ba:	0f b7 47 34          	movzwl 0x34(%edi),%eax
  /* If there is room in the last pbuf on the unsent queue,
  chain the first pbuf on the queue together with that. */
  if (useg != NULL &&
    TCP_TCPLEN(useg) != 0 &&
    !(TCPH_FLAGS(useg->tcphdr) & (TCP_SYN | TCP_FIN)) &&
    !(flags & (TCP_SYN | TCP_FIN)) &&
  8084be:	39 c2                	cmp    %eax,%edx
  8084c0:	0f 8f a2 01 00 00    	jg     808668 <tcp_enqueue+0x688>
    /* fit within max seg size */
    useg->len + queue->len <= pcb->mss) {
    /* Remove TCP header from first segment of our to-be-queued list */
    if(pbuf_header(queue->p, -TCP_HLEN)) {
  8084c6:	c7 44 24 04 ec ff ff 	movl   $0xffffffec,0x4(%esp)
  8084cd:	ff 
  8084ce:	8b 45 d0             	mov    -0x30(%ebp),%eax
  8084d1:	8b 40 04             	mov    0x4(%eax),%eax
  8084d4:	89 04 24             	mov    %eax,(%esp)
  8084d7:	e8 34 c8 ff ff       	call   804d10 <pbuf_header>
  8084dc:	84 c0                	test   %al,%al
  8084de:	74 1c                	je     8084fc <tcp_enqueue+0x51c>
      /* Can we cope with this failing?  Just assert for now */
      LWIP_ASSERT("pbuf_header failed\n", 0);
  8084e0:	c7 44 24 08 03 30 81 	movl   $0x813003,0x8(%esp)
  8084e7:	00 
  8084e8:	c7 44 24 04 52 01 00 	movl   $0x152,0x4(%esp)
  8084ef:	00 
  8084f0:	c7 04 24 de 2f 81 00 	movl   $0x812fde,(%esp)
  8084f7:	e8 7e 6b 00 00       	call   80f07a <_panic>
      TCP_STATS_INC(tcp.err);
      goto memerr;
    }
    pbuf_cat(useg->p, queue->p);
  8084fc:	8b 45 d0             	mov    -0x30(%ebp),%eax
  8084ff:	8b 40 04             	mov    0x4(%eax),%eax
  808502:	89 44 24 04          	mov    %eax,0x4(%esp)
  808506:	8b 46 04             	mov    0x4(%esi),%eax
  808509:	89 04 24             	mov    %eax,(%esp)
  80850c:	e8 a2 cd ff ff       	call   8052b3 <pbuf_cat>
    useg->len += queue->len;
  808511:	8b 55 d0             	mov    -0x30(%ebp),%edx
  808514:	0f b7 42 0c          	movzwl 0xc(%edx),%eax
  808518:	66 01 46 0c          	add    %ax,0xc(%esi)
    useg->next = queue->next;
  80851c:	8b 02                	mov    (%edx),%eax
  80851e:	89 06                	mov    %eax,(%esi)

    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("tcp_enqueue: chaining segments, new len %"U16_F"\n", useg->len));
    if (seg == queue) {
      seg = NULL;
  808520:	3b 55 dc             	cmp    -0x24(%ebp),%edx
  808523:	b8 00 00 00 00       	mov    $0x0,%eax
  808528:	0f 44 d8             	cmove  %eax,%ebx
    }
    memp_free(MEMP_TCP_SEG, queue);
  80852b:	89 54 24 04          	mov    %edx,0x4(%esp)
  80852f:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
  808536:	e8 07 c5 ff ff       	call   804a42 <memp_free>
  80853b:	eb 19                	jmp    808556 <tcp_enqueue+0x576>
    /* enqueue segment */
    else {
      useg->next = queue;
    }
  }
  if ((flags & TCP_SYN) || (flags & TCP_FIN)) {
  80853d:	0f b6 55 bc          	movzbl -0x44(%ebp),%edx
  808541:	83 e2 03             	and    $0x3,%edx
    ++len;
  808544:	0f b7 45 c4          	movzwl -0x3c(%ebp),%eax
  808548:	83 c0 01             	add    $0x1,%eax
  80854b:	84 d2                	test   %dl,%dl
  80854d:	66 0f 44 45 c2       	cmove  -0x3e(%ebp),%ax
  808552:	66 89 45 c2          	mov    %ax,-0x3e(%ebp)
  }
  if (flags & TCP_FIN) {
  808556:	f6 45 bc 01          	testb  $0x1,-0x44(%ebp)
  80855a:	74 04                	je     808560 <tcp_enqueue+0x580>
    pcb->flags |= TF_FIN;
  80855c:	80 4f 20 20          	orb    $0x20,0x20(%edi)
  }
  pcb->snd_lbb += len;
  808560:	0f b7 55 c2          	movzwl -0x3e(%ebp),%edx
  808564:	0f b7 c2             	movzwl %dx,%eax
  808567:	01 47 68             	add    %eax,0x68(%edi)

  pcb->snd_buf -= len;
  80856a:	66 29 57 6e          	sub    %dx,0x6e(%edi)

  /* update number of segments on the queues */
  pcb->snd_queuelen = queuelen;
  80856e:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  808572:	66 89 47 70          	mov    %ax,0x70(%edi)
  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue: %"S16_F" (after enqueued)\n", pcb->snd_queuelen));
  if (pcb->snd_queuelen != 0) {
  808576:	66 85 c0             	test   %ax,%ax
  808579:	74 28                	je     8085a3 <tcp_enqueue+0x5c3>
    LWIP_ASSERT("tcp_enqueue: valid queue length",
  80857b:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  80857f:	75 22                	jne    8085a3 <tcp_enqueue+0x5c3>
  808581:	83 7f 74 00          	cmpl   $0x0,0x74(%edi)
  808585:	75 1c                	jne    8085a3 <tcp_enqueue+0x5c3>
  808587:	c7 44 24 08 90 2f 81 	movl   $0x812f90,0x8(%esp)
  80858e:	00 
  80858f:	c7 44 24 04 7a 01 00 	movl   $0x17a,0x4(%esp)
  808596:	00 
  808597:	c7 04 24 de 2f 81 00 	movl   $0x812fde,(%esp)
  80859e:	e8 d7 6a 00 00       	call   80f07a <_panic>
      pcb->unacked != NULL || pcb->unsent != NULL);
  }

  /* Set the PSH flag in the last segment that we enqueued, but only
  if the segment has data (indicated by seglen > 0). */
  if (seg != NULL && seglen > 0 && seg->tcphdr != NULL && ((apiflags & TCP_WRITE_FLAG_MORE)==0)) {
  8085a3:	85 db                	test   %ebx,%ebx
  8085a5:	0f 84 8f 00 00 00    	je     80863a <tcp_enqueue+0x65a>
  8085ab:	66 83 7d e6 00       	cmpw   $0x0,-0x1a(%ebp)
  8085b0:	0f 84 84 00 00 00    	je     80863a <tcp_enqueue+0x65a>
  8085b6:	8b 5b 10             	mov    0x10(%ebx),%ebx
  8085b9:	85 db                	test   %ebx,%ebx
  8085bb:	0f 84 80 00 00 00    	je     808641 <tcp_enqueue+0x661>
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
  }

  return ERR_OK;
  8085c1:	b8 00 00 00 00       	mov    $0x0,%eax
      pcb->unacked != NULL || pcb->unsent != NULL);
  }

  /* Set the PSH flag in the last segment that we enqueued, but only
  if the segment has data (indicated by seglen > 0). */
  if (seg != NULL && seglen > 0 && seg->tcphdr != NULL && ((apiflags & TCP_WRITE_FLAG_MORE)==0)) {
  8085c6:	f6 45 b8 02          	testb  $0x2,-0x48(%ebp)
  8085ca:	0f 85 da 00 00 00    	jne    8086aa <tcp_enqueue+0x6ca>
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
  8085d0:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  8085d4:	89 04 24             	mov    %eax,(%esp)
  8085d7:	e8 a7 f7 ff ff       	call   807d83 <ntohs>
  8085dc:	83 c8 08             	or     $0x8,%eax
  8085df:	0f b7 c0             	movzwl %ax,%eax
  8085e2:	89 04 24             	mov    %eax,(%esp)
  8085e5:	e8 8c f7 ff ff       	call   807d76 <htons>
  8085ea:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  }

  return ERR_OK;
  8085ee:	b8 00 00 00 00       	mov    $0x0,%eax
  8085f3:	e9 b2 00 00 00       	jmp    8086aa <tcp_enqueue+0x6ca>
memerr:
  pcb->flags |= TF_NAGLEMEMERR;
  8085f8:	80 4f 20 80          	orb    $0x80,0x20(%edi)
  TCP_STATS_INC(tcp.memerr);

  if (queue != NULL) {
  8085fc:	8b 45 d0             	mov    -0x30(%ebp),%eax
  8085ff:	85 c0                	test   %eax,%eax
  808601:	74 08                	je     80860b <tcp_enqueue+0x62b>
    tcp_segs_free(queue);
  808603:	89 04 24             	mov    %eax,(%esp)
  808606:	e8 03 d8 ff ff       	call   805e0e <tcp_segs_free>
  }
  if (pcb->snd_queuelen != 0) {
  80860b:	66 83 7f 70 00       	cmpw   $0x0,0x70(%edi)
  808610:	74 36                	je     808648 <tcp_enqueue+0x668>
    LWIP_ASSERT("tcp_enqueue: valid queue length", pcb->unacked != NULL ||
  808612:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  808616:	75 37                	jne    80864f <tcp_enqueue+0x66f>
  808618:	83 7f 74 00          	cmpl   $0x0,0x74(%edi)
  80861c:	75 38                	jne    808656 <tcp_enqueue+0x676>
  80861e:	c7 44 24 08 90 2f 81 	movl   $0x812f90,0x8(%esp)
  808625:	00 
  808626:	c7 44 24 04 8d 01 00 	movl   $0x18d,0x4(%esp)
  80862d:	00 
  80862e:	c7 04 24 de 2f 81 00 	movl   $0x812fde,(%esp)
  808635:	e8 40 6a 00 00       	call   80f07a <_panic>
  if the segment has data (indicated by seglen > 0). */
  if (seg != NULL && seglen > 0 && seg->tcphdr != NULL && ((apiflags & TCP_WRITE_FLAG_MORE)==0)) {
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
  }

  return ERR_OK;
  80863a:	b8 00 00 00 00       	mov    $0x0,%eax
  80863f:	eb 69                	jmp    8086aa <tcp_enqueue+0x6ca>
  808641:	b8 00 00 00 00       	mov    $0x0,%eax
  808646:	eb 62                	jmp    8086aa <tcp_enqueue+0x6ca>
  if (pcb->snd_queuelen != 0) {
    LWIP_ASSERT("tcp_enqueue: valid queue length", pcb->unacked != NULL ||
      pcb->unsent != NULL);
  }
  LWIP_DEBUGF(TCP_QLEN_DEBUG | LWIP_DBG_STATE, ("tcp_enqueue: %"S16_F" (with mem err)\n", pcb->snd_queuelen));
  return ERR_MEM;
  808648:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80864d:	eb 5b                	jmp    8086aa <tcp_enqueue+0x6ca>
  80864f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  808654:	eb 54                	jmp    8086aa <tcp_enqueue+0x6ca>
  808656:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80865b:	eb 4d                	jmp    8086aa <tcp_enqueue+0x6ca>
  }
  else {
    /* empty list */
    if (useg == NULL) {
      /* initialize list with this segment */
      pcb->unsent = queue;
  80865d:	8b 45 d0             	mov    -0x30(%ebp),%eax
  808660:	89 47 74             	mov    %eax,0x74(%edi)
  808663:	e9 d5 fe ff ff       	jmp    80853d <tcp_enqueue+0x55d>
    }
    /* enqueue segment */
    else {
      useg->next = queue;
  808668:	8b 45 d0             	mov    -0x30(%ebp),%eax
  80866b:	89 06                	mov    %eax,(%esi)
  80866d:	e9 cb fe ff ff       	jmp    80853d <tcp_enqueue+0x55d>
    /* Copy the options into the header, if they are present. */
    if (optdata == NULL) {
      TCPH_HDRLEN_SET(seg->tcphdr, 5);
    }
    else {
      TCPH_HDRLEN_SET(seg->tcphdr, (5 + optlen / 4));
  808672:	c0 e8 02             	shr    $0x2,%al
  808675:	c1 e0 0c             	shl    $0xc,%eax
  808678:	66 05 00 50          	add    $0x5000,%ax
  80867c:	66 89 45 cc          	mov    %ax,-0x34(%ebp)
  808680:	0f b7 45 c4          	movzwl -0x3c(%ebp),%eax
  808684:	66 89 45 e0          	mov    %ax,-0x20(%ebp)

  /* First, break up the data into segments and tuck them together in
   * the local "queue" variable. */
  useg = queue = seg = NULL;
  seglen = 0;
  while (queue == NULL || left > 0) {
  808688:	c6 45 dc 01          	movb   $0x1,-0x24(%ebp)
    /* Copy the options into the header, if they are present. */
    if (optdata == NULL) {
      TCPH_HDRLEN_SET(seg->tcphdr, 5);
    }
    else {
      TCPH_HDRLEN_SET(seg->tcphdr, (5 + optlen / 4));
  80868c:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
  808693:	be 00 00 00 00       	mov    $0x0,%esi
                  (seg->p->len >= optlen));
      queuelen += pbuf_clen(seg->p);
      seg->dataptr = seg->p->payload;
    }
    /* copy from volatile memory? */
    else if (apiflags & TCP_WRITE_FLAG_COPY) {
  808698:	83 e2 01             	and    $0x1,%edx
  80869b:	88 55 ca             	mov    %dl,-0x36(%ebp)
     * ROM or other static memory, and need not be copied. If
     * optdata is != NULL, we have options instead of data. */
     
    /* options? */
    if (optdata != NULL) {
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
  80869e:	0f b6 45 cb          	movzbl -0x35(%ebp),%eax
  8086a2:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  8086a5:	e9 63 fa ff ff       	jmp    80810d <tcp_enqueue+0x12d>
    LWIP_ASSERT("tcp_enqueue: valid queue length", pcb->unacked != NULL ||
      pcb->unsent != NULL);
  }
  LWIP_DEBUGF(TCP_QLEN_DEBUG | LWIP_DBG_STATE, ("tcp_enqueue: %"S16_F" (with mem err)\n", pcb->snd_queuelen));
  return ERR_MEM;
}
  8086aa:	83 c4 4c             	add    $0x4c,%esp
  8086ad:	5b                   	pop    %ebx
  8086ae:	5e                   	pop    %esi
  8086af:	5f                   	pop    %edi
  8086b0:	5d                   	pop    %ebp
  8086b1:	c3                   	ret    

008086b2 <tcp_send_ctrl>:
 * @param flags the flags to set in the segment header
 * @return ERR_OK if sent, another err_t otherwise
 */
err_t
tcp_send_ctrl(struct tcp_pcb *pcb, u8_t flags)
{
  8086b2:	55                   	push   %ebp
  8086b3:	89 e5                	mov    %esp,%ebp
  8086b5:	83 ec 28             	sub    $0x28,%esp
  /* no data, no length, flags, copy=1, no optdata, no optdatalen */
  return tcp_enqueue(pcb, NULL, 0, flags, TCP_WRITE_FLAG_COPY, NULL, 0);
  8086b8:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
  8086bf:	00 
  8086c0:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
  8086c7:	00 
  8086c8:	c7 44 24 10 01 00 00 	movl   $0x1,0x10(%esp)
  8086cf:	00 
  8086d0:	0f b6 45 0c          	movzbl 0xc(%ebp),%eax
  8086d4:	89 44 24 0c          	mov    %eax,0xc(%esp)
  8086d8:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8086df:	00 
  8086e0:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8086e7:	00 
  8086e8:	8b 45 08             	mov    0x8(%ebp),%eax
  8086eb:	89 04 24             	mov    %eax,(%esp)
  8086ee:	e8 ed f8 ff ff       	call   807fe0 <tcp_enqueue>
}
  8086f3:	c9                   	leave  
  8086f4:	c3                   	ret    

008086f5 <tcp_write>:
 * 
 * @see tcp_write()
 */
err_t
tcp_write(struct tcp_pcb *pcb, const void *data, u16_t len, u8_t apiflags)
{
  8086f5:	55                   	push   %ebp
  8086f6:	89 e5                	mov    %esp,%ebp
  8086f8:	56                   	push   %esi
  8086f9:	53                   	push   %ebx
  8086fa:	83 ec 20             	sub    $0x20,%esp
  8086fd:	8b 55 08             	mov    0x8(%ebp),%edx
  808700:	8b 4d 10             	mov    0x10(%ebp),%ecx
  808703:	8b 5d 14             	mov    0x14(%ebp),%ebx
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_write(pcb=%p, data=%p, len=%"U16_F", apiflags=%"U16_F")\n", (void *)pcb,
    data, len, (u16_t)apiflags));
  /* connection is in valid state for data transmission? */
  if (pcb->state == ESTABLISHED ||
  808706:	8b 42 10             	mov    0x10(%edx),%eax
  808709:	83 f8 07             	cmp    $0x7,%eax
  80870c:	74 0d                	je     80871b <tcp_write+0x26>
     pcb->state == CLOSE_WAIT ||
  80870e:	8d 70 fe             	lea    -0x2(%eax),%esi
      return tcp_enqueue(pcb, (void *)data, len, 0, apiflags, NULL, 0);
    }
    return ERR_OK;
  } else {
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_STATE | 3, ("tcp_write() called in invalid state\n"));
    return ERR_CONN;
  808711:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
{
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_write(pcb=%p, data=%p, len=%"U16_F", apiflags=%"U16_F")\n", (void *)pcb,
    data, len, (u16_t)apiflags));
  /* connection is in valid state for data transmission? */
  if (pcb->state == ESTABLISHED ||
     pcb->state == CLOSE_WAIT ||
  808716:	83 fe 02             	cmp    $0x2,%esi
  808719:	77 3f                	ja     80875a <tcp_write+0x65>
     pcb->state == SYN_SENT ||
     pcb->state == SYN_RCVD) {
    if (len > 0) {
      return tcp_enqueue(pcb, (void *)data, len, 0, apiflags, NULL, 0);
    }
    return ERR_OK;
  80871b:	b8 00 00 00 00       	mov    $0x0,%eax
  /* connection is in valid state for data transmission? */
  if (pcb->state == ESTABLISHED ||
     pcb->state == CLOSE_WAIT ||
     pcb->state == SYN_SENT ||
     pcb->state == SYN_RCVD) {
    if (len > 0) {
  808720:	66 85 c9             	test   %cx,%cx
  808723:	74 35                	je     80875a <tcp_write+0x65>
      return tcp_enqueue(pcb, (void *)data, len, 0, apiflags, NULL, 0);
  808725:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
  80872c:	00 
  80872d:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
  808734:	00 
  808735:	0f b6 db             	movzbl %bl,%ebx
  808738:	89 5c 24 10          	mov    %ebx,0x10(%esp)
  80873c:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  808743:	00 
  808744:	0f b7 c9             	movzwl %cx,%ecx
  808747:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  80874b:	8b 45 0c             	mov    0xc(%ebp),%eax
  80874e:	89 44 24 04          	mov    %eax,0x4(%esp)
  808752:	89 14 24             	mov    %edx,(%esp)
  808755:	e8 86 f8 ff ff       	call   807fe0 <tcp_enqueue>
    return ERR_OK;
  } else {
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_STATE | 3, ("tcp_write() called in invalid state\n"));
    return ERR_CONN;
  }
}
  80875a:	83 c4 20             	add    $0x20,%esp
  80875d:	5b                   	pop    %ebx
  80875e:	5e                   	pop    %esi
  80875f:	5d                   	pop    %ebp
  808760:	c3                   	ret    

00808761 <tcp_output>:
 * @return ERR_OK if data has been sent or nothing to send
 *         another err_t on error
 */
err_t
tcp_output(struct tcp_pcb *pcb)
{
  808761:	55                   	push   %ebp
  808762:	89 e5                	mov    %esp,%ebp
  808764:	57                   	push   %edi
  808765:	56                   	push   %esi
  808766:	53                   	push   %ebx
  808767:	83 ec 3c             	sub    $0x3c,%esp
  80876a:	8b 7d 08             	mov    0x8(%ebp),%edi

  /* First, check if we are invoked by the TCP input processing
     code. If so, we do not output anything. Instead, we rely on the
     input processing code to call us when input processing is done
     with. */
  if (tcp_input_pcb == pcb) {
  80876d:	39 3d 78 c2 b3 00    	cmp    %edi,0xb3c278
  808773:	0f 84 53 04 00 00    	je     808bcc <tcp_output+0x46b>
    return ERR_OK;
  }

  wnd = LWIP_MIN(pcb->snd_wnd, pcb->cwnd);
  808779:	0f b7 47 4e          	movzwl 0x4e(%edi),%eax
  80877d:	66 39 47 5c          	cmp    %ax,0x5c(%edi)
  808781:	66 0f 46 47 5c       	cmovbe 0x5c(%edi),%ax
  808786:	0f b7 c0             	movzwl %ax,%eax
  808789:	89 45 d8             	mov    %eax,-0x28(%ebp)

  seg = pcb->unsent;
  80878c:	8b 5f 74             	mov    0x74(%edi),%ebx

  /* useg should point to last segment on unacked queue */
  useg = pcb->unacked;
  80878f:	8b 47 78             	mov    0x78(%edi),%eax
  808792:	89 45 dc             	mov    %eax,-0x24(%ebp)
  if (useg != NULL) {
  808795:	85 c0                	test   %eax,%eax
  808797:	74 0f                	je     8087a8 <tcp_output+0x47>
  808799:	89 c2                	mov    %eax,%edx
    for (; useg->next != NULL; useg = useg->next);
  80879b:	8b 02                	mov    (%edx),%eax
  80879d:	85 c0                	test   %eax,%eax
  80879f:	74 04                	je     8087a5 <tcp_output+0x44>
  8087a1:	89 c2                	mov    %eax,%edx
  8087a3:	eb f6                	jmp    80879b <tcp_output+0x3a>
  8087a5:	89 55 dc             	mov    %edx,-0x24(%ebp)
   * because the ->unsent queue is empty or because the window does
   * not allow it), construct an empty ACK segment and send it.
   *
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
  8087a8:	f6 47 20 02          	testb  $0x2,0x20(%edi)
  8087ac:	74 20                	je     8087ce <tcp_output+0x6d>
  8087ae:	85 db                	test   %ebx,%ebx
  8087b0:	74 27                	je     8087d9 <tcp_output+0x78>
     (seg == NULL ||
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
  8087b2:	8b 43 10             	mov    0x10(%ebx),%eax
  8087b5:	8b 40 04             	mov    0x4(%eax),%eax
  8087b8:	89 04 24             	mov    %eax,(%esp)
  8087bb:	e8 0a f8 ff ff       	call   807fca <ntohl>
  8087c0:	0f b7 53 0c          	movzwl 0xc(%ebx),%edx
  8087c4:	2b 57 48             	sub    0x48(%edi),%edx
  8087c7:	01 d0                	add    %edx,%eax
   * not allow it), construct an empty ACK segment and send it.
   *
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
     (seg == NULL ||
  8087c9:	39 45 d8             	cmp    %eax,-0x28(%ebp)
  8087cc:	72 0b                	jb     8087d9 <tcp_output+0x78>

  seg->p->payload = seg->tcphdr;

  seg->tcphdr->chksum = 0;
#if CHECKSUM_GEN_TCP
  seg->tcphdr->chksum = inet_chksum_pseudo(seg->p,
  8087ce:	8d 47 04             	lea    0x4(%edi),%eax
  8087d1:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  8087d4:	e9 92 03 00 00       	jmp    808b6b <tcp_output+0x40a>
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
     (seg == NULL ||
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
    p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  8087d9:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8087e0:	00 
  8087e1:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  8087e8:	00 
  8087e9:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  8087f0:	e8 e0 c6 ff ff       	call   804ed5 <pbuf_alloc>
  8087f5:	89 c6                	mov    %eax,%esi
    if (p == NULL) {
  8087f7:	85 c0                	test   %eax,%eax
  8087f9:	0f 84 d4 03 00 00    	je     808bd3 <tcp_output+0x472>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: (ACK) could not allocate pbuf\n"));
      return ERR_BUF;
    }
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: sending ACK for %"U32_F"\n", pcb->rcv_nxt));
    /* remove ACK flags from the PCB, as we send an empty ACK now */
    pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
  8087ff:	80 67 20 fc          	andb   $0xfc,0x20(%edi)

    tcphdr = p->payload;
  808803:	8b 58 04             	mov    0x4(%eax),%ebx
    tcphdr->src = htons(pcb->local_port);
  808806:	0f b7 47 1c          	movzwl 0x1c(%edi),%eax
  80880a:	89 04 24             	mov    %eax,(%esp)
  80880d:	e8 64 f5 ff ff       	call   807d76 <htons>
  808812:	66 89 03             	mov    %ax,(%ebx)
    tcphdr->dest = htons(pcb->remote_port);
  808815:	0f b7 47 1e          	movzwl 0x1e(%edi),%eax
  808819:	89 04 24             	mov    %eax,(%esp)
  80881c:	e8 55 f5 ff ff       	call   807d76 <htons>
  808821:	66 89 43 02          	mov    %ax,0x2(%ebx)
    tcphdr->seqno = htonl(pcb->snd_nxt);
  808825:	8b 47 54             	mov    0x54(%edi),%eax
  808828:	89 04 24             	mov    %eax,(%esp)
  80882b:	e8 60 f5 ff ff       	call   807d90 <htonl>
  808830:	89 43 04             	mov    %eax,0x4(%ebx)
    tcphdr->ackno = htonl(pcb->rcv_nxt);
  808833:	8b 47 24             	mov    0x24(%edi),%eax
  808836:	89 04 24             	mov    %eax,(%esp)
  808839:	e8 52 f5 ff ff       	call   807d90 <htonl>
  80883e:	89 43 08             	mov    %eax,0x8(%ebx)
    TCPH_FLAGS_SET(tcphdr, TCP_ACK);
  808841:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  808845:	89 04 24             	mov    %eax,(%esp)
  808848:	e8 36 f5 ff ff       	call   807d83 <ntohs>
  80884d:	25 c0 ff 00 00       	and    $0xffc0,%eax
  808852:	83 c8 10             	or     $0x10,%eax
  808855:	89 04 24             	mov    %eax,(%esp)
  808858:	e8 19 f5 ff ff       	call   807d76 <htons>
  80885d:	66 89 43 0c          	mov    %ax,0xc(%ebx)
    tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  808861:	0f b7 47 2a          	movzwl 0x2a(%edi),%eax
  808865:	89 04 24             	mov    %eax,(%esp)
  808868:	e8 09 f5 ff ff       	call   807d76 <htons>
  80886d:	66 89 43 0e          	mov    %ax,0xe(%ebx)
    tcphdr->urgp = 0;
  808871:	66 c7 43 12 00 00    	movw   $0x0,0x12(%ebx)
    TCPH_HDRLEN_SET(tcphdr, 5);
  808877:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80887b:	89 04 24             	mov    %eax,(%esp)
  80887e:	e8 00 f5 ff ff       	call   807d83 <ntohs>
  808883:	83 e0 3f             	and    $0x3f,%eax
  808886:	80 cc 50             	or     $0x50,%ah
  808889:	89 04 24             	mov    %eax,(%esp)
  80888c:	e8 e5 f4 ff ff       	call   807d76 <htons>
  808891:	66 89 43 0c          	mov    %ax,0xc(%ebx)

    tcphdr->chksum = 0;
  808895:	66 c7 43 10 00 00    	movw   $0x0,0x10(%ebx)
#if CHECKSUM_GEN_TCP
    tcphdr->chksum = inet_chksum_pseudo(p, &(pcb->local_ip), &(pcb->remote_ip),
  80889b:	8d 47 04             	lea    0x4(%edi),%eax
  80889e:	89 c1                	mov    %eax,%ecx
  8088a0:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  8088a4:	89 44 24 10          	mov    %eax,0x10(%esp)
  8088a8:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
  8088af:	00 
  8088b0:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  8088b3:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  8088b7:	89 7c 24 04          	mov    %edi,0x4(%esp)
  8088bb:	89 34 24             	mov    %esi,(%esp)
  8088be:	e8 6b f1 ff ff       	call   807a2e <inet_chksum_pseudo>
  8088c3:	66 89 43 10          	mov    %ax,0x10(%ebx)
                     pcb->tos, IP_PROTO_TCP, netif);
        netif->addr_hint = NULL;
      }
    }
#else /* LWIP_NETIF_HWADDRHINT*/
    ip_output(p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
  8088c7:	c7 44 24 14 06 00 00 	movl   $0x6,0x14(%esp)
  8088ce:	00 
  8088cf:	0f b6 47 0a          	movzbl 0xa(%edi),%eax
  8088d3:	89 44 24 10          	mov    %eax,0x10(%esp)
  8088d7:	0f b6 47 0b          	movzbl 0xb(%edi),%eax
  8088db:	89 44 24 0c          	mov    %eax,0xc(%esp)
  8088df:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8088e2:	89 44 24 08          	mov    %eax,0x8(%esp)
  8088e6:	89 7c 24 04          	mov    %edi,0x4(%esp)
  8088ea:	89 34 24             	mov    %esi,(%esp)
  8088ed:	e8 be e6 ff ff       	call   806fb0 <ip_output>
        IP_PROTO_TCP);
#endif /* LWIP_NETIF_HWADDRHINT*/
    pbuf_free(p);
  8088f2:	89 34 24             	mov    %esi,(%esp)
  8088f5:	e8 fa c4 ff ff       	call   804df4 <pbuf_free>

    return ERR_OK;
  8088fa:	b8 00 00 00 00       	mov    $0x0,%eax
  8088ff:	e9 e9 02 00 00       	jmp    808bed <tcp_output+0x48c>
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
         ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
    LWIP_ASSERT("RST not expected here!", 
  808904:	8b 43 10             	mov    0x10(%ebx),%eax
  808907:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80890b:	89 04 24             	mov    %eax,(%esp)
  80890e:	e8 70 f4 ff ff       	call   807d83 <ntohs>
  808913:	a8 04                	test   $0x4,%al
  808915:	74 1c                	je     808933 <tcp_output+0x1d2>
  808917:	c7 44 24 08 17 30 81 	movl   $0x813017,0x8(%esp)
  80891e:	00 
  80891f:	c7 44 24 04 05 02 00 	movl   $0x205,0x4(%esp)
  808926:	00 
  808927:	c7 04 24 de 2f 81 00 	movl   $0x812fde,(%esp)
  80892e:	e8 47 67 00 00       	call   80f07a <_panic>
     * - if tcp_enqueue had a memory error before (prevent delayed ACK timeout) or
     * - if FIN was already enqueued for this PCB (SYN is always alone in a segment -
     *   either seg->next != NULL or pcb->unacked == NULL;
     *   RST is no sent using tcp_enqueue/tcp_output.
     */
    if((tcp_do_output_nagle(pcb) == 0) &&
  808933:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  808937:	74 1c                	je     808955 <tcp_output+0x1f4>
  808939:	0f b6 47 20          	movzbl 0x20(%edi),%eax
  80893d:	a8 40                	test   $0x40,%al
  80893f:	75 14                	jne    808955 <tcp_output+0x1f4>
  808941:	8b 57 74             	mov    0x74(%edi),%edx
  808944:	85 d2                	test   %edx,%edx
  808946:	0f 84 8e 02 00 00    	je     808bda <tcp_output+0x479>
  80894c:	83 3a 00             	cmpl   $0x0,(%edx)
  80894f:	0f 84 85 02 00 00    	je     808bda <tcp_output+0x479>
                            pcb->lastack,
                            ntohl(seg->tcphdr->seqno), pcb->lastack, i));
    ++i;
#endif /* TCP_CWND_DEBUG */

    pcb->unsent = seg->next;
  808955:	8b 03                	mov    (%ebx),%eax
  808957:	89 47 74             	mov    %eax,0x74(%edi)

    if (pcb->state != SYN_SENT) {
  80895a:	83 7f 10 02          	cmpl   $0x2,0x10(%edi)
  80895e:	74 25                	je     808985 <tcp_output+0x224>
      TCPH_SET_FLAG(seg->tcphdr, TCP_ACK);
  808960:	8b 73 10             	mov    0x10(%ebx),%esi
  808963:	0f b7 46 0c          	movzwl 0xc(%esi),%eax
  808967:	89 04 24             	mov    %eax,(%esp)
  80896a:	e8 14 f4 ff ff       	call   807d83 <ntohs>
  80896f:	83 c8 10             	or     $0x10,%eax
  808972:	0f b7 c0             	movzwl %ax,%eax
  808975:	89 04 24             	mov    %eax,(%esp)
  808978:	e8 f9 f3 ff ff       	call   807d76 <htons>
  80897d:	66 89 46 0c          	mov    %ax,0xc(%esi)
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
  808981:	80 67 20 fc          	andb   $0xfc,0x20(%edi)
  /** @bug Exclude retransmitted segments from this count. */
  snmp_inc_tcpoutsegs();

  /* The TCP header has already been constructed, but the ackno and
   wnd fields remain. */
  seg->tcphdr->ackno = htonl(pcb->rcv_nxt);
  808985:	8b 73 10             	mov    0x10(%ebx),%esi
  808988:	8b 47 24             	mov    0x24(%edi),%eax
  80898b:	89 04 24             	mov    %eax,(%esp)
  80898e:	e8 fd f3 ff ff       	call   807d90 <htonl>
  808993:	89 46 08             	mov    %eax,0x8(%esi)

  /* advertise our receive window size in this TCP segment */
  seg->tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  808996:	8b 73 10             	mov    0x10(%ebx),%esi
  808999:	0f b7 47 2a          	movzwl 0x2a(%edi),%eax
  80899d:	89 04 24             	mov    %eax,(%esp)
  8089a0:	e8 d1 f3 ff ff       	call   807d76 <htons>
  8089a5:	66 89 46 0e          	mov    %ax,0xe(%esi)

  /* If we don't have a local IP address, we get one by
     calling ip_route(). */
  if (ip_addr_isany(&(pcb->local_ip))) {
  8089a9:	85 ff                	test   %edi,%edi
  8089ab:	74 05                	je     8089b2 <tcp_output+0x251>
  8089ad:	83 3f 00             	cmpl   $0x0,(%edi)
  8089b0:	75 27                	jne    8089d9 <tcp_output+0x278>
    netif = ip_route(&(pcb->remote_ip));
  8089b2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8089b5:	89 04 24             	mov    %eax,(%esp)
  8089b8:	e8 23 e1 ff ff       	call   806ae0 <ip_route>
    if (netif == NULL) {
  8089bd:	85 c0                	test   %eax,%eax
  8089bf:	0f 84 c1 00 00 00    	je     808a86 <tcp_output+0x325>
      return;
    }
    ip_addr_set(&(pcb->local_ip), &(netif->ip_addr));
  8089c5:	83 f8 fc             	cmp    $0xfffffffc,%eax
  8089c8:	74 08                	je     8089d2 <tcp_output+0x271>
  8089ca:	8b 40 04             	mov    0x4(%eax),%eax
  8089cd:	8d 76 00             	lea    0x0(%esi),%esi
  8089d0:	eb 05                	jmp    8089d7 <tcp_output+0x276>
  8089d2:	b8 00 00 00 00       	mov    $0x0,%eax
  8089d7:	89 07                	mov    %eax,(%edi)
  }

  /* Set retransmission timer running if it is not currently enabled */
  if(pcb->rtime == -1)
  8089d9:	66 83 7f 32 ff       	cmpw   $0xffff,0x32(%edi)
  8089de:	75 06                	jne    8089e6 <tcp_output+0x285>
    pcb->rtime = 0;
  8089e0:	66 c7 47 32 00 00    	movw   $0x0,0x32(%edi)

  if (pcb->rttest == 0) {
  8089e6:	83 7f 38 00          	cmpl   $0x0,0x38(%edi)
  8089ea:	75 19                	jne    808a05 <tcp_output+0x2a4>
    pcb->rttest = tcp_ticks;
  8089ec:	a1 60 c2 b3 00       	mov    0xb3c260,%eax
  8089f1:	89 47 38             	mov    %eax,0x38(%edi)
    pcb->rtseq = ntohl(seg->tcphdr->seqno);
  8089f4:	8b 43 10             	mov    0x10(%ebx),%eax
  8089f7:	8b 40 04             	mov    0x4(%eax),%eax
  8089fa:	89 04 24             	mov    %eax,(%esp)
  8089fd:	e8 c8 f5 ff ff       	call   807fca <ntohl>
  808a02:	89 47 3c             	mov    %eax,0x3c(%edi)
  }
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output_segment: %"U32_F":%"U32_F"\n",
          htonl(seg->tcphdr->seqno), htonl(seg->tcphdr->seqno) +
          seg->len));

  len = (u16_t)((u8_t *)seg->tcphdr - (u8_t *)seg->p->payload);
  808a05:	8b 43 04             	mov    0x4(%ebx),%eax
  808a08:	8b 53 10             	mov    0x10(%ebx),%edx
  808a0b:	2b 50 04             	sub    0x4(%eax),%edx

  seg->p->len -= len;
  808a0e:	66 29 50 0a          	sub    %dx,0xa(%eax)
  seg->p->tot_len -= len;
  808a12:	8b 43 04             	mov    0x4(%ebx),%eax
  808a15:	66 29 50 08          	sub    %dx,0x8(%eax)

  seg->p->payload = seg->tcphdr;
  808a19:	8b 43 04             	mov    0x4(%ebx),%eax
  808a1c:	8b 53 10             	mov    0x10(%ebx),%edx
  808a1f:	89 50 04             	mov    %edx,0x4(%eax)

  seg->tcphdr->chksum = 0;
  808a22:	8b 43 10             	mov    0x10(%ebx),%eax
  808a25:	66 c7 40 10 00 00    	movw   $0x0,0x10(%eax)
#if CHECKSUM_GEN_TCP
  seg->tcphdr->chksum = inet_chksum_pseudo(seg->p,
  808a2b:	8b 73 10             	mov    0x10(%ebx),%esi
             &(pcb->local_ip),
             &(pcb->remote_ip),
             IP_PROTO_TCP, seg->p->tot_len);
  808a2e:	8b 43 04             	mov    0x4(%ebx),%eax

  seg->p->payload = seg->tcphdr;

  seg->tcphdr->chksum = 0;
#if CHECKSUM_GEN_TCP
  seg->tcphdr->chksum = inet_chksum_pseudo(seg->p,
  808a31:	0f b7 50 08          	movzwl 0x8(%eax),%edx
  808a35:	89 54 24 10          	mov    %edx,0x10(%esp)
  808a39:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
  808a40:	00 
  808a41:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  808a44:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  808a48:	89 7c 24 04          	mov    %edi,0x4(%esp)
  808a4c:	89 04 24             	mov    %eax,(%esp)
  808a4f:	e8 da ef ff ff       	call   807a2e <inet_chksum_pseudo>
  808a54:	66 89 46 10          	mov    %ax,0x10(%esi)
                   pcb->tos, IP_PROTO_TCP, netif);
      netif->addr_hint = NULL;
    }
  }
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(seg->p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
  808a58:	c7 44 24 14 06 00 00 	movl   $0x6,0x14(%esp)
  808a5f:	00 
  808a60:	0f b6 47 0a          	movzbl 0xa(%edi),%eax
  808a64:	89 44 24 10          	mov    %eax,0x10(%esp)
  808a68:	0f b6 47 0b          	movzbl 0xb(%edi),%eax
  808a6c:	89 44 24 0c          	mov    %eax,0xc(%esp)
  808a70:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  808a73:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  808a77:	89 7c 24 04          	mov    %edi,0x4(%esp)
  808a7b:	8b 43 04             	mov    0x4(%ebx),%eax
  808a7e:	89 04 24             	mov    %eax,(%esp)
  808a81:	e8 2a e5 ff ff       	call   806fb0 <ip_output>
      TCPH_SET_FLAG(seg->tcphdr, TCP_ACK);
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
    }

    tcp_output_segment(seg, pcb);
    pcb->snd_nxt = ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);
  808a86:	8b 43 10             	mov    0x10(%ebx),%eax
  808a89:	8b 40 04             	mov    0x4(%eax),%eax
  808a8c:	89 04 24             	mov    %eax,(%esp)
  808a8f:	e8 36 f5 ff ff       	call   807fca <ntohl>
  808a94:	89 45 e0             	mov    %eax,-0x20(%ebp)
  808a97:	0f b7 73 0c          	movzwl 0xc(%ebx),%esi
  808a9b:	8b 43 10             	mov    0x10(%ebx),%eax
  808a9e:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  808aa2:	89 04 24             	mov    %eax,(%esp)
  808aa5:	e8 d9 f2 ff ff       	call   807d83 <ntohs>
  808aaa:	ba 01 00 00 00       	mov    $0x1,%edx
  808aaf:	a8 01                	test   $0x1,%al
  808ab1:	75 17                	jne    808aca <tcp_output+0x369>
  808ab3:	8b 43 10             	mov    0x10(%ebx),%eax
  808ab6:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  808aba:	89 04 24             	mov    %eax,(%esp)
  808abd:	e8 c1 f2 ff ff       	call   807d83 <ntohs>
  808ac2:	66 d1 e8             	shr    %ax
  808ac5:	89 c2                	mov    %eax,%edx
  808ac7:	83 e2 01             	and    $0x1,%edx
  808aca:	01 d6                	add    %edx,%esi
  808acc:	03 75 e0             	add    -0x20(%ebp),%esi
  808acf:	89 77 54             	mov    %esi,0x54(%edi)
    if (TCP_SEQ_LT(pcb->snd_max, pcb->snd_nxt)) {
  808ad2:	39 77 58             	cmp    %esi,0x58(%edi)
  808ad5:	79 03                	jns    808ada <tcp_output+0x379>
      pcb->snd_max = pcb->snd_nxt;
  808ad7:	89 77 58             	mov    %esi,0x58(%edi)
    }
    /* put segment on unacknowledged list if length > 0 */
    if (TCP_TCPLEN(seg) > 0) {
  808ada:	0f b7 73 0c          	movzwl 0xc(%ebx),%esi
  808ade:	8b 43 10             	mov    0x10(%ebx),%eax
  808ae1:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  808ae5:	89 04 24             	mov    %eax,(%esp)
  808ae8:	e8 96 f2 ff ff       	call   807d83 <ntohs>
  808aed:	ba 01 00 00 00       	mov    $0x1,%edx
  808af2:	a8 01                	test   $0x1,%al
  808af4:	75 17                	jne    808b0d <tcp_output+0x3ac>
  808af6:	8b 43 10             	mov    0x10(%ebx),%eax
  808af9:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  808afd:	89 04 24             	mov    %eax,(%esp)
  808b00:	e8 7e f2 ff ff       	call   807d83 <ntohs>
  808b05:	66 d1 e8             	shr    %ax
  808b08:	89 c2                	mov    %eax,%edx
  808b0a:	83 e2 01             	and    $0x1,%edx
  808b0d:	01 d6                	add    %edx,%esi
  808b0f:	85 f6                	test   %esi,%esi
  808b11:	7e 4d                	jle    808b60 <tcp_output+0x3ff>
      seg->next = NULL;
  808b13:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
      /* unacked list is empty? */
      if (pcb->unacked == NULL) {
  808b19:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  808b1d:	75 08                	jne    808b27 <tcp_output+0x3c6>
        pcb->unacked = seg;
  808b1f:	89 5f 78             	mov    %ebx,0x78(%edi)
  808b22:	89 5d dc             	mov    %ebx,-0x24(%ebp)
  808b25:	eb 41                	jmp    808b68 <tcp_output+0x407>
      /* unacked list is not empty? */
      } else {
        /* In the case of fast retransmit, the packet should not go to the tail
         * of the unacked queue, but rather at the head. We need to check for
         * this case. -STJ Jul 27, 2004 */
        if (TCP_SEQ_LT(ntohl(seg->tcphdr->seqno), ntohl(useg->tcphdr->seqno))){
  808b27:	8b 43 10             	mov    0x10(%ebx),%eax
  808b2a:	8b 40 04             	mov    0x4(%eax),%eax
  808b2d:	89 04 24             	mov    %eax,(%esp)
  808b30:	e8 95 f4 ff ff       	call   807fca <ntohl>
  808b35:	89 c6                	mov    %eax,%esi
  808b37:	8b 45 dc             	mov    -0x24(%ebp),%eax
  808b3a:	8b 40 10             	mov    0x10(%eax),%eax
  808b3d:	8b 40 04             	mov    0x4(%eax),%eax
  808b40:	89 04 24             	mov    %eax,(%esp)
  808b43:	e8 82 f4 ff ff       	call   807fca <ntohl>
  808b48:	39 c6                	cmp    %eax,%esi
  808b4a:	79 0a                	jns    808b56 <tcp_output+0x3f5>
          /* add segment to head of unacked list */
          seg->next = pcb->unacked;
  808b4c:	8b 47 78             	mov    0x78(%edi),%eax
  808b4f:	89 03                	mov    %eax,(%ebx)
          pcb->unacked = seg;
  808b51:	89 5f 78             	mov    %ebx,0x78(%edi)
  808b54:	eb 12                	jmp    808b68 <tcp_output+0x407>
        } else {
          /* add segment to tail of unacked list */
          useg->next = seg;
  808b56:	8b 45 dc             	mov    -0x24(%ebp),%eax
  808b59:	89 18                	mov    %ebx,(%eax)
  808b5b:	89 5d dc             	mov    %ebx,-0x24(%ebp)
  808b5e:	eb 08                	jmp    808b68 <tcp_output+0x407>
          useg = useg->next;
        }
      }
    /* do not queue empty segments on the unacked list */
    } else {
      tcp_seg_free(seg);
  808b60:	89 1c 24             	mov    %ebx,(%esp)
  808b63:	e8 61 d2 ff ff       	call   805dc9 <tcp_seg_free>
    }
    seg = pcb->unsent;
  808b68:	8b 5f 74             	mov    0x74(%edi),%ebx
                 ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,
                 ntohl(seg->tcphdr->seqno), pcb->lastack));
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
  808b6b:	85 db                	test   %ebx,%ebx
  808b6d:	74 52                	je     808bc1 <tcp_output+0x460>
         ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
  808b6f:	8b 43 10             	mov    0x10(%ebx),%eax
  808b72:	8b 40 04             	mov    0x4(%eax),%eax
  808b75:	89 04 24             	mov    %eax,(%esp)
  808b78:	e8 4d f4 ff ff       	call   807fca <ntohl>
  808b7d:	0f b7 53 0c          	movzwl 0xc(%ebx),%edx
  808b81:	2b 57 48             	sub    0x48(%edi),%edx
  808b84:	01 d0                	add    %edx,%eax
                 ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,
                 ntohl(seg->tcphdr->seqno), pcb->lastack));
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
  808b86:	39 45 d8             	cmp    %eax,-0x28(%ebp)
  808b89:	0f 83 75 fd ff ff    	jae    808904 <tcp_output+0x1a3>
  808b8f:	eb 51                	jmp    808be2 <tcp_output+0x481>
    }
    seg = pcb->unsent;
  }

  if (seg != NULL && pcb->persist_backoff == 0 && 
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > pcb->snd_wnd) {
  808b91:	8b 43 10             	mov    0x10(%ebx),%eax
  808b94:	8b 40 04             	mov    0x4(%eax),%eax
  808b97:	89 04 24             	mov    %eax,(%esp)
  808b9a:	e8 2b f4 ff ff       	call   807fca <ntohl>
  808b9f:	0f b7 53 0c          	movzwl 0xc(%ebx),%edx
  808ba3:	2b 57 48             	sub    0x48(%edi),%edx
  808ba6:	01 c2                	add    %eax,%edx
  808ba8:	0f b7 47 5c          	movzwl 0x5c(%edi),%eax
      tcp_seg_free(seg);
    }
    seg = pcb->unsent;
  }

  if (seg != NULL && pcb->persist_backoff == 0 && 
  808bac:	39 c2                	cmp    %eax,%edx
  808bae:	76 11                	jbe    808bc1 <tcp_output+0x460>
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > pcb->snd_wnd) {
    /* prepare for persist timer */
    pcb->persist_cnt = 0;
  808bb0:	c7 87 a0 00 00 00 00 	movl   $0x0,0xa0(%edi)
  808bb7:	00 00 00 
    pcb->persist_backoff = 1;
  808bba:	c6 87 a4 00 00 00 01 	movb   $0x1,0xa4(%edi)
  }

  pcb->flags &= ~TF_NAGLEMEMERR;
  808bc1:	80 67 20 7f          	andb   $0x7f,0x20(%edi)
  return ERR_OK;
  808bc5:	b8 00 00 00 00       	mov    $0x0,%eax
  808bca:	eb 21                	jmp    808bed <tcp_output+0x48c>
  /* First, check if we are invoked by the TCP input processing
     code. If so, we do not output anything. Instead, we rely on the
     input processing code to call us when input processing is done
     with. */
  if (tcp_input_pcb == pcb) {
    return ERR_OK;
  808bcc:	b8 00 00 00 00       	mov    $0x0,%eax
  808bd1:	eb 1a                	jmp    808bed <tcp_output+0x48c>
     (seg == NULL ||
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
    p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
    if (p == NULL) {
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: (ACK) could not allocate pbuf\n"));
      return ERR_BUF;
  808bd3:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  808bd8:	eb 13                	jmp    808bed <tcp_output+0x48c>
     * - if tcp_enqueue had a memory error before (prevent delayed ACK timeout) or
     * - if FIN was already enqueued for this PCB (SYN is always alone in a segment -
     *   either seg->next != NULL or pcb->unacked == NULL;
     *   RST is no sent using tcp_enqueue/tcp_output.
     */
    if((tcp_do_output_nagle(pcb) == 0) &&
  808bda:	a8 a0                	test   $0xa0,%al
  808bdc:	0f 85 73 fd ff ff    	jne    808955 <tcp_output+0x1f4>
      tcp_seg_free(seg);
    }
    seg = pcb->unsent;
  }

  if (seg != NULL && pcb->persist_backoff == 0 && 
  808be2:	80 bf a4 00 00 00 00 	cmpb   $0x0,0xa4(%edi)
  808be9:	75 d6                	jne    808bc1 <tcp_output+0x460>
  808beb:	eb a4                	jmp    808b91 <tcp_output+0x430>
    pcb->persist_backoff = 1;
  }

  pcb->flags &= ~TF_NAGLEMEMERR;
  return ERR_OK;
}
  808bed:	83 c4 3c             	add    $0x3c,%esp
  808bf0:	5b                   	pop    %ebx
  808bf1:	5e                   	pop    %esi
  808bf2:	5f                   	pop    %edi
  808bf3:	5d                   	pop    %ebp
  808bf4:	c3                   	ret    

00808bf5 <tcp_rst>:
 */
void
tcp_rst(u32_t seqno, u32_t ackno,
  struct ip_addr *local_ip, struct ip_addr *remote_ip,
  u16_t local_port, u16_t remote_port)
{
  808bf5:	55                   	push   %ebp
  808bf6:	89 e5                	mov    %esp,%ebp
  808bf8:	57                   	push   %edi
  808bf9:	56                   	push   %esi
  808bfa:	53                   	push   %ebx
  808bfb:	83 ec 2c             	sub    $0x2c,%esp
  808bfe:	8b 7d 18             	mov    0x18(%ebp),%edi
  808c01:	8b 45 1c             	mov    0x1c(%ebp),%eax
  808c04:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  struct pbuf *p;
  struct tcp_hdr *tcphdr;
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  808c07:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  808c0e:	00 
  808c0f:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  808c16:	00 
  808c17:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  808c1e:	e8 b2 c2 ff ff       	call   804ed5 <pbuf_alloc>
  808c23:	89 c6                	mov    %eax,%esi
  if (p == NULL) {
  808c25:	85 c0                	test   %eax,%eax
  808c27:	0f 84 1a 01 00 00    	je     808d47 <tcp_rst+0x152>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_rst: could not allocate memory for pbuf\n"));
      return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  808c2d:	66 83 78 0a 13       	cmpw   $0x13,0xa(%eax)
  808c32:	77 1c                	ja     808c50 <tcp_rst+0x5b>
  808c34:	c7 44 24 08 b0 2f 81 	movl   $0x812fb0,0x8(%esp)
  808c3b:	00 
  808c3c:	c7 44 24 04 be 02 00 	movl   $0x2be,0x4(%esp)
  808c43:	00 
  808c44:	c7 04 24 de 2f 81 00 	movl   $0x812fde,(%esp)
  808c4b:	e8 2a 64 00 00       	call   80f07a <_panic>
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = p->payload;
  808c50:	8b 58 04             	mov    0x4(%eax),%ebx
  tcphdr->src = htons(local_port);
  808c53:	0f b7 ff             	movzwl %di,%edi
  808c56:	89 3c 24             	mov    %edi,(%esp)
  808c59:	e8 18 f1 ff ff       	call   807d76 <htons>
  808c5e:	66 89 03             	mov    %ax,(%ebx)
  tcphdr->dest = htons(remote_port);
  808c61:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  808c65:	89 04 24             	mov    %eax,(%esp)
  808c68:	e8 09 f1 ff ff       	call   807d76 <htons>
  808c6d:	66 89 43 02          	mov    %ax,0x2(%ebx)
  tcphdr->seqno = htonl(seqno);
  808c71:	8b 45 08             	mov    0x8(%ebp),%eax
  808c74:	89 04 24             	mov    %eax,(%esp)
  808c77:	e8 14 f1 ff ff       	call   807d90 <htonl>
  808c7c:	89 43 04             	mov    %eax,0x4(%ebx)
  tcphdr->ackno = htonl(ackno);
  808c7f:	8b 45 0c             	mov    0xc(%ebp),%eax
  808c82:	89 04 24             	mov    %eax,(%esp)
  808c85:	e8 06 f1 ff ff       	call   807d90 <htonl>
  808c8a:	89 43 08             	mov    %eax,0x8(%ebx)
  TCPH_FLAGS_SET(tcphdr, TCP_RST | TCP_ACK);
  808c8d:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  808c91:	89 04 24             	mov    %eax,(%esp)
  808c94:	e8 ea f0 ff ff       	call   807d83 <ntohs>
  808c99:	25 c0 ff 00 00       	and    $0xffc0,%eax
  808c9e:	83 c8 14             	or     $0x14,%eax
  808ca1:	89 04 24             	mov    %eax,(%esp)
  808ca4:	e8 cd f0 ff ff       	call   807d76 <htons>
  808ca9:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  tcphdr->wnd = htons(TCP_WND);
  808cad:	c7 04 24 c0 5d 00 00 	movl   $0x5dc0,(%esp)
  808cb4:	e8 bd f0 ff ff       	call   807d76 <htons>
  808cb9:	66 89 43 0e          	mov    %ax,0xe(%ebx)
  tcphdr->urgp = 0;
  808cbd:	66 c7 43 12 00 00    	movw   $0x0,0x12(%ebx)
  TCPH_HDRLEN_SET(tcphdr, 5);
  808cc3:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  808cc7:	89 04 24             	mov    %eax,(%esp)
  808cca:	e8 b4 f0 ff ff       	call   807d83 <ntohs>
  808ccf:	83 e0 3f             	and    $0x3f,%eax
  808cd2:	80 cc 50             	or     $0x50,%ah
  808cd5:	89 04 24             	mov    %eax,(%esp)
  808cd8:	e8 99 f0 ff ff       	call   807d76 <htons>
  808cdd:	66 89 43 0c          	mov    %ax,0xc(%ebx)

  tcphdr->chksum = 0;
  808ce1:	66 c7 43 10 00 00    	movw   $0x0,0x10(%ebx)
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, local_ip, remote_ip,
  808ce7:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  808ceb:	89 44 24 10          	mov    %eax,0x10(%esp)
  808cef:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
  808cf6:	00 
  808cf7:	8b 45 14             	mov    0x14(%ebp),%eax
  808cfa:	89 44 24 08          	mov    %eax,0x8(%esp)
  808cfe:	8b 45 10             	mov    0x10(%ebp),%eax
  808d01:	89 44 24 04          	mov    %eax,0x4(%esp)
  808d05:	89 34 24             	mov    %esi,(%esp)
  808d08:	e8 21 ed ff ff       	call   807a2e <inet_chksum_pseudo>
  808d0d:	66 89 43 10          	mov    %ax,0x10(%ebx)
              IP_PROTO_TCP, p->tot_len);
#endif
  TCP_STATS_INC(tcp.xmit);
  snmp_inc_tcpoutrsts();
   /* Send output with hardcoded TTL since we have no access to the pcb */
  ip_output(p, local_ip, remote_ip, TCP_TTL, 0, IP_PROTO_TCP);
  808d11:	c7 44 24 14 06 00 00 	movl   $0x6,0x14(%esp)
  808d18:	00 
  808d19:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  808d20:	00 
  808d21:	c7 44 24 0c ff 00 00 	movl   $0xff,0xc(%esp)
  808d28:	00 
  808d29:	8b 45 14             	mov    0x14(%ebp),%eax
  808d2c:	89 44 24 08          	mov    %eax,0x8(%esp)
  808d30:	8b 45 10             	mov    0x10(%ebp),%eax
  808d33:	89 44 24 04          	mov    %eax,0x4(%esp)
  808d37:	89 34 24             	mov    %esi,(%esp)
  808d3a:	e8 71 e2 ff ff       	call   806fb0 <ip_output>
  pbuf_free(p);
  808d3f:	89 34 24             	mov    %esi,(%esp)
  808d42:	e8 ad c0 ff ff       	call   804df4 <pbuf_free>
  LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_rst: seqno %"U32_F" ackno %"U32_F".\n", seqno, ackno));
}
  808d47:	83 c4 2c             	add    $0x2c,%esp
  808d4a:	5b                   	pop    %ebx
  808d4b:	5e                   	pop    %esi
  808d4c:	5f                   	pop    %edi
  808d4d:	5d                   	pop    %ebp
  808d4e:	c3                   	ret    

00808d4f <tcp_rexmit_rto>:
 *
 * @param pcb the tcp_pcb for which to re-enqueue all unacked segments
 */
void
tcp_rexmit_rto(struct tcp_pcb *pcb)
{
  808d4f:	55                   	push   %ebp
  808d50:	89 e5                	mov    %esp,%ebp
  808d52:	53                   	push   %ebx
  808d53:	83 ec 14             	sub    $0x14,%esp
  808d56:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct tcp_seg *seg;

  if (pcb->unacked == NULL) {
  808d59:	8b 53 78             	mov    0x78(%ebx),%edx
  808d5c:	85 d2                	test   %edx,%edx
  808d5e:	74 40                	je     808da0 <tcp_rexmit_rto+0x51>
    return;
  }

  /* Move all unacked segments to the head of the unsent queue */
  for (seg = pcb->unacked; seg->next != NULL; seg = seg->next);
  808d60:	8b 02                	mov    (%edx),%eax
  808d62:	85 c0                	test   %eax,%eax
  808d64:	74 04                	je     808d6a <tcp_rexmit_rto+0x1b>
  808d66:	89 c2                	mov    %eax,%edx
  808d68:	eb f6                	jmp    808d60 <tcp_rexmit_rto+0x11>
  /* concatenate unsent queue after unacked queue */
  seg->next = pcb->unsent;
  808d6a:	8b 43 74             	mov    0x74(%ebx),%eax
  808d6d:	89 02                	mov    %eax,(%edx)
  /* unsent queue is the concatenated queue (of unacked, unsent) */
  pcb->unsent = pcb->unacked;
  808d6f:	8b 43 78             	mov    0x78(%ebx),%eax
  808d72:	89 43 74             	mov    %eax,0x74(%ebx)
  /* unacked queue is now empty */
  pcb->unacked = NULL;
  808d75:	c7 43 78 00 00 00 00 	movl   $0x0,0x78(%ebx)

  pcb->snd_nxt = ntohl(pcb->unsent->tcphdr->seqno);
  808d7c:	8b 40 10             	mov    0x10(%eax),%eax
  808d7f:	8b 40 04             	mov    0x4(%eax),%eax
  808d82:	89 04 24             	mov    %eax,(%esp)
  808d85:	e8 40 f2 ff ff       	call   807fca <ntohl>
  808d8a:	89 43 54             	mov    %eax,0x54(%ebx)
  /* increment number of retransmissions */
  ++pcb->nrtx;
  808d8d:	80 43 46 01          	addb   $0x1,0x46(%ebx)

  /* Don't take any RTT measurements after retransmitting. */
  pcb->rttest = 0;
  808d91:	c7 43 38 00 00 00 00 	movl   $0x0,0x38(%ebx)

  /* Do the actual retransmission */
  tcp_output(pcb);
  808d98:	89 1c 24             	mov    %ebx,(%esp)
  808d9b:	e8 c1 f9 ff ff       	call   808761 <tcp_output>
}
  808da0:	83 c4 14             	add    $0x14,%esp
  808da3:	5b                   	pop    %ebx
  808da4:	5d                   	pop    %ebp
  808da5:	c3                   	ret    

00808da6 <tcp_rexmit>:
 *
 * @param pcb the tcp_pcb for which to retransmit the first unacked segment
 */
void
tcp_rexmit(struct tcp_pcb *pcb)
{
  808da6:	55                   	push   %ebp
  808da7:	89 e5                	mov    %esp,%ebp
  808da9:	53                   	push   %ebx
  808daa:	83 ec 14             	sub    $0x14,%esp
  808dad:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct tcp_seg *seg;

  if (pcb->unacked == NULL) {
  808db0:	8b 43 78             	mov    0x78(%ebx),%eax
  808db3:	85 c0                	test   %eax,%eax
  808db5:	74 34                	je     808deb <tcp_rexmit+0x45>
    return;
  }

  /* Move the first unacked segment to the unsent queue */
  seg = pcb->unacked->next;
  808db7:	8b 10                	mov    (%eax),%edx
  pcb->unacked->next = pcb->unsent;
  808db9:	8b 4b 74             	mov    0x74(%ebx),%ecx
  808dbc:	89 08                	mov    %ecx,(%eax)
  pcb->unsent = pcb->unacked;
  808dbe:	8b 43 78             	mov    0x78(%ebx),%eax
  808dc1:	89 43 74             	mov    %eax,0x74(%ebx)
  pcb->unacked = seg;
  808dc4:	89 53 78             	mov    %edx,0x78(%ebx)

  pcb->snd_nxt = ntohl(pcb->unsent->tcphdr->seqno);
  808dc7:	8b 40 10             	mov    0x10(%eax),%eax
  808dca:	8b 40 04             	mov    0x4(%eax),%eax
  808dcd:	89 04 24             	mov    %eax,(%esp)
  808dd0:	e8 f5 f1 ff ff       	call   807fca <ntohl>
  808dd5:	89 43 54             	mov    %eax,0x54(%ebx)

  ++pcb->nrtx;
  808dd8:	80 43 46 01          	addb   $0x1,0x46(%ebx)

  /* Don't take any rtt measurements after retransmitting. */
  pcb->rttest = 0;
  808ddc:	c7 43 38 00 00 00 00 	movl   $0x0,0x38(%ebx)

  /* Do the actual retransmission. */
  snmp_inc_tcpretranssegs();
  tcp_output(pcb);
  808de3:	89 1c 24             	mov    %ebx,(%esp)
  808de6:	e8 76 f9 ff ff       	call   808761 <tcp_output>
}
  808deb:	83 c4 14             	add    $0x14,%esp
  808dee:	5b                   	pop    %ebx
  808def:	5d                   	pop    %ebp
  808df0:	c3                   	ret    

00808df1 <tcp_keepalive>:
 *
 * @param pcb the tcp_pcb for which to send a keepalive packet
 */
void
tcp_keepalive(struct tcp_pcb *pcb)
{
  808df1:	55                   	push   %ebp
  808df2:	89 e5                	mov    %esp,%ebp
  808df4:	57                   	push   %edi
  808df5:	56                   	push   %esi
  808df6:	53                   	push   %ebx
  808df7:	83 ec 2c             	sub    $0x2c,%esp
  808dfa:	8b 75 08             	mov    0x8(%ebp),%esi
                          ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip)));

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: tcp_ticks %"U32_F"   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
                          tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));
   
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  808dfd:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  808e04:	00 
  808e05:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  808e0c:	00 
  808e0d:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  808e14:	e8 bc c0 ff ff       	call   804ed5 <pbuf_alloc>
  808e19:	89 c7                	mov    %eax,%edi
   
  if(p == NULL) {
  808e1b:	85 c0                	test   %eax,%eax
  808e1d:	0f 84 1a 01 00 00    	je     808f3d <tcp_keepalive+0x14c>
    LWIP_DEBUGF(TCP_DEBUG, 
                ("tcp_keepalive: could not allocate memory for pbuf\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  808e23:	66 83 78 0a 13       	cmpw   $0x13,0xa(%eax)
  808e28:	77 1c                	ja     808e46 <tcp_keepalive+0x55>
  808e2a:	c7 44 24 08 b0 2f 81 	movl   $0x812fb0,0x8(%esp)
  808e31:	00 
  808e32:	c7 44 24 04 3a 03 00 	movl   $0x33a,0x4(%esp)
  808e39:	00 
  808e3a:	c7 04 24 de 2f 81 00 	movl   $0x812fde,(%esp)
  808e41:	e8 34 62 00 00       	call   80f07a <_panic>
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = p->payload;
  808e46:	8b 58 04             	mov    0x4(%eax),%ebx
  tcphdr->src = htons(pcb->local_port);
  808e49:	0f b7 46 1c          	movzwl 0x1c(%esi),%eax
  808e4d:	89 04 24             	mov    %eax,(%esp)
  808e50:	e8 21 ef ff ff       	call   807d76 <htons>
  808e55:	66 89 03             	mov    %ax,(%ebx)
  tcphdr->dest = htons(pcb->remote_port);
  808e58:	0f b7 46 1e          	movzwl 0x1e(%esi),%eax
  808e5c:	89 04 24             	mov    %eax,(%esp)
  808e5f:	e8 12 ef ff ff       	call   807d76 <htons>
  808e64:	66 89 43 02          	mov    %ax,0x2(%ebx)
  tcphdr->seqno = htonl(pcb->snd_nxt - 1);
  808e68:	8b 46 54             	mov    0x54(%esi),%eax
  808e6b:	83 e8 01             	sub    $0x1,%eax
  808e6e:	89 04 24             	mov    %eax,(%esp)
  808e71:	e8 1a ef ff ff       	call   807d90 <htonl>
  808e76:	89 43 04             	mov    %eax,0x4(%ebx)
  tcphdr->ackno = htonl(pcb->rcv_nxt);
  808e79:	8b 46 24             	mov    0x24(%esi),%eax
  808e7c:	89 04 24             	mov    %eax,(%esp)
  808e7f:	e8 0c ef ff ff       	call   807d90 <htonl>
  808e84:	89 43 08             	mov    %eax,0x8(%ebx)
  TCPH_FLAGS_SET(tcphdr, 0);
  808e87:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  808e8b:	89 04 24             	mov    %eax,(%esp)
  808e8e:	e8 f0 ee ff ff       	call   807d83 <ntohs>
  808e93:	25 c0 ff 00 00       	and    $0xffc0,%eax
  808e98:	89 04 24             	mov    %eax,(%esp)
  808e9b:	e8 d6 ee ff ff       	call   807d76 <htons>
  808ea0:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  808ea4:	0f b7 46 2a          	movzwl 0x2a(%esi),%eax
  808ea8:	89 04 24             	mov    %eax,(%esp)
  808eab:	e8 c6 ee ff ff       	call   807d76 <htons>
  808eb0:	66 89 43 0e          	mov    %ax,0xe(%ebx)
  tcphdr->urgp = 0;
  808eb4:	66 c7 43 12 00 00    	movw   $0x0,0x12(%ebx)
  TCPH_HDRLEN_SET(tcphdr, 5);
  808eba:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  808ebe:	89 04 24             	mov    %eax,(%esp)
  808ec1:	e8 bd ee ff ff       	call   807d83 <ntohs>
  808ec6:	83 e0 3f             	and    $0x3f,%eax
  808ec9:	80 cc 50             	or     $0x50,%ah
  808ecc:	89 04 24             	mov    %eax,(%esp)
  808ecf:	e8 a2 ee ff ff       	call   807d76 <htons>
  808ed4:	66 89 43 0c          	mov    %ax,0xc(%ebx)

  tcphdr->chksum = 0;
  808ed8:	66 c7 43 10 00 00    	movw   $0x0,0x10(%ebx)
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
  808ede:	8d 46 04             	lea    0x4(%esi),%eax
  808ee1:	89 c2                	mov    %eax,%edx
  808ee3:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  808ee7:	89 44 24 10          	mov    %eax,0x10(%esp)
  808eeb:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
  808ef2:	00 
  808ef3:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  808ef6:	89 54 24 08          	mov    %edx,0x8(%esp)
  808efa:	89 74 24 04          	mov    %esi,0x4(%esp)
  808efe:	89 3c 24             	mov    %edi,(%esp)
  808f01:	e8 28 eb ff ff       	call   807a2e <inet_chksum_pseudo>
  808f06:	66 89 43 10          	mov    %ax,0x10(%ebx)
                   0, IP_PROTO_TCP, netif);
      netif->addr_hint = NULL;
    }
  }
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
  808f0a:	c7 44 24 14 06 00 00 	movl   $0x6,0x14(%esp)
  808f11:	00 
  808f12:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  808f19:	00 
  808f1a:	0f b6 46 0b          	movzbl 0xb(%esi),%eax
  808f1e:	89 44 24 0c          	mov    %eax,0xc(%esp)
  808f22:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  808f25:	89 44 24 08          	mov    %eax,0x8(%esp)
  808f29:	89 74 24 04          	mov    %esi,0x4(%esp)
  808f2d:	89 3c 24             	mov    %edi,(%esp)
  808f30:	e8 7b e0 ff ff       	call   806fb0 <ip_output>
#endif /* LWIP_NETIF_HWADDRHINT*/

  pbuf_free(p);
  808f35:	89 3c 24             	mov    %edi,(%esp)
  808f38:	e8 b7 be ff ff       	call   804df4 <pbuf_free>

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: seqno %"U32_F" ackno %"U32_F".\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt));
}
  808f3d:	83 c4 2c             	add    $0x2c,%esp
  808f40:	5b                   	pop    %ebx
  808f41:	5e                   	pop    %esi
  808f42:	5f                   	pop    %edi
  808f43:	5d                   	pop    %ebp
  808f44:	c3                   	ret    

00808f45 <tcp_zero_window_probe>:
 *
 * @param pcb the tcp_pcb for which to send a zero-window probe packet
 */
void
tcp_zero_window_probe(struct tcp_pcb *pcb)
{
  808f45:	55                   	push   %ebp
  808f46:	89 e5                	mov    %esp,%ebp
  808f48:	57                   	push   %edi
  808f49:	56                   	push   %esi
  808f4a:	53                   	push   %ebx
  808f4b:	83 ec 2c             	sub    $0x2c,%esp
  808f4e:	8b 75 08             	mov    0x8(%ebp),%esi
  LWIP_DEBUGF(TCP_DEBUG, 
              ("tcp_zero_window_probe: tcp_ticks %"U32_F
               "   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
               tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));

  seg = pcb->unacked;
  808f51:	8b 46 78             	mov    0x78(%esi),%eax
  808f54:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  if(seg == NULL)
  808f57:	85 c0                	test   %eax,%eax
  808f59:	75 0e                	jne    808f69 <tcp_zero_window_probe+0x24>
    seg = pcb->unsent;
  808f5b:	8b 46 74             	mov    0x74(%esi),%eax
  808f5e:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  if(seg == NULL)
  808f61:	85 c0                	test   %eax,%eax
  808f63:	0f 84 4a 01 00 00    	je     8090b3 <tcp_zero_window_probe+0x16e>
    return;

  p = pbuf_alloc(PBUF_IP, TCP_HLEN + 1, PBUF_RAM);
  808f69:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  808f70:	00 
  808f71:	c7 44 24 04 15 00 00 	movl   $0x15,0x4(%esp)
  808f78:	00 
  808f79:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  808f80:	e8 50 bf ff ff       	call   804ed5 <pbuf_alloc>
  808f85:	89 c7                	mov    %eax,%edi
   
  if(p == NULL) {
  808f87:	85 c0                	test   %eax,%eax
  808f89:	0f 84 24 01 00 00    	je     8090b3 <tcp_zero_window_probe+0x16e>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: no memory for pbuf\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  808f8f:	66 83 78 0a 13       	cmpw   $0x13,0xa(%eax)
  808f94:	77 1c                	ja     808fb2 <tcp_zero_window_probe+0x6d>
  808f96:	c7 44 24 08 b0 2f 81 	movl   $0x812fb0,0x8(%esp)
  808f9d:	00 
  808f9e:	c7 44 24 04 8d 03 00 	movl   $0x38d,0x4(%esp)
  808fa5:	00 
  808fa6:	c7 04 24 de 2f 81 00 	movl   $0x812fde,(%esp)
  808fad:	e8 c8 60 00 00       	call   80f07a <_panic>
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = p->payload;
  808fb2:	8b 58 04             	mov    0x4(%eax),%ebx
  tcphdr->src = htons(pcb->local_port);
  808fb5:	0f b7 46 1c          	movzwl 0x1c(%esi),%eax
  808fb9:	89 04 24             	mov    %eax,(%esp)
  808fbc:	e8 b5 ed ff ff       	call   807d76 <htons>
  808fc1:	66 89 03             	mov    %ax,(%ebx)
  tcphdr->dest = htons(pcb->remote_port);
  808fc4:	0f b7 46 1e          	movzwl 0x1e(%esi),%eax
  808fc8:	89 04 24             	mov    %eax,(%esp)
  808fcb:	e8 a6 ed ff ff       	call   807d76 <htons>
  808fd0:	66 89 43 02          	mov    %ax,0x2(%ebx)
  tcphdr->seqno = seg->tcphdr->seqno;
  808fd4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  808fd7:	8b 40 10             	mov    0x10(%eax),%eax
  808fda:	8b 40 04             	mov    0x4(%eax),%eax
  808fdd:	89 43 04             	mov    %eax,0x4(%ebx)
  tcphdr->ackno = htonl(pcb->rcv_nxt);
  808fe0:	8b 46 24             	mov    0x24(%esi),%eax
  808fe3:	89 04 24             	mov    %eax,(%esp)
  808fe6:	e8 a5 ed ff ff       	call   807d90 <htonl>
  808feb:	89 43 08             	mov    %eax,0x8(%ebx)
  TCPH_FLAGS_SET(tcphdr, 0);
  808fee:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  808ff2:	89 04 24             	mov    %eax,(%esp)
  808ff5:	e8 89 ed ff ff       	call   807d83 <ntohs>
  808ffa:	25 c0 ff 00 00       	and    $0xffc0,%eax
  808fff:	89 04 24             	mov    %eax,(%esp)
  809002:	e8 6f ed ff ff       	call   807d76 <htons>
  809007:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  80900b:	0f b7 46 2a          	movzwl 0x2a(%esi),%eax
  80900f:	89 04 24             	mov    %eax,(%esp)
  809012:	e8 5f ed ff ff       	call   807d76 <htons>
  809017:	66 89 43 0e          	mov    %ax,0xe(%ebx)
  tcphdr->urgp = 0;
  80901b:	66 c7 43 12 00 00    	movw   $0x0,0x12(%ebx)
  TCPH_HDRLEN_SET(tcphdr, 5);
  809021:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  809025:	89 04 24             	mov    %eax,(%esp)
  809028:	e8 56 ed ff ff       	call   807d83 <ntohs>
  80902d:	83 e0 3f             	and    $0x3f,%eax
  809030:	80 cc 50             	or     $0x50,%ah
  809033:	89 04 24             	mov    %eax,(%esp)
  809036:	e8 3b ed ff ff       	call   807d76 <htons>
  80903b:	66 89 43 0c          	mov    %ax,0xc(%ebx)

  /* Copy in one byte from the head of the unacked queue */
  *((char *)p->payload + sizeof(struct tcp_hdr)) = *(char *)seg->dataptr;
  80903f:	8b 47 04             	mov    0x4(%edi),%eax
  809042:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  809045:	8b 51 08             	mov    0x8(%ecx),%edx
  809048:	0f b6 12             	movzbl (%edx),%edx
  80904b:	88 50 14             	mov    %dl,0x14(%eax)

  tcphdr->chksum = 0;
  80904e:	66 c7 43 10 00 00    	movw   $0x0,0x10(%ebx)
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
  809054:	8d 46 04             	lea    0x4(%esi),%eax
  809057:	89 c1                	mov    %eax,%ecx
  809059:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  80905d:	89 44 24 10          	mov    %eax,0x10(%esp)
  809061:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
  809068:	00 
  809069:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  80906c:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  809070:	89 74 24 04          	mov    %esi,0x4(%esp)
  809074:	89 3c 24             	mov    %edi,(%esp)
  809077:	e8 b2 e9 ff ff       	call   807a2e <inet_chksum_pseudo>
  80907c:	66 89 43 10          	mov    %ax,0x10(%ebx)
                   0, IP_PROTO_TCP, netif);
      netif->addr_hint = NULL;
    }
  }
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
  809080:	c7 44 24 14 06 00 00 	movl   $0x6,0x14(%esp)
  809087:	00 
  809088:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  80908f:	00 
  809090:	0f b6 46 0b          	movzbl 0xb(%esi),%eax
  809094:	89 44 24 0c          	mov    %eax,0xc(%esp)
  809098:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80909b:	89 44 24 08          	mov    %eax,0x8(%esp)
  80909f:	89 74 24 04          	mov    %esi,0x4(%esp)
  8090a3:	89 3c 24             	mov    %edi,(%esp)
  8090a6:	e8 05 df ff ff       	call   806fb0 <ip_output>
#endif /* LWIP_NETIF_HWADDRHINT*/

  pbuf_free(p);
  8090ab:	89 3c 24             	mov    %edi,(%esp)
  8090ae:	e8 41 bd ff ff       	call   804df4 <pbuf_free>

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: seqno %"U32_F
                          " ackno %"U32_F".\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt));
}
  8090b3:	83 c4 2c             	add    $0x2c,%esp
  8090b6:	5b                   	pop    %ebx
  8090b7:	5e                   	pop    %esi
  8090b8:	5f                   	pop    %edi
  8090b9:	5d                   	pop    %ebp
  8090ba:	c3                   	ret    
  8090bb:	66 90                	xchg   %ax,%ax
  8090bd:	66 90                	xchg   %ax,%ax
  8090bf:	90                   	nop

008090c0 <udp_input>:
 * @param inp network interface on which the datagram was received.
 *
 */
void
udp_input(struct pbuf *p, struct netif *inp)
{
  8090c0:	55                   	push   %ebp
  8090c1:	89 e5                	mov    %esp,%ebp
  8090c3:	57                   	push   %edi
  8090c4:	56                   	push   %esi
  8090c5:	53                   	push   %ebx
  8090c6:	83 ec 3c             	sub    $0x3c,%esp

  PERF_START;

  UDP_STATS_INC(udp.recv);

  iphdr = p->payload;
  8090c9:	8b 45 08             	mov    0x8(%ebp),%eax
  8090cc:	8b 40 04             	mov    0x4(%eax),%eax
  8090cf:	89 c7                	mov    %eax,%edi
  8090d1:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  /* Check minimum length (IP header + UDP header)
   * and move payload pointer to UDP header */
  if (p->tot_len < (IPH_HL(iphdr) * 4 + UDP_HLEN) || pbuf_header(p, -(s16_t)(IPH_HL(iphdr) * 4))) {
  8090d4:	8b 4d 08             	mov    0x8(%ebp),%ecx
  8090d7:	0f b7 59 08          	movzwl 0x8(%ecx),%ebx
  8090db:	0f b7 00             	movzwl (%eax),%eax
  8090de:	89 04 24             	mov    %eax,(%esp)
  8090e1:	e8 9d ec ff ff       	call   807d83 <ntohs>
  8090e6:	66 c1 e8 08          	shr    $0x8,%ax
  8090ea:	83 e0 0f             	and    $0xf,%eax
  8090ed:	8d 04 85 08 00 00 00 	lea    0x8(,%eax,4),%eax
  8090f4:	39 c3                	cmp    %eax,%ebx
  8090f6:	7c 28                	jl     809120 <udp_input+0x60>
  8090f8:	0f b7 07             	movzwl (%edi),%eax
  8090fb:	89 04 24             	mov    %eax,(%esp)
  8090fe:	e8 80 ec ff ff       	call   807d83 <ntohs>
  809103:	66 c1 e8 06          	shr    $0x6,%ax
  809107:	83 e0 3c             	and    $0x3c,%eax
  80910a:	f7 d8                	neg    %eax
  80910c:	98                   	cwtl   
  80910d:	89 44 24 04          	mov    %eax,0x4(%esp)
  809111:	8b 45 08             	mov    0x8(%ebp),%eax
  809114:	89 04 24             	mov    %eax,(%esp)
  809117:	e8 f4 bb ff ff       	call   804d10 <pbuf_header>
  80911c:	84 c0                	test   %al,%al
  80911e:	74 10                	je     809130 <udp_input+0x70>
    LWIP_DEBUGF(UDP_DEBUG,
                ("udp_input: short UDP datagram (%"U16_F" bytes) discarded\n", p->tot_len));
    UDP_STATS_INC(udp.lenerr);
    UDP_STATS_INC(udp.drop);
    snmp_inc_udpinerrors();
    pbuf_free(p);
  809120:	8b 45 08             	mov    0x8(%ebp),%eax
  809123:	89 04 24             	mov    %eax,(%esp)
  809126:	e8 c9 bc ff ff       	call   804df4 <pbuf_free>
    goto end;
  80912b:	e9 09 03 00 00       	jmp    809439 <udp_input+0x379>
  }

  udphdr = (struct udp_hdr *)p->payload;
  809130:	8b 45 08             	mov    0x8(%ebp),%eax
  809133:	8b 40 04             	mov    0x4(%eax),%eax
  809136:	89 c6                	mov    %eax,%esi
  809138:	89 45 d4             	mov    %eax,-0x2c(%ebp)

  LWIP_DEBUGF(UDP_DEBUG, ("udp_input: received datagram of length %"U16_F"\n", p->tot_len));

  /* convert src and dest ports to host byte order */
  src = ntohs(udphdr->src);
  80913b:	0f b7 00             	movzwl (%eax),%eax
  80913e:	89 04 24             	mov    %eax,(%esp)
  809141:	e8 3d ec ff ff       	call   807d83 <ntohs>
  809146:	66 89 45 de          	mov    %ax,-0x22(%ebp)
  dest = ntohs(udphdr->dest);
  80914a:	0f b7 46 02          	movzwl 0x2(%esi),%eax
  80914e:	89 04 24             	mov    %eax,(%esp)
  809151:	e8 2d ec ff ff       	call   807d83 <ntohs>
  809156:	89 c6                	mov    %eax,%esi

#if LWIP_DHCP
  pcb = NULL;
  /* when LWIP_DHCP is active, packets to DHCP_CLIENT_PORT may only be processed by
     the dhcp module, no other UDP pcb may use the local UDP port DHCP_CLIENT_PORT */
  if (dest == DHCP_CLIENT_PORT) {
  809158:	66 83 f8 44          	cmp    $0x44,%ax
  80915c:	75 5a                	jne    8091b8 <udp_input+0xf8>
  80915e:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
    /* all packets for DHCP_CLIENT_PORT not coming from DHCP_SERVER_PORT are dropped! */
    if (src == DHCP_SERVER_PORT) {
  809165:	66 83 7d de 43       	cmpw   $0x43,-0x22(%ebp)
  80916a:	0f 85 14 01 00 00    	jne    809284 <udp_input+0x1c4>
      if ((inp->dhcp != NULL) && (inp->dhcp->pcb != NULL)) {
  809170:	8b 45 0c             	mov    0xc(%ebp),%eax
  809173:	8b 40 20             	mov    0x20(%eax),%eax
  809176:	85 c0                	test   %eax,%eax
  809178:	0f 84 ff 00 00 00    	je     80927d <udp_input+0x1bd>
  80917e:	8b 40 08             	mov    0x8(%eax),%eax
  809181:	89 45 e0             	mov    %eax,-0x20(%ebp)
  809184:	85 c0                	test   %eax,%eax
  809186:	0f 84 f8 00 00 00    	je     809284 <udp_input+0x1c4>
        /* accept the packe if 
           (- broadcast or directed to us) -> DHCP is link-layer-addressed, local ip is always ANY!
           - inp->dhcp->pcb->remote == ANY or iphdr->src */
        if ((ip_addr_isany(&inp->dhcp->pcb->remote_ip) ||
  80918c:	83 f8 fc             	cmp    $0xfffffffc,%eax
  80918f:	0f 84 01 01 00 00    	je     809296 <udp_input+0x1d6>
  809195:	8b 40 04             	mov    0x4(%eax),%eax
  809198:	85 c0                	test   %eax,%eax
  80919a:	0f 84 f6 00 00 00    	je     809296 <udp_input+0x1d6>
  8091a0:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  8091a3:	3b 41 0c             	cmp    0xc(%ecx),%eax
  8091a6:	0f 84 ea 00 00 00    	je     809296 <udp_input+0x1d6>
  8091ac:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  8091b3:	e9 cc 00 00 00       	jmp    809284 <udp_input+0x1c4>
    uncon_pcb = NULL;
    /* Iterate through the UDP pcb list for a matching pcb.
     * 'Perfect match' pcbs (connected to the remote port & ip address) are
     * preferred. If no perfect match is found, the first unconnected pcb that
     * matches the local port and ip address gets the datagram. */
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
  8091b8:	8b 1d 74 c2 b3 00    	mov    0xb3c274,%ebx
  } else
#endif /* LWIP_DHCP */
  {
    prev = NULL;
    local_match = 0;
    uncon_pcb = NULL;
  8091be:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
      }
    }
  } else
#endif /* LWIP_DHCP */
  {
    prev = NULL;
  8091c5:	bf 00 00 00 00       	mov    $0x0,%edi
          (ip_addr_isany(&pcb->local_ip) ||
           ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest)) || 
#if LWIP_IGMP
           ip_addr_ismulticast(&(iphdr->dest)) ||
#endif /* LWIP_IGMP */
           ip_addr_isbroadcast(&(iphdr->dest), inp))) {
  8091ca:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8091cd:	83 c0 10             	add    $0x10,%eax
  8091d0:	89 45 d8             	mov    %eax,-0x28(%ebp)
    uncon_pcb = NULL;
    /* Iterate through the UDP pcb list for a matching pcb.
     * 'Perfect match' pcbs (connected to the remote port & ip address) are
     * preferred. If no perfect match is found, the first unconnected pcb that
     * matches the local port and ip address gets the datagram. */
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
  8091d3:	e9 95 00 00 00       	jmp    80926d <udp_input+0x1ad>
                   ip4_addr3(&pcb->local_ip), ip4_addr4(&pcb->local_ip), pcb->local_port,
                   ip4_addr1(&pcb->remote_ip), ip4_addr2(&pcb->remote_ip),
                   ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip), pcb->remote_port));

      /* compare PCB local addr+port to UDP destination addr+port */
      if ((pcb->local_port == dest) &&
  8091d8:	66 39 73 12          	cmp    %si,0x12(%ebx)
  8091dc:	0f 85 86 00 00 00    	jne    809268 <udp_input+0x1a8>
  8091e2:	85 db                	test   %ebx,%ebx
  8091e4:	74 24                	je     80920a <udp_input+0x14a>
          (ip_addr_isany(&pcb->local_ip) ||
  8091e6:	8b 03                	mov    (%ebx),%eax
  8091e8:	85 c0                	test   %eax,%eax
  8091ea:	74 1e                	je     80920a <udp_input+0x14a>
  8091ec:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  8091ef:	3b 41 10             	cmp    0x10(%ecx),%eax
  8091f2:	74 16                	je     80920a <udp_input+0x14a>
           ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest)) || 
#if LWIP_IGMP
           ip_addr_ismulticast(&(iphdr->dest)) ||
#endif /* LWIP_IGMP */
           ip_addr_isbroadcast(&(iphdr->dest), inp))) {
  8091f4:	8b 45 0c             	mov    0xc(%ebp),%eax
  8091f7:	89 44 24 04          	mov    %eax,0x4(%esp)
  8091fb:	8b 45 d8             	mov    -0x28(%ebp),%eax
  8091fe:	89 04 24             	mov    %eax,(%esp)
  809201:	e8 8b d8 ff ff       	call   806a91 <ip_addr_isbroadcast>
                   ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip), pcb->remote_port));

      /* compare PCB local addr+port to UDP destination addr+port */
      if ((pcb->local_port == dest) &&
          (ip_addr_isany(&pcb->local_ip) ||
           ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest)) || 
  809206:	84 c0                	test   %al,%al
  809208:	74 5e                	je     809268 <udp_input+0x1a8>
#if LWIP_IGMP
           ip_addr_ismulticast(&(iphdr->dest)) ||
#endif /* LWIP_IGMP */
           ip_addr_isbroadcast(&(iphdr->dest), inp))) {
        local_match = 1;
        if ((uncon_pcb == NULL) && 
  80920a:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
  80920e:	0f 85 0a 02 00 00    	jne    80941e <udp_input+0x35e>
  809214:	0f b6 43 10          	movzbl 0x10(%ebx),%eax
  809218:	83 e0 04             	and    $0x4,%eax
  80921b:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80921e:	0f 44 c3             	cmove  %ebx,%eax
  809221:	89 45 e0             	mov    %eax,-0x20(%ebp)
  809224:	e9 f5 01 00 00       	jmp    80941e <udp_input+0x35e>
          uncon_pcb = pcb;
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
          (pcb->remote_port == src) &&
  809229:	83 fb fc             	cmp    $0xfffffffc,%ebx
  80922c:	74 13                	je     809241 <udp_input+0x181>
          (ip_addr_isany(&pcb->remote_ip) ||
  80922e:	8b 43 04             	mov    0x4(%ebx),%eax
  809231:	85 c0                	test   %eax,%eax
  809233:	74 10                	je     809245 <udp_input+0x185>
  809235:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  809238:	3b 42 0c             	cmp    0xc(%edx),%eax
  80923b:	75 2b                	jne    809268 <udp_input+0x1a8>
  80923d:	89 d8                	mov    %ebx,%eax
  80923f:	eb 06                	jmp    809247 <udp_input+0x187>
  809241:	89 d8                	mov    %ebx,%eax
  809243:	eb 02                	jmp    809247 <udp_input+0x187>
  809245:	89 d8                	mov    %ebx,%eax
           ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)))) {
        /* the first fully matching PCB */
        if (prev != NULL) {
  809247:	85 ff                	test   %edi,%edi
  809249:	0f 84 e2 01 00 00    	je     809431 <udp_input+0x371>
          /* move the pcb to the front of udp_pcbs so that is
             found faster next time */
          prev->next = pcb->next;
  80924f:	8b 50 0c             	mov    0xc(%eax),%edx
  809252:	89 57 0c             	mov    %edx,0xc(%edi)
          pcb->next = udp_pcbs;
  809255:	8b 15 74 c2 b3 00    	mov    0xb3c274,%edx
  80925b:	89 50 0c             	mov    %edx,0xc(%eax)
          udp_pcbs = pcb;
  80925e:	a3 74 c2 b3 00       	mov    %eax,0xb3c274
  809263:	e9 c9 01 00 00       	jmp    809431 <udp_input+0x371>
    uncon_pcb = NULL;
    /* Iterate through the UDP pcb list for a matching pcb.
     * 'Perfect match' pcbs (connected to the remote port & ip address) are
     * preferred. If no perfect match is found, the first unconnected pcb that
     * matches the local port and ip address gets the datagram. */
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
  809268:	89 df                	mov    %ebx,%edi
  80926a:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  80926d:	85 db                	test   %ebx,%ebx
  80926f:	0f 85 63 ff ff ff    	jne    8091d8 <udp_input+0x118>
      pcb = uncon_pcb;
    }
  }

  /* Check checksum if this is a match or if it was directed at us. */
  if (pcb != NULL || ip_addr_cmp(&inp->ip_addr, &iphdr->dest)) {
  809275:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
  809279:	75 1b                	jne    809296 <udp_input+0x1d6>
  80927b:	eb 07                	jmp    809284 <udp_input+0x1c4>
  80927d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  809284:	8b 45 0c             	mov    0xc(%ebp),%eax
  809287:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  80928a:	8b 49 10             	mov    0x10(%ecx),%ecx
  80928d:	39 48 04             	cmp    %ecx,0x4(%eax)
  809290:	0f 85 7b 01 00 00    	jne    809411 <udp_input+0x351>
#endif /* CHECKSUM_CHECK_UDP */
    } else
#endif /* LWIP_UDPLITE */
    {
#if CHECKSUM_CHECK_UDP
      if (udphdr->chksum != 0) {
  809296:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  809299:	66 83 78 06 00       	cmpw   $0x0,0x6(%eax)
  80929e:	74 48                	je     8092e8 <udp_input+0x228>
        if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
  8092a0:	8b 45 08             	mov    0x8(%ebp),%eax
  8092a3:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  8092a7:	89 44 24 10          	mov    %eax,0x10(%esp)
  8092ab:	c7 44 24 0c 11 00 00 	movl   $0x11,0xc(%esp)
  8092b2:	00 
  8092b3:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  8092b6:	89 d0                	mov    %edx,%eax
  8092b8:	83 c0 10             	add    $0x10,%eax
  8092bb:	89 44 24 08          	mov    %eax,0x8(%esp)
  8092bf:	89 d0                	mov    %edx,%eax
  8092c1:	83 c0 0c             	add    $0xc,%eax
  8092c4:	89 44 24 04          	mov    %eax,0x4(%esp)
  8092c8:	8b 45 08             	mov    0x8(%ebp),%eax
  8092cb:	89 04 24             	mov    %eax,(%esp)
  8092ce:	e8 5b e7 ff ff       	call   807a2e <inet_chksum_pseudo>
  8092d3:	66 85 c0             	test   %ax,%ax
  8092d6:	74 10                	je     8092e8 <udp_input+0x228>
          LWIP_DEBUGF(UDP_DEBUG | 2,
                      ("udp_input: UDP datagram discarded due to failing checksum\n"));
          UDP_STATS_INC(udp.chkerr);
          UDP_STATS_INC(udp.drop);
          snmp_inc_udpinerrors();
          pbuf_free(p);
  8092d8:	8b 45 08             	mov    0x8(%ebp),%eax
  8092db:	89 04 24             	mov    %eax,(%esp)
  8092de:	e8 11 bb ff ff       	call   804df4 <pbuf_free>
          goto end;
  8092e3:	e9 51 01 00 00       	jmp    809439 <udp_input+0x379>
        }
      }
#endif /* CHECKSUM_CHECK_UDP */
    }
    if(pbuf_header(p, -UDP_HLEN)) {
  8092e8:	c7 44 24 04 f8 ff ff 	movl   $0xfffffff8,0x4(%esp)
  8092ef:	ff 
  8092f0:	8b 45 08             	mov    0x8(%ebp),%eax
  8092f3:	89 04 24             	mov    %eax,(%esp)
  8092f6:	e8 15 ba ff ff       	call   804d10 <pbuf_header>
  8092fb:	84 c0                	test   %al,%al
  8092fd:	74 1c                	je     80931b <udp_input+0x25b>
      /* Can we cope with this failing? Just assert for now */
      LWIP_ASSERT("pbuf_header failed\n", 0);
  8092ff:	c7 44 24 08 03 30 81 	movl   $0x813003,0x8(%esp)
  809306:	00 
  809307:	c7 44 24 04 0a 01 00 	movl   $0x10a,0x4(%esp)
  80930e:	00 
  80930f:	c7 04 24 2e 30 81 00 	movl   $0x81302e,(%esp)
  809316:	e8 5f 5d 00 00       	call   80f07a <_panic>
      UDP_STATS_INC(udp.drop);
      snmp_inc_udpinerrors();
      pbuf_free(p);
      goto end;
    }
    if (pcb != NULL) {
  80931b:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  80931e:	85 c9                	test   %ecx,%ecx
  809320:	74 43                	je     809365 <udp_input+0x2a5>
      snmp_inc_udpindatagrams();
      /* callback */
      if (pcb->recv != NULL) {
  809322:	8b 41 18             	mov    0x18(%ecx),%eax
  809325:	85 c0                	test   %eax,%eax
  809327:	74 2a                	je     809353 <udp_input+0x293>
        /* now the recv function is responsible for freeing p */
        pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src), src);
  809329:	0f b7 55 de          	movzwl -0x22(%ebp),%edx
  80932d:	89 54 24 10          	mov    %edx,0x10(%esp)
  809331:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  809334:	83 c2 0c             	add    $0xc,%edx
  809337:	89 54 24 0c          	mov    %edx,0xc(%esp)
  80933b:	8b 55 08             	mov    0x8(%ebp),%edx
  80933e:	89 54 24 08          	mov    %edx,0x8(%esp)
  809342:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  809346:	8b 51 1c             	mov    0x1c(%ecx),%edx
  809349:	89 14 24             	mov    %edx,(%esp)
  80934c:	ff d0                	call   *%eax
  80934e:	e9 e6 00 00 00       	jmp    809439 <udp_input+0x379>
      } else {
        /* no recv function registered? then we have to free the pbuf! */
        pbuf_free(p);
  809353:	8b 45 08             	mov    0x8(%ebp),%eax
  809356:	89 04 24             	mov    %eax,(%esp)
  809359:	e8 96 ba ff ff       	call   804df4 <pbuf_free>
        goto end;
  80935e:	66 90                	xchg   %ax,%ax
  809360:	e9 d4 00 00 00       	jmp    809439 <udp_input+0x379>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_input: not for us.\n"));

#if LWIP_ICMP
      /* No match was found, send ICMP destination port unreachable unless
         destination address was broadcast/multicast. */
      if (!ip_addr_isbroadcast(&iphdr->dest, inp) &&
  809365:	8b 45 0c             	mov    0xc(%ebp),%eax
  809368:	89 44 24 04          	mov    %eax,0x4(%esp)
  80936c:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  80936f:	89 f0                	mov    %esi,%eax
  809371:	83 c0 10             	add    $0x10,%eax
  809374:	89 04 24             	mov    %eax,(%esp)
  809377:	e8 15 d7 ff ff       	call   806a91 <ip_addr_isbroadcast>
  80937c:	84 c0                	test   %al,%al
  80937e:	0f 85 80 00 00 00    	jne    809404 <udp_input+0x344>
          !ip_addr_ismulticast(&iphdr->dest)) {
  809384:	8b 5e 10             	mov    0x10(%esi),%ebx
  809387:	c7 04 24 00 00 00 f0 	movl   $0xf0000000,(%esp)
  80938e:	e8 37 ec ff ff       	call   807fca <ntohl>
  809393:	21 c3                	and    %eax,%ebx
  809395:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  80939c:	e8 29 ec ff ff       	call   807fca <ntohl>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_input: not for us.\n"));

#if LWIP_ICMP
      /* No match was found, send ICMP destination port unreachable unless
         destination address was broadcast/multicast. */
      if (!ip_addr_isbroadcast(&iphdr->dest, inp) &&
  8093a1:	39 c3                	cmp    %eax,%ebx
  8093a3:	74 5f                	je     809404 <udp_input+0x344>
          !ip_addr_ismulticast(&iphdr->dest)) {
        /* move payload pointer back to ip header */
        pbuf_header(p, (IPH_HL(iphdr) * 4) + UDP_HLEN);
  8093a5:	0f b7 06             	movzwl (%esi),%eax
  8093a8:	89 04 24             	mov    %eax,(%esp)
  8093ab:	e8 d3 e9 ff ff       	call   807d83 <ntohs>
  8093b0:	66 c1 e8 08          	shr    $0x8,%ax
  8093b4:	83 e0 0f             	and    $0xf,%eax
  8093b7:	8d 04 85 08 00 00 00 	lea    0x8(,%eax,4),%eax
  8093be:	89 44 24 04          	mov    %eax,0x4(%esp)
  8093c2:	8b 45 08             	mov    0x8(%ebp),%eax
  8093c5:	89 04 24             	mov    %eax,(%esp)
  8093c8:	e8 43 b9 ff ff       	call   804d10 <pbuf_header>
        LWIP_ASSERT("p->payload == iphdr", (p->payload == iphdr));
  8093cd:	8b 4d 08             	mov    0x8(%ebp),%ecx
  8093d0:	39 71 04             	cmp    %esi,0x4(%ecx)
  8093d3:	74 1c                	je     8093f1 <udp_input+0x331>
  8093d5:	c7 44 24 08 42 30 81 	movl   $0x813042,0x8(%esp)
  8093dc:	00 
  8093dd:	c7 44 24 04 25 01 00 	movl   $0x125,0x4(%esp)
  8093e4:	00 
  8093e5:	c7 04 24 2e 30 81 00 	movl   $0x81302e,(%esp)
  8093ec:	e8 89 5c 00 00       	call   80f07a <_panic>
        icmp_dest_unreach(p, ICMP_DUR_PORT);
  8093f1:	c7 44 24 04 03 00 00 	movl   $0x3,0x4(%esp)
  8093f8:	00 
  8093f9:	8b 45 08             	mov    0x8(%ebp),%eax
  8093fc:	89 04 24             	mov    %eax,(%esp)
  8093ff:	e8 f1 59 00 00       	call   80edf5 <icmp_dest_unreach>
      }
#endif /* LWIP_ICMP */
      UDP_STATS_INC(udp.proterr);
      UDP_STATS_INC(udp.drop);
      snmp_inc_udpnoports();
      pbuf_free(p);
  809404:	8b 45 08             	mov    0x8(%ebp),%eax
  809407:	89 04 24             	mov    %eax,(%esp)
  80940a:	e8 e5 b9 ff ff       	call   804df4 <pbuf_free>
  80940f:	eb 28                	jmp    809439 <udp_input+0x379>
    }
  } else {
    pbuf_free(p);
  809411:	8b 45 08             	mov    0x8(%ebp),%eax
  809414:	89 04 24             	mov    %eax,(%esp)
  809417:	e8 d8 b9 ff ff       	call   804df4 <pbuf_free>
  80941c:	eb 1b                	jmp    809439 <udp_input+0x379>
          /* the first unconnected matching PCB */     
          uncon_pcb = pcb;
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
  80941e:	0f b7 45 de          	movzwl -0x22(%ebp),%eax
  809422:	66 39 43 14          	cmp    %ax,0x14(%ebx)
  809426:	0f 85 3c fe ff ff    	jne    809268 <udp_input+0x1a8>
  80942c:	e9 f8 fd ff ff       	jmp    809229 <udp_input+0x169>
  809431:	89 5d e0             	mov    %ebx,-0x20(%ebp)
  809434:	e9 5d fe ff ff       	jmp    809296 <udp_input+0x1d6>
  } else {
    pbuf_free(p);
  }
end:
  PERF_STOP("udp_input");
}
  809439:	83 c4 3c             	add    $0x3c,%esp
  80943c:	5b                   	pop    %ebx
  80943d:	5e                   	pop    %esi
  80943e:	5f                   	pop    %edi
  80943f:	5d                   	pop    %ebp
  809440:	c3                   	ret    

00809441 <udp_bind>:
 *
 * @see udp_disconnect()
 */
err_t
udp_bind(struct udp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
{
  809441:	55                   	push   %ebp
  809442:	89 e5                	mov    %esp,%ebp
  809444:	57                   	push   %edi
  809445:	56                   	push   %esi
  809446:	53                   	push   %ebx
  809447:	83 ec 1c             	sub    $0x1c,%esp
  80944a:	8b 55 08             	mov    0x8(%ebp),%edx
  80944d:	8b 7d 0c             	mov    0xc(%ebp),%edi
  809450:	8b 45 10             	mov    0x10(%ebp),%eax
  809453:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  809456:	89 c1                	mov    %eax,%ecx
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 3, (", port = %"U16_F")\n", port));

  rebind = 0;
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  809458:	a1 74 c2 b3 00       	mov    0xb3c274,%eax

  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 3, ("udp_bind(ipaddr = "));
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 3, (", port = %"U16_F")\n", port));

  rebind = 0;
  80945d:	be 00 00 00 00       	mov    $0x0,%esi
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  809462:	eb 2e                	jmp    809492 <udp_bind+0x51>
    /* is this UDP PCB already on active list? */
    if (pcb == ipcb) {
  809464:	39 c2                	cmp    %eax,%edx
  809466:	75 27                	jne    80948f <udp_bind+0x4e>
      /* pcb may occur at most once in active list */
      LWIP_ASSERT("rebind == 0", rebind == 0);
  809468:	89 f3                	mov    %esi,%ebx
  80946a:	84 db                	test   %bl,%bl
  80946c:	74 1c                	je     80948a <udp_bind+0x49>
  80946e:	c7 44 24 08 56 30 81 	movl   $0x813056,0x8(%esp)
  809475:	00 
  809476:	c7 44 24 04 41 02 00 	movl   $0x241,0x4(%esp)
  80947d:	00 
  80947e:	c7 04 24 2e 30 81 00 	movl   $0x81302e,(%esp)
  809485:	e8 f0 5b 00 00       	call   80f07a <_panic>
      /* pcb already in list, just rebind */
      rebind = 1;
  80948a:	be 01 00 00 00       	mov    $0x1,%esi
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 3, (", port = %"U16_F")\n", port));

  rebind = 0;
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  80948f:	8b 40 0c             	mov    0xc(%eax),%eax
  809492:	85 c0                	test   %eax,%eax
  809494:	75 ce                	jne    809464 <udp_bind+0x23>
        return ERR_USE;
      }
#endif
  }

  ip_addr_set(&pcb->local_ip, ipaddr);
  809496:	85 ff                	test   %edi,%edi
  809498:	74 04                	je     80949e <udp_bind+0x5d>
  80949a:	8b 07                	mov    (%edi),%eax
  80949c:	eb 05                	jmp    8094a3 <udp_bind+0x62>
  80949e:	b8 00 00 00 00       	mov    $0x0,%eax
  8094a3:	89 02                	mov    %eax,(%edx)

  /* no port specified? */
  if (port == 0) {
  8094a5:	66 83 7d e4 00       	cmpw   $0x0,-0x1c(%ebp)
  8094aa:	75 36                	jne    8094e2 <udp_bind+0xa1>
#ifndef UDP_LOCAL_PORT_RANGE_START
#define UDP_LOCAL_PORT_RANGE_START 4096
#define UDP_LOCAL_PORT_RANGE_END   0x7fff
#endif
    port = UDP_LOCAL_PORT_RANGE_START;
    ipcb = udp_pcbs;
  8094ac:	8b 3d 74 c2 b3 00    	mov    0xb3c274,%edi
  8094b2:	89 f8                	mov    %edi,%eax
  if (port == 0) {
#ifndef UDP_LOCAL_PORT_RANGE_START
#define UDP_LOCAL_PORT_RANGE_START 4096
#define UDP_LOCAL_PORT_RANGE_END   0x7fff
#endif
    port = UDP_LOCAL_PORT_RANGE_START;
  8094b4:	b9 00 10 00 00       	mov    $0x1000,%ecx
    ipcb = udp_pcbs;
    while ((ipcb != NULL) && (port != UDP_LOCAL_PORT_RANGE_END)) {
  8094b9:	eb 13                	jmp    8094ce <udp_bind+0x8d>
      if (ipcb->local_port == port) {
  8094bb:	0f b7 58 12          	movzwl 0x12(%eax),%ebx
  8094bf:	66 39 cb             	cmp    %cx,%bx
  8094c2:	75 07                	jne    8094cb <udp_bind+0x8a>
        /* port is already used by another udp_pcb */
        port++;
  8094c4:	8d 4b 01             	lea    0x1(%ebx),%ecx
        /* restart scanning all udp pcbs */
        ipcb = udp_pcbs;
  8094c7:	89 f8                	mov    %edi,%eax
  8094c9:	eb 03                	jmp    8094ce <udp_bind+0x8d>
      } else
        /* go on with next udp pcb */
        ipcb = ipcb->next;
  8094cb:	8b 40 0c             	mov    0xc(%eax),%eax
#define UDP_LOCAL_PORT_RANGE_START 4096
#define UDP_LOCAL_PORT_RANGE_END   0x7fff
#endif
    port = UDP_LOCAL_PORT_RANGE_START;
    ipcb = udp_pcbs;
    while ((ipcb != NULL) && (port != UDP_LOCAL_PORT_RANGE_END)) {
  8094ce:	85 c0                	test   %eax,%eax
  8094d0:	0f 95 c3             	setne  %bl
  8094d3:	66 81 f9 ff 7f       	cmp    $0x7fff,%cx
  8094d8:	74 04                	je     8094de <udp_bind+0x9d>
  8094da:	84 db                	test   %bl,%bl
  8094dc:	75 dd                	jne    8094bb <udp_bind+0x7a>
        ipcb = udp_pcbs;
      } else
        /* go on with next udp pcb */
        ipcb = ipcb->next;
    }
    if (ipcb != NULL) {
  8094de:	84 db                	test   %bl,%bl
  8094e0:	75 24                	jne    809506 <udp_bind+0xc5>
      /* no more ports available in local range */
      LWIP_DEBUGF(UDP_DEBUG, ("udp_bind: out of free UDP ports\n"));
      return ERR_USE;
    }
  }
  pcb->local_port = port;
  8094e2:	66 89 4a 12          	mov    %cx,0x12(%edx)
              ("udp_bind: bound to %"U16_F".%"U16_F".%"U16_F".%"U16_F", port %"U16_F"\n",
               (u16_t)(ntohl(pcb->local_ip.addr) >> 24 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) >> 16 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) >> 8 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) & 0xff), pcb->local_port));
  return ERR_OK;
  8094e6:	b8 00 00 00 00       	mov    $0x0,%eax
    }
  }
  pcb->local_port = port;
  snmp_insert_udpidx_tree(pcb);
  /* pcb not active yet? */
  if (rebind == 0) {
  8094eb:	89 f1                	mov    %esi,%ecx
  8094ed:	84 c9                	test   %cl,%cl
  8094ef:	75 1a                	jne    80950b <udp_bind+0xca>
    /* place the PCB on the active list if not already there */
    pcb->next = udp_pcbs;
  8094f1:	a1 74 c2 b3 00       	mov    0xb3c274,%eax
  8094f6:	89 42 0c             	mov    %eax,0xc(%edx)
    udp_pcbs = pcb;
  8094f9:	89 15 74 c2 b3 00    	mov    %edx,0xb3c274
              ("udp_bind: bound to %"U16_F".%"U16_F".%"U16_F".%"U16_F", port %"U16_F"\n",
               (u16_t)(ntohl(pcb->local_ip.addr) >> 24 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) >> 16 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) >> 8 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) & 0xff), pcb->local_port));
  return ERR_OK;
  8094ff:	b8 00 00 00 00       	mov    $0x0,%eax
  809504:	eb 05                	jmp    80950b <udp_bind+0xca>
        ipcb = ipcb->next;
    }
    if (ipcb != NULL) {
      /* no more ports available in local range */
      LWIP_DEBUGF(UDP_DEBUG, ("udp_bind: out of free UDP ports\n"));
      return ERR_USE;
  809506:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
               (u16_t)(ntohl(pcb->local_ip.addr) >> 24 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) >> 16 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) >> 8 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) & 0xff), pcb->local_port));
  return ERR_OK;
}
  80950b:	83 c4 1c             	add    $0x1c,%esp
  80950e:	5b                   	pop    %ebx
  80950f:	5e                   	pop    %esi
  809510:	5f                   	pop    %edi
  809511:	5d                   	pop    %ebp
  809512:	c3                   	ret    

00809513 <udp_sendto_if>:
 * @see udp_disconnect() udp_send()
 */
err_t
udp_sendto_if(struct udp_pcb *pcb, struct pbuf *p,
  struct ip_addr *dst_ip, u16_t dst_port, struct netif *netif)
{
  809513:	55                   	push   %ebp
  809514:	89 e5                	mov    %esp,%ebp
  809516:	57                   	push   %edi
  809517:	56                   	push   %esi
  809518:	53                   	push   %ebx
  809519:	83 ec 2c             	sub    $0x2c,%esp
  80951c:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80951f:	8b 7d 14             	mov    0x14(%ebp),%edi
  struct ip_addr *src_ip;
  err_t err;
  struct pbuf *q; /* q will be sent down the stack */

  /* if the PCB is not yet bound to a port, bind it here */
  if (pcb->local_port == 0) {
  809522:	66 83 7b 12 00       	cmpw   $0x0,0x12(%ebx)
  809527:	75 1c                	jne    809545 <udp_sendto_if+0x32>
    LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 2, ("udp_send: not yet bound to a port, binding now\n"));
    err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
  809529:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  809530:	00 
  809531:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  809535:	89 1c 24             	mov    %ebx,(%esp)
  809538:	e8 04 ff ff ff       	call   809441 <udp_bind>
    if (err != ERR_OK) {
  80953d:	84 c0                	test   %al,%al
  80953f:	0f 85 76 01 00 00    	jne    8096bb <udp_sendto_if+0x1a8>
      return err;
    }
  }

  /* not enough space to add an UDP header to first pbuf in given p chain? */
  if (pbuf_header(p, UDP_HLEN)) {
  809545:	c7 44 24 04 08 00 00 	movl   $0x8,0x4(%esp)
  80954c:	00 
  80954d:	8b 45 0c             	mov    0xc(%ebp),%eax
  809550:	89 04 24             	mov    %eax,(%esp)
  809553:	e8 b8 b7 ff ff       	call   804d10 <pbuf_header>
    LWIP_DEBUGF(UDP_DEBUG,
                ("udp_send: added header pbuf %p before given pbuf %p\n", (void *)q, (void *)p));
  } else {
    /* adding space for header within p succeeded */
    /* first pbuf q equals given pbuf */
    q = p;
  809558:	8b 75 0c             	mov    0xc(%ebp),%esi
      return err;
    }
  }

  /* not enough space to add an UDP header to first pbuf in given p chain? */
  if (pbuf_header(p, UDP_HLEN)) {
  80955b:	84 c0                	test   %al,%al
  80955d:	74 35                	je     809594 <udp_sendto_if+0x81>
    /* allocate header in a separate new pbuf */
    q = pbuf_alloc(PBUF_IP, UDP_HLEN, PBUF_RAM);
  80955f:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  809566:	00 
  809567:	c7 44 24 04 08 00 00 	movl   $0x8,0x4(%esp)
  80956e:	00 
  80956f:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  809576:	e8 5a b9 ff ff       	call   804ed5 <pbuf_alloc>
  80957b:	89 c6                	mov    %eax,%esi
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
  80957d:	85 c0                	test   %eax,%eax
  80957f:	0f 84 31 01 00 00    	je     8096b6 <udp_sendto_if+0x1a3>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 2, ("udp_send: could not allocate header\n"));
      return ERR_MEM;
    }
    /* chain header q in front of given pbuf p */
    pbuf_chain(q, p);
  809585:	8b 45 0c             	mov    0xc(%ebp),%eax
  809588:	89 44 24 04          	mov    %eax,0x4(%esp)
  80958c:	89 34 24             	mov    %esi,(%esp)
  80958f:	e8 96 bd ff ff       	call   80532a <pbuf_chain>
    /* adding space for header within p succeeded */
    /* first pbuf q equals given pbuf */
    q = p;
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: added header in given pbuf %p\n", (void *)p));
  }
  LWIP_ASSERT("check that first pbuf can hold struct udp_hdr",
  809594:	66 83 7e 0a 07       	cmpw   $0x7,0xa(%esi)
  809599:	77 1c                	ja     8095b7 <udp_sendto_if+0xa4>
  80959b:	c7 44 24 08 64 30 81 	movl   $0x813064,0x8(%esp)
  8095a2:	00 
  8095a3:	c7 44 24 04 b2 01 00 	movl   $0x1b2,0x4(%esp)
  8095aa:	00 
  8095ab:	c7 04 24 2e 30 81 00 	movl   $0x81302e,(%esp)
  8095b2:	e8 c3 5a 00 00       	call   80f07a <_panic>
              (q->len >= sizeof(struct udp_hdr)));
  /* q now represents the packet to be sent */
  udphdr = q->payload;
  8095b7:	8b 46 04             	mov    0x4(%esi),%eax
  8095ba:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  udphdr->src = htons(pcb->local_port);
  8095bd:	0f b7 43 12          	movzwl 0x12(%ebx),%eax
  8095c1:	89 04 24             	mov    %eax,(%esp)
  8095c4:	e8 ad e7 ff ff       	call   807d76 <htons>
  8095c9:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  8095cc:	66 89 01             	mov    %ax,(%ecx)
  udphdr->dest = htons(dst_port);
  8095cf:	0f b7 ff             	movzwl %di,%edi
  8095d2:	89 3c 24             	mov    %edi,(%esp)
  8095d5:	e8 9c e7 ff ff       	call   807d76 <htons>
  8095da:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  8095dd:	66 89 41 02          	mov    %ax,0x2(%ecx)
  /* in UDP, 0 checksum means 'no checksum' */
  udphdr->chksum = 0x0000; 
  8095e1:	66 c7 41 06 00 00    	movw   $0x0,0x6(%ecx)

  /* PCB local address is IP_ANY_ADDR? */
  if (ip_addr_isany(&pcb->local_ip)) {
  8095e7:	89 df                	mov    %ebx,%edi
  8095e9:	85 db                	test   %ebx,%ebx
  8095eb:	74 06                	je     8095f3 <udp_sendto_if+0xe0>
  8095ed:	8b 03                	mov    (%ebx),%eax
  8095ef:	85 c0                	test   %eax,%eax
  8095f1:	75 08                	jne    8095fb <udp_sendto_if+0xe8>
    /* use outgoing network interface IP address as source address */
    src_ip = &(netif->ip_addr);
  8095f3:	8b 45 18             	mov    0x18(%ebp),%eax
  8095f6:	8d 78 04             	lea    0x4(%eax),%edi
  8095f9:	eb 28                	jmp    809623 <udp_sendto_if+0x110>
  } else {
    /* check if UDP PCB local IP address is correct
     * this could be an old address if netif->ip_addr has changed */
    if (!ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))) {
  8095fb:	8b 55 18             	mov    0x18(%ebp),%edx
  8095fe:	3b 42 04             	cmp    0x4(%edx),%eax
  809601:	74 20                	je     809623 <udp_sendto_if+0x110>
        /* free the header pbuf */
        pbuf_free(q);
        q = NULL;
        /* p is still referenced by the caller, and will live on */
      }
      return ERR_VAL;
  809603:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  } else {
    /* check if UDP PCB local IP address is correct
     * this could be an old address if netif->ip_addr has changed */
    if (!ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))) {
      /* local_ip doesn't match, drop the packet */
      if (q != p) {
  809608:	3b 75 0c             	cmp    0xc(%ebp),%esi
  80960b:	0f 84 aa 00 00 00    	je     8096bb <udp_sendto_if+0x1a8>
        /* free the header pbuf */
        pbuf_free(q);
  809611:	89 34 24             	mov    %esi,(%esp)
  809614:	e8 db b7 ff ff       	call   804df4 <pbuf_free>
        q = NULL;
        /* p is still referenced by the caller, and will live on */
      }
      return ERR_VAL;
  809619:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  80961e:	e9 98 00 00 00       	jmp    8096bb <udp_sendto_if+0x1a8>
#endif /* LWIP_NETIF_HWADDRHINT*/
  } else
#endif /* LWIP_UDPLITE */
  {      /* UDP */
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: UDP packet length %"U16_F"\n", q->tot_len));
    udphdr->len = htons(q->tot_len);
  809623:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  809627:	89 04 24             	mov    %eax,(%esp)
  80962a:	e8 47 e7 ff ff       	call   807d76 <htons>
  80962f:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  809632:	66 89 42 04          	mov    %ax,0x4(%edx)
    /* calculate checksum */
#if CHECKSUM_GEN_UDP
    if ((pcb->flags & UDP_FLAGS_NOCHKSUM) == 0) {
  809636:	f6 43 10 01          	testb  $0x1,0x10(%ebx)
  80963a:	75 35                	jne    809671 <udp_sendto_if+0x15e>
      udphdr->chksum = inet_chksum_pseudo(q, src_ip, dst_ip, IP_PROTO_UDP, q->tot_len);
  80963c:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  809640:	89 44 24 10          	mov    %eax,0x10(%esp)
  809644:	c7 44 24 0c 11 00 00 	movl   $0x11,0xc(%esp)
  80964b:	00 
  80964c:	8b 45 10             	mov    0x10(%ebp),%eax
  80964f:	89 44 24 08          	mov    %eax,0x8(%esp)
  809653:	89 7c 24 04          	mov    %edi,0x4(%esp)
  809657:	89 34 24             	mov    %esi,(%esp)
  80965a:	e8 cf e3 ff ff       	call   807a2e <inet_chksum_pseudo>
  80965f:	66 85 c0             	test   %ax,%ax
  809662:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  809667:	0f 44 c2             	cmove  %edx,%eax
  80966a:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80966d:	66 89 42 06          	mov    %ax,0x6(%edx)
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: ip_output_if (,,,,IP_PROTO_UDP,)\n"));
    /* output to IP */
#if LWIP_NETIF_HWADDRHINT
    netif->addr_hint = &(pcb->addr_hint);
#endif /* LWIP_NETIF_HWADDRHINT*/
    err = ip_output_if(q, src_ip, dst_ip, pcb->ttl, pcb->tos, IP_PROTO_UDP, netif);    
  809671:	8b 45 18             	mov    0x18(%ebp),%eax
  809674:	89 44 24 18          	mov    %eax,0x18(%esp)
  809678:	c7 44 24 14 11 00 00 	movl   $0x11,0x14(%esp)
  80967f:	00 
  809680:	0f b6 43 0a          	movzbl 0xa(%ebx),%eax
  809684:	89 44 24 10          	mov    %eax,0x10(%esp)
  809688:	0f b6 43 0b          	movzbl 0xb(%ebx),%eax
  80968c:	89 44 24 0c          	mov    %eax,0xc(%esp)
  809690:	8b 45 10             	mov    0x10(%ebp),%eax
  809693:	89 44 24 08          	mov    %eax,0x8(%esp)
  809697:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80969b:	89 34 24             	mov    %esi,(%esp)
  80969e:	e8 7b d7 ff ff       	call   806e1e <ip_output_if>
  8096a3:	89 c3                	mov    %eax,%ebx
  }
  /* TODO: must this be increased even if error occured? */
  snmp_inc_udpoutdatagrams();

  /* did we chain a separate header pbuf earlier? */
  if (q != p) {
  8096a5:	3b 75 0c             	cmp    0xc(%ebp),%esi
  8096a8:	74 11                	je     8096bb <udp_sendto_if+0x1a8>
    /* free the header pbuf */
    pbuf_free(q);
  8096aa:	89 34 24             	mov    %esi,(%esp)
  8096ad:	e8 42 b7 ff ff       	call   804df4 <pbuf_free>
    q = NULL;
    /* p is still referenced by the caller, and will live on */
  }

  UDP_STATS_INC(udp.xmit);
  return err;
  8096b2:	89 d8                	mov    %ebx,%eax
  8096b4:	eb 05                	jmp    8096bb <udp_sendto_if+0x1a8>
    /* allocate header in a separate new pbuf */
    q = pbuf_alloc(PBUF_IP, UDP_HLEN, PBUF_RAM);
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 2, ("udp_send: could not allocate header\n"));
      return ERR_MEM;
  8096b6:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    /* p is still referenced by the caller, and will live on */
  }

  UDP_STATS_INC(udp.xmit);
  return err;
}
  8096bb:	83 c4 2c             	add    $0x2c,%esp
  8096be:	5b                   	pop    %ebx
  8096bf:	5e                   	pop    %esi
  8096c0:	5f                   	pop    %edi
  8096c1:	5d                   	pop    %ebp
  8096c2:	c3                   	ret    

008096c3 <udp_sendto>:
 * @see udp_disconnect() udp_send()
 */
err_t
udp_sendto(struct udp_pcb *pcb, struct pbuf *p,
  struct ip_addr *dst_ip, u16_t dst_port)
{
  8096c3:	55                   	push   %ebp
  8096c4:	89 e5                	mov    %esp,%ebp
  8096c6:	56                   	push   %esi
  8096c7:	53                   	push   %ebx
  8096c8:	83 ec 20             	sub    $0x20,%esp
  8096cb:	8b 5d 10             	mov    0x10(%ebp),%ebx
  8096ce:	8b 75 14             	mov    0x14(%ebp),%esi

  /* find the outgoing network interface for this packet */
#if LWIP_IGMP
  netif = ip_route((ip_addr_ismulticast(dst_ip))?(&(pcb->multicast_ip)):(dst_ip));
#else
  netif = ip_route(dst_ip);
  8096d1:	89 1c 24             	mov    %ebx,(%esp)
  8096d4:	e8 07 d4 ff ff       	call   806ae0 <ip_route>
#endif /* LWIP_IGMP */

  /* no outgoing network interface could be found? */
  if (netif == NULL) {
  8096d9:	85 c0                	test   %eax,%eax
  8096db:	74 23                	je     809700 <udp_sendto+0x3d>
    LWIP_DEBUGF(UDP_DEBUG | 1, ("udp_send: No route to 0x%"X32_F"\n", dst_ip->addr));
    UDP_STATS_INC(udp.rterr);
    return ERR_RTE;
  }
  return udp_sendto_if(pcb, p, dst_ip, dst_port, netif);
  8096dd:	89 44 24 10          	mov    %eax,0x10(%esp)
  8096e1:	0f b7 f6             	movzwl %si,%esi
  8096e4:	89 74 24 0c          	mov    %esi,0xc(%esp)
  8096e8:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  8096ec:	8b 45 0c             	mov    0xc(%ebp),%eax
  8096ef:	89 44 24 04          	mov    %eax,0x4(%esp)
  8096f3:	8b 45 08             	mov    0x8(%ebp),%eax
  8096f6:	89 04 24             	mov    %eax,(%esp)
  8096f9:	e8 15 fe ff ff       	call   809513 <udp_sendto_if>
  8096fe:	eb 05                	jmp    809705 <udp_sendto+0x42>

  /* no outgoing network interface could be found? */
  if (netif == NULL) {
    LWIP_DEBUGF(UDP_DEBUG | 1, ("udp_send: No route to 0x%"X32_F"\n", dst_ip->addr));
    UDP_STATS_INC(udp.rterr);
    return ERR_RTE;
  809700:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  }
  return udp_sendto_if(pcb, p, dst_ip, dst_port, netif);
}
  809705:	83 c4 20             	add    $0x20,%esp
  809708:	5b                   	pop    %ebx
  809709:	5e                   	pop    %esi
  80970a:	5d                   	pop    %ebp
  80970b:	c3                   	ret    

0080970c <udp_send>:
 *
 * @see udp_disconnect() udp_sendto()
 */
err_t
udp_send(struct udp_pcb *pcb, struct pbuf *p)
{
  80970c:	55                   	push   %ebp
  80970d:	89 e5                	mov    %esp,%ebp
  80970f:	83 ec 18             	sub    $0x18,%esp
  809712:	8b 45 08             	mov    0x8(%ebp),%eax
  /* send to the packet using remote ip and port stored in the pcb */
  return udp_sendto(pcb, p, &pcb->remote_ip, pcb->remote_port);
  809715:	0f b7 50 14          	movzwl 0x14(%eax),%edx
  809719:	89 54 24 0c          	mov    %edx,0xc(%esp)
  80971d:	8d 50 04             	lea    0x4(%eax),%edx
  809720:	89 54 24 08          	mov    %edx,0x8(%esp)
  809724:	8b 55 0c             	mov    0xc(%ebp),%edx
  809727:	89 54 24 04          	mov    %edx,0x4(%esp)
  80972b:	89 04 24             	mov    %eax,(%esp)
  80972e:	e8 90 ff ff ff       	call   8096c3 <udp_sendto>
}
  809733:	c9                   	leave  
  809734:	c3                   	ret    

00809735 <udp_connect>:
 *
 * @see udp_disconnect()
 */
err_t
udp_connect(struct udp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
{
  809735:	55                   	push   %ebp
  809736:	89 e5                	mov    %esp,%ebp
  809738:	57                   	push   %edi
  809739:	56                   	push   %esi
  80973a:	53                   	push   %ebx
  80973b:	83 ec 1c             	sub    $0x1c,%esp
  80973e:	8b 5d 08             	mov    0x8(%ebp),%ebx
  809741:	8b 75 0c             	mov    0xc(%ebp),%esi
  809744:	8b 7d 10             	mov    0x10(%ebp),%edi
  struct udp_pcb *ipcb;

  if (pcb->local_port == 0) {
  809747:	66 83 7b 12 00       	cmpw   $0x0,0x12(%ebx)
  80974c:	75 1a                	jne    809768 <udp_connect+0x33>
    err_t err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
  80974e:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  809755:	00 
  809756:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80975a:	89 1c 24             	mov    %ebx,(%esp)
  80975d:	e8 df fc ff ff       	call   809441 <udp_bind>
  809762:	89 c2                	mov    %eax,%edx
    if (err != ERR_OK)
  809764:	84 d2                	test   %dl,%dl
  809766:	75 3f                	jne    8097a7 <udp_connect+0x72>
      return err;
  }

  ip_addr_set(&pcb->remote_ip, ipaddr);
  809768:	85 f6                	test   %esi,%esi
  80976a:	74 06                	je     809772 <udp_connect+0x3d>
  80976c:	8b 06                	mov    (%esi),%eax
  80976e:	66 90                	xchg   %ax,%ax
  809770:	eb 05                	jmp    809777 <udp_connect+0x42>
  809772:	b8 00 00 00 00       	mov    $0x0,%eax
  809777:	89 43 04             	mov    %eax,0x4(%ebx)
  pcb->remote_port = port;
  80977a:	66 89 7b 14          	mov    %di,0x14(%ebx)
  pcb->flags |= UDP_FLAGS_CONNECTED;
  80977e:	80 4b 10 04          	orb    $0x4,0x10(%ebx)
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 16 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 8 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) & 0xff), pcb->remote_port));

  /* Insert UDP PCB into the list of active UDP PCBs. */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  809782:	8b 15 74 c2 b3 00    	mov    0xb3c274,%edx
  809788:	89 d0                	mov    %edx,%eax
  80978a:	eb 07                	jmp    809793 <udp_connect+0x5e>
    if (pcb == ipcb) {
  80978c:	39 c3                	cmp    %eax,%ebx
  80978e:	74 12                	je     8097a2 <udp_connect+0x6d>
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 16 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 8 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) & 0xff), pcb->remote_port));

  /* Insert UDP PCB into the list of active UDP PCBs. */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  809790:	8b 40 0c             	mov    0xc(%eax),%eax
  809793:	85 c0                	test   %eax,%eax
  809795:	75 f5                	jne    80978c <udp_connect+0x57>
      /* already on the list, just return */
      return ERR_OK;
    }
  }
  /* PCB not yet on the list, add PCB now */
  pcb->next = udp_pcbs;
  809797:	89 53 0c             	mov    %edx,0xc(%ebx)
  udp_pcbs = pcb;
  80979a:	89 1d 74 c2 b3 00    	mov    %ebx,0xb3c274
  return ERR_OK;
  8097a0:	eb 05                	jmp    8097a7 <udp_connect+0x72>

  /* Insert UDP PCB into the list of active UDP PCBs. */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
    if (pcb == ipcb) {
      /* already on the list, just return */
      return ERR_OK;
  8097a2:	b8 00 00 00 00       	mov    $0x0,%eax
  }
  /* PCB not yet on the list, add PCB now */
  pcb->next = udp_pcbs;
  udp_pcbs = pcb;
  return ERR_OK;
}
  8097a7:	83 c4 1c             	add    $0x1c,%esp
  8097aa:	5b                   	pop    %ebx
  8097ab:	5e                   	pop    %esi
  8097ac:	5f                   	pop    %edi
  8097ad:	5d                   	pop    %ebp
  8097ae:	c3                   	ret    

008097af <udp_disconnect>:
 *
 * @param pcb the udp pcb to disconnect.
 */
void
udp_disconnect(struct udp_pcb *pcb)
{
  8097af:	55                   	push   %ebp
  8097b0:	89 e5                	mov    %esp,%ebp
  8097b2:	8b 45 08             	mov    0x8(%ebp),%eax
  /* reset remote address association */
  ip_addr_set(&pcb->remote_ip, IP_ADDR_ANY);
  8097b5:	8b 15 a0 2c 81 00    	mov    0x812ca0,%edx
  8097bb:	89 50 04             	mov    %edx,0x4(%eax)
  pcb->remote_port = 0;
  8097be:	66 c7 40 14 00 00    	movw   $0x0,0x14(%eax)
  /* mark PCB as unconnected */
  pcb->flags &= ~UDP_FLAGS_CONNECTED;
  8097c4:	80 60 10 fb          	andb   $0xfb,0x10(%eax)
}
  8097c8:	5d                   	pop    %ebp
  8097c9:	c3                   	ret    

008097ca <udp_recv>:
void
udp_recv(struct udp_pcb *pcb,
         void (* recv)(void *arg, struct udp_pcb *upcb, struct pbuf *p,
                       struct ip_addr *addr, u16_t port),
         void *recv_arg)
{
  8097ca:	55                   	push   %ebp
  8097cb:	89 e5                	mov    %esp,%ebp
  8097cd:	8b 45 08             	mov    0x8(%ebp),%eax
  /* remember recv() callback and user data */
  pcb->recv = recv;
  8097d0:	8b 55 0c             	mov    0xc(%ebp),%edx
  8097d3:	89 50 18             	mov    %edx,0x18(%eax)
  pcb->recv_arg = recv_arg;
  8097d6:	8b 55 10             	mov    0x10(%ebp),%edx
  8097d9:	89 50 1c             	mov    %edx,0x1c(%eax)
}
  8097dc:	5d                   	pop    %ebp
  8097dd:	c3                   	ret    

008097de <udp_remove>:
 *
 * @see udp_new()
 */
void
udp_remove(struct udp_pcb *pcb)
{
  8097de:	55                   	push   %ebp
  8097df:	89 e5                	mov    %esp,%ebp
  8097e1:	83 ec 18             	sub    $0x18,%esp
  8097e4:	8b 4d 08             	mov    0x8(%ebp),%ecx
  struct udp_pcb *pcb2;

  snmp_delete_udpidx_tree(pcb);
  /* pcb to be removed is first in list? */
  if (udp_pcbs == pcb) {
  8097e7:	a1 74 c2 b3 00       	mov    0xb3c274,%eax
  8097ec:	39 c8                	cmp    %ecx,%eax
  8097ee:	75 1e                	jne    80980e <udp_remove+0x30>
    /* make list start at 2nd pcb */
    udp_pcbs = udp_pcbs->next;
  8097f0:	8b 40 0c             	mov    0xc(%eax),%eax
  8097f3:	a3 74 c2 b3 00       	mov    %eax,0xb3c274
  8097f8:	eb 18                	jmp    809812 <udp_remove+0x34>
    /* pcb not 1st in list */
  } else
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
      /* find pcb in udp_pcbs list */
      if (pcb2->next != NULL && pcb2->next == pcb) {
  8097fa:	8b 50 0c             	mov    0xc(%eax),%edx
  8097fd:	85 d2                	test   %edx,%edx
  8097ff:	74 0a                	je     80980b <udp_remove+0x2d>
  809801:	39 d1                	cmp    %edx,%ecx
  809803:	75 06                	jne    80980b <udp_remove+0x2d>
        /* remove pcb from list */
        pcb2->next = pcb->next;
  809805:	8b 51 0c             	mov    0xc(%ecx),%edx
  809808:	89 50 0c             	mov    %edx,0xc(%eax)
  if (udp_pcbs == pcb) {
    /* make list start at 2nd pcb */
    udp_pcbs = udp_pcbs->next;
    /* pcb not 1st in list */
  } else
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
  80980b:	8b 40 0c             	mov    0xc(%eax),%eax
  80980e:	85 c0                	test   %eax,%eax
  809810:	75 e8                	jne    8097fa <udp_remove+0x1c>
      if (pcb2->next != NULL && pcb2->next == pcb) {
        /* remove pcb from list */
        pcb2->next = pcb->next;
      }
    }
  memp_free(MEMP_UDP_PCB, pcb);
  809812:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  809816:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  80981d:	e8 20 b2 ff ff       	call   804a42 <memp_free>
}
  809822:	c9                   	leave  
  809823:	c3                   	ret    

00809824 <udp_new>:
 *
 * @see udp_remove()
 */
struct udp_pcb *
udp_new(void)
{
  809824:	55                   	push   %ebp
  809825:	89 e5                	mov    %esp,%ebp
  809827:	53                   	push   %ebx
  809828:	83 ec 14             	sub    $0x14,%esp
  struct udp_pcb *pcb;
  pcb = memp_malloc(MEMP_UDP_PCB);
  80982b:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  809832:	e8 ab b1 ff ff       	call   8049e2 <memp_malloc>
  809837:	89 c3                	mov    %eax,%ebx
  /* could allocate UDP PCB? */
  if (pcb != NULL) {
  809839:	85 c0                	test   %eax,%eax
  80983b:	74 1c                	je     809859 <udp_new+0x35>
    /* UDP Lite: by initializing to all zeroes, chksum_len is set to 0
     * which means checksum is generated over the whole datagram per default
     * (recommended as default by RFC 3828). */
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct udp_pcb));
  80983d:	c7 44 24 08 20 00 00 	movl   $0x20,0x8(%esp)
  809844:	00 
  809845:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80984c:	00 
  80984d:	89 04 24             	mov    %eax,(%esp)
  809850:	e8 92 60 00 00       	call   80f8e7 <memset>
    pcb->ttl = UDP_TTL;
  809855:	c6 43 0b ff          	movb   $0xff,0xb(%ebx)
  }
  return pcb;
}
  809859:	89 d8                	mov    %ebx,%eax
  80985b:	83 c4 14             	add    $0x14,%esp
  80985e:	5b                   	pop    %ebx
  80985f:	5d                   	pop    %ebp
  809860:	c3                   	ret    
  809861:	66 90                	xchg   %ax,%ax
  809863:	66 90                	xchg   %ax,%ax
  809865:	66 90                	xchg   %ax,%ax
  809867:	66 90                	xchg   %ax,%ax
  809869:	66 90                	xchg   %ax,%ax
  80986b:	66 90                	xchg   %ax,%ax
  80986d:	66 90                	xchg   %ax,%ax
  80986f:	90                   	nop

00809870 <free_etharp_q>:
 *
 * @param q a qeueue of etharp_q_entry's to free
 */
static void
free_etharp_q(struct etharp_q_entry *q)
{
  809870:	55                   	push   %ebp
  809871:	89 e5                	mov    %esp,%ebp
  809873:	56                   	push   %esi
  809874:	53                   	push   %ebx
  809875:	83 ec 10             	sub    $0x10,%esp
  809878:	89 c3                	mov    %eax,%ebx
  struct etharp_q_entry *r;
  LWIP_ASSERT("q != NULL", q != NULL);
  80987a:	85 c0                	test   %eax,%eax
  80987c:	75 1c                	jne    80989a <free_etharp_q+0x2a>
  80987e:	c7 44 24 08 a8 27 81 	movl   $0x8127a8,0x8(%esp)
  809885:	00 
  809886:	c7 44 24 04 93 00 00 	movl   $0x93,0x4(%esp)
  80988d:	00 
  80988e:	c7 04 24 92 30 81 00 	movl   $0x813092,(%esp)
  809895:	e8 e0 57 00 00       	call   80f07a <_panic>
  LWIP_ASSERT("q->p != NULL", q->p != NULL);
  80989a:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
  80989e:	75 1c                	jne    8098bc <free_etharp_q+0x4c>
  8098a0:	c7 44 24 08 aa 30 81 	movl   $0x8130aa,0x8(%esp)
  8098a7:	00 
  8098a8:	c7 44 24 04 94 00 00 	movl   $0x94,0x4(%esp)
  8098af:	00 
  8098b0:	c7 04 24 92 30 81 00 	movl   $0x813092,(%esp)
  8098b7:	e8 be 57 00 00       	call   80f07a <_panic>
  while (q) {
    r = q;
    q = q->next;
  8098bc:	8b 33                	mov    (%ebx),%esi
    LWIP_ASSERT("r->p != NULL", (r->p != NULL));
  8098be:	8b 43 04             	mov    0x4(%ebx),%eax
  8098c1:	85 c0                	test   %eax,%eax
  8098c3:	75 1c                	jne    8098e1 <free_etharp_q+0x71>
  8098c5:	c7 44 24 08 b7 30 81 	movl   $0x8130b7,0x8(%esp)
  8098cc:	00 
  8098cd:	c7 44 24 04 98 00 00 	movl   $0x98,0x4(%esp)
  8098d4:	00 
  8098d5:	c7 04 24 92 30 81 00 	movl   $0x813092,(%esp)
  8098dc:	e8 99 57 00 00       	call   80f07a <_panic>
    pbuf_free(r->p);
  8098e1:	89 04 24             	mov    %eax,(%esp)
  8098e4:	e8 0b b5 ff ff       	call   804df4 <pbuf_free>
    memp_free(MEMP_ARP_QUEUE, r);
  8098e9:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8098ed:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
  8098f4:	e8 49 b1 ff ff       	call   804a42 <memp_free>
free_etharp_q(struct etharp_q_entry *q)
{
  struct etharp_q_entry *r;
  LWIP_ASSERT("q != NULL", q != NULL);
  LWIP_ASSERT("q->p != NULL", q->p != NULL);
  while (q) {
  8098f9:	85 f6                	test   %esi,%esi
  8098fb:	74 04                	je     809901 <free_etharp_q+0x91>
    r = q;
    q = q->next;
  8098fd:	89 f3                	mov    %esi,%ebx
  8098ff:	eb bb                	jmp    8098bc <free_etharp_q+0x4c>
    LWIP_ASSERT("r->p != NULL", (r->p != NULL));
    pbuf_free(r->p);
    memp_free(MEMP_ARP_QUEUE, r);
  }
}
  809901:	83 c4 10             	add    $0x10,%esp
  809904:	5b                   	pop    %ebx
  809905:	5e                   	pop    %esi
  809906:	5d                   	pop    %ebp
  809907:	c3                   	ret    

00809908 <find_entry>:
#if LWIP_NETIF_HWADDRHINT
find_entry(struct ip_addr *ipaddr, u8_t flags, struct netif *netif)
#else /* LWIP_NETIF_HWADDRHINT */
find_entry(struct ip_addr *ipaddr, u8_t flags)
#endif /* LWIP_NETIF_HWADDRHINT */
{
  809908:	55                   	push   %ebp
  809909:	89 e5                	mov    %esp,%ebp
  80990b:	57                   	push   %edi
  80990c:	56                   	push   %esi
  80990d:	53                   	push   %ebx
  80990e:	83 ec 2c             	sub    $0x2c,%esp
  809911:	89 c3                	mov    %eax,%ebx
  809913:	89 55 dc             	mov    %edx,-0x24(%ebp)
  u8_t age_queue = 0;
#endif

  /* First, test if the last call to this function asked for the
   * same address. If so, we're really fast! */
  if (ipaddr) {
  809916:	85 c0                	test   %eax,%eax
  809918:	75 2f                	jne    809949 <find_entry+0x41>
  80991a:	ba 54 5a b3 00       	mov    $0xb35a54,%edx
#endif
      /* pending without queued packets? */
      } else {
        if (arp_table[i].ctime >= age_pending) {
          old_pending = i;
          age_pending = arp_table[i].ctime;
  80991f:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
  809923:	c6 45 e0 0a          	movb   $0xa,-0x20(%ebp)
  809927:	c6 45 e2 00          	movb   $0x0,-0x1e(%ebp)
  80992b:	c6 45 db 00          	movb   $0x0,-0x25(%ebp)
  80992f:	b9 00 00 00 00       	mov    $0x0,%ecx
  809934:	b8 0a 00 00 00       	mov    $0xa,%eax
  809939:	c6 45 e1 0a          	movb   $0xa,-0x1f(%ebp)
  80993d:	c6 45 da 0a          	movb   $0xa,-0x26(%ebp)
  809941:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
  809944:	e9 b8 00 00 00       	jmp    809a01 <find_entry+0xf9>
          return per_pcb_cache;
        }
      }
    }
#else /* #if LWIP_NETIF_HWADDRHINT */
    if (arp_table[etharp_cached_entry].state == ETHARP_STATE_STABLE) {
  809949:	0f b6 05 20 5a b3 00 	movzbl 0xb35a20,%eax
  809950:	0f b6 d0             	movzbl %al,%edx
  809953:	6b ca 1c             	imul   $0x1c,%edx,%ecx
  809956:	83 b9 50 5a b3 00 02 	cmpl   $0x2,0xb35a50(%ecx)
  80995d:	75 bb                	jne    80991a <find_entry+0x12>
      /* the cached entry is stable */
      if (ip_addr_cmp(ipaddr, &arp_table[etharp_cached_entry].ipaddr)) {
  80995f:	8b b9 44 5a b3 00    	mov    0xb35a44(%ecx),%edi
  809965:	39 3b                	cmp    %edi,(%ebx)
  809967:	75 b1                	jne    80991a <find_entry+0x12>
        /* cached entry was the right one! */
        ETHARP_STATS_INC(etharp.cachehit);
        return etharp_cached_entry;
  809969:	e9 a7 01 00 00       	jmp    809b15 <find_entry+0x20d>
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (arp_table[i].state == ETHARP_STATE_EMPTY)) {
  80996e:	3c 0a                	cmp    $0xa,%al
  809970:	75 0a                	jne    80997c <find_entry+0x74>
  809972:	83 7a fc 00          	cmpl   $0x0,-0x4(%edx)
  809976:	75 04                	jne    80997c <find_entry+0x74>
      LWIP_DEBUGF(ETHARP_DEBUG, ("find_entry: found empty entry %"U16_F"\n", (u16_t)i));
      /* remember first empty entry */
      empty = i;
  809978:	89 c8                	mov    %ecx,%eax
  80997a:	eb 7f                	jmp    8099fb <find_entry+0xf3>
  80997c:	89 d7                	mov    %edx,%edi
    }
    /* pending entry? */
    else if (arp_table[i].state == ETHARP_STATE_PENDING) {
  80997e:	8b 72 fc             	mov    -0x4(%edx),%esi
  809981:	83 fe 01             	cmp    $0x1,%esi
  809984:	75 45                	jne    8099cb <find_entry+0xc3>
      /* if given, does IP address match IP address in ARP entry? */
      if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
  809986:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  809989:	85 f6                	test   %esi,%esi
  80998b:	74 14                	je     8099a1 <find_entry+0x99>
  80998d:	8b 5a f0             	mov    -0x10(%edx),%ebx
  809990:	39 1e                	cmp    %ebx,(%esi)
  809992:	75 0d                	jne    8099a1 <find_entry+0x99>
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: found matching pending entry %"U16_F"\n", (u16_t)i));
        /* found exact IP address match, simply bail out */
#if LWIP_NETIF_HWADDRHINT
        NETIF_SET_HINT(netif, i);
#else /* #if LWIP_NETIF_HWADDRHINT */
        etharp_cached_entry = i;
  809994:	88 0d 20 5a b3 00    	mov    %cl,0xb35a20
#endif /* #if LWIP_NETIF_HWADDRHINT */
        return i;
  80999a:	89 c8                	mov    %ecx,%eax
  80999c:	e9 74 01 00 00       	jmp    809b15 <find_entry+0x20d>
#if ARP_QUEUEING
      /* pending with queued packets? */
      } else if (arp_table[i].q != NULL) {
  8099a1:	83 7f ec 00          	cmpl   $0x0,-0x14(%edi)
  8099a5:	74 12                	je     8099b9 <find_entry+0xb1>
        if (arp_table[i].ctime >= age_queue) {
  8099a7:	0f b6 37             	movzbl (%edi),%esi
  8099aa:	89 f3                	mov    %esi,%ebx
  8099ac:	38 5d e3             	cmp    %bl,-0x1d(%ebp)
  8099af:	77 4a                	ja     8099fb <find_entry+0xf3>
          old_queue = i;
  8099b1:	88 4d e0             	mov    %cl,-0x20(%ebp)
          age_queue = arp_table[i].ctime;
  8099b4:	88 5d e3             	mov    %bl,-0x1d(%ebp)
  8099b7:	eb 42                	jmp    8099fb <find_entry+0xf3>
        }
#endif
      /* pending without queued packets? */
      } else {
        if (arp_table[i].ctime >= age_pending) {
  8099b9:	0f b6 37             	movzbl (%edi),%esi
  8099bc:	89 f3                	mov    %esi,%ebx
  8099be:	38 5d db             	cmp    %bl,-0x25(%ebp)
  8099c1:	77 38                	ja     8099fb <find_entry+0xf3>
          old_pending = i;
  8099c3:	88 4d da             	mov    %cl,-0x26(%ebp)
          age_pending = arp_table[i].ctime;
  8099c6:	88 5d db             	mov    %bl,-0x25(%ebp)
  8099c9:	eb 30                	jmp    8099fb <find_entry+0xf3>
        }
      }        
    }
    /* stable entry? */
    else if (arp_table[i].state == ETHARP_STATE_STABLE) {
  8099cb:	83 fe 02             	cmp    $0x2,%esi
  8099ce:	75 2b                	jne    8099fb <find_entry+0xf3>
      /* if given, does IP address match IP address in ARP entry? */
      if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
  8099d0:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  8099d3:	85 f6                	test   %esi,%esi
  8099d5:	74 14                	je     8099eb <find_entry+0xe3>
  8099d7:	8b 5a f0             	mov    -0x10(%edx),%ebx
  8099da:	39 1e                	cmp    %ebx,(%esi)
  8099dc:	75 0d                	jne    8099eb <find_entry+0xe3>
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: found matching stable entry %"U16_F"\n", (u16_t)i));
        /* found exact IP address match, simply bail out */
#if LWIP_NETIF_HWADDRHINT
        NETIF_SET_HINT(netif, i);
#else /* #if LWIP_NETIF_HWADDRHINT */
        etharp_cached_entry = i;
  8099de:	88 0d 20 5a b3 00    	mov    %cl,0xb35a20
#endif /* #if LWIP_NETIF_HWADDRHINT */
        return i;
  8099e4:	89 c8                	mov    %ecx,%eax
  8099e6:	e9 2a 01 00 00       	jmp    809b15 <find_entry+0x20d>
      /* remember entry with oldest stable entry in oldest, its age in maxtime */
      } else if (arp_table[i].ctime >= age_stable) {
  8099eb:	0f b6 37             	movzbl (%edi),%esi
  8099ee:	89 f3                	mov    %esi,%ebx
  8099f0:	38 5d e2             	cmp    %bl,-0x1e(%ebp)
  8099f3:	77 06                	ja     8099fb <find_entry+0xf3>
        old_stable = i;
  8099f5:	88 4d e1             	mov    %cl,-0x1f(%ebp)
        age_stable = arp_table[i].ctime;
  8099f8:	88 5d e2             	mov    %bl,-0x1e(%ebp)
   * 4) remember the oldest pending entry with queued packets (if any)
   * 5) search for a matching IP entry, either pending or stable
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
  8099fb:	83 c1 01             	add    $0x1,%ecx
  8099fe:	83 c2 1c             	add    $0x1c,%edx
  809a01:	80 f9 0a             	cmp    $0xa,%cl
  809a04:	0f 85 64 ff ff ff    	jne    80996e <find_entry+0x66>
  809a0a:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
    }
  }
  /* { we have no match } => try to create a new entry */
   
  /* no empty entry found and not allowed to recycle? */
  if (((empty == ARP_TABLE_SIZE) && ((flags & ETHARP_TRY_HARD) == 0))
  809a0d:	3c 0a                	cmp    $0xa,%al
  809a0f:	75 0f                	jne    809a20 <find_entry+0x118>
  809a11:	f6 45 dc 01          	testb  $0x1,-0x24(%ebp)
  809a15:	0f 85 ee 00 00 00    	jne    809b09 <find_entry+0x201>
  809a1b:	e9 cd 00 00 00       	jmp    809aed <find_entry+0x1e5>
      /* or don't create new entry, only search? */
      || ((flags & ETHARP_FIND_ONLY) != 0)) {
  809a20:	f6 45 dc 02          	testb  $0x2,-0x24(%ebp)
  809a24:	0f 85 ca 00 00 00    	jne    809af4 <find_entry+0x1ec>
   * { ETHARP_TRY_HARD is set at this point }
   */ 

  /* 1) empty entry available? */
  if (empty < ARP_TABLE_SIZE) {
    i = empty;
  809a2a:	89 c6                	mov    %eax,%esi
   * 
   * { ETHARP_TRY_HARD is set at this point }
   */ 

  /* 1) empty entry available? */
  if (empty < ARP_TABLE_SIZE) {
  809a2c:	3c 09                	cmp    $0x9,%al
  809a2e:	66 90                	xchg   %ax,%ax
  809a30:	7e 68                	jle    809a9a <find_entry+0x192>
    i = empty;
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting empty entry %"U16_F"\n", (u16_t)i));
  }
  /* 2) found recyclable stable entry? */
  else if (old_stable < ARP_TABLE_SIZE) {
  809a32:	80 7d e1 09          	cmpb   $0x9,-0x1f(%ebp)
  809a36:	7f 31                	jg     809a69 <find_entry+0x161>
    /* recycle oldest stable*/
    i = old_stable;
  809a38:	0f b6 45 e1          	movzbl -0x1f(%ebp),%eax
  809a3c:	89 c6                	mov    %eax,%esi
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting oldest stable entry %"U16_F"\n", (u16_t)i));
#if ARP_QUEUEING
    /* no queued packets should exist on stable entries */
    LWIP_ASSERT("arp_table[i].q == NULL", arp_table[i].q == NULL);
  809a3e:	0f b6 c0             	movzbl %al,%eax
  809a41:	6b c0 1c             	imul   $0x1c,%eax,%eax
  809a44:	83 b8 40 5a b3 00 00 	cmpl   $0x0,0xb35a40(%eax)
  809a4b:	74 4d                	je     809a9a <find_entry+0x192>
  809a4d:	c7 44 24 08 c4 30 81 	movl   $0x8130c4,0x8(%esp)
  809a54:	00 
  809a55:	c7 44 24 04 75 01 00 	movl   $0x175,0x4(%esp)
  809a5c:	00 
  809a5d:	c7 04 24 92 30 81 00 	movl   $0x813092,(%esp)
  809a64:	e8 11 56 00 00       	call   80f07a <_panic>
#endif
  /* 3) found recyclable pending entry without queued packets? */
  } else if (old_pending < ARP_TABLE_SIZE) {
  809a69:	80 7d da 09          	cmpb   $0x9,-0x26(%ebp)
  809a6d:	7f 06                	jg     809a75 <find_entry+0x16d>
    /* recycle oldest pending */
    i = old_pending;
  809a6f:	0f b6 75 da          	movzbl -0x26(%ebp),%esi
  809a73:	eb 25                	jmp    809a9a <find_entry+0x192>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting oldest pending entry %"U16_F" (without queue)\n", (u16_t)i));
#if ARP_QUEUEING
  /* 4) found recyclable pending entry with queued packets? */
  } else if (old_queue < ARP_TABLE_SIZE) {
  809a75:	0f b6 45 e0          	movzbl -0x20(%ebp),%eax
  809a79:	3c 09                	cmp    $0x9,%al
  809a7b:	7f 7e                	jg     809afb <find_entry+0x1f3>
    /* recycle oldest pending */
    i = old_queue;
  809a7d:	89 c6                	mov    %eax,%esi
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting oldest pending entry %"U16_F", freeing packet queue %p\n", (u16_t)i, (void *)(arp_table[i].q)));
    free_etharp_q(arp_table[i].q);
  809a7f:	0f b6 f8             	movzbl %al,%edi
  809a82:	6b ff 1c             	imul   $0x1c,%edi,%edi
  809a85:	8b 87 40 5a b3 00    	mov    0xb35a40(%edi),%eax
  809a8b:	e8 e0 fd ff ff       	call   809870 <free_etharp_q>
    arp_table[i].q = NULL;
  809a90:	c7 87 40 5a b3 00 00 	movl   $0x0,0xb35a40(%edi)
  809a97:	00 00 00 
  } else {
    return (s8_t)ERR_MEM;
  }

  /* { empty or recyclable entry found } */
  LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
  809a9a:	89 f0                	mov    %esi,%eax
  809a9c:	3c 09                	cmp    $0x9,%al
  809a9e:	76 1c                	jbe    809abc <find_entry+0x1b4>
  809aa0:	c7 44 24 08 db 30 81 	movl   $0x8130db,0x8(%esp)
  809aa7:	00 
  809aa8:	c7 44 24 04 8b 01 00 	movl   $0x18b,0x4(%esp)
  809aaf:	00 
  809ab0:	c7 04 24 92 30 81 00 	movl   $0x813092,(%esp)
  809ab7:	e8 be 55 00 00       	call   80f07a <_panic>
  if (arp_table[i].state != ETHARP_STATE_EMPTY)
  {
    snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
  }
  /* recycle entry (no-op for an already empty entry) */
  arp_table[i].state = ETHARP_STATE_EMPTY;
  809abc:	89 f0                	mov    %esi,%eax
  809abe:	0f b6 c0             	movzbl %al,%eax
  809ac1:	6b d0 1c             	imul   $0x1c,%eax,%edx
  809ac4:	c7 82 50 5a b3 00 00 	movl   $0x0,0xb35a50(%edx)
  809acb:	00 00 00 

  /* IP address given? */
  if (ipaddr != NULL) {
  809ace:	85 db                	test   %ebx,%ebx
  809ad0:	74 08                	je     809ada <find_entry+0x1d2>
    /* set IP address */
    ip_addr_set(&arp_table[i].ipaddr, ipaddr);
  809ad2:	8b 0b                	mov    (%ebx),%ecx
  809ad4:	89 8a 44 5a b3 00    	mov    %ecx,0xb35a44(%edx)
  }
  arp_table[i].ctime = 0;
  809ada:	6b c0 1c             	imul   $0x1c,%eax,%eax
  809add:	c6 80 54 5a b3 00 00 	movb   $0x0,0xb35a54(%eax)
#if LWIP_NETIF_HWADDRHINT
  NETIF_SET_HINT(netif, i);
#else /* #if LWIP_NETIF_HWADDRHINT */
  etharp_cached_entry = i;
  809ae4:	89 f0                	mov    %esi,%eax
  809ae6:	a2 20 5a b3 00       	mov    %al,0xb35a20
#endif /* #if LWIP_NETIF_HWADDRHINT */
  return (err_t)i;
  809aeb:	eb 28                	jmp    809b15 <find_entry+0x20d>
  /* no empty entry found and not allowed to recycle? */
  if (((empty == ARP_TABLE_SIZE) && ((flags & ETHARP_TRY_HARD) == 0))
      /* or don't create new entry, only search? */
      || ((flags & ETHARP_FIND_ONLY) != 0)) {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: no empty entry found and not allowed to recycle\n"));
    return (s8_t)ERR_MEM;
  809aed:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  809af2:	eb 21                	jmp    809b15 <find_entry+0x20d>
  809af4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  809af9:	eb 1a                	jmp    809b15 <find_entry+0x20d>
    free_etharp_q(arp_table[i].q);
    arp_table[i].q = NULL;
#endif
    /* no empty or recyclable entries found */
  } else {
    return (s8_t)ERR_MEM;
  809afb:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  809b00:	eb 13                	jmp    809b15 <find_entry+0x20d>
  /* no empty entry found and not allowed to recycle? */
  if (((empty == ARP_TABLE_SIZE) && ((flags & ETHARP_TRY_HARD) == 0))
      /* or don't create new entry, only search? */
      || ((flags & ETHARP_FIND_ONLY) != 0)) {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: no empty entry found and not allowed to recycle\n"));
    return (s8_t)ERR_MEM;
  809b02:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  809b07:	eb 0c                	jmp    809b15 <find_entry+0x20d>
  /* { we have no match } => try to create a new entry */
   
  /* no empty entry found and not allowed to recycle? */
  if (((empty == ARP_TABLE_SIZE) && ((flags & ETHARP_TRY_HARD) == 0))
      /* or don't create new entry, only search? */
      || ((flags & ETHARP_FIND_ONLY) != 0)) {
  809b09:	f6 45 dc 02          	testb  $0x2,-0x24(%ebp)
  809b0d:	0f 84 1f ff ff ff    	je     809a32 <find_entry+0x12a>
  809b13:	eb ed                	jmp    809b02 <find_entry+0x1fa>
  NETIF_SET_HINT(netif, i);
#else /* #if LWIP_NETIF_HWADDRHINT */
  etharp_cached_entry = i;
#endif /* #if LWIP_NETIF_HWADDRHINT */
  return (err_t)i;
}
  809b15:	83 c4 2c             	add    $0x2c,%esp
  809b18:	5b                   	pop    %ebx
  809b19:	5e                   	pop    %esi
  809b1a:	5f                   	pop    %edi
  809b1b:	5d                   	pop    %ebp
  809b1c:	c3                   	ret    

00809b1d <etharp_send_ip>:
 * @params dst the destination MAC address to be copied into the ethernet header
 * @return ERR_OK if the packet was sent, any other err_t on failure
 */
static err_t
etharp_send_ip(struct netif *netif, struct pbuf *p, struct eth_addr *src, struct eth_addr *dst)
{
  809b1d:	55                   	push   %ebp
  809b1e:	89 e5                	mov    %esp,%ebp
  809b20:	57                   	push   %edi
  809b21:	56                   	push   %esi
  809b22:	53                   	push   %ebx
  809b23:	83 ec 2c             	sub    $0x2c,%esp
  809b26:	89 c6                	mov    %eax,%esi
  809b28:	89 55 e0             	mov    %edx,-0x20(%ebp)
  809b2b:	8b 7d 08             	mov    0x8(%ebp),%edi
  struct eth_hdr *ethhdr = p->payload;
  809b2e:	8b 5a 04             	mov    0x4(%edx),%ebx
  u8_t k;

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  809b31:	80 7e 24 06          	cmpb   $0x6,0x24(%esi)
  809b35:	74 1c                	je     809b53 <etharp_send_ip+0x36>
  809b37:	c7 44 24 08 08 31 81 	movl   $0x813108,0x8(%esp)
  809b3e:	00 
  809b3f:	c7 44 24 04 b3 01 00 	movl   $0x1b3,0x4(%esp)
  809b46:	00 
  809b47:	c7 04 24 92 30 81 00 	movl   $0x813092,(%esp)
  809b4e:	e8 27 55 00 00       	call   80f07a <_panic>
  809b53:	b8 06 00 00 00       	mov    $0x6,%eax
  809b58:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
              (netif->hwaddr_len == ETHARP_HWADDR_LEN));
  k = ETHARP_HWADDR_LEN;
  while(k > 0) {
    k--;
  809b5b:	83 e8 01             	sub    $0x1,%eax
    ethhdr->dest.addr[k] = dst->addr[k];
  809b5e:	0f b6 d0             	movzbl %al,%edx
  809b61:	0f b6 0c 17          	movzbl (%edi,%edx,1),%ecx
  809b65:	88 0c 13             	mov    %cl,(%ebx,%edx,1)
    ethhdr->src.addr[k]  = src->addr[k];
  809b68:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  809b6b:	0f b6 0c 11          	movzbl (%ecx,%edx,1),%ecx
  809b6f:	88 4c 13 06          	mov    %cl,0x6(%ebx,%edx,1)
  u8_t k;

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
              (netif->hwaddr_len == ETHARP_HWADDR_LEN));
  k = ETHARP_HWADDR_LEN;
  while(k > 0) {
  809b73:	84 c0                	test   %al,%al
  809b75:	75 e4                	jne    809b5b <etharp_send_ip+0x3e>
    k--;
    ethhdr->dest.addr[k] = dst->addr[k];
    ethhdr->src.addr[k]  = src->addr[k];
  }
  ethhdr->type = htons(ETHTYPE_IP);
  809b77:	c7 04 24 00 08 00 00 	movl   $0x800,(%esp)
  809b7e:	e8 f3 e1 ff ff       	call   807d76 <htons>
  809b83:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_send_ip: sending packet %p\n", (void *)p));
  /* send the packet */
  return netif->linkoutput(netif, p);
  809b87:	8b 45 e0             	mov    -0x20(%ebp),%eax
  809b8a:	89 44 24 04          	mov    %eax,0x4(%esp)
  809b8e:	89 34 24             	mov    %esi,(%esp)
  809b91:	ff 56 18             	call   *0x18(%esi)
}
  809b94:	83 c4 2c             	add    $0x2c,%esp
  809b97:	5b                   	pop    %ebx
  809b98:	5e                   	pop    %esi
  809b99:	5f                   	pop    %edi
  809b9a:	5d                   	pop    %ebp
  809b9b:	c3                   	ret    

00809b9c <update_arp_entry>:
 *
 * @see pbuf_free()
 */
static err_t
update_arp_entry(struct netif *netif, struct ip_addr *ipaddr, struct eth_addr *ethaddr, u8_t flags)
{
  809b9c:	55                   	push   %ebp
  809b9d:	89 e5                	mov    %esp,%ebp
  809b9f:	57                   	push   %edi
  809ba0:	56                   	push   %esi
  809ba1:	53                   	push   %ebx
  809ba2:	83 ec 2c             	sub    $0x2c,%esp
  809ba5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  809ba8:	89 cb                	mov    %ecx,%ebx
  809baa:	8b 4d 08             	mov    0x8(%ebp),%ecx
  809bad:	89 4d e0             	mov    %ecx,-0x20(%ebp)
  s8_t i;
  u8_t k;
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 3, ("update_arp_entry()\n"));
  LWIP_ASSERT("netif->hwaddr_len == ETHARP_HWADDR_LEN", netif->hwaddr_len == ETHARP_HWADDR_LEN);
  809bb0:	80 78 24 06          	cmpb   $0x6,0x24(%eax)
  809bb4:	74 1c                	je     809bd2 <update_arp_entry+0x36>
  809bb6:	c7 44 24 08 4c 31 81 	movl   $0x81314c,0x8(%esp)
  809bbd:	00 
  809bbe:	c7 44 24 04 d9 01 00 	movl   $0x1d9,0x4(%esp)
  809bc5:	00 
  809bc6:	c7 04 24 92 30 81 00 	movl   $0x813092,(%esp)
  809bcd:	e8 a8 54 00 00       	call   80f07a <_panic>
  809bd2:	89 d6                	mov    %edx,%esi
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: %"U16_F".%"U16_F".%"U16_F".%"U16_F" - %02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F"\n",
                                        ip4_addr1(ipaddr), ip4_addr2(ipaddr), ip4_addr3(ipaddr), ip4_addr4(ipaddr), 
                                        ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
                                        ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
  809bd4:	85 d2                	test   %edx,%edx
  809bd6:	0f 84 e2 00 00 00    	je     809cbe <update_arp_entry+0x122>
  809bdc:	83 3a 00             	cmpl   $0x0,(%edx)
  809bdf:	0f 84 e0 00 00 00    	je     809cc5 <update_arp_entry+0x129>
      ip_addr_isbroadcast(ipaddr, netif) ||
  809be5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  809be8:	89 44 24 04          	mov    %eax,0x4(%esp)
  809bec:	89 14 24             	mov    %edx,(%esp)
  809bef:	e8 9d ce ff ff       	call   806a91 <ip_addr_isbroadcast>
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: %"U16_F".%"U16_F".%"U16_F".%"U16_F" - %02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F"\n",
                                        ip4_addr1(ipaddr), ip4_addr2(ipaddr), ip4_addr3(ipaddr), ip4_addr4(ipaddr), 
                                        ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
                                        ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
  809bf4:	84 c0                	test   %al,%al
  809bf6:	0f 85 d0 00 00 00    	jne    809ccc <update_arp_entry+0x130>
      ip_addr_isbroadcast(ipaddr, netif) ||
      ip_addr_ismulticast(ipaddr)) {
  809bfc:	8b 3e                	mov    (%esi),%edi
  809bfe:	c7 04 24 00 00 00 f0 	movl   $0xf0000000,(%esp)
  809c05:	e8 c0 e3 ff ff       	call   807fca <ntohl>
  809c0a:	21 c7                	and    %eax,%edi
  809c0c:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  809c13:	e8 b2 e3 ff ff       	call   807fca <ntohl>
                                        ip4_addr1(ipaddr), ip4_addr2(ipaddr), ip4_addr3(ipaddr), ip4_addr4(ipaddr), 
                                        ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
                                        ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
      ip_addr_isbroadcast(ipaddr, netif) ||
  809c18:	39 c7                	cmp    %eax,%edi
  809c1a:	0f 84 b3 00 00 00    	je     809cd3 <update_arp_entry+0x137>
  }
  /* find or create ARP entry */
#if LWIP_NETIF_HWADDRHINT
  i = find_entry(ipaddr, flags, netif);
#else /* LWIP_NETIF_HWADDRHINT */
  i = find_entry(ipaddr, flags);
  809c20:	0f b6 55 e0          	movzbl -0x20(%ebp),%edx
  809c24:	89 f0                	mov    %esi,%eax
  809c26:	e8 dd fc ff ff       	call   809908 <find_entry>
#endif /* LWIP_NETIF_HWADDRHINT */
  /* bail out if no entry could be found */
  if (i < 0)
  809c2b:	84 c0                	test   %al,%al
  809c2d:	0f 88 a5 00 00 00    	js     809cd8 <update_arp_entry+0x13c>
    return (err_t)i;
  
  /* mark it stable */
  arp_table[i].state = ETHARP_STATE_STABLE;
  809c33:	0f be f8             	movsbl %al,%edi
  809c36:	6b c7 1c             	imul   $0x1c,%edi,%eax
  809c39:	c7 80 50 5a b3 00 02 	movl   $0x2,0xb35a50(%eax)
  809c40:	00 00 00 
  /* record network interface */
  arp_table[i].netif = netif;
  809c43:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  809c46:	89 88 58 5a b3 00    	mov    %ecx,0xb35a58(%eax)
  /* insert in SNMP ARP index tree */
  snmp_insert_arpidx_tree(netif, &arp_table[i].ipaddr);

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: updating stable entry %"S16_F"\n", (s16_t)i));
  /* update address */
  k = ETHARP_HWADDR_LEN;
  809c4c:	ba 06 00 00 00       	mov    $0x6,%edx
  while (k > 0) {
    k--;
    arp_table[i].ethaddr.addr[k] = ethaddr->addr[k];
  809c51:	89 c6                	mov    %eax,%esi

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: updating stable entry %"S16_F"\n", (s16_t)i));
  /* update address */
  k = ETHARP_HWADDR_LEN;
  while (k > 0) {
    k--;
  809c53:	83 ea 01             	sub    $0x1,%edx
    arp_table[i].ethaddr.addr[k] = ethaddr->addr[k];
  809c56:	0f b6 c2             	movzbl %dl,%eax
  809c59:	0f b6 0c 03          	movzbl (%ebx,%eax,1),%ecx
  809c5d:	88 8c 30 48 5a b3 00 	mov    %cl,0xb35a48(%eax,%esi,1)
  snmp_insert_arpidx_tree(netif, &arp_table[i].ipaddr);

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: updating stable entry %"S16_F"\n", (s16_t)i));
  /* update address */
  k = ETHARP_HWADDR_LEN;
  while (k > 0) {
  809c64:	84 d2                	test   %dl,%dl
  809c66:	75 eb                	jne    809c53 <update_arp_entry+0xb7>
    k--;
    arp_table[i].ethaddr.addr[k] = ethaddr->addr[k];
  }
  /* reset time stamp */
  arp_table[i].ctime = 0;
  809c68:	6b c7 1c             	imul   $0x1c,%edi,%eax
  809c6b:	c6 80 54 5a b3 00 00 	movb   $0x0,0xb35a54(%eax)
#if ARP_QUEUEING
  /* this is where we will send out queued packets! */
  while (arp_table[i].q != NULL) {
  809c72:	89 c7                	mov    %eax,%edi
    /* get the packet pointer */
    p = q->p;
    /* now queue entry can be freed */
    memp_free(MEMP_ARP_QUEUE, q);
    /* send the queued IP packet */
    etharp_send_ip(netif, p, (struct eth_addr*)(netif->hwaddr), ethaddr);
  809c74:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  809c77:	83 c0 25             	add    $0x25,%eax
  809c7a:	89 45 e0             	mov    %eax,-0x20(%ebp)
  }
  /* reset time stamp */
  arp_table[i].ctime = 0;
#if ARP_QUEUEING
  /* this is where we will send out queued packets! */
  while (arp_table[i].q != NULL) {
  809c7d:	eb 33                	jmp    809cb2 <update_arp_entry+0x116>
    struct pbuf *p;
    /* remember remainder of queue */
    struct etharp_q_entry *q = arp_table[i].q;
    /* pop first item off the queue */
    arp_table[i].q = q->next;
  809c7f:	8b 10                	mov    (%eax),%edx
  809c81:	89 97 40 5a b3 00    	mov    %edx,0xb35a40(%edi)
    /* get the packet pointer */
    p = q->p;
  809c87:	8b 70 04             	mov    0x4(%eax),%esi
    /* now queue entry can be freed */
    memp_free(MEMP_ARP_QUEUE, q);
  809c8a:	89 44 24 04          	mov    %eax,0x4(%esp)
  809c8e:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
  809c95:	e8 a8 ad ff ff       	call   804a42 <memp_free>
    /* send the queued IP packet */
    etharp_send_ip(netif, p, (struct eth_addr*)(netif->hwaddr), ethaddr);
  809c9a:	89 1c 24             	mov    %ebx,(%esp)
  809c9d:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  809ca0:	89 f2                	mov    %esi,%edx
  809ca2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  809ca5:	e8 73 fe ff ff       	call   809b1d <etharp_send_ip>
    /* free the queued IP packet */
    pbuf_free(p);
  809caa:	89 34 24             	mov    %esi,(%esp)
  809cad:	e8 42 b1 ff ff       	call   804df4 <pbuf_free>
  }
  /* reset time stamp */
  arp_table[i].ctime = 0;
#if ARP_QUEUEING
  /* this is where we will send out queued packets! */
  while (arp_table[i].q != NULL) {
  809cb2:	8b 87 40 5a b3 00    	mov    0xb35a40(%edi),%eax
  809cb8:	85 c0                	test   %eax,%eax
  809cba:	75 c3                	jne    809c7f <update_arp_entry+0xe3>
  809cbc:	eb 1a                	jmp    809cd8 <update_arp_entry+0x13c>
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
      ip_addr_isbroadcast(ipaddr, netif) ||
      ip_addr_ismulticast(ipaddr)) {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: will not add non-unicast IP address to ARP cache\n"));
    return ERR_ARG;
  809cbe:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  809cc3:	eb 13                	jmp    809cd8 <update_arp_entry+0x13c>
  809cc5:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  809cca:	eb 0c                	jmp    809cd8 <update_arp_entry+0x13c>
  809ccc:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  809cd1:	eb 05                	jmp    809cd8 <update_arp_entry+0x13c>
  809cd3:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
    /* free the queued IP packet */
    pbuf_free(p);
  }
#endif
  return ERR_OK;
}
  809cd8:	83 c4 2c             	add    $0x2c,%esp
  809cdb:	5b                   	pop    %ebx
  809cdc:	5e                   	pop    %esi
  809cdd:	5f                   	pop    %edi
  809cde:	5d                   	pop    %ebp
  809cdf:	c3                   	ret    

00809ce0 <etharp_tmr>:
 * This function should be called every ETHARP_TMR_INTERVAL microseconds (5 seconds),
 * in order to expire entries in the ARP table.
 */
void
etharp_tmr(void)
{
  809ce0:	55                   	push   %ebp
  809ce1:	89 e5                	mov    %esp,%ebp
  809ce3:	57                   	push   %edi
  809ce4:	56                   	push   %esi
  809ce5:	53                   	push   %ebx
  809ce6:	83 ec 0c             	sub    $0xc,%esp
  809ce9:	bb 54 5a b3 00       	mov    $0xb35a54,%ebx
  809cee:	bf 6c 5b b3 00       	mov    $0xb35b6c,%edi
  809cf3:	89 de                	mov    %ebx,%esi
  u8_t i;

  LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    arp_table[i].ctime++;
  809cf5:	0f b6 03             	movzbl (%ebx),%eax
  809cf8:	8d 50 01             	lea    0x1(%eax),%edx
  809cfb:	88 13                	mov    %dl,(%ebx)
    if (((arp_table[i].state == ETHARP_STATE_STABLE) &&
  809cfd:	8b 43 fc             	mov    -0x4(%ebx),%eax
  809d00:	83 f8 02             	cmp    $0x2,%eax
  809d03:	75 07                	jne    809d0c <etharp_tmr+0x2c>
  809d05:	80 fa ef             	cmp    $0xef,%dl
  809d08:	77 0d                	ja     809d17 <etharp_tmr+0x37>
  809d0a:	eb 25                	jmp    809d31 <etharp_tmr+0x51>
         (arp_table[i].ctime >= ARP_MAXAGE)) ||
  809d0c:	83 f8 01             	cmp    $0x1,%eax
  809d0f:	90                   	nop
  809d10:	75 1f                	jne    809d31 <etharp_tmr+0x51>
        ((arp_table[i].state == ETHARP_STATE_PENDING)  &&
  809d12:	80 fa 01             	cmp    $0x1,%dl
  809d15:	76 1a                	jbe    809d31 <etharp_tmr+0x51>
      /* clean up entries that have just been expired */
      /* remove from SNMP ARP index tree */
      snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
#if ARP_QUEUEING
      /* and empty packet queue */
      if (arp_table[i].q != NULL) {
  809d17:	8b 46 ec             	mov    -0x14(%esi),%eax
  809d1a:	85 c0                	test   %eax,%eax
  809d1c:	74 0c                	je     809d2a <etharp_tmr+0x4a>
        /* remove all queued packets */
        LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer: freeing entry %"U16_F", packet queue %p.\n", (u16_t)i, (void *)(arp_table[i].q)));
        free_etharp_q(arp_table[i].q);
  809d1e:	e8 4d fb ff ff       	call   809870 <free_etharp_q>
        arp_table[i].q = NULL;
  809d23:	c7 46 ec 00 00 00 00 	movl   $0x0,-0x14(%esi)
      }
#endif
      /* recycle entry for re-use */      
      arp_table[i].state = ETHARP_STATE_EMPTY;
  809d2a:	c7 46 fc 00 00 00 00 	movl   $0x0,-0x4(%esi)
  809d31:	83 c3 1c             	add    $0x1c,%ebx
{
  u8_t i;

  LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
  809d34:	39 fb                	cmp    %edi,%ebx
  809d36:	75 bb                	jne    809cf3 <etharp_tmr+0x13>
    if (arp_table[i].state == ETHARP_STATE_PENDING) {
        /* resend an ARP query here? */
    }
#endif
  }
}
  809d38:	83 c4 0c             	add    $0xc,%esp
  809d3b:	5b                   	pop    %ebx
  809d3c:	5e                   	pop    %esi
  809d3d:	5f                   	pop    %edi
  809d3e:	5d                   	pop    %ebp
  809d3f:	c3                   	ret    

00809d40 <etharp_find_addr>:
 * @return table index if found, -1 otherwise
 */
s8_t
etharp_find_addr(struct netif *netif, struct ip_addr *ipaddr,
         struct eth_addr **eth_ret, struct ip_addr **ip_ret)
{
  809d40:	55                   	push   %ebp
  809d41:	89 e5                	mov    %esp,%ebp
  809d43:	53                   	push   %ebx
  809d44:	83 ec 04             	sub    $0x4,%esp
  LWIP_UNUSED_ARG(netif);

#if LWIP_NETIF_HWADDRHINT
  i = find_entry(ipaddr, ETHARP_FIND_ONLY, NULL);
#else /* LWIP_NETIF_HWADDRHINT */
  i = find_entry(ipaddr, ETHARP_FIND_ONLY);
  809d47:	ba 02 00 00 00       	mov    $0x2,%edx
  809d4c:	8b 45 0c             	mov    0xc(%ebp),%eax
  809d4f:	e8 b4 fb ff ff       	call   809908 <find_entry>
#endif /* LWIP_NETIF_HWADDRHINT */
  if((i >= 0) && arp_table[i].state == ETHARP_STATE_STABLE) {
  809d54:	84 c0                	test   %al,%al
  809d56:	78 29                	js     809d81 <etharp_find_addr+0x41>
  809d58:	0f be d0             	movsbl %al,%edx
  809d5b:	6b ca 1c             	imul   $0x1c,%edx,%ecx
  809d5e:	83 b9 50 5a b3 00 02 	cmpl   $0x2,0xb35a50(%ecx)
  809d65:	75 21                	jne    809d88 <etharp_find_addr+0x48>
      *eth_ret = &arp_table[i].ethaddr;
  809d67:	89 ca                	mov    %ecx,%edx
  809d69:	8d 99 48 5a b3 00    	lea    0xb35a48(%ecx),%ebx
  809d6f:	8b 4d 10             	mov    0x10(%ebp),%ecx
  809d72:	89 19                	mov    %ebx,(%ecx)
      *ip_ret = &arp_table[i].ipaddr;
  809d74:	81 c2 44 5a b3 00    	add    $0xb35a44,%edx
  809d7a:	8b 4d 14             	mov    0x14(%ebp),%ecx
  809d7d:	89 11                	mov    %edx,(%ecx)
      return i;
  809d7f:	eb 0c                	jmp    809d8d <etharp_find_addr+0x4d>
  }
  return -1;
  809d81:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  809d86:	eb 05                	jmp    809d8d <etharp_find_addr+0x4d>
  809d88:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  809d8d:	83 c4 04             	add    $0x4,%esp
  809d90:	5b                   	pop    %ebx
  809d91:	5d                   	pop    %ebp
  809d92:	c3                   	ret    

00809d93 <etharp_ip_input>:
 *
 * @see pbuf_free()
 */
void
etharp_ip_input(struct netif *netif, struct pbuf *p)
{
  809d93:	55                   	push   %ebp
  809d94:	89 e5                	mov    %esp,%ebp
  809d96:	83 ec 18             	sub    $0x18,%esp
  809d99:	8b 45 08             	mov    0x8(%ebp),%eax
  struct ethip_hdr *hdr;
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  809d9c:	85 c0                	test   %eax,%eax
  809d9e:	75 1c                	jne    809dbc <etharp_ip_input+0x29>
  809da0:	c7 44 24 08 02 24 81 	movl   $0x812402,0x8(%esp)
  809da7:	00 
  809da8:	c7 44 24 04 48 02 00 	movl   $0x248,0x4(%esp)
  809daf:	00 
  809db0:	c7 04 24 92 30 81 00 	movl   $0x813092,(%esp)
  809db7:	e8 be 52 00 00       	call   80f07a <_panic>
  /* Only insert an entry if the source IP address of the
     incoming IP packet comes from a host on the local network. */
  hdr = p->payload;
  809dbc:	8b 55 0c             	mov    0xc(%ebp),%edx
  809dbf:	8b 52 04             	mov    0x4(%edx),%edx
  /* source is not on the local network? */
  if (!ip_addr_netcmp(&(hdr->ip.src), &(netif->ip_addr), &(netif->netmask))) {
  809dc2:	8b 48 04             	mov    0x4(%eax),%ecx
  809dc5:	33 4a 1c             	xor    0x1c(%edx),%ecx
  809dc8:	85 48 08             	test   %ecx,0x8(%eax)
  809dcb:	75 12                	jne    809ddf <etharp_ip_input+0x4c>

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_ip_input: updating ETHARP table.\n"));
  /* update ARP table */
  /* @todo We could use ETHARP_TRY_HARD if we think we are going to talk
   * back soon (for example, if the destination IP address is ours. */
  update_arp_entry(netif, &(hdr->ip.src), &(hdr->eth.src), 0);
  809dcd:	8d 4a 06             	lea    0x6(%edx),%ecx
  809dd0:	83 c2 1c             	add    $0x1c,%edx
  809dd3:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  809dda:	e8 bd fd ff ff       	call   809b9c <update_arp_entry>
}
  809ddf:	c9                   	leave  
  809de0:	c3                   	ret    

00809de1 <etharp_arp_input>:
 *
 * @see pbuf_free()
 */
void
etharp_arp_input(struct netif *netif, struct eth_addr *ethaddr, struct pbuf *p)
{
  809de1:	55                   	push   %ebp
  809de2:	89 e5                	mov    %esp,%ebp
  809de4:	57                   	push   %edi
  809de5:	56                   	push   %esi
  809de6:	53                   	push   %ebx
  809de7:	83 ec 2c             	sub    $0x2c,%esp
  809dea:	8b 5d 10             	mov    0x10(%ebp),%ebx
  u8_t for_us;
#if LWIP_AUTOIP
  const u8_t * ethdst_hwaddr;
#endif /* LWIP_AUTOIP */

  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  809ded:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  809df1:	75 1c                	jne    809e0f <etharp_arp_input+0x2e>
  809df3:	c7 44 24 08 02 24 81 	movl   $0x812402,0x8(%esp)
  809dfa:	00 
  809dfb:	c7 44 24 04 75 02 00 	movl   $0x275,0x4(%esp)
  809e02:	00 
  809e03:	c7 04 24 92 30 81 00 	movl   $0x813092,(%esp)
  809e0a:	e8 6b 52 00 00       	call   80f07a <_panic>
  
  /* drop short ARP packets: we have to check for p->len instead of p->tot_len here
     since a struct etharp_hdr is pointed to p->payload, so it musn't be chained! */
  if (p->len < sizeof(struct etharp_hdr)) {
  809e0f:	66 83 7b 0a 29       	cmpw   $0x29,0xa(%ebx)
  809e14:	77 0d                	ja     809e23 <etharp_arp_input+0x42>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 1, ("etharp_arp_input: packet dropped, too short (%"S16_F"/%"S16_F")\n", p->tot_len, (s16_t)sizeof(struct etharp_hdr)));
    ETHARP_STATS_INC(etharp.lenerr);
    ETHARP_STATS_INC(etharp.drop);
    pbuf_free(p);
  809e16:	89 1c 24             	mov    %ebx,(%esp)
  809e19:	e8 d6 af ff ff       	call   804df4 <pbuf_free>
    return;
  809e1e:	e9 a6 01 00 00       	jmp    809fc9 <etharp_arp_input+0x1e8>
  }

  hdr = p->payload;
  809e23:	8b 73 04             	mov    0x4(%ebx),%esi

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
  809e26:	0f b7 7e 0e          	movzwl 0xe(%esi),%edi
  809e2a:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  809e31:	e8 40 df ff ff       	call   807d76 <htons>
  809e36:	66 39 c7             	cmp    %ax,%di
  809e39:	75 3f                	jne    809e7a <etharp_arp_input+0x99>
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
  809e3b:	0f b7 7e 12          	movzwl 0x12(%esi),%edi
  809e3f:	c7 04 24 04 06 00 00 	movl   $0x604,(%esp)
  809e46:	e8 2b df ff ff       	call   807d76 <htons>
  }

  hdr = p->payload;

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
  809e4b:	66 39 c7             	cmp    %ax,%di
  809e4e:	75 2a                	jne    809e7a <etharp_arp_input+0x99>
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
      (hdr->proto != htons(ETHTYPE_IP)) ||
  809e50:	0f b7 7e 10          	movzwl 0x10(%esi),%edi
  809e54:	c7 04 24 00 08 00 00 	movl   $0x800,(%esp)
  809e5b:	e8 16 df ff ff       	call   807d76 <htons>

  hdr = p->payload;

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
  809e60:	66 39 c7             	cmp    %ax,%di
  809e63:	75 15                	jne    809e7a <etharp_arp_input+0x99>
      (hdr->proto != htons(ETHTYPE_IP)) ||
      (hdr->ethhdr.type != htons(ETHTYPE_ARP)))  {
  809e65:	0f b7 7e 0c          	movzwl 0xc(%esi),%edi
  809e69:	c7 04 24 06 08 00 00 	movl   $0x806,(%esp)
  809e70:	e8 01 df ff ff       	call   807d76 <htons>
  hdr = p->payload;

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
      (hdr->proto != htons(ETHTYPE_IP)) ||
  809e75:	66 39 c7             	cmp    %ax,%di
  809e78:	74 0d                	je     809e87 <etharp_arp_input+0xa6>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 1,
      ("etharp_arp_input: packet dropped, wrong hw type, hwlen, proto, protolen or ethernet type (%"U16_F"/%"U16_F"/%"U16_F"/%"U16_F"/%"U16_F")\n",
      hdr->hwtype, ARPH_HWLEN(hdr), hdr->proto, ARPH_PROTOLEN(hdr), hdr->ethhdr.type));
    ETHARP_STATS_INC(etharp.proterr);
    ETHARP_STATS_INC(etharp.drop);
    pbuf_free(p);
  809e7a:	89 1c 24             	mov    %ebx,(%esp)
  809e7d:	e8 72 af ff ff       	call   804df4 <pbuf_free>
    return;
  809e82:	e9 42 01 00 00       	jmp    809fc9 <etharp_arp_input+0x1e8>
  autoip_arp_reply(netif, hdr);
#endif /* LWIP_AUTOIP */

  /* Copy struct ip_addr2 to aligned ip_addr, to support compilers without
   * structure packing (not using structure copy which breaks strict-aliasing rules). */
  SMEMCPY(&sipaddr, &hdr->sipaddr, sizeof(sipaddr));
  809e87:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  809e8e:	00 
  809e8f:	8d 46 1c             	lea    0x1c(%esi),%eax
  809e92:	89 44 24 04          	mov    %eax,0x4(%esp)
  809e96:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  809e99:	89 04 24             	mov    %eax,(%esp)
  809e9c:	e8 fb 5a 00 00       	call   80f99c <memcpy>
  SMEMCPY(&dipaddr, &hdr->dipaddr, sizeof(dipaddr));
  809ea1:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  809ea8:	00 
  809ea9:	8d 46 26             	lea    0x26(%esi),%eax
  809eac:	89 44 24 04          	mov    %eax,0x4(%esp)
  809eb0:	8d 45 e0             	lea    -0x20(%ebp),%eax
  809eb3:	89 04 24             	mov    %eax,(%esp)
  809eb6:	e8 e1 5a 00 00       	call   80f99c <memcpy>

  /* this interface is not configured? */
  if (netif->ip_addr.addr == 0) {
  809ebb:	8b 45 08             	mov    0x8(%ebp),%eax
  809ebe:	8b 40 04             	mov    0x4(%eax),%eax
  809ec1:	85 c0                	test   %eax,%eax
  809ec3:	74 21                	je     809ee6 <etharp_arp_input+0x105>
    for_us = 0;
  } else {
    /* ARP packet directed to us? */
    for_us = ip_addr_cmp(&dipaddr, &(netif->ip_addr));
  809ec5:	3b 45 e0             	cmp    -0x20(%ebp),%eax
  }

  /* ARP message directed to us? */
  if (for_us) {
  809ec8:	0f 94 c0             	sete   %al
  809ecb:	89 c7                	mov    %eax,%edi
  809ecd:	75 1c                	jne    809eeb <etharp_arp_input+0x10a>
    /* add IP address in ARP cache; assume requester wants to talk to us.
     * can result in directly sending the queued packets for this host. */
    update_arp_entry(netif, &sipaddr, &(hdr->shwaddr), ETHARP_TRY_HARD);
  809ecf:	8d 4e 16             	lea    0x16(%esi),%ecx
  809ed2:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  809ed9:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  809edc:	8b 45 08             	mov    0x8(%ebp),%eax
  809edf:	e8 b8 fc ff ff       	call   809b9c <update_arp_entry>
  809ee4:	eb 1a                	jmp    809f00 <etharp_arp_input+0x11f>
  SMEMCPY(&sipaddr, &hdr->sipaddr, sizeof(sipaddr));
  SMEMCPY(&dipaddr, &hdr->dipaddr, sizeof(dipaddr));

  /* this interface is not configured? */
  if (netif->ip_addr.addr == 0) {
    for_us = 0;
  809ee6:	bf 00 00 00 00       	mov    $0x0,%edi
     * can result in directly sending the queued packets for this host. */
    update_arp_entry(netif, &sipaddr, &(hdr->shwaddr), ETHARP_TRY_HARD);
  /* ARP message not directed to us? */
  } else {
    /* update the source IP address in the cache, if present */
    update_arp_entry(netif, &sipaddr, &(hdr->shwaddr), 0);
  809eeb:	8d 4e 16             	lea    0x16(%esi),%ecx
  809eee:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  809ef5:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  809ef8:	8b 45 08             	mov    0x8(%ebp),%eax
  809efb:	e8 9c fc ff ff       	call   809b9c <update_arp_entry>
  }

  /* now act on the message itself */
  switch (htons(hdr->opcode)) {
  809f00:	0f b7 46 14          	movzwl 0x14(%esi),%eax
  809f04:	89 04 24             	mov    %eax,(%esp)
  809f07:	e8 6a de ff ff       	call   807d76 <htons>
  809f0c:	66 83 f8 01          	cmp    $0x1,%ax
  809f10:	74 0f                	je     809f21 <etharp_arp_input+0x140>
  809f12:	66 83 f8 02          	cmp    $0x2,%ax
  809f16:	0f 84 93 00 00 00    	je     809faf <etharp_arp_input+0x1ce>
  809f1c:	e9 a0 00 00 00       	jmp    809fc1 <etharp_arp_input+0x1e0>
     * reply. In any case, we time-stamp any existing ARP entry,
     * and possiby send out an IP packet that was queued on it. */

    LWIP_DEBUGF (ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: incoming ARP request\n"));
    /* ARP request for our address? */
    if (for_us) {
  809f21:	89 f8                	mov    %edi,%eax
  809f23:	84 c0                	test   %al,%al
  809f25:	0f 84 96 00 00 00    	je     809fc1 <etharp_arp_input+0x1e0>

      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: replying to ARP request for our IP address\n"));
      /* Re-use pbuf to send ARP reply.
         Since we are re-using an existing pbuf, we can't call etharp_raw since
         that would allocate a new pbuf. */
      hdr->opcode = htons(ARP_REPLY);
  809f2b:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  809f32:	e8 3f de ff ff       	call   807d76 <htons>
  809f37:	66 89 46 14          	mov    %ax,0x14(%esi)

      hdr->dipaddr = hdr->sipaddr;
  809f3b:	8b 46 1c             	mov    0x1c(%esi),%eax
  809f3e:	89 46 26             	mov    %eax,0x26(%esi)
      hdr->sipaddr = *(struct ip_addr2 *)&netif->ip_addr;
  809f41:	8b 45 08             	mov    0x8(%ebp),%eax
  809f44:	8b 40 04             	mov    0x4(%eax),%eax
  809f47:	89 46 1c             	mov    %eax,0x1c(%esi)

      LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  809f4a:	ba 06 00 00 00       	mov    $0x6,%edx
  809f4f:	8b 45 08             	mov    0x8(%ebp),%eax
  809f52:	80 78 24 06          	cmpb   $0x6,0x24(%eax)
  809f56:	74 1c                	je     809f74 <etharp_arp_input+0x193>
  809f58:	c7 44 24 08 08 31 81 	movl   $0x813108,0x8(%esp)
  809f5f:	00 
  809f60:	c7 44 24 04 c7 02 00 	movl   $0x2c7,0x4(%esp)
  809f67:	00 
  809f68:	c7 04 24 92 30 81 00 	movl   $0x813092,(%esp)
  809f6f:	e8 06 51 00 00       	call   80f07a <_panic>
       * link layer. (See RFC3927 Section 2.5) */
      ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : hdr->shwaddr.addr;
#endif /* LWIP_AUTOIP */

      while(i > 0) {
        i--;
  809f74:	83 ea 01             	sub    $0x1,%edx
        hdr->dhwaddr.addr[i] = hdr->shwaddr.addr[i];
  809f77:	0f b6 c2             	movzbl %dl,%eax
  809f7a:	0f b6 4c 06 16       	movzbl 0x16(%esi,%eax,1),%ecx
  809f7f:	88 4c 06 20          	mov    %cl,0x20(%esi,%eax,1)
#if LWIP_AUTOIP
        hdr->ethhdr.dest.addr[i] = ethdst_hwaddr[i];
#else  /* LWIP_AUTOIP */
        hdr->ethhdr.dest.addr[i] = hdr->shwaddr.addr[i];
  809f83:	88 0c 06             	mov    %cl,(%esi,%eax,1)
#endif /* LWIP_AUTOIP */
        hdr->shwaddr.addr[i] = ethaddr->addr[i];
  809f86:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  809f89:	0f b6 0c 01          	movzbl (%ecx,%eax,1),%ecx
  809f8d:	88 4c 06 16          	mov    %cl,0x16(%esi,%eax,1)
        hdr->ethhdr.src.addr[i] = ethaddr->addr[i];
  809f91:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  809f94:	0f b6 0c 01          	movzbl (%ecx,%eax,1),%ecx
  809f98:	88 4c 06 06          	mov    %cl,0x6(%esi,%eax,1)
      /* If we are using Link-Local, ARP packets must be broadcast on the
       * link layer. (See RFC3927 Section 2.5) */
      ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : hdr->shwaddr.addr;
#endif /* LWIP_AUTOIP */

      while(i > 0) {
  809f9c:	84 d2                	test   %dl,%dl
  809f9e:	75 d4                	jne    809f74 <etharp_arp_input+0x193>

      /* hwtype, hwaddr_len, proto, protolen and the type in the ethernet header
         are already correct, we tested that before */

      /* return ARP reply */
      netif->linkoutput(netif, p);
  809fa0:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  809fa4:	8b 45 08             	mov    0x8(%ebp),%eax
  809fa7:	89 04 24             	mov    %eax,(%esp)
  809faa:	ff 50 18             	call   *0x18(%eax)
  809fad:	eb 12                	jmp    809fc1 <etharp_arp_input+0x1e0>
#if (LWIP_DHCP && DHCP_DOES_ARP_CHECK)
    /* DHCP wants to know about ARP replies from any host with an
     * IP address also offered to us by the DHCP server. We do not
     * want to take a duplicate IP address on a single network.
     * @todo How should we handle redundant (fail-over) interfaces? */
    dhcp_arp_reply(netif, &sipaddr);
  809faf:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  809fb2:	89 44 24 04          	mov    %eax,0x4(%esp)
  809fb6:	8b 45 08             	mov    0x8(%ebp),%eax
  809fb9:	89 04 24             	mov    %eax,(%esp)
  809fbc:	e8 1d 9e ff ff       	call   803dde <dhcp_arp_reply>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: ARP unknown opcode type %"S16_F"\n", htons(hdr->opcode)));
    ETHARP_STATS_INC(etharp.err);
    break;
  }
  /* free ARP packet */
  pbuf_free(p);
  809fc1:	89 1c 24             	mov    %ebx,(%esp)
  809fc4:	e8 2b ae ff ff       	call   804df4 <pbuf_free>
}
  809fc9:	83 c4 2c             	add    $0x2c,%esp
  809fcc:	5b                   	pop    %ebx
  809fcd:	5e                   	pop    %esi
  809fce:	5f                   	pop    %edi
  809fcf:	5d                   	pop    %ebp
  809fd0:	c3                   	ret    

00809fd1 <etharp_request>:
 *         ERR_MEM if the ARP packet couldn't be allocated
 *         any other err_t on failure
 */
err_t
etharp_request(struct netif *netif, struct ip_addr *ipaddr)
{
  809fd1:	55                   	push   %ebp
  809fd2:	89 e5                	mov    %esp,%ebp
  809fd4:	57                   	push   %edi
  809fd5:	56                   	push   %esi
  809fd6:	53                   	push   %ebx
  809fd7:	83 ec 1c             	sub    $0x1c,%esp
  809fda:	8b 75 08             	mov    0x8(%ebp),%esi
#if LWIP_AUTOIP
  const u8_t * ethdst_hwaddr;
#endif /* LWIP_AUTOIP */

  /* allocate a pbuf for the outgoing ARP request packet */
  p = pbuf_alloc(PBUF_LINK, sizeof(struct etharp_hdr), PBUF_RAM);
  809fdd:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  809fe4:	00 
  809fe5:	c7 44 24 04 2a 00 00 	movl   $0x2a,0x4(%esp)
  809fec:	00 
  809fed:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  809ff4:	e8 dc ae ff ff       	call   804ed5 <pbuf_alloc>
  809ff9:	89 c7                	mov    %eax,%edi
  /* could allocate a pbuf for an ARP request? */
  if (p == NULL) {
  809ffb:	85 c0                	test   %eax,%eax
  809ffd:	0f 84 f4 00 00 00    	je     80a0f7 <etharp_request+0x126>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 2, ("etharp_raw: could not allocate pbuf for ARP request.\n"));
    ETHARP_STATS_INC(etharp.memerr);
    return ERR_MEM;
  }
  LWIP_ASSERT("check that first pbuf can hold struct etharp_hdr",
  80a003:	66 83 78 0a 29       	cmpw   $0x29,0xa(%eax)
  80a008:	77 1c                	ja     80a026 <etharp_request+0x55>
  80a00a:	c7 44 24 08 74 31 81 	movl   $0x813174,0x8(%esp)
  80a011:	00 
  80a012:	c7 44 24 04 1c 04 00 	movl   $0x41c,0x4(%esp)
  80a019:	00 
  80a01a:	c7 04 24 92 30 81 00 	movl   $0x813092,(%esp)
  80a021:	e8 54 50 00 00       	call   80f07a <_panic>
              (p->len >= sizeof(struct etharp_hdr)));

  hdr = p->payload;
  80a026:	8b 58 04             	mov    0x4(%eax),%ebx
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_raw: sending raw ARP packet.\n"));
  hdr->opcode = htons(opcode);
  80a029:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  80a030:	e8 41 dd ff ff       	call   807d76 <htons>
  80a035:	66 89 43 14          	mov    %ax,0x14(%ebx)

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  80a039:	80 7e 24 06          	cmpb   $0x6,0x24(%esi)
  80a03d:	74 1c                	je     80a05b <etharp_request+0x8a>
  80a03f:	c7 44 24 08 08 31 81 	movl   $0x813108,0x8(%esp)
  80a046:	00 
  80a047:	c7 44 24 04 23 04 00 	movl   $0x423,0x4(%esp)
  80a04e:	00 
  80a04f:	c7 04 24 92 30 81 00 	movl   $0x813092,(%esp)
  80a056:	e8 1f 50 00 00       	call   80f07a <_panic>
  80a05b:	ba 06 00 00 00       	mov    $0x6,%edx
   * link layer. (See RFC3927 Section 2.5) */
  ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : ethdst_addr->addr;
#endif /* LWIP_AUTOIP */
  /* Write MAC-Addresses (combined loop for both headers) */
  while(k > 0) {
    k--;
  80a060:	83 ea 01             	sub    $0x1,%edx
    /* Write the ARP MAC-Addresses */
    hdr->shwaddr.addr[k] = hwsrc_addr->addr[k];
  80a063:	0f b6 c2             	movzbl %dl,%eax
  80a066:	0f b6 4c 06 25       	movzbl 0x25(%esi,%eax,1),%ecx
  80a06b:	88 4c 03 16          	mov    %cl,0x16(%ebx,%eax,1)
    hdr->dhwaddr.addr[k] = hwdst_addr->addr[k];
  80a06f:	0f b6 88 f1 31 81 00 	movzbl 0x8131f1(%eax),%ecx
  80a076:	88 4c 03 20          	mov    %cl,0x20(%ebx,%eax,1)
    /* Write the Ethernet MAC-Addresses */
#if LWIP_AUTOIP
    hdr->ethhdr.dest.addr[k] = ethdst_hwaddr[k];
#else  /* LWIP_AUTOIP */
    hdr->ethhdr.dest.addr[k] = ethdst_addr->addr[k];
  80a07a:	0f b6 88 f7 31 81 00 	movzbl 0x8131f7(%eax),%ecx
  80a081:	88 0c 03             	mov    %cl,(%ebx,%eax,1)
#endif /* LWIP_AUTOIP */
    hdr->ethhdr.src.addr[k]  = ethsrc_addr->addr[k];
  80a084:	0f b6 4c 06 25       	movzbl 0x25(%esi,%eax,1),%ecx
  80a089:	88 4c 03 06          	mov    %cl,0x6(%ebx,%eax,1)
  /* If we are using Link-Local, ARP packets must be broadcast on the
   * link layer. (See RFC3927 Section 2.5) */
  ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : ethdst_addr->addr;
#endif /* LWIP_AUTOIP */
  /* Write MAC-Addresses (combined loop for both headers) */
  while(k > 0) {
  80a08d:	84 d2                	test   %dl,%dl
  80a08f:	75 cf                	jne    80a060 <etharp_request+0x8f>
#else  /* LWIP_AUTOIP */
    hdr->ethhdr.dest.addr[k] = ethdst_addr->addr[k];
#endif /* LWIP_AUTOIP */
    hdr->ethhdr.src.addr[k]  = ethsrc_addr->addr[k];
  }
  hdr->sipaddr = *(struct ip_addr2 *)ipsrc_addr;
  80a091:	8b 46 04             	mov    0x4(%esi),%eax
  80a094:	89 43 1c             	mov    %eax,0x1c(%ebx)
  hdr->dipaddr = *(struct ip_addr2 *)ipdst_addr;
  80a097:	8b 45 0c             	mov    0xc(%ebp),%eax
  80a09a:	8b 00                	mov    (%eax),%eax
  80a09c:	89 43 26             	mov    %eax,0x26(%ebx)

  hdr->hwtype = htons(HWTYPE_ETHERNET);
  80a09f:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  80a0a6:	e8 cb dc ff ff       	call   807d76 <htons>
  80a0ab:	66 89 43 0e          	mov    %ax,0xe(%ebx)
  hdr->proto = htons(ETHTYPE_IP);
  80a0af:	c7 04 24 00 08 00 00 	movl   $0x800,(%esp)
  80a0b6:	e8 bb dc ff ff       	call   807d76 <htons>
  80a0bb:	66 89 43 10          	mov    %ax,0x10(%ebx)
  /* set hwlen and protolen together */
  hdr->_hwlen_protolen = htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr));
  80a0bf:	c7 04 24 04 06 00 00 	movl   $0x604,(%esp)
  80a0c6:	e8 ab dc ff ff       	call   807d76 <htons>
  80a0cb:	66 89 43 12          	mov    %ax,0x12(%ebx)

  hdr->ethhdr.type = htons(ETHTYPE_ARP);
  80a0cf:	c7 04 24 06 08 00 00 	movl   $0x806,(%esp)
  80a0d6:	e8 9b dc ff ff       	call   807d76 <htons>
  80a0db:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  /* send ARP query */
  result = netif->linkoutput(netif, p);
  80a0df:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80a0e3:	89 34 24             	mov    %esi,(%esp)
  80a0e6:	ff 56 18             	call   *0x18(%esi)
  80a0e9:	89 c3                	mov    %eax,%ebx
  ETHARP_STATS_INC(etharp.xmit);
  /* free ARP query packet */
  pbuf_free(p);
  80a0eb:	89 3c 24             	mov    %edi,(%esp)
  80a0ee:	e8 01 ad ff ff       	call   804df4 <pbuf_free>
  p = NULL;
  /* could not allocate pbuf for ARP request */

  return result;
  80a0f3:	89 d8                	mov    %ebx,%eax
  80a0f5:	eb 05                	jmp    80a0fc <etharp_request+0x12b>
  p = pbuf_alloc(PBUF_LINK, sizeof(struct etharp_hdr), PBUF_RAM);
  /* could allocate a pbuf for an ARP request? */
  if (p == NULL) {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 2, ("etharp_raw: could not allocate pbuf for ARP request.\n"));
    ETHARP_STATS_INC(etharp.memerr);
    return ERR_MEM;
  80a0f7:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
{
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_request: sending ARP request.\n"));
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
                    (struct eth_addr *)netif->hwaddr, &netif->ip_addr, &ethzero,
                    ipaddr, ARP_REQUEST);
}
  80a0fc:	83 c4 1c             	add    $0x1c,%esp
  80a0ff:	5b                   	pop    %ebx
  80a100:	5e                   	pop    %esi
  80a101:	5f                   	pop    %edi
  80a102:	5d                   	pop    %ebp
  80a103:	c3                   	ret    

0080a104 <etharp_query>:
 * - ERR_ARG Non-unicast address given, those will not appear in ARP cache.
 *
 */
err_t
etharp_query(struct netif *netif, struct ip_addr *ipaddr, struct pbuf *q)
{
  80a104:	55                   	push   %ebp
  80a105:	89 e5                	mov    %esp,%ebp
  80a107:	57                   	push   %edi
  80a108:	56                   	push   %esi
  80a109:	53                   	push   %ebx
  80a10a:	83 ec 1c             	sub    $0x1c,%esp
  80a10d:	8b 7d 08             	mov    0x8(%ebp),%edi
  80a110:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
  err_t result = ERR_MEM;
  s8_t i; /* ARP entry index */

  /* non-unicast address? */
  if (ip_addr_isbroadcast(ipaddr, netif) ||
  80a113:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80a117:	89 1c 24             	mov    %ebx,(%esp)
  80a11a:	e8 72 c9 ff ff       	call   806a91 <ip_addr_isbroadcast>
  80a11f:	84 c0                	test   %al,%al
  80a121:	0f 85 ad 01 00 00    	jne    80a2d4 <etharp_query+0x1d0>
      ip_addr_ismulticast(ipaddr) ||
  80a127:	8b 33                	mov    (%ebx),%esi
  80a129:	c7 04 24 00 00 00 f0 	movl   $0xf0000000,(%esp)
  80a130:	e8 95 de ff ff       	call   807fca <ntohl>
  80a135:	21 c6                	and    %eax,%esi
  80a137:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  80a13e:	e8 87 de ff ff       	call   807fca <ntohl>
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
  err_t result = ERR_MEM;
  s8_t i; /* ARP entry index */

  /* non-unicast address? */
  if (ip_addr_isbroadcast(ipaddr, netif) ||
  80a143:	39 c6                	cmp    %eax,%esi
  80a145:	0f 84 93 01 00 00    	je     80a2de <etharp_query+0x1da>
      ip_addr_ismulticast(ipaddr) ||
  80a14b:	85 db                	test   %ebx,%ebx
  80a14d:	0f 84 95 01 00 00    	je     80a2e8 <etharp_query+0x1e4>
      ip_addr_isany(ipaddr)) {
  80a153:	83 3b 00             	cmpl   $0x0,(%ebx)
  80a156:	0f 84 93 01 00 00    	je     80a2ef <etharp_query+0x1eb>

  /* find entry in ARP cache, ask to create entry if queueing packet */
#if LWIP_NETIF_HWADDRHINT
  i = find_entry(ipaddr, ETHARP_TRY_HARD, netif);
#else /* LWIP_NETIF_HWADDRHINT */
  i = find_entry(ipaddr, ETHARP_TRY_HARD);
  80a15c:	ba 01 00 00 00       	mov    $0x1,%edx
  80a161:	89 d8                	mov    %ebx,%eax
  80a163:	e8 a0 f7 ff ff       	call   809908 <find_entry>
#endif /* LWIP_NETIF_HWADDRHINT */

  /* could not find or create entry? */
  if (i < 0) {
  80a168:	84 c0                	test   %al,%al
  80a16a:	0f 88 fb 01 00 00    	js     80a36b <etharp_query+0x267>
    }
    return (err_t)i;
  }

  /* mark a fresh entry as pending (we just sent a request) */
  if (arp_table[i].state == ETHARP_STATE_EMPTY) {
  80a170:	0f be f0             	movsbl %al,%esi
  80a173:	6b c6 1c             	imul   $0x1c,%esi,%eax
  80a176:	8b 80 50 5a b3 00    	mov    0xb35a50(%eax),%eax
  80a17c:	85 c0                	test   %eax,%eax
  80a17e:	75 0f                	jne    80a18f <etharp_query+0x8b>
    arp_table[i].state = ETHARP_STATE_PENDING;
  80a180:	6b c6 1c             	imul   $0x1c,%esi,%eax
  80a183:	c7 80 50 5a b3 00 01 	movl   $0x1,0xb35a50(%eax)
  80a18a:	00 00 00 
  80a18d:	eb 38                	jmp    80a1c7 <etharp_query+0xc3>
  }

  /* { i is either a STABLE or (new or existing) PENDING entry } */
  LWIP_ASSERT("arp_table[i].state == PENDING or STABLE",
  80a18f:	8d 50 ff             	lea    -0x1(%eax),%edx
  80a192:	83 fa 01             	cmp    $0x1,%edx
  80a195:	76 1c                	jbe    80a1b3 <etharp_query+0xaf>
  80a197:	c7 44 24 08 a8 31 81 	movl   $0x8131a8,0x8(%esp)
  80a19e:	00 
  80a19f:	c7 44 24 04 92 03 00 	movl   $0x392,0x4(%esp)
  80a1a6:	00 
  80a1a7:	c7 04 24 92 30 81 00 	movl   $0x813092,(%esp)
  80a1ae:	e8 c7 4e 00 00       	call   80f07a <_panic>
  ((arp_table[i].state == ETHARP_STATE_PENDING) ||
   (arp_table[i].state == ETHARP_STATE_STABLE)));

  /* do we have a pending entry? or an implicit query request? */
  if ((arp_table[i].state == ETHARP_STATE_PENDING) || (q == NULL)) {
  80a1b3:	83 f8 01             	cmp    $0x1,%eax
  80a1b6:	74 0f                	je     80a1c7 <etharp_query+0xc3>
  80a1b8:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  80a1bc:	0f 85 94 01 00 00    	jne    80a356 <etharp_query+0x252>
  80a1c2:	e9 81 01 00 00       	jmp    80a348 <etharp_query+0x244>
    /* try to resolve it; send out ARP request */
    result = etharp_request(netif, ipaddr);
  80a1c7:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80a1cb:	89 3c 24             	mov    %edi,(%esp)
  80a1ce:	e8 fe fd ff ff       	call   809fd1 <etharp_request>
  80a1d3:	89 c3                	mov    %eax,%ebx
         etharp_query again could lead to sending the queued packets. */
    }
  }
  
  /* packet given? */
  if (q != NULL) {
  80a1d5:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  80a1d9:	0f 84 17 01 00 00    	je     80a2f6 <etharp_query+0x1f2>
    /* stable entry? */
    if (arp_table[i].state == ETHARP_STATE_STABLE) {
  80a1df:	6b c6 1c             	imul   $0x1c,%esi,%eax
  80a1e2:	8b 90 50 5a b3 00    	mov    0xb35a50(%eax),%edx
  80a1e8:	83 fa 02             	cmp    $0x2,%edx
  80a1eb:	75 1e                	jne    80a20b <etharp_query+0x107>
 *
 */
err_t
etharp_query(struct netif *netif, struct ip_addr *ipaddr, struct pbuf *q)
{
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
  80a1ed:	8d 4f 25             	lea    0x25(%edi),%ecx
  if (q != NULL) {
    /* stable entry? */
    if (arp_table[i].state == ETHARP_STATE_STABLE) {
      /* we have a valid IP->Ethernet address mapping */
      /* send the packet */
      result = etharp_send_ip(netif, q, srcaddr, &(arp_table[i].ethaddr));
  80a1f0:	6b f6 1c             	imul   $0x1c,%esi,%esi
  80a1f3:	81 c6 48 5a b3 00    	add    $0xb35a48,%esi
  80a1f9:	89 34 24             	mov    %esi,(%esp)
  80a1fc:	8b 55 10             	mov    0x10(%ebp),%edx
  80a1ff:	89 f8                	mov    %edi,%eax
  80a201:	e8 17 f9 ff ff       	call   809b1d <etharp_send_ip>
  80a206:	e9 60 01 00 00       	jmp    80a36b <etharp_query+0x267>
   (arp_table[i].state == ETHARP_STATE_STABLE)));

  /* do we have a pending entry? or an implicit query request? */
  if ((arp_table[i].state == ETHARP_STATE_PENDING) || (q == NULL)) {
    /* try to resolve it; send out ARP request */
    result = etharp_request(netif, ipaddr);
  80a20b:	89 d8                	mov    %ebx,%eax
    if (arp_table[i].state == ETHARP_STATE_STABLE) {
      /* we have a valid IP->Ethernet address mapping */
      /* send the packet */
      result = etharp_send_ip(netif, q, srcaddr, &(arp_table[i].ethaddr));
    /* pending entry? (either just created or already pending */
    } else if (arp_table[i].state == ETHARP_STATE_PENDING) {
  80a20d:	83 fa 01             	cmp    $0x1,%edx
  80a210:	0f 85 55 01 00 00    	jne    80a36b <etharp_query+0x267>
  80a216:	8b 45 10             	mov    0x10(%ebp),%eax
      /* IF q includes a PBUF_REF, PBUF_POOL or PBUF_RAM, we have no choice but
       * to copy the whole queue into a new PBUF_RAM (see bug #11400) 
       * PBUF_ROMs can be left as they are, since ROM must not get changed. */
      p = q;
      while (p) {
        LWIP_ASSERT("no packet queues allowed!", (p->len != p->tot_len) || (p->next == 0));
  80a219:	0f b7 48 08          	movzwl 0x8(%eax),%ecx
  80a21d:	66 39 48 0a          	cmp    %cx,0xa(%eax)
  80a221:	75 21                	jne    80a244 <etharp_query+0x140>
  80a223:	83 38 00             	cmpl   $0x0,(%eax)
  80a226:	74 1c                	je     80a244 <etharp_query+0x140>
  80a228:	c7 44 24 08 ee 30 81 	movl   $0x8130ee,0x8(%esp)
  80a22f:	00 
  80a230:	c7 44 24 04 b1 03 00 	movl   $0x3b1,0x4(%esp)
  80a237:	00 
  80a238:	c7 04 24 92 30 81 00 	movl   $0x813092,(%esp)
  80a23f:	e8 36 4e 00 00       	call   80f07a <_panic>
        if(p->type != PBUF_ROM) {
  80a244:	80 78 0c 01          	cmpb   $0x1,0xc(%eax)
  80a248:	0f 85 b7 00 00 00    	jne    80a305 <etharp_query+0x201>
          copy_needed = 1;
          break;
        }
        p = p->next;
  80a24e:	8b 00                	mov    (%eax),%eax
      int copy_needed = 0;
      /* IF q includes a PBUF_REF, PBUF_POOL or PBUF_RAM, we have no choice but
       * to copy the whole queue into a new PBUF_RAM (see bug #11400) 
       * PBUF_ROMs can be left as they are, since ROM must not get changed. */
      p = q;
      while (p) {
  80a250:	85 c0                	test   %eax,%eax
  80a252:	75 c5                	jne    80a219 <etharp_query+0x115>
  80a254:	e9 9f 00 00 00       	jmp    80a2f8 <etharp_query+0x1f4>
      }
      if(copy_needed) {
        /* copy the whole packet into new pbufs */
        p = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
        if(p != NULL) {
          if (pbuf_copy(p, q) != ERR_OK) {
  80a259:	8b 45 10             	mov    0x10(%ebp),%eax
  80a25c:	89 44 24 04          	mov    %eax,0x4(%esp)
  80a260:	89 3c 24             	mov    %edi,(%esp)
  80a263:	e8 9c b1 ff ff       	call   805404 <pbuf_copy>
        }
        p = p->next;
      }
      if(copy_needed) {
        /* copy the whole packet into new pbufs */
        p = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
  80a268:	89 7d 10             	mov    %edi,0x10(%ebp)
        if(p != NULL) {
          if (pbuf_copy(p, q) != ERR_OK) {
  80a26b:	84 c0                	test   %al,%al
  80a26d:	0f 84 bc 00 00 00    	je     80a32f <etharp_query+0x22b>
            pbuf_free(p);
  80a273:	89 3c 24             	mov    %edi,(%esp)
  80a276:	e8 79 ab ff ff       	call   804df4 <pbuf_free>
  80a27b:	e9 ab 00 00 00       	jmp    80a32b <etharp_query+0x227>
        /* queue packet ... */
        struct etharp_q_entry *new_entry;
        /* allocate a new arp queue entry */
        new_entry = memp_malloc(MEMP_ARP_QUEUE);
        if (new_entry != NULL) {
          new_entry->next = 0;
  80a280:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
          new_entry->p = p;
  80a286:	8b 7d 10             	mov    0x10(%ebp),%edi
  80a289:	89 78 04             	mov    %edi,0x4(%eax)
          if(arp_table[i].q != NULL) {
  80a28c:	6b d6 1c             	imul   $0x1c,%esi,%edx
  80a28f:	8b 8a 40 5a b3 00    	mov    0xb35a40(%edx),%ecx
  80a295:	85 c9                	test   %ecx,%ecx
  80a297:	74 16                	je     80a2af <etharp_query+0x1ab>
            /* queue was already existent, append the new entry to the end */
            struct etharp_q_entry *r;
            r = arp_table[i].q;
            while (r->next != NULL) {
  80a299:	8b 11                	mov    (%ecx),%edx
  80a29b:	85 d2                	test   %edx,%edx
  80a29d:	74 04                	je     80a2a3 <etharp_query+0x19f>
              r = r->next;
  80a29f:	89 d1                	mov    %edx,%ecx
  80a2a1:	eb f6                	jmp    80a299 <etharp_query+0x195>
            }
            r->next = new_entry;
  80a2a3:	89 01                	mov    %eax,(%ecx)
          } else {
            /* queue did not exist, first item in queue */
            arp_table[i].q = new_entry;
          }
          LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: queued packet %p on ARP entry %"S16_F"\n", (void *)q, (s16_t)i));
          result = ERR_OK;
  80a2a5:	b8 00 00 00 00       	mov    $0x0,%eax
  80a2aa:	e9 bc 00 00 00       	jmp    80a36b <etharp_query+0x267>
              r = r->next;
            }
            r->next = new_entry;
          } else {
            /* queue did not exist, first item in queue */
            arp_table[i].q = new_entry;
  80a2af:	6b f6 1c             	imul   $0x1c,%esi,%esi
  80a2b2:	89 86 40 5a b3 00    	mov    %eax,0xb35a40(%esi)
          }
          LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: queued packet %p on ARP entry %"S16_F"\n", (void *)q, (s16_t)i));
          result = ERR_OK;
  80a2b8:	b8 00 00 00 00       	mov    $0x0,%eax
  80a2bd:	e9 a9 00 00 00       	jmp    80a36b <etharp_query+0x267>
        } else {
          /* the pool MEMP_ARP_QUEUE is empty */
          pbuf_free(p);
  80a2c2:	8b 45 10             	mov    0x10(%ebp),%eax
  80a2c5:	89 04 24             	mov    %eax,(%esp)
  80a2c8:	e8 27 ab ff ff       	call   804df4 <pbuf_free>
   (arp_table[i].state == ETHARP_STATE_STABLE)));

  /* do we have a pending entry? or an implicit query request? */
  if ((arp_table[i].state == ETHARP_STATE_PENDING) || (q == NULL)) {
    /* try to resolve it; send out ARP request */
    result = etharp_request(netif, ipaddr);
  80a2cd:	89 d8                	mov    %ebx,%eax
  80a2cf:	e9 97 00 00 00       	jmp    80a36b <etharp_query+0x267>
  /* non-unicast address? */
  if (ip_addr_isbroadcast(ipaddr, netif) ||
      ip_addr_ismulticast(ipaddr) ||
      ip_addr_isany(ipaddr)) {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: will not add non-unicast IP address to ARP cache\n"));
    return ERR_ARG;
  80a2d4:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  80a2d9:	e9 8d 00 00 00       	jmp    80a36b <etharp_query+0x267>
  80a2de:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  80a2e3:	e9 83 00 00 00       	jmp    80a36b <etharp_query+0x267>
  80a2e8:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  80a2ed:	eb 7c                	jmp    80a36b <etharp_query+0x267>
  80a2ef:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  80a2f4:	eb 75                	jmp    80a36b <etharp_query+0x267>
  80a2f6:	eb 73                	jmp    80a36b <etharp_query+0x267>
          }
        }
      } else {
        /* referencing the old pbuf is enough */
        p = q;
        pbuf_ref(p);
  80a2f8:	8b 45 10             	mov    0x10(%ebp),%eax
  80a2fb:	89 04 24             	mov    %eax,(%esp)
  80a2fe:	e8 9f af ff ff       	call   8052a2 <pbuf_ref>
  80a303:	eb 2a                	jmp    80a32f <etharp_query+0x22b>
        }
        p = p->next;
      }
      if(copy_needed) {
        /* copy the whole packet into new pbufs */
        p = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
  80a305:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  80a309:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80a310:	00 
  80a311:	89 44 24 04          	mov    %eax,0x4(%esp)
  80a315:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  80a31c:	e8 b4 ab ff ff       	call   804ed5 <pbuf_alloc>
  80a321:	89 c7                	mov    %eax,%edi
        if(p != NULL) {
  80a323:	85 c0                	test   %eax,%eax
  80a325:	0f 85 2e ff ff ff    	jne    80a259 <etharp_query+0x155>
   (arp_table[i].state == ETHARP_STATE_STABLE)));

  /* do we have a pending entry? or an implicit query request? */
  if ((arp_table[i].state == ETHARP_STATE_PENDING) || (q == NULL)) {
    /* try to resolve it; send out ARP request */
    result = etharp_request(netif, ipaddr);
  80a32b:	89 d8                	mov    %ebx,%eax
  80a32d:	eb 3c                	jmp    80a36b <etharp_query+0x267>
      /* packet could be taken over? */
      if (p != NULL) {
        /* queue packet ... */
        struct etharp_q_entry *new_entry;
        /* allocate a new arp queue entry */
        new_entry = memp_malloc(MEMP_ARP_QUEUE);
  80a32f:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
  80a336:	e8 a7 a6 ff ff       	call   8049e2 <memp_malloc>
        if (new_entry != NULL) {
  80a33b:	85 c0                	test   %eax,%eax
  80a33d:	0f 85 3d ff ff ff    	jne    80a280 <etharp_query+0x17c>
  80a343:	e9 7a ff ff ff       	jmp    80a2c2 <etharp_query+0x1be>
   (arp_table[i].state == ETHARP_STATE_STABLE)));

  /* do we have a pending entry? or an implicit query request? */
  if ((arp_table[i].state == ETHARP_STATE_PENDING) || (q == NULL)) {
    /* try to resolve it; send out ARP request */
    result = etharp_request(netif, ipaddr);
  80a348:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80a34c:	89 3c 24             	mov    %edi,(%esp)
  80a34f:	e8 7d fc ff ff       	call   809fd1 <etharp_request>
  80a354:	eb 15                	jmp    80a36b <etharp_query+0x267>
  }
  
  /* packet given? */
  if (q != NULL) {
    /* stable entry? */
    if (arp_table[i].state == ETHARP_STATE_STABLE) {
  80a356:	6b c6 1c             	imul   $0x1c,%esi,%eax
  80a359:	83 b8 50 5a b3 00 02 	cmpl   $0x2,0xb35a50(%eax)
  80a360:	0f 84 87 fe ff ff    	je     80a1ed <etharp_query+0xe9>
 */
err_t
etharp_query(struct netif *netif, struct ip_addr *ipaddr, struct pbuf *q)
{
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
  err_t result = ERR_MEM;
  80a366:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: Ethernet destination address unknown, queueing disabled, packet %p dropped\n", (void *)q));
#endif
    }
  }
  return result;
}
  80a36b:	83 c4 1c             	add    $0x1c,%esp
  80a36e:	5b                   	pop    %ebx
  80a36f:	5e                   	pop    %esi
  80a370:	5f                   	pop    %edi
  80a371:	5d                   	pop    %ebp
  80a372:	c3                   	ret    

0080a373 <etharp_output>:
 * - ERR_RTE No route to destination (no gateway to external networks),
 * or the return type of either etharp_query() or etharp_send_ip().
 */
err_t
etharp_output(struct netif *netif, struct pbuf *q, struct ip_addr *ipaddr)
{
  80a373:	55                   	push   %ebp
  80a374:	89 e5                	mov    %esp,%ebp
  80a376:	57                   	push   %edi
  80a377:	56                   	push   %esi
  80a378:	53                   	push   %ebx
  80a379:	83 ec 2c             	sub    $0x2c,%esp
  80a37c:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80a37f:	8b 75 10             	mov    0x10(%ebp),%esi
  struct eth_addr *dest, mcastaddr;

  /* make room for Ethernet header - should not fail */
  if (pbuf_header(q, sizeof(struct eth_hdr)) != 0) {
  80a382:	c7 44 24 04 0e 00 00 	movl   $0xe,0x4(%esp)
  80a389:	00 
  80a38a:	8b 45 0c             	mov    0xc(%ebp),%eax
  80a38d:	89 04 24             	mov    %eax,(%esp)
  80a390:	e8 7b a9 ff ff       	call   804d10 <pbuf_header>
  80a395:	84 c0                	test   %al,%al
  80a397:	0f 85 b4 00 00 00    	jne    80a451 <etharp_output+0xde>
  dest = NULL;
  /* Determine on destination hardware address. Broadcasts and multicasts
   * are special, other IP addresses are looked up in the ARP table. */

  /* broadcast destination IP address? */
  if (ip_addr_isbroadcast(ipaddr, netif)) {
  80a39d:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80a3a1:	89 34 24             	mov    %esi,(%esp)
  80a3a4:	e8 e8 c6 ff ff       	call   806a91 <ip_addr_isbroadcast>
  80a3a9:	84 c0                	test   %al,%al
  80a3ab:	0f 85 89 00 00 00    	jne    80a43a <etharp_output+0xc7>
    /* broadcast on Ethernet also */
    dest = (struct eth_addr *)&ethbroadcast;
  /* multicast destination IP address? */
  } else if (ip_addr_ismulticast(ipaddr)) {
  80a3b1:	8b 3e                	mov    (%esi),%edi
  80a3b3:	c7 04 24 00 00 00 f0 	movl   $0xf0000000,(%esp)
  80a3ba:	e8 0b dc ff ff       	call   807fca <ntohl>
  80a3bf:	21 c7                	and    %eax,%edi
  80a3c1:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  80a3c8:	e8 fd db ff ff       	call   807fca <ntohl>
  80a3cd:	39 c7                	cmp    %eax,%edi
  80a3cf:	75 41                	jne    80a412 <etharp_output+0x9f>
    /* Hash IP multicast address to MAC address.*/
    mcastaddr.addr[0] = 0x01;
  80a3d1:	c6 45 e2 01          	movb   $0x1,-0x1e(%ebp)
    mcastaddr.addr[1] = 0x00;
  80a3d5:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
    mcastaddr.addr[2] = 0x5e;
  80a3d9:	c6 45 e4 5e          	movb   $0x5e,-0x1c(%ebp)
    mcastaddr.addr[3] = ip4_addr2(ipaddr) & 0x7f;
  80a3dd:	8b 06                	mov    (%esi),%eax
  80a3df:	89 04 24             	mov    %eax,(%esp)
  80a3e2:	e8 e3 db ff ff       	call   807fca <ntohl>
  80a3e7:	c1 e8 10             	shr    $0x10,%eax
  80a3ea:	83 e0 7f             	and    $0x7f,%eax
  80a3ed:	88 45 e5             	mov    %al,-0x1b(%ebp)
    mcastaddr.addr[4] = ip4_addr3(ipaddr);
  80a3f0:	8b 06                	mov    (%esi),%eax
  80a3f2:	89 04 24             	mov    %eax,(%esp)
  80a3f5:	e8 d0 db ff ff       	call   807fca <ntohl>
  80a3fa:	c1 e8 08             	shr    $0x8,%eax
  80a3fd:	88 45 e6             	mov    %al,-0x1a(%ebp)
    mcastaddr.addr[5] = ip4_addr4(ipaddr);
  80a400:	8b 06                	mov    (%esi),%eax
  80a402:	89 04 24             	mov    %eax,(%esp)
  80a405:	e8 c0 db ff ff       	call   807fca <ntohl>
  80a40a:	88 45 e7             	mov    %al,-0x19(%ebp)
    /* destination Ethernet address is multicast */
    dest = &mcastaddr;
  80a40d:	8d 45 e2             	lea    -0x1e(%ebp),%eax
  80a410:	eb 2d                	jmp    80a43f <etharp_output+0xcc>
  /* unicast destination IP address? */
  } else {
    /* outside local network? */
    if (!ip_addr_netcmp(ipaddr, &(netif->ip_addr), &(netif->netmask))) {
  80a412:	8b 43 04             	mov    0x4(%ebx),%eax
  80a415:	33 06                	xor    (%esi),%eax
  80a417:	85 43 08             	test   %eax,0x8(%ebx)
  80a41a:	74 09                	je     80a425 <etharp_output+0xb2>
      /* interface has default gateway? */
      if (netif->gw.addr != 0) {
  80a41c:	83 7b 0c 00          	cmpl   $0x0,0xc(%ebx)
  80a420:	74 36                	je     80a458 <etharp_output+0xe5>
        /* send to hardware address of default gateway IP address */
        ipaddr = &(netif->gw);
  80a422:	8d 73 0c             	lea    0xc(%ebx),%esi
        /* no route to destination error (default gateway missing) */
        return ERR_RTE;
      }
    }
    /* queue on destination Ethernet address belonging to ipaddr */
    return etharp_query(netif, ipaddr, q);
  80a425:	8b 45 0c             	mov    0xc(%ebp),%eax
  80a428:	89 44 24 08          	mov    %eax,0x8(%esp)
  80a42c:	89 74 24 04          	mov    %esi,0x4(%esp)
  80a430:	89 1c 24             	mov    %ebx,(%esp)
  80a433:	e8 cc fc ff ff       	call   80a104 <etharp_query>
  80a438:	eb 23                	jmp    80a45d <etharp_output+0xea>
   * are special, other IP addresses are looked up in the ARP table. */

  /* broadcast destination IP address? */
  if (ip_addr_isbroadcast(ipaddr, netif)) {
    /* broadcast on Ethernet also */
    dest = (struct eth_addr *)&ethbroadcast;
  80a43a:	b8 f7 31 81 00       	mov    $0x8131f7,%eax
  }

  /* continuation for multicast/broadcast destinations */
  /* obtain source Ethernet address of the given interface */
  /* send packet directly on the link */
  return etharp_send_ip(netif, q, (struct eth_addr*)(netif->hwaddr), dest);
  80a43f:	8d 4b 25             	lea    0x25(%ebx),%ecx
  80a442:	89 04 24             	mov    %eax,(%esp)
  80a445:	8b 55 0c             	mov    0xc(%ebp),%edx
  80a448:	89 d8                	mov    %ebx,%eax
  80a44a:	e8 ce f6 ff ff       	call   809b1d <etharp_send_ip>
  80a44f:	eb 0c                	jmp    80a45d <etharp_output+0xea>
  /* make room for Ethernet header - should not fail */
  if (pbuf_header(q, sizeof(struct eth_hdr)) != 0) {
    /* bail out */
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 2, ("etharp_output: could not allocate room for header.\n"));
    LINK_STATS_INC(link.lenerr);
    return ERR_BUF;
  80a451:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  80a456:	eb 05                	jmp    80a45d <etharp_output+0xea>
        /* send to hardware address of default gateway IP address */
        ipaddr = &(netif->gw);
      /* no default gateway available */
      } else {
        /* no route to destination error (default gateway missing) */
        return ERR_RTE;
  80a458:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax

  /* continuation for multicast/broadcast destinations */
  /* obtain source Ethernet address of the given interface */
  /* send packet directly on the link */
  return etharp_send_ip(netif, q, (struct eth_addr*)(netif->hwaddr), dest);
}
  80a45d:	83 c4 2c             	add    $0x2c,%esp
  80a460:	5b                   	pop    %ebx
  80a461:	5e                   	pop    %esi
  80a462:	5f                   	pop    %edi
  80a463:	5d                   	pop    %ebp
  80a464:	c3                   	ret    

0080a465 <ethernet_input>:
 * @param p the recevied packet, p->payload pointing to the ethernet header
 * @param netif the network interface on which the packet was received
 */
err_t
ethernet_input(struct pbuf *p, struct netif *netif)
{
  80a465:	55                   	push   %ebp
  80a466:	89 e5                	mov    %esp,%ebp
  80a468:	56                   	push   %esi
  80a469:	53                   	push   %ebx
  80a46a:	83 ec 10             	sub    $0x10,%esp
  80a46d:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80a470:	8b 75 0c             	mov    0xc(%ebp),%esi
     (unsigned)ethhdr->dest.addr[3], (unsigned)ethhdr->dest.addr[4], (unsigned)ethhdr->dest.addr[5],
     (unsigned)ethhdr->src.addr[0], (unsigned)ethhdr->src.addr[1], (unsigned)ethhdr->src.addr[2],
     (unsigned)ethhdr->src.addr[3], (unsigned)ethhdr->src.addr[4], (unsigned)ethhdr->src.addr[5],
     (unsigned)htons(ethhdr->type)));

  switch (htons(ethhdr->type)) {
  80a473:	8b 43 04             	mov    0x4(%ebx),%eax
  80a476:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80a47a:	89 04 24             	mov    %eax,(%esp)
  80a47d:	e8 f4 d8 ff ff       	call   807d76 <htons>
  80a482:	66 3d 00 08          	cmp    $0x800,%ax
  80a486:	74 0a                	je     80a492 <ethernet_input+0x2d>
  80a488:	66 3d 06 08          	cmp    $0x806,%ax
  80a48c:	74 4e                	je     80a4dc <ethernet_input+0x77>
  80a48e:	66 90                	xchg   %ax,%ax
  80a490:	eb 5f                	jmp    80a4f1 <ethernet_input+0x8c>
    /* IP packet? */
    case ETHTYPE_IP:
#if ETHARP_TRUST_IP_MAC
      /* update ARP table */
      etharp_ip_input(netif, p);
  80a492:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80a496:	89 34 24             	mov    %esi,(%esp)
  80a499:	e8 f5 f8 ff ff       	call   809d93 <etharp_ip_input>
#endif /* ETHARP_TRUST_IP_MAC */
      /* skip Ethernet header */
      if(pbuf_header(p, -(s16_t)sizeof(struct eth_hdr))) {
  80a49e:	c7 44 24 04 f2 ff ff 	movl   $0xfffffff2,0x4(%esp)
  80a4a5:	ff 
  80a4a6:	89 1c 24             	mov    %ebx,(%esp)
  80a4a9:	e8 62 a8 ff ff       	call   804d10 <pbuf_header>
  80a4ae:	84 c0                	test   %al,%al
  80a4b0:	74 1c                	je     80a4ce <ethernet_input+0x69>
        LWIP_ASSERT("Can't move over header in packet", 0);
  80a4b2:	c7 44 24 08 d0 31 81 	movl   $0x8131d0,0x8(%esp)
  80a4b9:	00 
  80a4ba:	c7 44 24 04 7e 04 00 	movl   $0x47e,0x4(%esp)
  80a4c1:	00 
  80a4c2:	c7 04 24 92 30 81 00 	movl   $0x813092,(%esp)
  80a4c9:	e8 ac 4b 00 00       	call   80f07a <_panic>
        pbuf_free(p);
        p = NULL;
      } else {
        /* pass to IP layer */
        ip_input(p, netif);
  80a4ce:	89 74 24 04          	mov    %esi,0x4(%esp)
  80a4d2:	89 1c 24             	mov    %ebx,(%esp)
  80a4d5:	e8 66 c6 ff ff       	call   806b40 <ip_input>
      }
      break;
  80a4da:	eb 1d                	jmp    80a4f9 <ethernet_input+0x94>
      
    case ETHTYPE_ARP:
      /* pass p to ARP module */
      etharp_arp_input(netif, (struct eth_addr*)(netif->hwaddr), p);
  80a4dc:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  80a4e0:	8d 46 25             	lea    0x25(%esi),%eax
  80a4e3:	89 44 24 04          	mov    %eax,0x4(%esp)
  80a4e7:	89 34 24             	mov    %esi,(%esp)
  80a4ea:	e8 f2 f8 ff ff       	call   809de1 <etharp_arp_input>
      break;
  80a4ef:	eb 08                	jmp    80a4f9 <ethernet_input+0x94>
#endif /* PPPOE_SUPPORT */

    default:
      ETHARP_STATS_INC(etharp.proterr);
      ETHARP_STATS_INC(etharp.drop);
      pbuf_free(p);
  80a4f1:	89 1c 24             	mov    %ebx,(%esp)
  80a4f4:	e8 fb a8 ff ff       	call   804df4 <pbuf_free>
  }

  /* This means the pbuf is freed or consumed,
     so the caller doesn't have to free it again */
  return ERR_OK;
}
  80a4f9:	b8 00 00 00 00       	mov    $0x0,%eax
  80a4fe:	83 c4 10             	add    $0x10,%esp
  80a501:	5b                   	pop    %ebx
  80a502:	5e                   	pop    %esi
  80a503:	5d                   	pop    %ebp
  80a504:	c3                   	ret    
  80a505:	66 90                	xchg   %ax,%ax
  80a507:	66 90                	xchg   %ax,%ax
  80a509:	66 90                	xchg   %ax,%ax
  80a50b:	66 90                	xchg   %ax,%ax
  80a50d:	66 90                	xchg   %ax,%ax
  80a50f:	90                   	nop

0080a510 <lwip_thread_entry>:
    void *arg;
};

static void
lwip_thread_entry(uint32_t arg)
{
  80a510:	55                   	push   %ebp
  80a511:	89 e5                	mov    %esp,%ebp
  80a513:	53                   	push   %ebx
  80a514:	83 ec 14             	sub    $0x14,%esp
  80a517:	8b 5d 08             	mov    0x8(%ebp),%ebx
    struct lwip_thread *lt = (struct lwip_thread *)arg;
    lwip_core_lock();
    lt->func(lt->arg);
  80a51a:	8b 43 04             	mov    0x4(%ebx),%eax
  80a51d:	89 04 24             	mov    %eax,(%esp)
  80a520:	ff 13                	call   *(%ebx)
    lwip_core_unlock();
    free(lt);
  80a522:	89 1c 24             	mov    %ebx,(%esp)
  80a525:	e8 76 6b 00 00       	call   8110a0 <free>
}
  80a52a:	83 c4 14             	add    $0x14,%esp
  80a52d:	5b                   	pop    %ebx
  80a52e:	5d                   	pop    %ebp
  80a52f:	c3                   	ret    

0080a530 <timeout_cleanup>:
    return tid;
}

static void
timeout_cleanup(thread_id_t tid)
{
  80a530:	55                   	push   %ebp
  80a531:	89 e5                	mov    %esp,%ebp
  80a533:	83 ec 18             	sub    $0x18,%esp
  80a536:	8b 4d 08             	mov    0x8(%ebp),%ecx
    lwip_core_lock();

    struct sys_thread *t;
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  80a539:	ba 01 ff 00 ff       	mov    $0xff00ff01,%edx
  80a53e:	89 c8                	mov    %ecx,%eax
  80a540:	f7 e2                	mul    %edx
  80a542:	c1 ea 08             	shr    $0x8,%edx
  80a545:	89 d0                	mov    %edx,%eax
  80a547:	c1 e0 08             	shl    $0x8,%eax
  80a54a:	01 c2                	add    %eax,%edx
  80a54c:	89 c8                	mov    %ecx,%eax
  80a54e:	29 d0                	sub    %edx,%eax
  80a550:	8b 14 85 60 5b b3 00 	mov    0xb35b60(,%eax,4),%edx
  80a557:	eb 26                	jmp    80a57f <timeout_cleanup+0x4f>
	if (t->tid == tid) {
  80a559:	39 0a                	cmp    %ecx,(%edx)
  80a55b:	75 1f                	jne    80a57c <timeout_cleanup+0x4c>
	    LIST_REMOVE(t, link);
  80a55d:	8b 42 08             	mov    0x8(%edx),%eax
  80a560:	85 c0                	test   %eax,%eax
  80a562:	74 06                	je     80a56a <timeout_cleanup+0x3a>
  80a564:	8b 4a 0c             	mov    0xc(%edx),%ecx
  80a567:	89 48 0c             	mov    %ecx,0xc(%eax)
  80a56a:	8b 42 0c             	mov    0xc(%edx),%eax
  80a56d:	8b 4a 08             	mov    0x8(%edx),%ecx
  80a570:	89 08                	mov    %ecx,(%eax)
	    free(t);
  80a572:	89 14 24             	mov    %edx,(%esp)
  80a575:	e8 26 6b 00 00       	call   8110a0 <free>
	    goto done;
  80a57a:	eb 07                	jmp    80a583 <timeout_cleanup+0x53>
timeout_cleanup(thread_id_t tid)
{
    lwip_core_lock();

    struct sys_thread *t;
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  80a57c:	8b 52 08             	mov    0x8(%edx),%edx
  80a57f:	85 d2                	test   %edx,%edx
  80a581:	75 d6                	jne    80a559 <timeout_cleanup+0x29>
	}

    if (debug) cprintf("timeout_cleanup: bogus tid %ld\n", tid);
 done:
    lwip_core_unlock();
}
  80a583:	c9                   	leave  
  80a584:	c3                   	ret    

0080a585 <sys_init>:
enum { thread_hash_size = 257 };
static LIST_HEAD(thread_list, sys_thread) threads[thread_hash_size];

void
sys_init(void)
{
  80a585:	55                   	push   %ebp
  80a586:	89 e5                	mov    %esp,%ebp
  80a588:	56                   	push   %esi
  80a589:	53                   	push   %ebx
  80a58a:	8b 15 80 ad b3 00    	mov    0xb3ad80,%edx
  80a590:	b8 a0 ad b3 00       	mov    $0xb3ada0,%eax
  80a595:	be a0 c1 b3 00       	mov    $0xb3c1a0,%esi
  80a59a:	89 c1                	mov    %eax,%ecx
    int i = 0;
    for (i = 0; i < NSEM; i++) {
	sems[i].freed = 1;
  80a59c:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
	LIST_INSERT_HEAD(&sem_free, &sems[i], link);
  80a5a2:	89 50 0c             	mov    %edx,0xc(%eax)
  80a5a5:	85 d2                	test   %edx,%edx
  80a5a7:	74 06                	je     80a5af <sys_init+0x2a>
  80a5a9:	8d 58 0c             	lea    0xc(%eax),%ebx
  80a5ac:	89 5a 10             	mov    %ebx,0x10(%edx)
  80a5af:	c7 41 10 80 ad b3 00 	movl   $0xb3ad80,0x10(%ecx)
  80a5b6:	83 c0 14             	add    $0x14,%eax

void
sys_init(void)
{
    int i = 0;
    for (i = 0; i < NSEM; i++) {
  80a5b9:	39 f0                	cmp    %esi,%eax
  80a5bb:	74 04                	je     80a5c1 <sys_init+0x3c>
	sems[i].freed = 1;
	LIST_INSERT_HEAD(&sem_free, &sems[i], link);
  80a5bd:	89 ca                	mov    %ecx,%edx
  80a5bf:	eb d9                	jmp    80a59a <sys_init+0x15>
  80a5c1:	c7 05 80 ad b3 00 8c 	movl   $0xb3c18c,0xb3ad80
  80a5c8:	c1 b3 00 
  80a5cb:	8b 15 64 5f b3 00    	mov    0xb35f64,%edx
  80a5d1:	b8 80 5f b3 00       	mov    $0xb35f80,%eax
  80a5d6:	be 80 ad b3 00       	mov    $0xb3ad80,%esi
  80a5db:	89 c1                	mov    %eax,%ecx
    }

    for (i = 0; i < NMBOX; i++) {
	mboxes[i].freed = 1;
  80a5dd:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
	LIST_INSERT_HEAD(&mbox_free, &mboxes[i], link);
  80a5e3:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
  80a5e9:	85 d2                	test   %edx,%edx
  80a5eb:	74 0c                	je     80a5f9 <sys_init+0x74>
  80a5ed:	8d 98 94 00 00 00    	lea    0x94(%eax),%ebx
  80a5f3:	89 9a 98 00 00 00    	mov    %ebx,0x98(%edx)
  80a5f9:	c7 81 98 00 00 00 64 	movl   $0xb35f64,0x98(%ecx)
  80a600:	5f b3 00 
  80a603:	05 9c 00 00 00       	add    $0x9c,%eax
    for (i = 0; i < NSEM; i++) {
	sems[i].freed = 1;
	LIST_INSERT_HEAD(&sem_free, &sems[i], link);
    }

    for (i = 0; i < NMBOX; i++) {
  80a608:	39 f0                	cmp    %esi,%eax
  80a60a:	74 04                	je     80a610 <sys_init+0x8b>
	mboxes[i].freed = 1;
	LIST_INSERT_HEAD(&mbox_free, &mboxes[i], link);
  80a60c:	89 ca                	mov    %ecx,%edx
  80a60e:	eb cb                	jmp    80a5db <sys_init+0x56>
  80a610:	c7 05 64 5f b3 00 e4 	movl   $0xb3ace4,0xb35f64
  80a617:	ac b3 00 
    }
}
  80a61a:	5b                   	pop    %ebx
  80a61b:	5e                   	pop    %esi
  80a61c:	5d                   	pop    %ebp
  80a61d:	c3                   	ret    

0080a61e <sys_sem_new>:
    return ERR_OK;
}

sys_sem_t
sys_sem_new(u8_t count)
{
  80a61e:	55                   	push   %ebp
  80a61f:	89 e5                	mov    %esp,%ebp
  80a621:	53                   	push   %ebx
  80a622:	83 ec 14             	sub    $0x14,%esp
  80a625:	8b 4d 08             	mov    0x8(%ebp),%ecx
    struct sys_sem_entry *se = LIST_FIRST(&sem_free);
  80a628:	a1 80 ad b3 00       	mov    0xb3ad80,%eax
    if (!se) {
  80a62d:	85 c0                	test   %eax,%eax
  80a62f:	75 13                	jne    80a644 <sys_sem_new+0x26>
	cprintf("lwip: sys_sem_new: out of semaphores\n");
  80a631:	c7 04 24 00 32 81 00 	movl   $0x813200,(%esp)
  80a638:	e8 36 4b 00 00       	call   80f173 <cprintf>
	return SYS_SEM_NULL;
  80a63d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80a642:	eb 5d                	jmp    80a6a1 <sys_sem_new+0x83>
    }
    LIST_REMOVE(se, link);
  80a644:	8b 50 0c             	mov    0xc(%eax),%edx
  80a647:	85 d2                	test   %edx,%edx
  80a649:	74 06                	je     80a651 <sys_sem_new+0x33>
  80a64b:	8b 58 10             	mov    0x10(%eax),%ebx
  80a64e:	89 5a 10             	mov    %ebx,0x10(%edx)
  80a651:	8b 50 10             	mov    0x10(%eax),%edx
  80a654:	8b 58 0c             	mov    0xc(%eax),%ebx
  80a657:	89 1a                	mov    %ebx,(%edx)
    assert(se->freed);
  80a659:	83 38 00             	cmpl   $0x0,(%eax)
  80a65c:	75 24                	jne    80a682 <sys_sem_new+0x64>
  80a65e:	c7 44 24 0c 75 33 81 	movl   $0x813375,0xc(%esp)
  80a665:	00 
  80a666:	c7 44 24 08 7f 33 81 	movl   $0x81337f,0x8(%esp)
  80a66d:	00 
  80a66e:	c7 44 24 04 8d 00 00 	movl   $0x8d,0x4(%esp)
  80a675:	00 
  80a676:	c7 04 24 94 33 81 00 	movl   $0x813394,(%esp)
  80a67d:	e8 f8 49 00 00       	call   80f07a <_panic>
    se->freed = 0;
  80a682:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

    se->counter = count;
  80a688:	0f b6 c9             	movzbl %cl,%ecx
  80a68b:	66 89 48 08          	mov    %cx,0x8(%eax)
    se->gen++;
  80a68f:	83 40 04 01          	addl   $0x1,0x4(%eax)
    return se - &sems[0];
  80a693:	2d a0 ad b3 00       	sub    $0xb3ada0,%eax
  80a698:	c1 f8 02             	sar    $0x2,%eax
  80a69b:	69 c0 cd cc cc cc    	imul   $0xcccccccd,%eax,%eax
}
  80a6a1:	83 c4 14             	add    $0x14,%esp
  80a6a4:	5b                   	pop    %ebx
  80a6a5:	5d                   	pop    %ebp
  80a6a6:	c3                   	ret    

0080a6a7 <sys_sem_free>:

void
sys_sem_free(sys_sem_t sem)
{
  80a6a7:	55                   	push   %ebp
  80a6a8:	89 e5                	mov    %esp,%ebp
  80a6aa:	83 ec 18             	sub    $0x18,%esp
  80a6ad:	8b 45 08             	mov    0x8(%ebp),%eax
    assert(!sems[sem].freed);
  80a6b0:	8d 14 80             	lea    (%eax,%eax,4),%edx
  80a6b3:	83 3c 95 a0 ad b3 00 	cmpl   $0x0,0xb3ada0(,%edx,4)
  80a6ba:	00 
  80a6bb:	74 24                	je     80a6e1 <sys_sem_free+0x3a>
  80a6bd:	c7 44 24 0c b1 33 81 	movl   $0x8133b1,0xc(%esp)
  80a6c4:	00 
  80a6c5:	c7 44 24 08 7f 33 81 	movl   $0x81337f,0x8(%esp)
  80a6cc:	00 
  80a6cd:	c7 44 24 04 98 00 00 	movl   $0x98,0x4(%esp)
  80a6d4:	00 
  80a6d5:	c7 04 24 94 33 81 00 	movl   $0x813394,(%esp)
  80a6dc:	e8 99 49 00 00       	call   80f07a <_panic>
    sems[sem].freed = 1;
  80a6e1:	8d 0c 80             	lea    (%eax,%eax,4),%ecx
  80a6e4:	c1 e1 02             	shl    $0x2,%ecx
  80a6e7:	8d 91 a0 ad b3 00    	lea    0xb3ada0(%ecx),%edx
  80a6ed:	c7 81 a0 ad b3 00 01 	movl   $0x1,0xb3ada0(%ecx)
  80a6f4:	00 00 00 
    sems[sem].gen++;
  80a6f7:	83 42 04 01          	addl   $0x1,0x4(%edx)
    LIST_INSERT_HEAD(&sem_free, &sems[sem], link);
  80a6fb:	8b 0d 80 ad b3 00    	mov    0xb3ad80,%ecx
  80a701:	89 4a 0c             	mov    %ecx,0xc(%edx)
  80a704:	85 c9                	test   %ecx,%ecx
  80a706:	74 0d                	je     80a715 <sys_sem_free+0x6e>
  80a708:	8d 14 80             	lea    (%eax,%eax,4),%edx
  80a70b:	8d 14 95 ac ad b3 00 	lea    0xb3adac(,%edx,4),%edx
  80a712:	89 51 10             	mov    %edx,0x10(%ecx)
  80a715:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  80a71c:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
  80a71f:	8d 0c 8d a0 ad b3 00 	lea    0xb3ada0(,%ecx,4),%ecx
  80a726:	89 0d 80 ad b3 00    	mov    %ecx,0xb3ad80
  80a72c:	01 d0                	add    %edx,%eax
  80a72e:	c7 04 85 b0 ad b3 00 	movl   $0xb3ad80,0xb3adb0(,%eax,4)
  80a735:	80 ad b3 00 
}
  80a739:	c9                   	leave  
  80a73a:	c3                   	ret    

0080a73b <sys_mbox_free>:
    return i;
}

void
sys_mbox_free(sys_mbox_t mbox)
{
  80a73b:	55                   	push   %ebp
  80a73c:	89 e5                	mov    %esp,%ebp
  80a73e:	57                   	push   %edi
  80a73f:	56                   	push   %esi
  80a740:	53                   	push   %ebx
  80a741:	83 ec 1c             	sub    $0x1c,%esp
  80a744:	8b 5d 08             	mov    0x8(%ebp),%ebx
    assert(!mboxes[mbox].freed);
  80a747:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80a74d:	83 b8 80 5f b3 00 00 	cmpl   $0x0,0xb35f80(%eax)
  80a754:	74 24                	je     80a77a <sys_mbox_free+0x3f>
  80a756:	c7 44 24 0c c2 33 81 	movl   $0x8133c2,0xc(%esp)
  80a75d:	00 
  80a75e:	c7 44 24 08 7f 33 81 	movl   $0x81337f,0x8(%esp)
  80a765:	00 
  80a766:	c7 44 24 04 62 00 00 	movl   $0x62,0x4(%esp)
  80a76d:	00 
  80a76e:	c7 04 24 94 33 81 00 	movl   $0x813394,(%esp)
  80a775:	e8 00 49 00 00       	call   80f07a <_panic>
    sys_sem_free(mboxes[mbox].queued_msg);
  80a77a:	69 f3 9c 00 00 00    	imul   $0x9c,%ebx,%esi
  80a780:	8b 86 0c 60 b3 00    	mov    0xb3600c(%esi),%eax
  80a786:	89 04 24             	mov    %eax,(%esp)
  80a789:	e8 19 ff ff ff       	call   80a6a7 <sys_sem_free>
    sys_sem_free(mboxes[mbox].free_msg);
  80a78e:	8b 86 10 60 b3 00    	mov    0xb36010(%esi),%eax
  80a794:	89 04 24             	mov    %eax,(%esp)
  80a797:	e8 0b ff ff ff       	call   80a6a7 <sys_sem_free>
    LIST_INSERT_HEAD(&mbox_free, &mboxes[mbox], link);
  80a79c:	a1 64 5f b3 00       	mov    0xb35f64,%eax
  80a7a1:	89 86 14 60 b3 00    	mov    %eax,0xb36014(%esi)
  80a7a7:	85 c0                	test   %eax,%eax
  80a7a9:	74 0e                	je     80a7b9 <sys_mbox_free+0x7e>
  80a7ab:	89 f2                	mov    %esi,%edx
  80a7ad:	81 c2 14 60 b3 00    	add    $0xb36014,%edx
  80a7b3:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
  80a7b9:	69 db 9c 00 00 00    	imul   $0x9c,%ebx,%ebx
  80a7bf:	8d 83 80 5f b3 00    	lea    0xb35f80(%ebx),%eax
  80a7c5:	a3 64 5f b3 00       	mov    %eax,0xb35f64
  80a7ca:	c7 83 18 60 b3 00 64 	movl   $0xb35f64,0xb36018(%ebx)
  80a7d1:	5f b3 00 
    mboxes[mbox].freed = 1;
  80a7d4:	c7 83 80 5f b3 00 01 	movl   $0x1,0xb35f80(%ebx)
  80a7db:	00 00 00 
}
  80a7de:	83 c4 1c             	add    $0x1c,%esp
  80a7e1:	5b                   	pop    %ebx
  80a7e2:	5e                   	pop    %esi
  80a7e3:	5f                   	pop    %edi
  80a7e4:	5d                   	pop    %ebp
  80a7e5:	c3                   	ret    

0080a7e6 <sys_mbox_new>:
    }
}

sys_mbox_t
sys_mbox_new(int size)
{
  80a7e6:	55                   	push   %ebp
  80a7e7:	89 e5                	mov    %esp,%ebp
  80a7e9:	56                   	push   %esi
  80a7ea:	53                   	push   %ebx
  80a7eb:	83 ec 10             	sub    $0x10,%esp
    assert(size < MBOXSLOTS);
  80a7ee:	83 7d 08 1f          	cmpl   $0x1f,0x8(%ebp)
  80a7f2:	7e 24                	jle    80a818 <sys_mbox_new+0x32>
  80a7f4:	c7 44 24 0c d6 33 81 	movl   $0x8133d6,0xc(%esp)
  80a7fb:	00 
  80a7fc:	c7 44 24 08 7f 33 81 	movl   $0x81337f,0x8(%esp)
  80a803:	00 
  80a804:	c7 44 24 04 45 00 00 	movl   $0x45,0x4(%esp)
  80a80b:	00 
  80a80c:	c7 04 24 94 33 81 00 	movl   $0x813394,(%esp)
  80a813:	e8 62 48 00 00       	call   80f07a <_panic>
    struct sys_mbox_entry *mbe = LIST_FIRST(&mbox_free);
  80a818:	8b 1d 64 5f b3 00    	mov    0xb35f64,%ebx
    if (!mbe) {
  80a81e:	85 db                	test   %ebx,%ebx
  80a820:	75 16                	jne    80a838 <sys_mbox_new+0x52>
	cprintf("lwip: sys_mbox_new: out of mailboxes\n");
  80a822:	c7 04 24 28 32 81 00 	movl   $0x813228,(%esp)
  80a829:	e8 45 49 00 00       	call   80f173 <cprintf>
	return SYS_MBOX_NULL;
  80a82e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80a833:	e9 c1 00 00 00       	jmp    80a8f9 <sys_mbox_new+0x113>
    }
    LIST_REMOVE(mbe, link);
  80a838:	8b 83 94 00 00 00    	mov    0x94(%ebx),%eax
  80a83e:	85 c0                	test   %eax,%eax
  80a840:	74 0c                	je     80a84e <sys_mbox_new+0x68>
  80a842:	8b 93 98 00 00 00    	mov    0x98(%ebx),%edx
  80a848:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
  80a84e:	8b 83 98 00 00 00    	mov    0x98(%ebx),%eax
  80a854:	8b 93 94 00 00 00    	mov    0x94(%ebx),%edx
  80a85a:	89 10                	mov    %edx,(%eax)
    assert(mbe->freed);
  80a85c:	83 3b 00             	cmpl   $0x0,(%ebx)
  80a85f:	75 24                	jne    80a885 <sys_mbox_new+0x9f>
  80a861:	c7 44 24 0c e7 33 81 	movl   $0x8133e7,0xc(%esp)
  80a868:	00 
  80a869:	c7 44 24 08 7f 33 81 	movl   $0x81337f,0x8(%esp)
  80a870:	00 
  80a871:	c7 44 24 04 4c 00 00 	movl   $0x4c,0x4(%esp)
  80a878:	00 
  80a879:	c7 04 24 94 33 81 00 	movl   $0x813394,(%esp)
  80a880:	e8 f5 47 00 00       	call   80f07a <_panic>
    mbe->freed = 0;
  80a885:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)

    int i = mbe - &mboxes[0];
  80a88b:	89 de                	mov    %ebx,%esi
  80a88d:	81 ee 80 5f b3 00    	sub    $0xb35f80,%esi
  80a893:	c1 fe 02             	sar    $0x2,%esi
  80a896:	69 f6 97 6f f9 96    	imul   $0x96f96f97,%esi,%esi
    mbe->head = -1;
  80a89c:	c7 43 04 ff ff ff ff 	movl   $0xffffffff,0x4(%ebx)
    mbe->nextq = 0;
  80a8a3:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    mbe->queued_msg = sys_sem_new(0);
  80a8aa:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80a8b1:	e8 68 fd ff ff       	call   80a61e <sys_sem_new>
  80a8b6:	89 83 8c 00 00 00    	mov    %eax,0x8c(%ebx)
    mbe->free_msg = sys_sem_new(MBOXSLOTS);
  80a8bc:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
  80a8c3:	e8 56 fd ff ff       	call   80a61e <sys_sem_new>
  80a8c8:	89 83 90 00 00 00    	mov    %eax,0x90(%ebx)

    if (mbe->queued_msg == SYS_SEM_NULL ||
  80a8ce:	83 bb 8c 00 00 00 ff 	cmpl   $0xffffffff,0x8c(%ebx)
  80a8d5:	74 05                	je     80a8dc <sys_mbox_new+0xf6>
  80a8d7:	83 f8 ff             	cmp    $0xffffffff,%eax
  80a8da:	75 1b                	jne    80a8f7 <sys_mbox_new+0x111>
	mbe->free_msg == SYS_SEM_NULL)
    {
	sys_mbox_free(i);
  80a8dc:	89 34 24             	mov    %esi,(%esp)
  80a8df:	e8 57 fe ff ff       	call   80a73b <sys_mbox_free>
	cprintf("lwip: sys_mbox_new: can't get semaphore\n");
  80a8e4:	c7 04 24 50 32 81 00 	movl   $0x813250,(%esp)
  80a8eb:	e8 83 48 00 00       	call   80f173 <cprintf>
	return SYS_MBOX_NULL;
  80a8f0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80a8f5:	eb 02                	jmp    80a8f9 <sys_mbox_new+0x113>
    }
    return i;
  80a8f7:	89 f0                	mov    %esi,%eax
}
  80a8f9:	83 c4 10             	add    $0x10,%esp
  80a8fc:	5b                   	pop    %ebx
  80a8fd:	5e                   	pop    %esi
  80a8fe:	5d                   	pop    %ebp
  80a8ff:	c3                   	ret    

0080a900 <sys_sem_signal>:
    LIST_INSERT_HEAD(&sem_free, &sems[sem], link);
}

void
sys_sem_signal(sys_sem_t sem)
{
  80a900:	55                   	push   %ebp
  80a901:	89 e5                	mov    %esp,%ebp
  80a903:	83 ec 18             	sub    $0x18,%esp
  80a906:	8b 45 08             	mov    0x8(%ebp),%eax
    assert(!sems[sem].freed);
  80a909:	8d 14 80             	lea    (%eax,%eax,4),%edx
  80a90c:	83 3c 95 a0 ad b3 00 	cmpl   $0x0,0xb3ada0(,%edx,4)
  80a913:	00 
  80a914:	74 24                	je     80a93a <sys_sem_signal+0x3a>
  80a916:	c7 44 24 0c b1 33 81 	movl   $0x8133b1,0xc(%esp)
  80a91d:	00 
  80a91e:	c7 44 24 08 7f 33 81 	movl   $0x81337f,0x8(%esp)
  80a925:	00 
  80a926:	c7 44 24 04 a1 00 00 	movl   $0xa1,0x4(%esp)
  80a92d:	00 
  80a92e:	c7 04 24 94 33 81 00 	movl   $0x813394,(%esp)
  80a935:	e8 40 47 00 00       	call   80f07a <_panic>
    sems[sem].counter++;
  80a93a:	8d 14 80             	lea    (%eax,%eax,4),%edx
  80a93d:	8d 14 95 a0 ad b3 00 	lea    0xb3ada0(,%edx,4),%edx
  80a944:	66 83 42 08 01       	addw   $0x1,0x8(%edx)
    if (sems[sem].waiters) {
  80a949:	66 83 7a 0a 00       	cmpw   $0x0,0xa(%edx)
  80a94e:	74 23                	je     80a973 <sys_sem_signal+0x73>
	sems[sem].waiters = 0;
  80a950:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  80a957:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
  80a95a:	66 c7 04 8d aa ad b3 	movw   $0x0,0xb3adaa(,%ecx,4)
  80a961:	00 00 00 
	thread_wakeup(&sems[sem].v);
  80a964:	8d 04 8d a8 ad b3 00 	lea    0xb3ada8(,%ecx,4),%eax
  80a96b:	89 04 24             	mov    %eax,(%esp)
  80a96e:	e8 3c 05 00 00       	call   80aeaf <thread_wakeup>
    }
}
  80a973:	c9                   	leave  
  80a974:	c3                   	ret    

0080a975 <sys_arch_sem_wait>:

u32_t
sys_arch_sem_wait(sys_sem_t sem, u32_t tm_msec)
{
  80a975:	55                   	push   %ebp
  80a976:	89 e5                	mov    %esp,%ebp
  80a978:	57                   	push   %edi
  80a979:	56                   	push   %esi
  80a97a:	53                   	push   %ebx
  80a97b:	83 ec 2c             	sub    $0x2c,%esp
  80a97e:	8b 75 0c             	mov    0xc(%ebp),%esi
    assert(!sems[sem].freed);
  80a981:	8b 45 08             	mov    0x8(%ebp),%eax
  80a984:	8d 04 80             	lea    (%eax,%eax,4),%eax
  80a987:	83 3c 85 a0 ad b3 00 	cmpl   $0x0,0xb3ada0(,%eax,4)
  80a98e:	00 
  80a98f:	74 24                	je     80a9b5 <sys_arch_sem_wait+0x40>
  80a991:	c7 44 24 0c b1 33 81 	movl   $0x8133b1,0xc(%esp)
  80a998:	00 
  80a999:	c7 44 24 08 7f 33 81 	movl   $0x81337f,0x8(%esp)
  80a9a0:	00 
  80a9a1:	c7 44 24 04 ac 00 00 	movl   $0xac,0x4(%esp)
  80a9a8:	00 
  80a9a9:	c7 04 24 94 33 81 00 	movl   $0x813394,(%esp)
  80a9b0:	e8 c5 46 00 00       	call   80f07a <_panic>
    u32_t waited = 0;

    int gen = sems[sem].gen;
  80a9b5:	8b 45 08             	mov    0x8(%ebp),%eax
  80a9b8:	8d 04 80             	lea    (%eax,%eax,4),%eax
  80a9bb:	8b 04 85 a4 ad b3 00 	mov    0xb3ada4(,%eax,4),%eax
  80a9c2:	89 45 dc             	mov    %eax,-0x24(%ebp)

u32_t
sys_arch_sem_wait(sys_sem_t sem, u32_t tm_msec)
{
    assert(!sems[sem].freed);
    u32_t waited = 0;
  80a9c5:	bf 00 00 00 00       	mov    $0x0,%edi

    int gen = sems[sem].gen;

    while (tm_msec == 0 || waited < tm_msec) {
	if (sems[sem].counter > 0) {
  80a9ca:	8b 45 08             	mov    0x8(%ebp),%eax
  80a9cd:	8d 04 80             	lea    (%eax,%eax,4),%eax
  80a9d0:	89 45 e0             	mov    %eax,-0x20(%ebp)
    assert(!sems[sem].freed);
    u32_t waited = 0;

    int gen = sems[sem].gen;

    while (tm_msec == 0 || waited < tm_msec) {
  80a9d3:	e9 90 00 00 00       	jmp    80aa68 <sys_arch_sem_wait+0xf3>
	if (sems[sem].counter > 0) {
  80a9d8:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80a9db:	0f b7 04 85 a8 ad b3 	movzwl 0xb3ada8(,%eax,4),%eax
  80a9e2:	00 
  80a9e3:	66 85 c0             	test   %ax,%ax
  80a9e6:	74 18                	je     80aa00 <sys_arch_sem_wait+0x8b>
	    sems[sem].counter--;
  80a9e8:	8b 55 08             	mov    0x8(%ebp),%edx
  80a9eb:	8d 14 92             	lea    (%edx,%edx,4),%edx
  80a9ee:	83 e8 01             	sub    $0x1,%eax
  80a9f1:	66 89 04 95 a8 ad b3 	mov    %ax,0xb3ada8(,%edx,4)
  80a9f8:	00 
	    return waited;
  80a9f9:	89 f8                	mov    %edi,%eax
  80a9fb:	e9 84 00 00 00       	jmp    80aa84 <sys_arch_sem_wait+0x10f>
 	} else if (tm_msec == SYS_ARCH_NOWAIT) {
  80aa00:	83 fe fe             	cmp    $0xfffffffe,%esi
  80aa03:	74 7a                	je     80aa7f <sys_arch_sem_wait+0x10a>
	    return SYS_ARCH_TIMEOUT;
	} else {
	    uint32_t a = sys_time_msec();
  80aa05:	e8 11 54 00 00       	call   80fe1b <sys_time_msec>
  80aa0a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	    uint32_t sleep_until = tm_msec ? a + (tm_msec - waited) : ~0;
  80aa0d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80aa12:	85 f6                	test   %esi,%esi
  80aa14:	74 07                	je     80aa1d <sys_arch_sem_wait+0xa8>
  80aa16:	89 f0                	mov    %esi,%eax
  80aa18:	29 f8                	sub    %edi,%eax
  80aa1a:	03 45 e4             	add    -0x1c(%ebp),%eax
	    sems[sem].waiters = 1;
  80aa1d:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  80aa20:	8d 1c 8d a0 ad b3 00 	lea    0xb3ada0(,%ecx,4),%ebx
  80aa27:	66 c7 43 0a 01 00    	movw   $0x1,0xa(%ebx)
	    uint32_t cur_v = sems[sem].v;
	    lwip_core_unlock();
	    thread_wait(&sems[sem].v, cur_v, sleep_until);
  80aa2d:	89 44 24 08          	mov    %eax,0x8(%esp)
  80aa31:	8b 43 08             	mov    0x8(%ebx),%eax
  80aa34:	89 44 24 04          	mov    %eax,0x4(%esp)
  80aa38:	8d 43 08             	lea    0x8(%ebx),%eax
  80aa3b:	89 04 24             	mov    %eax,(%esp)
  80aa3e:	e8 a6 06 00 00       	call   80b0e9 <thread_wait>
	    lwip_core_lock();
	    if (gen != sems[sem].gen) {
  80aa43:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80aa46:	39 43 04             	cmp    %eax,0x4(%ebx)
  80aa49:	74 13                	je     80aa5e <sys_arch_sem_wait+0xe9>
		cprintf("sys_arch_sem_wait: sem freed under waiter!\n");
  80aa4b:	c7 04 24 7c 32 81 00 	movl   $0x81327c,(%esp)
  80aa52:	e8 1c 47 00 00       	call   80f173 <cprintf>
		return SYS_ARCH_TIMEOUT;
  80aa57:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80aa5c:	eb 26                	jmp    80aa84 <sys_arch_sem_wait+0x10f>
	    }
	    uint32_t b = sys_time_msec();
  80aa5e:	e8 b8 53 00 00       	call   80fe1b <sys_time_msec>
	    waited += (b - a);
  80aa63:	2b 45 e4             	sub    -0x1c(%ebp),%eax
  80aa66:	01 c7                	add    %eax,%edi
    assert(!sems[sem].freed);
    u32_t waited = 0;

    int gen = sems[sem].gen;

    while (tm_msec == 0 || waited < tm_msec) {
  80aa68:	39 f7                	cmp    %esi,%edi
  80aa6a:	0f 82 68 ff ff ff    	jb     80a9d8 <sys_arch_sem_wait+0x63>
  80aa70:	85 f6                	test   %esi,%esi
  80aa72:	0f 84 60 ff ff ff    	je     80a9d8 <sys_arch_sem_wait+0x63>
	    uint32_t b = sys_time_msec();
	    waited += (b - a);
	}
    }

    return SYS_ARCH_TIMEOUT;
  80aa78:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80aa7d:	eb 05                	jmp    80aa84 <sys_arch_sem_wait+0x10f>
    while (tm_msec == 0 || waited < tm_msec) {
	if (sems[sem].counter > 0) {
	    sems[sem].counter--;
	    return waited;
 	} else if (tm_msec == SYS_ARCH_NOWAIT) {
	    return SYS_ARCH_TIMEOUT;
  80aa7f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
	    waited += (b - a);
	}
    }

    return SYS_ARCH_TIMEOUT;
}
  80aa84:	83 c4 2c             	add    $0x2c,%esp
  80aa87:	5b                   	pop    %ebx
  80aa88:	5e                   	pop    %esi
  80aa89:	5f                   	pop    %edi
  80aa8a:	5d                   	pop    %ebp
  80aa8b:	c3                   	ret    

0080aa8c <sys_mbox_trypost>:
    assert(sys_mbox_trypost(mbox, msg) == ERR_OK);
}

err_t 
sys_mbox_trypost(sys_mbox_t mbox, void *msg)
{
  80aa8c:	55                   	push   %ebp
  80aa8d:	89 e5                	mov    %esp,%ebp
  80aa8f:	56                   	push   %esi
  80aa90:	53                   	push   %ebx
  80aa91:	83 ec 10             	sub    $0x10,%esp
  80aa94:	8b 5d 08             	mov    0x8(%ebp),%ebx
    assert(!mboxes[mbox].freed);
  80aa97:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80aa9d:	83 b8 80 5f b3 00 00 	cmpl   $0x0,0xb35f80(%eax)
  80aaa4:	74 24                	je     80aaca <sys_mbox_trypost+0x3e>
  80aaa6:	c7 44 24 0c c2 33 81 	movl   $0x8133c2,0xc(%esp)
  80aaad:	00 
  80aaae:	c7 44 24 08 7f 33 81 	movl   $0x81337f,0x8(%esp)
  80aab5:	00 
  80aab6:	c7 44 24 04 72 00 00 	movl   $0x72,0x4(%esp)
  80aabd:	00 
  80aabe:	c7 04 24 94 33 81 00 	movl   $0x813394,(%esp)
  80aac5:	e8 b0 45 00 00       	call   80f07a <_panic>

    sys_arch_sem_wait(mboxes[mbox].free_msg, 0);
  80aaca:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80aad1:	00 
  80aad2:	69 f3 9c 00 00 00    	imul   $0x9c,%ebx,%esi
  80aad8:	8b 86 10 60 b3 00    	mov    0xb36010(%esi),%eax
  80aade:	89 04 24             	mov    %eax,(%esp)
  80aae1:	e8 8f fe ff ff       	call   80a975 <sys_arch_sem_wait>
    if (mboxes[mbox].nextq == mboxes[mbox].head)
  80aae6:	8b 86 88 5f b3 00    	mov    0xb35f88(%esi),%eax
  80aaec:	81 c6 80 5f b3 00    	add    $0xb35f80,%esi
  80aaf2:	3b 46 04             	cmp    0x4(%esi),%eax
  80aaf5:	74 53                	je     80ab4a <sys_mbox_trypost+0xbe>
	return ERR_MEM;

    int slot = mboxes[mbox].nextq;
    mboxes[mbox].nextq = (slot + 1) % MBOXSLOTS;
  80aaf7:	89 f2                	mov    %esi,%edx
  80aaf9:	8d 70 01             	lea    0x1(%eax),%esi
  80aafc:	89 f1                	mov    %esi,%ecx
  80aafe:	c1 f9 1f             	sar    $0x1f,%ecx
  80ab01:	c1 e9 1b             	shr    $0x1b,%ecx
  80ab04:	01 ce                	add    %ecx,%esi
  80ab06:	83 e6 1f             	and    $0x1f,%esi
  80ab09:	29 ce                	sub    %ecx,%esi
  80ab0b:	89 72 08             	mov    %esi,0x8(%edx)
    mboxes[mbox].msg[slot] = msg;
  80ab0e:	6b cb 27             	imul   $0x27,%ebx,%ecx
  80ab11:	01 c1                	add    %eax,%ecx
  80ab13:	8b 75 0c             	mov    0xc(%ebp),%esi
  80ab16:	89 34 8d 8c 5f b3 00 	mov    %esi,0xb35f8c(,%ecx,4)

    if (mboxes[mbox].head == -1)
  80ab1d:	83 7a 04 ff          	cmpl   $0xffffffff,0x4(%edx)
  80ab21:	75 0c                	jne    80ab2f <sys_mbox_trypost+0xa3>
	mboxes[mbox].head = slot;
  80ab23:	69 d3 9c 00 00 00    	imul   $0x9c,%ebx,%edx
  80ab29:	89 82 84 5f b3 00    	mov    %eax,0xb35f84(%edx)

    sys_sem_signal(mboxes[mbox].queued_msg);
  80ab2f:	69 db 9c 00 00 00    	imul   $0x9c,%ebx,%ebx
  80ab35:	8b 83 0c 60 b3 00    	mov    0xb3600c(%ebx),%eax
  80ab3b:	89 04 24             	mov    %eax,(%esp)
  80ab3e:	e8 bd fd ff ff       	call   80a900 <sys_sem_signal>

    return ERR_OK;
  80ab43:	b8 00 00 00 00       	mov    $0x0,%eax
  80ab48:	eb 05                	jmp    80ab4f <sys_mbox_trypost+0xc3>
{
    assert(!mboxes[mbox].freed);

    sys_arch_sem_wait(mboxes[mbox].free_msg, 0);
    if (mboxes[mbox].nextq == mboxes[mbox].head)
	return ERR_MEM;
  80ab4a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
	mboxes[mbox].head = slot;

    sys_sem_signal(mboxes[mbox].queued_msg);

    return ERR_OK;
}
  80ab4f:	83 c4 10             	add    $0x10,%esp
  80ab52:	5b                   	pop    %ebx
  80ab53:	5e                   	pop    %esi
  80ab54:	5d                   	pop    %ebp
  80ab55:	c3                   	ret    

0080ab56 <sys_mbox_post>:
    mboxes[mbox].freed = 1;
}

void
sys_mbox_post(sys_mbox_t mbox, void *msg)
{
  80ab56:	55                   	push   %ebp
  80ab57:	89 e5                	mov    %esp,%ebp
  80ab59:	83 ec 18             	sub    $0x18,%esp
    assert(sys_mbox_trypost(mbox, msg) == ERR_OK);
  80ab5c:	8b 45 0c             	mov    0xc(%ebp),%eax
  80ab5f:	89 44 24 04          	mov    %eax,0x4(%esp)
  80ab63:	8b 45 08             	mov    0x8(%ebp),%eax
  80ab66:	89 04 24             	mov    %eax,(%esp)
  80ab69:	e8 1e ff ff ff       	call   80aa8c <sys_mbox_trypost>
  80ab6e:	84 c0                	test   %al,%al
  80ab70:	74 24                	je     80ab96 <sys_mbox_post+0x40>
  80ab72:	c7 44 24 0c a8 32 81 	movl   $0x8132a8,0xc(%esp)
  80ab79:	00 
  80ab7a:	c7 44 24 08 7f 33 81 	movl   $0x81337f,0x8(%esp)
  80ab81:	00 
  80ab82:	c7 44 24 04 6c 00 00 	movl   $0x6c,0x4(%esp)
  80ab89:	00 
  80ab8a:	c7 04 24 94 33 81 00 	movl   $0x813394,(%esp)
  80ab91:	e8 e4 44 00 00       	call   80f07a <_panic>
}
  80ab96:	c9                   	leave  
  80ab97:	c3                   	ret    

0080ab98 <sys_arch_mbox_fetch>:
    return SYS_ARCH_TIMEOUT;
}

u32_t
sys_arch_mbox_fetch(sys_mbox_t mbox, void **msg, u32_t tm_msec)
{
  80ab98:	55                   	push   %ebp
  80ab99:	89 e5                	mov    %esp,%ebp
  80ab9b:	57                   	push   %edi
  80ab9c:	56                   	push   %esi
  80ab9d:	53                   	push   %ebx
  80ab9e:	83 ec 1c             	sub    $0x1c,%esp
  80aba1:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80aba4:	8b 7d 0c             	mov    0xc(%ebp),%edi
    assert(!mboxes[mbox].freed);
  80aba7:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80abad:	83 b8 80 5f b3 00 00 	cmpl   $0x0,0xb35f80(%eax)
  80abb4:	74 24                	je     80abda <sys_arch_mbox_fetch+0x42>
  80abb6:	c7 44 24 0c c2 33 81 	movl   $0x8133c2,0xc(%esp)
  80abbd:	00 
  80abbe:	c7 44 24 08 7f 33 81 	movl   $0x81337f,0x8(%esp)
  80abc5:	00 
  80abc6:	c7 44 24 04 ce 00 00 	movl   $0xce,0x4(%esp)
  80abcd:	00 
  80abce:	c7 04 24 94 33 81 00 	movl   $0x813394,(%esp)
  80abd5:	e8 a0 44 00 00       	call   80f07a <_panic>

    u32_t waited = sys_arch_sem_wait(mboxes[mbox].queued_msg, tm_msec);
  80abda:	8b 45 10             	mov    0x10(%ebp),%eax
  80abdd:	89 44 24 04          	mov    %eax,0x4(%esp)
  80abe1:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80abe7:	8b 80 0c 60 b3 00    	mov    0xb3600c(%eax),%eax
  80abed:	89 04 24             	mov    %eax,(%esp)
  80abf0:	e8 80 fd ff ff       	call   80a975 <sys_arch_sem_wait>
  80abf5:	89 c6                	mov    %eax,%esi
    if (waited == SYS_ARCH_TIMEOUT)
  80abf7:	83 f8 ff             	cmp    $0xffffffff,%eax
  80abfa:	0f 84 88 00 00 00    	je     80ac88 <sys_arch_mbox_fetch+0xf0>
	return waited;

    int slot = mboxes[mbox].head;
  80ac00:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80ac06:	8b 80 84 5f b3 00    	mov    0xb35f84(%eax),%eax
    if (slot == -1)
  80ac0c:	83 f8 ff             	cmp    $0xffffffff,%eax
  80ac0f:	75 1c                	jne    80ac2d <sys_arch_mbox_fetch+0x95>
	panic("lwip: sys_arch_mbox_fetch: no message");
  80ac11:	c7 44 24 08 d0 32 81 	movl   $0x8132d0,0x8(%esp)
  80ac18:	00 
  80ac19:	c7 44 24 04 d6 00 00 	movl   $0xd6,0x4(%esp)
  80ac20:	00 
  80ac21:	c7 04 24 94 33 81 00 	movl   $0x813394,(%esp)
  80ac28:	e8 4d 44 00 00       	call   80f07a <_panic>
    if (msg)
  80ac2d:	85 ff                	test   %edi,%edi
  80ac2f:	74 0e                	je     80ac3f <sys_arch_mbox_fetch+0xa7>
	*msg = mboxes[mbox].msg[slot];
  80ac31:	6b d3 27             	imul   $0x27,%ebx,%edx
  80ac34:	01 c2                	add    %eax,%edx
  80ac36:	8b 14 95 8c 5f b3 00 	mov    0xb35f8c(,%edx,4),%edx
  80ac3d:	89 17                	mov    %edx,(%edi)

    mboxes[mbox].head = (slot + 1) % MBOXSLOTS;
  80ac3f:	83 c0 01             	add    $0x1,%eax
  80ac42:	99                   	cltd   
  80ac43:	c1 ea 1b             	shr    $0x1b,%edx
  80ac46:	01 d0                	add    %edx,%eax
  80ac48:	83 e0 1f             	and    $0x1f,%eax
  80ac4b:	29 d0                	sub    %edx,%eax
  80ac4d:	69 d3 9c 00 00 00    	imul   $0x9c,%ebx,%edx
  80ac53:	89 82 84 5f b3 00    	mov    %eax,0xb35f84(%edx)
  80ac59:	81 c2 80 5f b3 00    	add    $0xb35f80,%edx
    if (mboxes[mbox].head == mboxes[mbox].nextq)
  80ac5f:	3b 42 08             	cmp    0x8(%edx),%eax
  80ac62:	75 10                	jne    80ac74 <sys_arch_mbox_fetch+0xdc>
	mboxes[mbox].head = -1;
  80ac64:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80ac6a:	c7 80 84 5f b3 00 ff 	movl   $0xffffffff,0xb35f84(%eax)
  80ac71:	ff ff ff 

    sys_sem_signal(mboxes[mbox].free_msg);
  80ac74:	69 db 9c 00 00 00    	imul   $0x9c,%ebx,%ebx
  80ac7a:	8b 83 10 60 b3 00    	mov    0xb36010(%ebx),%eax
  80ac80:	89 04 24             	mov    %eax,(%esp)
  80ac83:	e8 78 fc ff ff       	call   80a900 <sys_sem_signal>
    return waited;
}
  80ac88:	89 f0                	mov    %esi,%eax
  80ac8a:	83 c4 1c             	add    $0x1c,%esp
  80ac8d:	5b                   	pop    %ebx
  80ac8e:	5e                   	pop    %esi
  80ac8f:	5f                   	pop    %edi
  80ac90:	5d                   	pop    %ebp
  80ac91:	c3                   	ret    

0080ac92 <sys_arch_mbox_tryfetch>:

u32_t 
sys_arch_mbox_tryfetch(sys_mbox_t mbox, void **msg)
{
  80ac92:	55                   	push   %ebp
  80ac93:	89 e5                	mov    %esp,%ebp
  80ac95:	83 ec 18             	sub    $0x18,%esp
    return sys_arch_mbox_fetch(mbox, msg, SYS_ARCH_NOWAIT);
  80ac98:	c7 44 24 08 fe ff ff 	movl   $0xfffffffe,0x8(%esp)
  80ac9f:	ff 
  80aca0:	8b 45 0c             	mov    0xc(%ebp),%eax
  80aca3:	89 44 24 04          	mov    %eax,0x4(%esp)
  80aca7:	8b 45 08             	mov    0x8(%ebp),%eax
  80acaa:	89 04 24             	mov    %eax,(%esp)
  80acad:	e8 e6 fe ff ff       	call   80ab98 <sys_arch_mbox_fetch>
}
  80acb2:	c9                   	leave  
  80acb3:	c3                   	ret    

0080acb4 <sys_thread_new>:
}

sys_thread_t
sys_thread_new(char *name, void (* thread)(void *arg), void *arg, 
	       int stacksize, int prio)
{
  80acb4:	55                   	push   %ebp
  80acb5:	89 e5                	mov    %esp,%ebp
  80acb7:	83 ec 28             	sub    $0x28,%esp
    struct lwip_thread *lt = malloc(sizeof(*lt));
  80acba:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  80acc1:	e8 ac 64 00 00       	call   811172 <malloc>
    if (lt == 0)
  80acc6:	85 c0                	test   %eax,%eax
  80acc8:	75 1c                	jne    80ace6 <sys_thread_new+0x32>
	panic("sys_thread_new: cannot allocate thread struct");
  80acca:	c7 44 24 08 f8 32 81 	movl   $0x8132f8,0x8(%esp)
  80acd1:	00 
  80acd2:	c7 44 24 04 fd 00 00 	movl   $0xfd,0x4(%esp)
  80acd9:	00 
  80acda:	c7 04 24 94 33 81 00 	movl   $0x813394,(%esp)
  80ace1:	e8 94 43 00 00       	call   80f07a <_panic>

    if (stacksize > PGSIZE)
  80ace6:	81 7d 14 00 10 00 00 	cmpl   $0x1000,0x14(%ebp)
  80aced:	7e 23                	jle    80ad12 <sys_thread_new+0x5e>
	panic("large stack %d", stacksize);
  80acef:	8b 45 14             	mov    0x14(%ebp),%eax
  80acf2:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80acf6:	c7 44 24 08 f2 33 81 	movl   $0x8133f2,0x8(%esp)
  80acfd:	00 
  80acfe:	c7 44 24 04 00 01 00 	movl   $0x100,0x4(%esp)
  80ad05:	00 
  80ad06:	c7 04 24 94 33 81 00 	movl   $0x813394,(%esp)
  80ad0d:	e8 68 43 00 00       	call   80f07a <_panic>

    lt->func = thread;
  80ad12:	8b 55 0c             	mov    0xc(%ebp),%edx
  80ad15:	89 10                	mov    %edx,(%eax)
    lt->arg = arg;
  80ad17:	8b 55 10             	mov    0x10(%ebp),%edx
  80ad1a:	89 50 04             	mov    %edx,0x4(%eax)

    thread_id_t tid;
    int r = thread_create(&tid, name, lwip_thread_entry, (uint32_t)lt);
  80ad1d:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80ad21:	c7 44 24 08 10 a5 80 	movl   $0x80a510,0x8(%esp)
  80ad28:	00 
  80ad29:	8b 45 08             	mov    0x8(%ebp),%eax
  80ad2c:	89 44 24 04          	mov    %eax,0x4(%esp)
  80ad30:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80ad33:	89 04 24             	mov    %eax,(%esp)
  80ad36:	e8 e2 01 00 00       	call   80af1d <thread_create>

    if (r < 0)
  80ad3b:	85 c0                	test   %eax,%eax
  80ad3d:	79 28                	jns    80ad67 <sys_thread_new+0xb3>
	panic("lwip: sys_thread_new: cannot create: %s\n", e2s(r));
  80ad3f:	89 04 24             	mov    %eax,(%esp)
  80ad42:	e8 39 05 00 00       	call   80b280 <e2s>
  80ad47:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80ad4b:	c7 44 24 08 28 33 81 	movl   $0x813328,0x8(%esp)
  80ad52:	00 
  80ad53:	c7 44 24 04 09 01 00 	movl   $0x109,0x4(%esp)
  80ad5a:	00 
  80ad5b:	c7 04 24 94 33 81 00 	movl   $0x813394,(%esp)
  80ad62:	e8 13 43 00 00       	call   80f07a <_panic>

    return tid;
}
  80ad67:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80ad6a:	c9                   	leave  
  80ad6b:	c3                   	ret    

0080ad6c <sys_arch_timeouts>:
    lwip_core_unlock();
}

struct sys_timeouts *
sys_arch_timeouts(void)
{
  80ad6c:	55                   	push   %ebp
  80ad6d:	89 e5                	mov    %esp,%ebp
  80ad6f:	57                   	push   %edi
  80ad70:	56                   	push   %esi
  80ad71:	53                   	push   %ebx
  80ad72:	83 ec 1c             	sub    $0x1c,%esp
    thread_id_t tid = thread_id();
  80ad75:	e8 29 01 00 00       	call   80aea3 <thread_id>
  80ad7a:	89 c6                	mov    %eax,%esi

    struct sys_thread *t;
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  80ad7c:	bf 01 ff 00 ff       	mov    $0xff00ff01,%edi
  80ad81:	f7 e7                	mul    %edi
  80ad83:	c1 ea 08             	shr    $0x8,%edx
  80ad86:	89 d7                	mov    %edx,%edi
  80ad88:	89 d0                	mov    %edx,%eax
  80ad8a:	c1 e0 08             	shl    $0x8,%eax
  80ad8d:	01 c7                	add    %eax,%edi
  80ad8f:	89 f0                	mov    %esi,%eax
  80ad91:	29 f8                	sub    %edi,%eax
  80ad93:	89 c7                	mov    %eax,%edi
  80ad95:	8b 1c 85 60 5b b3 00 	mov    0xb35b60(,%eax,4),%ebx
  80ad9c:	eb 0b                	jmp    80ada9 <sys_arch_timeouts+0x3d>
	if (t->tid == tid)
  80ad9e:	39 33                	cmp    %esi,(%ebx)
  80ada0:	0f 84 b6 00 00 00    	je     80ae5c <sys_arch_timeouts+0xf0>
sys_arch_timeouts(void)
{
    thread_id_t tid = thread_id();

    struct sys_thread *t;
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  80ada6:	8b 5b 08             	mov    0x8(%ebx),%ebx
  80ada9:	85 db                	test   %ebx,%ebx
  80adab:	75 f1                	jne    80ad9e <sys_arch_timeouts+0x32>
	if (t->tid == tid)
	    goto out;

    t = malloc(sizeof(*t));
  80adad:	c7 04 24 10 00 00 00 	movl   $0x10,(%esp)
  80adb4:	e8 b9 63 00 00       	call   811172 <malloc>
  80adb9:	89 c3                	mov    %eax,%ebx
    if (t == 0)
  80adbb:	85 c0                	test   %eax,%eax
  80adbd:	75 1c                	jne    80addb <sys_arch_timeouts+0x6f>
	panic("sys_arch_timeouts: cannot malloc");
  80adbf:	c7 44 24 08 54 33 81 	movl   $0x813354,0x8(%esp)
  80adc6:	00 
  80adc7:	c7 44 24 04 2c 01 00 	movl   $0x12c,0x4(%esp)
  80adce:	00 
  80adcf:	c7 04 24 94 33 81 00 	movl   $0x813394,(%esp)
  80add6:	e8 9f 42 00 00       	call   80f07a <_panic>

    int r = thread_onhalt(timeout_cleanup);
  80addb:	c7 04 24 30 a5 80 00 	movl   $0x80a530,(%esp)
  80ade2:	e8 0a 01 00 00       	call   80aef1 <thread_onhalt>
    if (r < 0)
  80ade7:	85 c0                	test   %eax,%eax
  80ade9:	79 28                	jns    80ae13 <sys_arch_timeouts+0xa7>
	panic("thread_onhalt failed: %s", e2s(r));
  80adeb:	89 04 24             	mov    %eax,(%esp)
  80adee:	e8 8d 04 00 00       	call   80b280 <e2s>
  80adf3:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80adf7:	c7 44 24 08 01 34 81 	movl   $0x813401,0x8(%esp)
  80adfe:	00 
  80adff:	c7 44 24 04 30 01 00 	movl   $0x130,0x4(%esp)
  80ae06:	00 
  80ae07:	c7 04 24 94 33 81 00 	movl   $0x813394,(%esp)
  80ae0e:	e8 67 42 00 00       	call   80f07a <_panic>

    t->tid = tid;
  80ae13:	89 33                	mov    %esi,(%ebx)
    memset(&t->tmo, 0, sizeof(t->tmo));
  80ae15:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  80ae1c:	00 
  80ae1d:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80ae24:	00 
  80ae25:	8d 43 04             	lea    0x4(%ebx),%eax
  80ae28:	89 04 24             	mov    %eax,(%esp)
  80ae2b:	e8 b7 4a 00 00       	call   80f8e7 <memset>
    LIST_INSERT_HEAD(&threads[tid % thread_hash_size], t, link);
  80ae30:	8b 04 bd 60 5b b3 00 	mov    0xb35b60(,%edi,4),%eax
  80ae37:	89 43 08             	mov    %eax,0x8(%ebx)
  80ae3a:	85 c0                	test   %eax,%eax
  80ae3c:	74 0d                	je     80ae4b <sys_arch_timeouts+0xdf>
  80ae3e:	8b 04 bd 60 5b b3 00 	mov    0xb35b60(,%edi,4),%eax
  80ae45:	8d 53 08             	lea    0x8(%ebx),%edx
  80ae48:	89 50 0c             	mov    %edx,0xc(%eax)
  80ae4b:	89 1c bd 60 5b b3 00 	mov    %ebx,0xb35b60(,%edi,4)
  80ae52:	8d 04 bd 60 5b b3 00 	lea    0xb35b60(,%edi,4),%eax
  80ae59:	89 43 0c             	mov    %eax,0xc(%ebx)

out:
    return &t->tmo;
  80ae5c:	8d 43 04             	lea    0x4(%ebx),%eax
}
  80ae5f:	83 c4 1c             	add    $0x1c,%esp
  80ae62:	5b                   	pop    %ebx
  80ae63:	5e                   	pop    %esi
  80ae64:	5f                   	pop    %edi
  80ae65:	5d                   	pop    %ebp
  80ae66:	c3                   	ret    

0080ae67 <lwip_core_lock>:

void
lwip_core_lock(void)
{
  80ae67:	55                   	push   %ebp
  80ae68:	89 e5                	mov    %esp,%ebp
}
  80ae6a:	5d                   	pop    %ebp
  80ae6b:	c3                   	ret    

0080ae6c <lwip_core_unlock>:

void
lwip_core_unlock(void)
{
  80ae6c:	55                   	push   %ebp
  80ae6d:	89 e5                	mov    %esp,%ebp
}
  80ae6f:	5d                   	pop    %ebp
  80ae70:	c3                   	ret    
  80ae71:	66 90                	xchg   %ax,%ax
  80ae73:	66 90                	xchg   %ax,%ax
  80ae75:	66 90                	xchg   %ax,%ax
  80ae77:	66 90                	xchg   %ax,%ax
  80ae79:	66 90                	xchg   %ax,%ax
  80ae7b:	66 90                	xchg   %ax,%ax
  80ae7d:	66 90                	xchg   %ax,%ax
  80ae7f:	90                   	nop

0080ae80 <thread_init>:

static struct thread_queue thread_queue;
static struct thread_queue kill_queue;

void
thread_init(void) {
  80ae80:	55                   	push   %ebp
  80ae81:	89 e5                	mov    %esp,%ebp
};

static inline void 
threadq_init(struct thread_queue *tq)
{
    tq->tq_first = 0;
  80ae83:	c7 05 a8 c1 b3 00 00 	movl   $0x0,0xb3c1a8
  80ae8a:	00 00 00 
    tq->tq_last = 0;
  80ae8d:	c7 05 ac c1 b3 00 00 	movl   $0x0,0xb3c1ac
  80ae94:	00 00 00 
    threadq_init(&thread_queue);
    max_tid = 0;
  80ae97:	c7 05 b4 c1 b3 00 00 	movl   $0x0,0xb3c1b4
  80ae9e:	00 00 00 
}
  80aea1:	5d                   	pop    %ebp
  80aea2:	c3                   	ret    

0080aea3 <thread_id>:

uint32_t
thread_id(void) {
  80aea3:	55                   	push   %ebp
  80aea4:	89 e5                	mov    %esp,%ebp
    return cur_tc->tc_tid;
  80aea6:	a1 b0 c1 b3 00       	mov    0xb3c1b0,%eax
  80aeab:	8b 00                	mov    (%eax),%eax
}
  80aead:	5d                   	pop    %ebp
  80aeae:	c3                   	ret    

0080aeaf <thread_wakeup>:

void
thread_wakeup(volatile uint32_t *addr) {
  80aeaf:	55                   	push   %ebp
  80aeb0:	89 e5                	mov    %esp,%ebp
  80aeb2:	8b 55 08             	mov    0x8(%ebp),%edx
    struct thread_context *tc = thread_queue.tq_first;
  80aeb5:	a1 a8 c1 b3 00       	mov    0xb3c1a8,%eax
    while (tc) {
  80aeba:	eb 0c                	jmp    80aec8 <thread_wakeup+0x19>
	if (tc->tc_wait_addr == addr)
  80aebc:	39 50 48             	cmp    %edx,0x48(%eax)
  80aebf:	75 04                	jne    80aec5 <thread_wakeup+0x16>
	    tc->tc_wakeup = 1;
  80aec1:	c6 40 4c 01          	movb   $0x1,0x4c(%eax)
	tc = tc->tc_queue_link;
  80aec5:	8b 40 64             	mov    0x64(%eax),%eax
}

void
thread_wakeup(volatile uint32_t *addr) {
    struct thread_context *tc = thread_queue.tq_first;
    while (tc) {
  80aec8:	85 c0                	test   %eax,%eax
  80aeca:	75 f0                	jne    80aebc <thread_wakeup+0xd>
	if (tc->tc_wait_addr == addr)
	    tc->tc_wakeup = 1;
	tc = tc->tc_queue_link;
    }
}
  80aecc:	5d                   	pop    %ebp
  80aecd:	c3                   	ret    

0080aece <thread_wakeups_pending>:
    cur_tc->tc_wakeup = 0;
}

int
thread_wakeups_pending(void)
{
  80aece:	55                   	push   %ebp
  80aecf:	89 e5                	mov    %esp,%ebp
    struct thread_context *tc = thread_queue.tq_first;
  80aed1:	8b 15 a8 c1 b3 00    	mov    0xb3c1a8,%edx
    int n = 0;
  80aed7:	b8 00 00 00 00       	mov    $0x0,%eax
    while (tc) {
  80aedc:	eb 0d                	jmp    80aeeb <thread_wakeups_pending+0x1d>
	if (tc->tc_wakeup)
  80aede:	0f b6 4a 4c          	movzbl 0x4c(%edx),%ecx
	    ++n;
  80aee2:	80 f9 01             	cmp    $0x1,%cl
  80aee5:	83 d8 ff             	sbb    $0xffffffff,%eax
	tc = tc->tc_queue_link;
  80aee8:	8b 52 64             	mov    0x64(%edx),%edx
int
thread_wakeups_pending(void)
{
    struct thread_context *tc = thread_queue.tq_first;
    int n = 0;
    while (tc) {
  80aeeb:	85 d2                	test   %edx,%edx
  80aeed:	75 ef                	jne    80aede <thread_wakeups_pending+0x10>
	if (tc->tc_wakeup)
	    ++n;
	tc = tc->tc_queue_link;
    }
    return n;
}
  80aeef:	5d                   	pop    %ebp
  80aef0:	c3                   	ret    

0080aef1 <thread_onhalt>:

int
thread_onhalt(void (*fun)(thread_id_t)) {
    if (cur_tc->tc_nonhalt >= THREAD_NUM_ONHALT)
  80aef1:	a1 b0 c1 b3 00       	mov    0xb3c1b0,%eax
  80aef6:	8b 50 60             	mov    0x60(%eax),%edx
  80aef9:	83 fa 03             	cmp    $0x3,%edx
  80aefc:	7f 17                	jg     80af15 <thread_onhalt+0x24>
    }
    return n;
}

int
thread_onhalt(void (*fun)(thread_id_t)) {
  80aefe:	55                   	push   %ebp
  80aeff:	89 e5                	mov    %esp,%ebp
    if (cur_tc->tc_nonhalt >= THREAD_NUM_ONHALT)
	return -E_NO_MEM;

    cur_tc->tc_onhalt[cur_tc->tc_nonhalt++] = fun;
  80af01:	8d 4a 01             	lea    0x1(%edx),%ecx
  80af04:	89 48 60             	mov    %ecx,0x60(%eax)
  80af07:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80af0a:	89 4c 90 50          	mov    %ecx,0x50(%eax,%edx,4)
    return 0;
  80af0e:	b8 00 00 00 00       	mov    $0x0,%eax
  80af13:	eb 06                	jmp    80af1b <thread_onhalt+0x2a>
}

int
thread_onhalt(void (*fun)(thread_id_t)) {
    if (cur_tc->tc_nonhalt >= THREAD_NUM_ONHALT)
	return -E_NO_MEM;
  80af15:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  80af1a:	c3                   	ret    

    cur_tc->tc_onhalt[cur_tc->tc_nonhalt++] = fun;
    return 0;
}
  80af1b:	5d                   	pop    %ebp
  80af1c:	c3                   	ret    

0080af1d <thread_create>:
    thread_halt();
}

int
thread_create(thread_id_t *tid, const char *name, 
		void (*entry)(uint32_t), uint32_t arg) {
  80af1d:	55                   	push   %ebp
  80af1e:	89 e5                	mov    %esp,%ebp
  80af20:	57                   	push   %edi
  80af21:	56                   	push   %esi
  80af22:	53                   	push   %ebx
  80af23:	83 ec 1c             	sub    $0x1c,%esp
  80af26:	8b 75 08             	mov    0x8(%ebp),%esi
    struct thread_context *tc = malloc(sizeof(struct thread_context));
  80af29:	c7 04 24 68 00 00 00 	movl   $0x68,(%esp)
  80af30:	e8 3d 62 00 00       	call   811172 <malloc>
  80af35:	89 c3                	mov    %eax,%ebx
    if (!tc)
  80af37:	85 c0                	test   %eax,%eax
  80af39:	0f 84 16 01 00 00    	je     80b055 <thread_create+0x138>
	return -E_NO_MEM;

    memset(tc, 0, sizeof(struct thread_context));
  80af3f:	c7 44 24 08 68 00 00 	movl   $0x68,0x8(%esp)
  80af46:	00 
  80af47:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80af4e:	00 
  80af4f:	89 04 24             	mov    %eax,(%esp)
  80af52:	e8 90 49 00 00       	call   80f8e7 <memset>
}

static void
thread_set_name(struct thread_context *tc, const char *name)
{
    strncpy(tc->tc_name, name, name_size - 1);
  80af57:	c7 44 24 08 1f 00 00 	movl   $0x1f,0x8(%esp)
  80af5e:	00 
  80af5f:	8b 45 0c             	mov    0xc(%ebp),%eax
  80af62:	89 44 24 04          	mov    %eax,0x4(%esp)
  80af66:	8d 43 08             	lea    0x8(%ebx),%eax
  80af69:	89 04 24             	mov    %eax,(%esp)
  80af6c:	e8 71 48 00 00       	call   80f7e2 <strncpy>
    tc->tc_name[name_size - 1] = 0;
  80af71:	c6 43 27 00          	movb   $0x0,0x27(%ebx)
    return 0;
}

static thread_id_t
alloc_tid(void) {
    int tid = max_tid++;
  80af75:	8b 15 b4 c1 b3 00    	mov    0xb3c1b4,%edx
  80af7b:	8d 42 01             	lea    0x1(%edx),%eax
  80af7e:	a3 b4 c1 b3 00       	mov    %eax,0xb3c1b4
    if (max_tid == (uint32_t)~0)
  80af83:	83 f8 ff             	cmp    $0xffffffff,%eax
  80af86:	75 1c                	jne    80afa4 <thread_create+0x87>
	panic("alloc_tid: no more thread ids");
  80af88:	c7 44 24 08 1a 34 81 	movl   $0x81341a,0x8(%esp)
  80af8f:	00 
  80af90:	c7 44 24 04 54 00 00 	movl   $0x54,0x4(%esp)
  80af97:	00 
  80af98:	c7 04 24 38 34 81 00 	movl   $0x813438,(%esp)
  80af9f:	e8 d6 40 00 00       	call   80f07a <_panic>
	return -E_NO_MEM;

    memset(tc, 0, sizeof(struct thread_context));
    
    thread_set_name(tc, name);
    tc->tc_tid = alloc_tid();
  80afa4:	89 13                	mov    %edx,(%ebx)

    tc->tc_stack_bottom = malloc(stack_size);
  80afa6:	c7 04 24 00 10 00 00 	movl   $0x1000,(%esp)
  80afad:	e8 c0 61 00 00       	call   811172 <malloc>
  80afb2:	89 43 04             	mov    %eax,0x4(%ebx)
    if (!tc->tc_stack_bottom) {
  80afb5:	85 c0                	test   %eax,%eax
  80afb7:	75 12                	jne    80afcb <thread_create+0xae>
	free(tc);
  80afb9:	89 1c 24             	mov    %ebx,(%esp)
  80afbc:	e8 df 60 00 00       	call   8110a0 <free>
	return -E_NO_MEM;
  80afc1:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  80afc6:	e9 96 00 00 00       	jmp    80b061 <thread_create+0x144>
    }

    void *stacktop = tc->tc_stack_bottom + stack_size;
    // Terminate stack unwinding
    stacktop = stacktop - 4;
  80afcb:	8d b8 fc 0f 00 00    	lea    0xffc(%eax),%edi
    memset(stacktop, 0, 4);
  80afd1:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  80afd8:	00 
  80afd9:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80afe0:	00 
  80afe1:	89 3c 24             	mov    %edi,(%esp)
  80afe4:	e8 fe 48 00 00       	call   80f8e7 <memset>
    
    memset(&tc->tc_jb, 0, sizeof(tc->tc_jb));
  80afe9:	c7 44 24 08 18 00 00 	movl   $0x18,0x8(%esp)
  80aff0:	00 
  80aff1:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80aff8:	00 
  80aff9:	8d 43 30             	lea    0x30(%ebx),%eax
  80affc:	89 04 24             	mov    %eax,(%esp)
  80afff:	e8 e3 48 00 00       	call   80f8e7 <memset>
    tc->tc_jb.jb_esp = (uint32_t)stacktop;
  80b004:	89 7b 34             	mov    %edi,0x34(%ebx)
    tc->tc_jb.jb_eip = (uint32_t)&thread_entry;
  80b007:	c7 43 30 e7 b1 80 00 	movl   $0x80b1e7,0x30(%ebx)
    tc->tc_entry = entry;
  80b00e:	8b 45 10             	mov    0x10(%ebp),%eax
  80b011:	89 43 28             	mov    %eax,0x28(%ebx)
    tc->tc_arg = arg;
  80b014:	8b 45 14             	mov    0x14(%ebp),%eax
  80b017:	89 43 2c             	mov    %eax,0x2c(%ebx)
}

static inline void
threadq_push(struct thread_queue *tq, struct thread_context *tc)
{
    tc->tc_queue_link = 0;
  80b01a:	c7 43 64 00 00 00 00 	movl   $0x0,0x64(%ebx)
    if (!tq->tq_first) {
  80b021:	83 3d a8 c1 b3 00 00 	cmpl   $0x0,0xb3c1a8
  80b028:	75 0e                	jne    80b038 <thread_create+0x11b>
	tq->tq_first = tc;
  80b02a:	89 1d a8 c1 b3 00    	mov    %ebx,0xb3c1a8
	tq->tq_last = tc;
  80b030:	89 1d ac c1 b3 00    	mov    %ebx,0xb3c1ac
  80b036:	eb 0e                	jmp    80b046 <thread_create+0x129>
    } else {
	tq->tq_last->tc_queue_link = tc;
  80b038:	a1 ac c1 b3 00       	mov    0xb3c1ac,%eax
  80b03d:	89 58 64             	mov    %ebx,0x64(%eax)
	tq->tq_last = tc;
  80b040:	89 1d ac c1 b3 00    	mov    %ebx,0xb3c1ac

    threadq_push(&thread_queue, tc);

    if (tid)
  80b046:	85 f6                	test   %esi,%esi
  80b048:	74 12                	je     80b05c <thread_create+0x13f>
	*tid = tc->tc_tid;
  80b04a:	8b 03                	mov    (%ebx),%eax
  80b04c:	89 06                	mov    %eax,(%esi)
    return 0;
  80b04e:	b8 00 00 00 00       	mov    $0x0,%eax
  80b053:	eb 0c                	jmp    80b061 <thread_create+0x144>
int
thread_create(thread_id_t *tid, const char *name, 
		void (*entry)(uint32_t), uint32_t arg) {
    struct thread_context *tc = malloc(sizeof(struct thread_context));
    if (!tc)
	return -E_NO_MEM;
  80b055:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  80b05a:	eb 05                	jmp    80b061 <thread_create+0x144>

    threadq_push(&thread_queue, tc);

    if (tid)
	*tid = tc->tc_tid;
    return 0;
  80b05c:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80b061:	83 c4 1c             	add    $0x1c,%esp
  80b064:	5b                   	pop    %ebx
  80b065:	5e                   	pop    %esi
  80b066:	5f                   	pop    %edi
  80b067:	5d                   	pop    %ebp
  80b068:	c3                   	ret    

0080b069 <thread_yield>:
    // when yield has no thread to run, it will return here!
    exit();
}

void
thread_yield(void) {
  80b069:	55                   	push   %ebp
  80b06a:	89 e5                	mov    %esp,%ebp
  80b06c:	53                   	push   %ebx
  80b06d:	83 ec 14             	sub    $0x14,%esp
}

static inline struct thread_context *
threadq_pop(struct thread_queue *tq)
{
    if (!tq->tq_first)
  80b070:	8b 1d a8 c1 b3 00    	mov    0xb3c1a8,%ebx
  80b076:	85 db                	test   %ebx,%ebx
  80b078:	74 69                	je     80b0e3 <thread_yield+0x7a>
	return 0;

    struct thread_context *tc = tq->tq_first;
    tq->tq_first = tc->tc_queue_link;
  80b07a:	8b 43 64             	mov    0x64(%ebx),%eax
  80b07d:	a3 a8 c1 b3 00       	mov    %eax,0xb3c1a8
    tc->tc_queue_link = 0;
  80b082:	c7 43 64 00 00 00 00 	movl   $0x0,0x64(%ebx)
    struct thread_context *next_tc = threadq_pop(&thread_queue);

    if (!next_tc)
	return;

    if (cur_tc) {
  80b089:	a1 b0 c1 b3 00       	mov    0xb3c1b0,%eax
  80b08e:	85 c0                	test   %eax,%eax
  80b090:	74 3e                	je     80b0d0 <thread_yield+0x67>
	if (jos_setjmp(&cur_tc->tc_jb) != 0)
  80b092:	83 c0 30             	add    $0x30,%eax
  80b095:	89 04 24             	mov    %eax,(%esp)
  80b098:	e8 73 01 00 00       	call   80b210 <jos_setjmp>
  80b09d:	85 c0                	test   %eax,%eax
  80b09f:	75 42                	jne    80b0e3 <thread_yield+0x7a>
	    return;
	threadq_push(&thread_queue, cur_tc);
  80b0a1:	a1 b0 c1 b3 00       	mov    0xb3c1b0,%eax
}

static inline void
threadq_push(struct thread_queue *tq, struct thread_context *tc)
{
    tc->tc_queue_link = 0;
  80b0a6:	c7 40 64 00 00 00 00 	movl   $0x0,0x64(%eax)
    if (!tq->tq_first) {
  80b0ad:	83 3d a8 c1 b3 00 00 	cmpl   $0x0,0xb3c1a8
  80b0b4:	75 0c                	jne    80b0c2 <thread_yield+0x59>
	tq->tq_first = tc;
  80b0b6:	a3 a8 c1 b3 00       	mov    %eax,0xb3c1a8
	tq->tq_last = tc;
  80b0bb:	a3 ac c1 b3 00       	mov    %eax,0xb3c1ac
  80b0c0:	eb 0e                	jmp    80b0d0 <thread_yield+0x67>
    } else {
	tq->tq_last->tc_queue_link = tc;
  80b0c2:	8b 15 ac c1 b3 00    	mov    0xb3c1ac,%edx
  80b0c8:	89 42 64             	mov    %eax,0x64(%edx)
	tq->tq_last = tc;
  80b0cb:	a3 ac c1 b3 00       	mov    %eax,0xb3c1ac
    }

    cur_tc = next_tc;
  80b0d0:	89 1d b0 c1 b3 00    	mov    %ebx,0xb3c1b0
    jos_longjmp(&cur_tc->tc_jb, 1);
  80b0d6:	8d 43 30             	lea    0x30(%ebx),%eax
  80b0d9:	ba 01 00 00 00       	mov    $0x1,%edx
  80b0de:	e8 5d 01 00 00       	call   80b240 <jos_longjmp>
}
  80b0e3:	83 c4 14             	add    $0x14,%esp
  80b0e6:	5b                   	pop    %ebx
  80b0e7:	5d                   	pop    %ebp
  80b0e8:	c3                   	ret    

0080b0e9 <thread_wait>:
	tc = tc->tc_queue_link;
    }
}

void
thread_wait(volatile uint32_t *addr, uint32_t val, uint32_t msec) {
  80b0e9:	55                   	push   %ebp
  80b0ea:	89 e5                	mov    %esp,%ebp
  80b0ec:	57                   	push   %edi
  80b0ed:	56                   	push   %esi
  80b0ee:	53                   	push   %ebx
  80b0ef:	83 ec 0c             	sub    $0xc,%esp
  80b0f2:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80b0f5:	8b 7d 10             	mov    0x10(%ebp),%edi
    uint32_t s = sys_time_msec();
  80b0f8:	e8 1e 4d 00 00       	call   80fe1b <sys_time_msec>
  80b0fd:	89 c6                	mov    %eax,%esi
    uint32_t p = s;

    cur_tc->tc_wait_addr = addr;
  80b0ff:	a1 b0 c1 b3 00       	mov    0xb3c1b0,%eax
  80b104:	89 58 48             	mov    %ebx,0x48(%eax)
    cur_tc->tc_wakeup = 0;
  80b107:	c6 40 4c 00          	movb   $0x0,0x4c(%eax)
}

void
thread_wait(volatile uint32_t *addr, uint32_t val, uint32_t msec) {
    uint32_t s = sys_time_msec();
    uint32_t p = s;
  80b10b:	89 f0                	mov    %esi,%eax

    cur_tc->tc_wait_addr = addr;
    cur_tc->tc_wakeup = 0;

    while (p < msec) {
  80b10d:	eb 26                	jmp    80b135 <thread_wait+0x4c>
	if (p < s)
  80b10f:	39 f0                	cmp    %esi,%eax
  80b111:	72 26                	jb     80b139 <thread_wait+0x50>
	    break;
	if (addr && *addr != val)
  80b113:	85 db                	test   %ebx,%ebx
  80b115:	74 07                	je     80b11e <thread_wait+0x35>
  80b117:	8b 03                	mov    (%ebx),%eax
  80b119:	3b 45 0c             	cmp    0xc(%ebp),%eax
  80b11c:	75 1b                	jne    80b139 <thread_wait+0x50>
	    break;
	if (cur_tc->tc_wakeup)
  80b11e:	a1 b0 c1 b3 00       	mov    0xb3c1b0,%eax
  80b123:	0f b6 40 4c          	movzbl 0x4c(%eax),%eax
  80b127:	84 c0                	test   %al,%al
  80b129:	75 0e                	jne    80b139 <thread_wait+0x50>
	    break;

	thread_yield();
  80b12b:	e8 39 ff ff ff       	call   80b069 <thread_yield>
	p = sys_time_msec();
  80b130:	e8 e6 4c 00 00       	call   80fe1b <sys_time_msec>
    uint32_t p = s;

    cur_tc->tc_wait_addr = addr;
    cur_tc->tc_wakeup = 0;

    while (p < msec) {
  80b135:	39 f8                	cmp    %edi,%eax
  80b137:	72 d6                	jb     80b10f <thread_wait+0x26>

	thread_yield();
	p = sys_time_msec();
    }

    cur_tc->tc_wait_addr = 0;
  80b139:	a1 b0 c1 b3 00       	mov    0xb3c1b0,%eax
  80b13e:	c7 40 48 00 00 00 00 	movl   $0x0,0x48(%eax)
    cur_tc->tc_wakeup = 0;
  80b145:	c6 40 4c 00          	movb   $0x0,0x4c(%eax)
}
  80b149:	83 c4 0c             	add    $0xc,%esp
  80b14c:	5b                   	pop    %ebx
  80b14d:	5e                   	pop    %esi
  80b14e:	5f                   	pop    %edi
  80b14f:	5d                   	pop    %ebp
  80b150:	c3                   	ret    

0080b151 <thread_halt>:
    free(tc->tc_stack_bottom);
    free(tc);
}

void
thread_halt() {
  80b151:	55                   	push   %ebp
  80b152:	89 e5                	mov    %esp,%ebp
  80b154:	56                   	push   %esi
  80b155:	53                   	push   %ebx
  80b156:	83 ec 10             	sub    $0x10,%esp
}

static inline struct thread_context *
threadq_pop(struct thread_queue *tq)
{
    if (!tq->tq_first)
  80b159:	8b 1d a0 c1 b3 00    	mov    0xb3c1a0,%ebx
  80b15f:	85 db                	test   %ebx,%ebx
  80b161:	74 3a                	je     80b19d <thread_halt+0x4c>
	return 0;

    struct thread_context *tc = tq->tq_first;
    tq->tq_first = tc->tc_queue_link;
  80b163:	8b 43 64             	mov    0x64(%ebx),%eax
  80b166:	a3 a0 c1 b3 00       	mov    %eax,0xb3c1a0
    tc->tc_queue_link = 0;
  80b16b:	c7 43 64 00 00 00 00 	movl   $0x0,0x64(%ebx)
  80b172:	be 00 00 00 00       	mov    $0x0,%esi
  80b177:	eb 0c                	jmp    80b185 <thread_halt+0x34>
thread_clean(struct thread_context *tc) {
    if (!tc) return;

    int i;
    for (i = 0; i < tc->tc_nonhalt; i++)
	tc->tc_onhalt[i](tc->tc_tid);
  80b179:	8b 03                	mov    (%ebx),%eax
  80b17b:	89 04 24             	mov    %eax,(%esp)
  80b17e:	ff 54 b3 50          	call   *0x50(%ebx,%esi,4)
static void
thread_clean(struct thread_context *tc) {
    if (!tc) return;

    int i;
    for (i = 0; i < tc->tc_nonhalt; i++)
  80b182:	83 c6 01             	add    $0x1,%esi
  80b185:	3b 73 60             	cmp    0x60(%ebx),%esi
  80b188:	7c ef                	jl     80b179 <thread_halt+0x28>
	tc->tc_onhalt[i](tc->tc_tid);
    free(tc->tc_stack_bottom);
  80b18a:	8b 43 04             	mov    0x4(%ebx),%eax
  80b18d:	89 04 24             	mov    %eax,(%esp)
  80b190:	e8 0b 5f 00 00       	call   8110a0 <free>
    free(tc);
  80b195:	89 1c 24             	mov    %ebx,(%esp)
  80b198:	e8 03 5f 00 00       	call   8110a0 <free>
thread_halt() {
    // right now the kill_queue will never be more than one
    // clean up a thread if one is on the queue
    thread_clean(threadq_pop(&kill_queue));

    threadq_push(&kill_queue, cur_tc);
  80b19d:	a1 b0 c1 b3 00       	mov    0xb3c1b0,%eax
}

static inline void
threadq_push(struct thread_queue *tq, struct thread_context *tc)
{
    tc->tc_queue_link = 0;
  80b1a2:	c7 40 64 00 00 00 00 	movl   $0x0,0x64(%eax)
    if (!tq->tq_first) {
  80b1a9:	83 3d a0 c1 b3 00 00 	cmpl   $0x0,0xb3c1a0
  80b1b0:	75 0c                	jne    80b1be <thread_halt+0x6d>
	tq->tq_first = tc;
  80b1b2:	a3 a0 c1 b3 00       	mov    %eax,0xb3c1a0
	tq->tq_last = tc;
  80b1b7:	a3 a4 c1 b3 00       	mov    %eax,0xb3c1a4
  80b1bc:	eb 0e                	jmp    80b1cc <thread_halt+0x7b>
    } else {
	tq->tq_last->tc_queue_link = tc;
  80b1be:	8b 15 a4 c1 b3 00    	mov    0xb3c1a4,%edx
  80b1c4:	89 42 64             	mov    %eax,0x64(%edx)
	tq->tq_last = tc;
  80b1c7:	a3 a4 c1 b3 00       	mov    %eax,0xb3c1a4
    cur_tc = NULL;
  80b1cc:	c7 05 b0 c1 b3 00 00 	movl   $0x0,0xb3c1b0
  80b1d3:	00 00 00 
    thread_yield();
  80b1d6:	e8 8e fe ff ff       	call   80b069 <thread_yield>
    // WHAT IF THERE ARE NO MORE THREADS? HOW DO WE STOP?
    // when yield has no thread to run, it will return here!
    exit();
  80b1db:	e8 81 3e 00 00       	call   80f061 <exit>
}
  80b1e0:	83 c4 10             	add    $0x10,%esp
  80b1e3:	5b                   	pop    %ebx
  80b1e4:	5e                   	pop    %esi
  80b1e5:	5d                   	pop    %ebp
  80b1e6:	c3                   	ret    

0080b1e7 <thread_entry>:
    strncpy(tc->tc_name, name, name_size - 1);
    tc->tc_name[name_size - 1] = 0;
}

static void
thread_entry(void) {
  80b1e7:	55                   	push   %ebp
  80b1e8:	89 e5                	mov    %esp,%ebp
  80b1ea:	83 ec 18             	sub    $0x18,%esp
    cur_tc->tc_entry(cur_tc->tc_arg);
  80b1ed:	a1 b0 c1 b3 00       	mov    0xb3c1b0,%eax
  80b1f2:	8b 50 2c             	mov    0x2c(%eax),%edx
  80b1f5:	89 14 24             	mov    %edx,(%esp)
  80b1f8:	ff 50 28             	call   *0x28(%eax)
    thread_halt();
  80b1fb:	e8 51 ff ff ff       	call   80b151 <thread_halt>
}
  80b200:	c9                   	leave  
  80b201:	c3                   	ret    
  80b202:	66 90                	xchg   %ax,%ax
  80b204:	66 90                	xchg   %ax,%ax
  80b206:	66 90                	xchg   %ax,%ax
  80b208:	66 90                	xchg   %ax,%ax
  80b20a:	66 90                	xchg   %ax,%ax
  80b20c:	66 90                	xchg   %ax,%ax
  80b20e:	66 90                	xchg   %ax,%ax

0080b210 <jos_setjmp>:
#define ENTRY(x) \
        .text; _ALIGN_TEXT; .globl x; .type x,@function; x:


ENTRY(jos_setjmp)
	movl	4(%esp), %ecx	// jos_jmp_buf
  80b210:	8b 4c 24 04          	mov    0x4(%esp),%ecx

	movl	0(%esp), %edx	// %eip as pushed by call
  80b214:	8b 14 24             	mov    (%esp),%edx
	movl	%edx,  0(%ecx)
  80b217:	89 11                	mov    %edx,(%ecx)

	leal	4(%esp), %edx	// where %esp will point when we return
  80b219:	8d 54 24 04          	lea    0x4(%esp),%edx
	movl	%edx,  4(%ecx)
  80b21d:	89 51 04             	mov    %edx,0x4(%ecx)

	movl	%ebp,  8(%ecx)
  80b220:	89 69 08             	mov    %ebp,0x8(%ecx)
	movl	%ebx, 12(%ecx)
  80b223:	89 59 0c             	mov    %ebx,0xc(%ecx)
	movl	%esi, 16(%ecx)
  80b226:	89 71 10             	mov    %esi,0x10(%ecx)
	movl	%edi, 20(%ecx)
  80b229:	89 79 14             	mov    %edi,0x14(%ecx)

	movl	$0, %eax
  80b22c:	b8 00 00 00 00       	mov    $0x0,%eax
	ret
  80b231:	c3                   	ret    
  80b232:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  80b239:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0080b240 <jos_longjmp>:

ENTRY(jos_longjmp)
	// %eax is the jos_jmp_buf*
	// %edx is the return value

	movl	 0(%eax), %ecx	// %eip
  80b240:	8b 08                	mov    (%eax),%ecx
	movl	 4(%eax), %esp
  80b242:	8b 60 04             	mov    0x4(%eax),%esp
	movl	 8(%eax), %ebp
  80b245:	8b 68 08             	mov    0x8(%eax),%ebp
	movl	12(%eax), %ebx
  80b248:	8b 58 0c             	mov    0xc(%eax),%ebx
	movl	16(%eax), %esi
  80b24b:	8b 70 10             	mov    0x10(%eax),%esi
	movl	20(%eax), %edi
  80b24e:	8b 78 14             	mov    0x14(%eax),%edi

	movl	%edx, %eax
  80b251:	89 d0                	mov    %edx,%eax
	jmp	*%ecx
  80b253:	ff e1                	jmp    *%ecx

0080b255 <perror>:
  [ENSRQUERYDOMAINTOOLONG] = "ENSRQUERYDOMAINTOOLONG",  /* Domain name is too long */
  [ENSRCNAMELOOP] = "ENSRCNAMELOOP" /* Domain name is too long */
};

void
perror(const char *s) {
  80b255:	55                   	push   %ebp
  80b256:	89 e5                	mov    %esp,%ebp
  80b258:	83 ec 18             	sub    $0x18,%esp
	cprintf("%s: %s\n", s, e2s(err));
}

const char *
e2s(int err) {
	return sys_errlist[err];
  80b25b:	a1 00 c2 b3 00       	mov    0xb3c200,%eax
};

void
perror(const char *s) {
	int err = errno;
	cprintf("%s: %s\n", s, e2s(err));
  80b260:	8b 04 85 20 50 81 00 	mov    0x815020(,%eax,4),%eax
  80b267:	89 44 24 08          	mov    %eax,0x8(%esp)
  80b26b:	8b 45 08             	mov    0x8(%ebp),%eax
  80b26e:	89 44 24 04          	mov    %eax,0x4(%esp)
  80b272:	c7 04 24 53 34 81 00 	movl   $0x813453,(%esp)
  80b279:	e8 f5 3e 00 00       	call   80f173 <cprintf>
}
  80b27e:	c9                   	leave  
  80b27f:	c3                   	ret    

0080b280 <e2s>:

const char *
e2s(int err) {
  80b280:	55                   	push   %ebp
  80b281:	89 e5                	mov    %esp,%ebp
	return sys_errlist[err];
  80b283:	8b 45 08             	mov    0x8(%ebp),%eax
  80b286:	8b 04 85 20 50 81 00 	mov    0x815020(,%eax,4),%eax
}
  80b28d:	5d                   	pop    %ebp
  80b28e:	c3                   	ret    
  80b28f:	90                   	nop

0080b290 <low_level_output>:
 * might be chained.
 *
 */
static err_t
low_level_output(struct netif *netif, struct pbuf *p)
{
  80b290:	55                   	push   %ebp
  80b291:	89 e5                	mov    %esp,%ebp
  80b293:	57                   	push   %edi
  80b294:	56                   	push   %esi
  80b295:	53                   	push   %ebx
  80b296:	83 ec 2c             	sub    $0x2c,%esp
  80b299:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    int r = sys_page_alloc(0, (void *)PKTMAP, PTE_U|PTE_W|PTE_P);
  80b29c:	c7 44 24 08 07 00 00 	movl   $0x7,0x8(%esp)
  80b2a3:	00 
  80b2a4:	c7 44 24 04 00 00 00 	movl   $0x10000000,0x4(%esp)
  80b2ab:	10 
  80b2ac:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80b2b3:	e8 fb 48 00 00       	call   80fbb3 <sys_page_alloc>
    if (r < 0)
  80b2b8:	85 c0                	test   %eax,%eax
  80b2ba:	79 1c                	jns    80b2d8 <low_level_output+0x48>
	panic("jif: could not allocate page of memory");
  80b2bc:	c7 44 24 08 38 39 81 	movl   $0x813938,0x8(%esp)
  80b2c3:	00 
  80b2c4:	c7 44 24 04 55 00 00 	movl   $0x55,0x4(%esp)
  80b2cb:	00 
  80b2cc:	c7 04 24 89 39 81 00 	movl   $0x813989,(%esp)
  80b2d3:	e8 a2 3d 00 00       	call   80f07a <_panic>
    struct jif_pkt *pkt = (struct jif_pkt *)PKTMAP;

    struct jif *jif;
    jif = netif->state;
  80b2d8:	8b 45 08             	mov    0x8(%ebp),%eax
  80b2db:	8b 40 1c             	mov    0x1c(%eax),%eax
  80b2de:	89 45 e4             	mov    %eax,-0x1c(%ebp)

    char *txbuf = pkt->jp_data;
  80b2e1:	bf 04 00 00 10       	mov    $0x10000004,%edi
    int txsize = 0;
  80b2e6:	be 00 00 00 00       	mov    $0x0,%esi
    struct pbuf *q;
    for (q = p; q != NULL; q = q->next) {
  80b2eb:	eb 57                	jmp    80b344 <low_level_output+0xb4>
	/* Send the data from the pbuf to the interface, one pbuf at a
	   time. The size of the data in each pbuf is kept in the ->len
	   variable. */

	if (txsize + q->len > 2000)
  80b2ed:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80b2f1:	0f b7 d0             	movzwl %ax,%edx
  80b2f4:	8d 0c 32             	lea    (%edx,%esi,1),%ecx
  80b2f7:	81 f9 d0 07 00 00    	cmp    $0x7d0,%ecx
  80b2fd:	7e 24                	jle    80b323 <low_level_output+0x93>
	    panic("oversized packet, fragment %d txsize %d\n", q->len, txsize);
  80b2ff:	89 74 24 10          	mov    %esi,0x10(%esp)
  80b303:	89 54 24 0c          	mov    %edx,0xc(%esp)
  80b307:	c7 44 24 08 60 39 81 	movl   $0x813960,0x8(%esp)
  80b30e:	00 
  80b30f:	c7 44 24 04 64 00 00 	movl   $0x64,0x4(%esp)
  80b316:	00 
  80b317:	c7 04 24 89 39 81 00 	movl   $0x813989,(%esp)
  80b31e:	e8 57 3d 00 00       	call   80f07a <_panic>
	memcpy(&txbuf[txsize], q->payload, q->len);
  80b323:	0f b7 c0             	movzwl %ax,%eax
  80b326:	89 44 24 08          	mov    %eax,0x8(%esp)
  80b32a:	8b 43 04             	mov    0x4(%ebx),%eax
  80b32d:	89 44 24 04          	mov    %eax,0x4(%esp)
  80b331:	8d 04 37             	lea    (%edi,%esi,1),%eax
  80b334:	89 04 24             	mov    %eax,(%esp)
  80b337:	e8 60 46 00 00       	call   80f99c <memcpy>
	txsize += q->len;
  80b33c:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80b340:	01 c6                	add    %eax,%esi
    jif = netif->state;

    char *txbuf = pkt->jp_data;
    int txsize = 0;
    struct pbuf *q;
    for (q = p; q != NULL; q = q->next) {
  80b342:	8b 1b                	mov    (%ebx),%ebx
  80b344:	85 db                	test   %ebx,%ebx
  80b346:	75 a5                	jne    80b2ed <low_level_output+0x5d>
	    panic("oversized packet, fragment %d txsize %d\n", q->len, txsize);
	memcpy(&txbuf[txsize], q->payload, q->len);
	txsize += q->len;
    }

    pkt->jp_len = txsize;
  80b348:	89 35 00 00 00 10    	mov    %esi,0x10000000

    ipc_send(jif->envid, NSREQ_OUTPUT, (void *)pkt, PTE_P|PTE_W|PTE_U);
  80b34e:	c7 44 24 0c 07 00 00 	movl   $0x7,0xc(%esp)
  80b355:	00 
  80b356:	c7 44 24 08 00 00 00 	movl   $0x10000000,0x8(%esp)
  80b35d:	10 
  80b35e:	c7 44 24 04 0b 00 00 	movl   $0xb,0x4(%esp)
  80b365:	00 
  80b366:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80b369:	8b 40 04             	mov    0x4(%eax),%eax
  80b36c:	89 04 24             	mov    %eax,(%esp)
  80b36f:	e8 f6 4e 00 00       	call   81026a <ipc_send>
    sys_page_unmap(0, (void *)pkt);
  80b374:	c7 44 24 04 00 00 00 	movl   $0x10000000,0x4(%esp)
  80b37b:	10 
  80b37c:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80b383:	e8 d2 48 00 00       	call   80fc5a <sys_page_unmap>

    return ERR_OK;
}
  80b388:	b8 00 00 00 00       	mov    $0x0,%eax
  80b38d:	83 c4 2c             	add    $0x2c,%esp
  80b390:	5b                   	pop    %ebx
  80b391:	5e                   	pop    %esi
  80b392:	5f                   	pop    %edi
  80b393:	5d                   	pop    %ebp
  80b394:	c3                   	ret    

0080b395 <jif_output>:
 */

static err_t
jif_output(struct netif *netif, struct pbuf *p,
      struct ip_addr *ipaddr)
{
  80b395:	55                   	push   %ebp
  80b396:	89 e5                	mov    %esp,%ebp
  80b398:	83 ec 18             	sub    $0x18,%esp
    /* resolve hardware address, then send (or queue) packet */
    return etharp_output(netif, p, ipaddr);
  80b39b:	8b 45 10             	mov    0x10(%ebp),%eax
  80b39e:	89 44 24 08          	mov    %eax,0x8(%esp)
  80b3a2:	8b 45 0c             	mov    0xc(%ebp),%eax
  80b3a5:	89 44 24 04          	mov    %eax,0x4(%esp)
  80b3a9:	8b 45 08             	mov    0x8(%ebp),%eax
  80b3ac:	89 04 24             	mov    %eax,(%esp)
  80b3af:	e8 bf ef ff ff       	call   80a373 <etharp_output>
}
  80b3b4:	c9                   	leave  
  80b3b5:	c3                   	ret    

0080b3b6 <jif_input>:
 *
 */

void
jif_input(struct netif *netif, void *va)
{
  80b3b6:	55                   	push   %ebp
  80b3b7:	89 e5                	mov    %esp,%ebp
  80b3b9:	57                   	push   %edi
  80b3ba:	56                   	push   %esi
  80b3bb:	53                   	push   %ebx
  80b3bc:	83 ec 2c             	sub    $0x2c,%esp
  80b3bf:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    struct jif *jif;
    struct eth_hdr *ethhdr;
    struct pbuf *p;

    jif = netif->state;
  80b3c2:	8b 45 08             	mov    0x8(%ebp),%eax
  80b3c5:	8b 40 1c             	mov    0x1c(%eax),%eax
  80b3c8:	89 45 d8             	mov    %eax,-0x28(%ebp)
 */
static struct pbuf *
low_level_input(void *va)
{
    struct jif_pkt *pkt = (struct jif_pkt *)va;
    s16_t len = pkt->jp_len;
  80b3cb:	8b 03                	mov    (%ebx),%eax
  80b3cd:	89 c7                	mov    %eax,%edi

    struct pbuf *p = pbuf_alloc(PBUF_RAW, len, PBUF_POOL);
  80b3cf:	c7 44 24 08 03 00 00 	movl   $0x3,0x8(%esp)
  80b3d6:	00 
  80b3d7:	0f b7 c0             	movzwl %ax,%eax
  80b3da:	89 44 24 04          	mov    %eax,0x4(%esp)
  80b3de:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  80b3e5:	e8 eb 9a ff ff       	call   804ed5 <pbuf_alloc>
  80b3ea:	89 45 dc             	mov    %eax,-0x24(%ebp)
    if (p == 0)
  80b3ed:	85 c0                	test   %eax,%eax
  80b3ef:	0f 84 c1 00 00 00    	je     80b4b6 <jif_input+0x100>
	return 0;

    /* We iterate over the pbuf chain until we have read the entire
     * packet into the pbuf. */
    void *rxbuf = (void *) pkt->jp_data;
  80b3f5:	8d 53 04             	lea    0x4(%ebx),%edx
  80b3f8:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    int copied = 0;
    struct pbuf *q;
    for (q = p; q != NULL; q = q->next) {
  80b3fb:	89 c3                	mov    %eax,%ebx
	return 0;

    /* We iterate over the pbuf chain until we have read the entire
     * packet into the pbuf. */
    void *rxbuf = (void *) pkt->jp_data;
    int copied = 0;
  80b3fd:	be 00 00 00 00       	mov    $0x0,%esi
    for (q = p; q != NULL; q = q->next) {
	/* Read enough bytes to fill this pbuf in the chain. The
	 * available data in the pbuf is given by the q->len
	 * variable. */
	int bytes = q->len;
	if (bytes > (len - copied))
  80b402:	0f bf c7             	movswl %di,%eax
  80b405:	89 45 e0             	mov    %eax,-0x20(%ebp)
    struct pbuf *q;
    for (q = p; q != NULL; q = q->next) {
	/* Read enough bytes to fill this pbuf in the chain. The
	 * available data in the pbuf is given by the q->len
	 * variable. */
	int bytes = q->len;
  80b408:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
	if (bytes > (len - copied))
  80b40c:	8b 7d e0             	mov    -0x20(%ebp),%edi
  80b40f:	29 f7                	sub    %esi,%edi
  80b411:	39 c7                	cmp    %eax,%edi
  80b413:	0f 4f f8             	cmovg  %eax,%edi
	    bytes = len - copied;
	memcpy(q->payload, rxbuf + copied, bytes);
  80b416:	89 7c 24 08          	mov    %edi,0x8(%esp)
  80b41a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80b41d:	01 f0                	add    %esi,%eax
  80b41f:	89 44 24 04          	mov    %eax,0x4(%esp)
  80b423:	8b 43 04             	mov    0x4(%ebx),%eax
  80b426:	89 04 24             	mov    %eax,(%esp)
  80b429:	e8 6e 45 00 00       	call   80f99c <memcpy>
	copied += bytes;
  80b42e:	01 fe                	add    %edi,%esi
    /* We iterate over the pbuf chain until we have read the entire
     * packet into the pbuf. */
    void *rxbuf = (void *) pkt->jp_data;
    int copied = 0;
    struct pbuf *q;
    for (q = p; q != NULL; q = q->next) {
  80b430:	8b 1b                	mov    (%ebx),%ebx
  80b432:	85 db                	test   %ebx,%ebx
  80b434:	75 d2                	jne    80b408 <jif_input+0x52>
  80b436:	eb 5e                	jmp    80b496 <jif_input+0xe0>
    ethhdr = p->payload;

    switch (htons(ethhdr->type)) {
    case ETHTYPE_IP:
	/* update ARP table */
	etharp_ip_input(netif, p);
  80b438:	8b 75 dc             	mov    -0x24(%ebp),%esi
  80b43b:	89 74 24 04          	mov    %esi,0x4(%esp)
  80b43f:	8b 45 08             	mov    0x8(%ebp),%eax
  80b442:	89 04 24             	mov    %eax,(%esp)
  80b445:	e8 49 e9 ff ff       	call   809d93 <etharp_ip_input>
	/* skip Ethernet header */
	pbuf_header(p, -(int)sizeof(struct eth_hdr));
  80b44a:	c7 44 24 04 f2 ff ff 	movl   $0xfffffff2,0x4(%esp)
  80b451:	ff 
  80b452:	89 34 24             	mov    %esi,(%esp)
  80b455:	e8 b6 98 ff ff       	call   804d10 <pbuf_header>
	/* pass to network layer */
	netif->input(p, netif);
  80b45a:	8b 45 08             	mov    0x8(%ebp),%eax
  80b45d:	89 44 24 04          	mov    %eax,0x4(%esp)
  80b461:	89 34 24             	mov    %esi,(%esp)
  80b464:	8b 45 08             	mov    0x8(%ebp),%eax
  80b467:	ff 50 10             	call   *0x10(%eax)
	break;
  80b46a:	eb 4a                	jmp    80b4b6 <jif_input+0x100>
      
    case ETHTYPE_ARP:
	/* pass p to ARP module  */
	etharp_arp_input(netif, jif->ethaddr, p);
  80b46c:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80b46f:	89 44 24 08          	mov    %eax,0x8(%esp)
  80b473:	8b 45 d8             	mov    -0x28(%ebp),%eax
  80b476:	8b 00                	mov    (%eax),%eax
  80b478:	89 44 24 04          	mov    %eax,0x4(%esp)
  80b47c:	8b 45 08             	mov    0x8(%ebp),%eax
  80b47f:	89 04 24             	mov    %eax,(%esp)
  80b482:	e8 5a e9 ff ff       	call   809de1 <etharp_arp_input>
	break;
  80b487:	eb 2d                	jmp    80b4b6 <jif_input+0x100>

    default:
	pbuf_free(p);
  80b489:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80b48c:	89 04 24             	mov    %eax,(%esp)
  80b48f:	e8 60 99 ff ff       	call   804df4 <pbuf_free>
  80b494:	eb 20                	jmp    80b4b6 <jif_input+0x100>
    /* no packet could be read, silently ignore this */
    if (p == NULL) return;
    /* points to packet payload, which starts with an Ethernet header */
    ethhdr = p->payload;

    switch (htons(ethhdr->type)) {
  80b496:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80b499:	8b 40 04             	mov    0x4(%eax),%eax
  80b49c:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80b4a0:	89 04 24             	mov    %eax,(%esp)
  80b4a3:	e8 ce c8 ff ff       	call   807d76 <htons>
  80b4a8:	66 3d 00 08          	cmp    $0x800,%ax
  80b4ac:	74 8a                	je     80b438 <jif_input+0x82>
  80b4ae:	66 3d 06 08          	cmp    $0x806,%ax
  80b4b2:	74 b8                	je     80b46c <jif_input+0xb6>
  80b4b4:	eb d3                	jmp    80b489 <jif_input+0xd3>
	break;

    default:
	pbuf_free(p);
    }
}
  80b4b6:	83 c4 2c             	add    $0x2c,%esp
  80b4b9:	5b                   	pop    %ebx
  80b4ba:	5e                   	pop    %esi
  80b4bb:	5f                   	pop    %edi
  80b4bc:	5d                   	pop    %ebp
  80b4bd:	c3                   	ret    

0080b4be <jif_init>:
 *
 */

err_t
jif_init(struct netif *netif)
{
  80b4be:	55                   	push   %ebp
  80b4bf:	89 e5                	mov    %esp,%ebp
  80b4c1:	57                   	push   %edi
  80b4c2:	56                   	push   %esi
  80b4c3:	53                   	push   %ebx
  80b4c4:	83 ec 2c             	sub    $0x2c,%esp
  80b4c7:	8b 5d 08             	mov    0x8(%ebp),%ebx
    struct jif *jif;
    envid_t *output_envid; 

    jif = mem_malloc(sizeof(struct jif));
  80b4ca:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  80b4d1:	e8 e9 92 ff ff       	call   8047bf <mem_malloc>
  80b4d6:	89 c6                	mov    %eax,%esi

    if (jif == NULL) {
  80b4d8:	85 c0                	test   %eax,%eax
  80b4da:	0f 84 8c 00 00 00    	je     80b56c <jif_init+0xae>
	LWIP_DEBUGF(NETIF_DEBUG, ("jif_init: out of memory\n"));
	return ERR_MEM;
    }

    output_envid = (envid_t *)netif->state;
  80b4e0:	8b 7b 1c             	mov    0x1c(%ebx),%edi

    netif->state = jif;
  80b4e3:	89 43 1c             	mov    %eax,0x1c(%ebx)
    netif->output = jif_output;
  80b4e6:	c7 43 14 95 b3 80 00 	movl   $0x80b395,0x14(%ebx)
    netif->linkoutput = low_level_output;
  80b4ed:	c7 43 18 90 b2 80 00 	movl   $0x80b290,0x18(%ebx)
    memcpy(&netif->name[0], "en", 2);
  80b4f4:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
  80b4fb:	00 
  80b4fc:	c7 44 24 04 4c 46 81 	movl   $0x81464c,0x4(%esp)
  80b503:	00 
  80b504:	8d 43 2f             	lea    0x2f(%ebx),%eax
  80b507:	89 04 24             	mov    %eax,(%esp)
  80b50a:	e8 8d 44 00 00       	call   80f99c <memcpy>

    jif->ethaddr = (struct eth_addr *)&(netif->hwaddr[0]);
  80b50f:	8d 43 25             	lea    0x25(%ebx),%eax
  80b512:	89 06                	mov    %eax,(%esi)
    jif->envid = *output_envid; 
  80b514:	8b 07                	mov    (%edi),%eax
  80b516:	89 46 04             	mov    %eax,0x4(%esi)
static void
low_level_init(struct netif *netif)
{
    int r;

    netif->hwaddr_len = 6;
  80b519:	c6 43 24 06          	movb   $0x6,0x24(%ebx)
    netif->mtu = 1500;
  80b51d:	66 c7 43 2c dc 05    	movw   $0x5dc,0x2c(%ebx)
    netif->flags = NETIF_FLAG_BROADCAST;
  80b523:	c6 43 2e 02          	movb   $0x2,0x2e(%ebx)

    // MAC address is hardcoded to eliminate a system call
    netif->hwaddr[0] = 0x52;
  80b527:	c6 43 25 52          	movb   $0x52,0x25(%ebx)
    netif->hwaddr[1] = 0x54;
  80b52b:	c6 43 26 54          	movb   $0x54,0x26(%ebx)
    netif->hwaddr[2] = 0x00;
  80b52f:	c6 43 27 00          	movb   $0x0,0x27(%ebx)
    netif->hwaddr[3] = 0x12;
  80b533:	c6 43 28 12          	movb   $0x12,0x28(%ebx)
    netif->hwaddr[4] = 0x34;
  80b537:	c6 43 29 34          	movb   $0x34,0x29(%ebx)
    netif->hwaddr[5] = 0x56;
  80b53b:	c6 43 2a 56          	movb   $0x56,0x2a(%ebx)
    etharp_init();

    // qemu user-net is dumb; if the host OS does not send and ARP request
    // first, the qemu will send packets destined for the host using the mac
    // addr 00:00:00:00:00; do a arp request for the user-net NAT at 10.0.2.2
    uint32_t ipaddr = inet_addr("10.0.2.2");
  80b53f:	c7 04 24 6b 1d 81 00 	movl   $0x811d6b,(%esp)
  80b546:	e8 5a ca ff ff       	call   807fa5 <inet_addr>
  80b54b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    etharp_query(netif, (struct ip_addr *) &ipaddr, 0);
  80b54e:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80b555:	00 
  80b556:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80b559:	89 44 24 04          	mov    %eax,0x4(%esp)
  80b55d:	89 1c 24             	mov    %ebx,(%esp)
  80b560:	e8 9f eb ff ff       	call   80a104 <etharp_query>

    return ERR_OK;
  80b565:	b8 00 00 00 00       	mov    $0x0,%eax
  80b56a:	eb 05                	jmp    80b571 <jif_init+0xb3>

    jif = mem_malloc(sizeof(struct jif));

    if (jif == NULL) {
	LWIP_DEBUGF(NETIF_DEBUG, ("jif_init: out of memory\n"));
	return ERR_MEM;
  80b56c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    // addr 00:00:00:00:00; do a arp request for the user-net NAT at 10.0.2.2
    uint32_t ipaddr = inet_addr("10.0.2.2");
    etharp_query(netif, (struct ip_addr *) &ipaddr, 0);

    return ERR_OK;
}
  80b571:	83 c4 2c             	add    $0x2c,%esp
  80b574:	5b                   	pop    %ebx
  80b575:	5e                   	pop    %esi
  80b576:	5f                   	pop    %edi
  80b577:	5d                   	pop    %ebp
  80b578:	c3                   	ret    

0080b579 <netconn_new_with_proto_and_callback>:
 * @return a newly allocated struct netconn or
 *         NULL on memory error
 */
struct netconn*
netconn_new_with_proto_and_callback(enum netconn_type t, u8_t proto, netconn_callback callback)
{
  80b579:	55                   	push   %ebp
  80b57a:	89 e5                	mov    %esp,%ebp
  80b57c:	56                   	push   %esi
  80b57d:	53                   	push   %ebx
  80b57e:	83 ec 30             	sub    $0x30,%esp
  80b581:	8b 75 0c             	mov    0xc(%ebp),%esi
  struct netconn *conn;
  struct api_msg msg;

  conn = netconn_alloc(t, callback);
  80b584:	8b 45 10             	mov    0x10(%ebp),%eax
  80b587:	89 44 24 04          	mov    %eax,0x4(%esp)
  80b58b:	8b 45 08             	mov    0x8(%ebp),%eax
  80b58e:	89 04 24             	mov    %eax,(%esp)
  80b591:	e8 44 10 00 00       	call   80c5da <netconn_alloc>
  80b596:	89 c3                	mov    %eax,%ebx
  
  if (conn != NULL ) {
  80b598:	85 c0                	test   %eax,%eax
  80b59a:	0f 84 d8 00 00 00    	je     80b678 <netconn_new_with_proto_and_callback+0xff>
    msg.function = do_newconn;
  80b5a0:	c7 45 e4 d3 c4 80 00 	movl   $0x80c4d3,-0x1c(%ebp)
    msg.msg.msg.n.proto = proto;
  80b5a7:	89 f0                	mov    %esi,%eax
  80b5a9:	88 45 ec             	mov    %al,-0x14(%ebp)
    msg.msg.conn = conn;
  80b5ac:	89 5d e8             	mov    %ebx,-0x18(%ebp)
    TCPIP_APIMSG(&msg);
  80b5af:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80b5b2:	89 04 24             	mov    %eax,(%esp)
  80b5b5:	e8 71 71 ff ff       	call   80272b <tcpip_apimsg>

    if (conn->err != ERR_OK) {
  80b5ba:	80 7b 0c 00          	cmpb   $0x0,0xc(%ebx)
  80b5be:	0f 84 b6 00 00 00    	je     80b67a <netconn_new_with_proto_and_callback+0x101>
      LWIP_ASSERT("freeing conn without freeing pcb", conn->pcb.tcp == NULL);
  80b5c4:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
  80b5c8:	74 1c                	je     80b5e6 <netconn_new_with_proto_and_callback+0x6d>
  80b5ca:	c7 44 24 08 a0 39 81 	movl   $0x8139a0,0x8(%esp)
  80b5d1:	00 
  80b5d2:	c7 44 24 04 52 00 00 	movl   $0x52,0x4(%esp)
  80b5d9:	00 
  80b5da:	c7 04 24 52 3a 81 00 	movl   $0x813a52,(%esp)
  80b5e1:	e8 94 3a 00 00       	call   80f07a <_panic>
      LWIP_ASSERT("conn has no op_completed", conn->op_completed != SYS_SEM_NULL);
  80b5e6:	8b 43 10             	mov    0x10(%ebx),%eax
  80b5e9:	83 f8 ff             	cmp    $0xffffffff,%eax
  80b5ec:	75 1c                	jne    80b60a <netconn_new_with_proto_and_callback+0x91>
  80b5ee:	c7 44 24 08 69 3a 81 	movl   $0x813a69,0x8(%esp)
  80b5f5:	00 
  80b5f6:	c7 44 24 04 53 00 00 	movl   $0x53,0x4(%esp)
  80b5fd:	00 
  80b5fe:	c7 04 24 52 3a 81 00 	movl   $0x813a52,(%esp)
  80b605:	e8 70 3a 00 00       	call   80f07a <_panic>
      LWIP_ASSERT("conn has no recvmbox", conn->recvmbox != SYS_MBOX_NULL);
  80b60a:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80b60e:	75 1c                	jne    80b62c <netconn_new_with_proto_and_callback+0xb3>
  80b610:	c7 44 24 08 82 3a 81 	movl   $0x813a82,0x8(%esp)
  80b617:	00 
  80b618:	c7 44 24 04 54 00 00 	movl   $0x54,0x4(%esp)
  80b61f:	00 
  80b620:	c7 04 24 52 3a 81 00 	movl   $0x813a52,(%esp)
  80b627:	e8 4e 3a 00 00       	call   80f07a <_panic>
      LWIP_ASSERT("conn->acceptmbox shouldn't exist", conn->acceptmbox == SYS_MBOX_NULL);
  80b62c:	83 7b 18 ff          	cmpl   $0xffffffff,0x18(%ebx)
  80b630:	74 1c                	je     80b64e <netconn_new_with_proto_and_callback+0xd5>
  80b632:	c7 44 24 08 c4 39 81 	movl   $0x8139c4,0x8(%esp)
  80b639:	00 
  80b63a:	c7 44 24 04 55 00 00 	movl   $0x55,0x4(%esp)
  80b641:	00 
  80b642:	c7 04 24 52 3a 81 00 	movl   $0x813a52,(%esp)
  80b649:	e8 2c 3a 00 00       	call   80f07a <_panic>
      sys_sem_free(conn->op_completed);
  80b64e:	89 04 24             	mov    %eax,(%esp)
  80b651:	e8 51 f0 ff ff       	call   80a6a7 <sys_sem_free>
      sys_mbox_free(conn->recvmbox);
  80b656:	8b 43 14             	mov    0x14(%ebx),%eax
  80b659:	89 04 24             	mov    %eax,(%esp)
  80b65c:	e8 da f0 ff ff       	call   80a73b <sys_mbox_free>
      memp_free(MEMP_NETCONN, conn);
  80b661:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80b665:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
  80b66c:	e8 d1 93 ff ff       	call   804a42 <memp_free>
      return NULL;
  80b671:	b8 00 00 00 00       	mov    $0x0,%eax
  80b676:	eb 04                	jmp    80b67c <netconn_new_with_proto_and_callback+0x103>
  80b678:	eb 02                	jmp    80b67c <netconn_new_with_proto_and_callback+0x103>
    }
  }
  return conn;
  80b67a:	89 d8                	mov    %ebx,%eax
}
  80b67c:	83 c4 30             	add    $0x30,%esp
  80b67f:	5b                   	pop    %ebx
  80b680:	5e                   	pop    %esi
  80b681:	5d                   	pop    %ebp
  80b682:	c3                   	ret    

0080b683 <netconn_delete>:
 * @param conn the netconn to delete
 * @return ERR_OK if the connection was deleted
 */
err_t
netconn_delete(struct netconn *conn)
{
  80b683:	55                   	push   %ebp
  80b684:	89 e5                	mov    %esp,%ebp
  80b686:	53                   	push   %ebx
  80b687:	83 ec 34             	sub    $0x34,%esp
  80b68a:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  /* No ASSERT here because possible to get a (conn == NULL) if we got an accept error */
  if (conn == NULL) {
  80b68d:	85 db                	test   %ebx,%ebx
  80b68f:	74 24                	je     80b6b5 <netconn_delete+0x32>
    return ERR_OK;
  }

  msg.function = do_delconn;
  80b691:	c7 45 e4 2f c8 80 00 	movl   $0x80c82f,-0x1c(%ebp)
  msg.msg.conn = conn;
  80b698:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  tcpip_apimsg(&msg);
  80b69b:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80b69e:	89 04 24             	mov    %eax,(%esp)
  80b6a1:	e8 85 70 ff ff       	call   80272b <tcpip_apimsg>

  conn->pcb.tcp = NULL;
  80b6a6:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
  netconn_free(conn);
  80b6ad:	89 1c 24             	mov    %ebx,(%esp)
  80b6b0:	e8 e3 0f 00 00       	call   80c698 <netconn_free>

  return ERR_OK;
}
  80b6b5:	b8 00 00 00 00       	mov    $0x0,%eax
  80b6ba:	83 c4 34             	add    $0x34,%esp
  80b6bd:	5b                   	pop    %ebx
  80b6be:	5d                   	pop    %ebp
  80b6bf:	c3                   	ret    

0080b6c0 <netconn_type>:
 * @param conn the netconn of which to get the type
 * @return the netconn_type of conn
 */
enum netconn_type
netconn_type(struct netconn *conn)
{
  80b6c0:	55                   	push   %ebp
  80b6c1:	89 e5                	mov    %esp,%ebp
  80b6c3:	83 ec 18             	sub    $0x18,%esp
  80b6c6:	8b 45 08             	mov    0x8(%ebp),%eax
  LWIP_ERROR("netconn_type: invalid conn", (conn != NULL), return NETCONN_INVALID;);
  80b6c9:	85 c0                	test   %eax,%eax
  80b6cb:	75 1c                	jne    80b6e9 <netconn_type+0x29>
  80b6cd:	c7 44 24 08 97 3a 81 	movl   $0x813a97,0x8(%esp)
  80b6d4:	00 
  80b6d5:	c7 44 24 04 84 00 00 	movl   $0x84,0x4(%esp)
  80b6dc:	00 
  80b6dd:	c7 04 24 52 3a 81 00 	movl   $0x813a52,(%esp)
  80b6e4:	e8 91 39 00 00       	call   80f07a <_panic>
  80b6e9:	8b 00                	mov    (%eax),%eax
  return conn->type;
}
  80b6eb:	c9                   	leave  
  80b6ec:	c3                   	ret    

0080b6ed <netconn_getaddr>:
 * @return ERR_CONN for invalid connections
 *         ERR_OK if the information was retrieved
 */
err_t
netconn_getaddr(struct netconn *conn, struct ip_addr *addr, u16_t *port, u8_t local)
{
  80b6ed:	55                   	push   %ebp
  80b6ee:	89 e5                	mov    %esp,%ebp
  80b6f0:	53                   	push   %ebx
  80b6f1:	83 ec 34             	sub    $0x34,%esp
  80b6f4:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80b6f7:	8b 55 0c             	mov    0xc(%ebp),%edx
  80b6fa:	8b 45 10             	mov    0x10(%ebp),%eax
  80b6fd:	8b 4d 14             	mov    0x14(%ebp),%ecx
  struct api_msg msg;

  LWIP_ERROR("netconn_getaddr: invalid conn", (conn != NULL), return ERR_ARG;);
  80b700:	85 db                	test   %ebx,%ebx
  80b702:	75 1c                	jne    80b720 <netconn_getaddr+0x33>
  80b704:	c7 44 24 08 b2 3a 81 	movl   $0x813ab2,0x8(%esp)
  80b70b:	00 
  80b70c:	c7 44 24 04 98 00 00 	movl   $0x98,0x4(%esp)
  80b713:	00 
  80b714:	c7 04 24 52 3a 81 00 	movl   $0x813a52,(%esp)
  80b71b:	e8 5a 39 00 00       	call   80f07a <_panic>
  LWIP_ERROR("netconn_getaddr: invalid addr", (addr != NULL), return ERR_ARG;);
  80b720:	85 d2                	test   %edx,%edx
  80b722:	75 1c                	jne    80b740 <netconn_getaddr+0x53>
  80b724:	c7 44 24 08 d0 3a 81 	movl   $0x813ad0,0x8(%esp)
  80b72b:	00 
  80b72c:	c7 44 24 04 99 00 00 	movl   $0x99,0x4(%esp)
  80b733:	00 
  80b734:	c7 04 24 52 3a 81 00 	movl   $0x813a52,(%esp)
  80b73b:	e8 3a 39 00 00       	call   80f07a <_panic>
  LWIP_ERROR("netconn_getaddr: invalid port", (port != NULL), return ERR_ARG;);
  80b740:	85 c0                	test   %eax,%eax
  80b742:	75 1c                	jne    80b760 <netconn_getaddr+0x73>
  80b744:	c7 44 24 08 ee 3a 81 	movl   $0x813aee,0x8(%esp)
  80b74b:	00 
  80b74c:	c7 44 24 04 9a 00 00 	movl   $0x9a,0x4(%esp)
  80b753:	00 
  80b754:	c7 04 24 52 3a 81 00 	movl   $0x813a52,(%esp)
  80b75b:	e8 1a 39 00 00       	call   80f07a <_panic>

  msg.function = do_getaddr;
  80b760:	c7 45 e4 a0 cc 80 00 	movl   $0x80cca0,-0x1c(%ebp)
  msg.msg.conn = conn;
  80b767:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.ad.ipaddr = addr;
  80b76a:	89 55 ec             	mov    %edx,-0x14(%ebp)
  msg.msg.msg.ad.port = port;
  80b76d:	89 45 f0             	mov    %eax,-0x10(%ebp)
  msg.msg.msg.ad.local = local;
  80b770:	88 4d f4             	mov    %cl,-0xc(%ebp)
  TCPIP_APIMSG(&msg);
  80b773:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80b776:	89 04 24             	mov    %eax,(%esp)
  80b779:	e8 ad 6f ff ff       	call   80272b <tcpip_apimsg>

  return conn->err;
  80b77e:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80b782:	83 c4 34             	add    $0x34,%esp
  80b785:	5b                   	pop    %ebx
  80b786:	5d                   	pop    %ebp
  80b787:	c3                   	ret    

0080b788 <netconn_bind>:
 * @param port the local port to bind the netconn to (not used for RAW)
 * @return ERR_OK if bound, any other err_t on failure
 */
err_t
netconn_bind(struct netconn *conn, struct ip_addr *addr, u16_t port)
{
  80b788:	55                   	push   %ebp
  80b789:	89 e5                	mov    %esp,%ebp
  80b78b:	53                   	push   %ebx
  80b78c:	83 ec 34             	sub    $0x34,%esp
  80b78f:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80b792:	8b 45 10             	mov    0x10(%ebp),%eax
  struct api_msg msg;

  LWIP_ERROR("netconn_bind: invalid conn", (conn != NULL), return ERR_ARG;);
  80b795:	85 db                	test   %ebx,%ebx
  80b797:	75 1c                	jne    80b7b5 <netconn_bind+0x2d>
  80b799:	c7 44 24 08 0c 3b 81 	movl   $0x813b0c,0x8(%esp)
  80b7a0:	00 
  80b7a1:	c7 44 24 04 b5 00 00 	movl   $0xb5,0x4(%esp)
  80b7a8:	00 
  80b7a9:	c7 04 24 52 3a 81 00 	movl   $0x813a52,(%esp)
  80b7b0:	e8 c5 38 00 00       	call   80f07a <_panic>

  msg.function = do_bind;
  80b7b5:	c7 45 e4 e1 c8 80 00 	movl   $0x80c8e1,-0x1c(%ebp)
  msg.msg.conn = conn;
  80b7bc:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.bc.ipaddr = addr;
  80b7bf:	8b 55 0c             	mov    0xc(%ebp),%edx
  80b7c2:	89 55 ec             	mov    %edx,-0x14(%ebp)
  msg.msg.msg.bc.port = port;
  80b7c5:	66 89 45 f0          	mov    %ax,-0x10(%ebp)
  TCPIP_APIMSG(&msg);
  80b7c9:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80b7cc:	89 04 24             	mov    %eax,(%esp)
  80b7cf:	e8 57 6f ff ff       	call   80272b <tcpip_apimsg>
  return conn->err;
  80b7d4:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80b7d8:	83 c4 34             	add    $0x34,%esp
  80b7db:	5b                   	pop    %ebx
  80b7dc:	5d                   	pop    %ebp
  80b7dd:	c3                   	ret    

0080b7de <netconn_connect>:
 * @param port the remote port to connect to (no used for RAW)
 * @return ERR_OK if connected, return value of tcp_/udp_/raw_connect otherwise
 */
err_t
netconn_connect(struct netconn *conn, struct ip_addr *addr, u16_t port)
{
  80b7de:	55                   	push   %ebp
  80b7df:	89 e5                	mov    %esp,%ebp
  80b7e1:	53                   	push   %ebx
  80b7e2:	83 ec 34             	sub    $0x34,%esp
  80b7e5:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80b7e8:	8b 45 10             	mov    0x10(%ebp),%eax
  struct api_msg msg;

  LWIP_ERROR("netconn_connect: invalid conn", (conn != NULL), return ERR_ARG;);
  80b7eb:	85 db                	test   %ebx,%ebx
  80b7ed:	75 1c                	jne    80b80b <netconn_connect+0x2d>
  80b7ef:	c7 44 24 08 27 3b 81 	movl   $0x813b27,0x8(%esp)
  80b7f6:	00 
  80b7f7:	c7 44 24 04 cc 00 00 	movl   $0xcc,0x4(%esp)
  80b7fe:	00 
  80b7ff:	c7 04 24 52 3a 81 00 	movl   $0x813a52,(%esp)
  80b806:	e8 6f 38 00 00       	call   80f07a <_panic>

  msg.function = do_connect;
  80b80b:	c7 45 e4 77 c9 80 00 	movl   $0x80c977,-0x1c(%ebp)
  msg.msg.conn = conn;
  80b812:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.bc.ipaddr = addr;
  80b815:	8b 55 0c             	mov    0xc(%ebp),%edx
  80b818:	89 55 ec             	mov    %edx,-0x14(%ebp)
  msg.msg.msg.bc.port = port;
  80b81b:	66 89 45 f0          	mov    %ax,-0x10(%ebp)
  /* This is the only function which need to not block tcpip_thread */
  tcpip_apimsg(&msg);
  80b81f:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80b822:	89 04 24             	mov    %eax,(%esp)
  80b825:	e8 01 6f ff ff       	call   80272b <tcpip_apimsg>
  return conn->err;
  80b82a:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80b82e:	83 c4 34             	add    $0x34,%esp
  80b831:	5b                   	pop    %ebx
  80b832:	5d                   	pop    %ebp
  80b833:	c3                   	ret    

0080b834 <netconn_disconnect>:
 * @param conn the netconn to disconnect
 * @return TODO: return value is not set here...
 */
err_t
netconn_disconnect(struct netconn *conn)
{
  80b834:	55                   	push   %ebp
  80b835:	89 e5                	mov    %esp,%ebp
  80b837:	53                   	push   %ebx
  80b838:	83 ec 34             	sub    $0x34,%esp
  80b83b:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  LWIP_ERROR("netconn_disconnect: invalid conn", (conn != NULL), return ERR_ARG;);
  80b83e:	85 db                	test   %ebx,%ebx
  80b840:	75 1c                	jne    80b85e <netconn_disconnect+0x2a>
  80b842:	c7 44 24 08 e8 39 81 	movl   $0x8139e8,0x8(%esp)
  80b849:	00 
  80b84a:	c7 44 24 04 e2 00 00 	movl   $0xe2,0x4(%esp)
  80b851:	00 
  80b852:	c7 04 24 52 3a 81 00 	movl   $0x813a52,(%esp)
  80b859:	e8 1c 38 00 00       	call   80f07a <_panic>

  msg.function = do_disconnect;
  80b85e:	c7 45 e4 3d ca 80 00 	movl   $0x80ca3d,-0x1c(%ebp)
  msg.msg.conn = conn;
  80b865:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  TCPIP_APIMSG(&msg);
  80b868:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80b86b:	89 04 24             	mov    %eax,(%esp)
  80b86e:	e8 b8 6e ff ff       	call   80272b <tcpip_apimsg>
  return conn->err;
  80b873:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80b877:	83 c4 34             	add    $0x34,%esp
  80b87a:	5b                   	pop    %ebx
  80b87b:	5d                   	pop    %ebp
  80b87c:	c3                   	ret    

0080b87d <netconn_listen_with_backlog>:
 * @return ERR_OK if the netconn was set to listen (UDP and RAW netconns
 *         don't return any error (yet?))
 */
err_t
netconn_listen_with_backlog(struct netconn *conn, u8_t backlog)
{
  80b87d:	55                   	push   %ebp
  80b87e:	89 e5                	mov    %esp,%ebp
  80b880:	53                   	push   %ebx
  80b881:	83 ec 34             	sub    $0x34,%esp
  80b884:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  /* This does no harm. If TCP_LISTEN_BACKLOG is off, backlog is unused. */
  LWIP_UNUSED_ARG(backlog);

  LWIP_ERROR("netconn_listen: invalid conn", (conn != NULL), return ERR_ARG;);
  80b887:	85 db                	test   %ebx,%ebx
  80b889:	75 1c                	jne    80b8a7 <netconn_listen_with_backlog+0x2a>
  80b88b:	c7 44 24 08 45 3b 81 	movl   $0x813b45,0x8(%esp)
  80b892:	00 
  80b893:	c7 44 24 04 fa 00 00 	movl   $0xfa,0x4(%esp)
  80b89a:	00 
  80b89b:	c7 04 24 52 3a 81 00 	movl   $0x813a52,(%esp)
  80b8a2:	e8 d3 37 00 00       	call   80f07a <_panic>

  msg.function = do_listen;
  80b8a7:	c7 45 e4 74 ca 80 00 	movl   $0x80ca74,-0x1c(%ebp)
  msg.msg.conn = conn;
  80b8ae:	89 5d e8             	mov    %ebx,-0x18(%ebp)
#if TCP_LISTEN_BACKLOG
  msg.msg.msg.lb.backlog = backlog;
#endif /* TCP_LISTEN_BACKLOG */
  TCPIP_APIMSG(&msg);
  80b8b1:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80b8b4:	89 04 24             	mov    %eax,(%esp)
  80b8b7:	e8 6f 6e ff ff       	call   80272b <tcpip_apimsg>
  return conn->err;
  80b8bc:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80b8c0:	83 c4 34             	add    $0x34,%esp
  80b8c3:	5b                   	pop    %ebx
  80b8c4:	5d                   	pop    %ebp
  80b8c5:	c3                   	ret    

0080b8c6 <netconn_accept>:
 * @param conn the TCP listen netconn
 * @return the newly accepted netconn or NULL on timeout
 */
struct netconn *
netconn_accept(struct netconn *conn)
{
  80b8c6:	55                   	push   %ebp
  80b8c7:	89 e5                	mov    %esp,%ebp
  80b8c9:	53                   	push   %ebx
  80b8ca:	83 ec 24             	sub    $0x24,%esp
  80b8cd:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct netconn *newconn;

  LWIP_ERROR("netconn_accept: invalid conn",       (conn != NULL),                      return NULL;);
  80b8d0:	85 db                	test   %ebx,%ebx
  80b8d2:	75 1c                	jne    80b8f0 <netconn_accept+0x2a>
  80b8d4:	c7 44 24 08 62 3b 81 	movl   $0x813b62,0x8(%esp)
  80b8db:	00 
  80b8dc:	c7 44 24 04 10 01 00 	movl   $0x110,0x4(%esp)
  80b8e3:	00 
  80b8e4:	c7 04 24 52 3a 81 00 	movl   $0x813a52,(%esp)
  80b8eb:	e8 8a 37 00 00       	call   80f07a <_panic>
  LWIP_ERROR("netconn_accept: invalid acceptmbox", (conn->acceptmbox != SYS_MBOX_NULL), return NULL;);
  80b8f0:	8b 43 18             	mov    0x18(%ebx),%eax
  80b8f3:	83 f8 ff             	cmp    $0xffffffff,%eax
  80b8f6:	75 1c                	jne    80b914 <netconn_accept+0x4e>
  80b8f8:	c7 44 24 08 0c 3a 81 	movl   $0x813a0c,0x8(%esp)
  80b8ff:	00 
  80b900:	c7 44 24 04 11 01 00 	movl   $0x111,0x4(%esp)
  80b907:	00 
  80b908:	c7 04 24 52 3a 81 00 	movl   $0x813a52,(%esp)
  80b90f:	e8 66 37 00 00       	call   80f07a <_panic>
#if LWIP_SO_RCVTIMEO
  if (sys_arch_mbox_fetch(conn->acceptmbox, (void *)&newconn, conn->recv_timeout) == SYS_ARCH_TIMEOUT) {
    newconn = NULL;
  } else
#else
  sys_arch_mbox_fetch(conn->acceptmbox, (void *)&newconn, 0);
  80b914:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80b91b:	00 
  80b91c:	8d 55 f4             	lea    -0xc(%ebp),%edx
  80b91f:	89 54 24 04          	mov    %edx,0x4(%esp)
  80b923:	89 04 24             	mov    %eax,(%esp)
  80b926:	e8 6d f2 ff ff       	call   80ab98 <sys_arch_mbox_fetch>
#endif /* LWIP_SO_RCVTIMEO*/
  {
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVMINUS, 0);
  80b92b:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80b92e:	85 c0                	test   %eax,%eax
  80b930:	74 15                	je     80b947 <netconn_accept+0x81>
  80b932:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80b939:	00 
  80b93a:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  80b941:	00 
  80b942:	89 1c 24             	mov    %ebx,(%esp)
  80b945:	ff d0                	call   *%eax
    }
#endif /* TCP_LISTEN_BACKLOG */
  }

  return newconn;
}
  80b947:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80b94a:	83 c4 24             	add    $0x24,%esp
  80b94d:	5b                   	pop    %ebx
  80b94e:	5d                   	pop    %ebp
  80b94f:	c3                   	ret    

0080b950 <netconn_recv>:
 * @param conn the netconn from which to receive data
 * @return a new netbuf containing received data or NULL on memory error or timeout
 */
struct netbuf *
netconn_recv(struct netconn *conn)
{
  80b950:	55                   	push   %ebp
  80b951:	89 e5                	mov    %esp,%ebp
  80b953:	53                   	push   %ebx
  80b954:	83 ec 34             	sub    $0x34,%esp
  80b957:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;
  struct netbuf *buf = NULL;
  80b95a:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  struct pbuf *p;
  u16_t len;

  LWIP_ERROR("netconn_recv: invalid conn",  (conn != NULL), return NULL;);
  80b961:	85 db                	test   %ebx,%ebx
  80b963:	75 1c                	jne    80b981 <netconn_recv+0x31>
  80b965:	c7 44 24 08 7f 3b 81 	movl   $0x813b7f,0x8(%esp)
  80b96c:	00 
  80b96d:	c7 44 24 04 3a 01 00 	movl   $0x13a,0x4(%esp)
  80b974:	00 
  80b975:	c7 04 24 52 3a 81 00 	movl   $0x813a52,(%esp)
  80b97c:	e8 f9 36 00 00       	call   80f07a <_panic>

  if (conn->recvmbox == SYS_MBOX_NULL) {
  80b981:	8b 43 14             	mov    0x14(%ebx),%eax
  80b984:	83 f8 ff             	cmp    $0xffffffff,%eax
  80b987:	75 0e                	jne    80b997 <netconn_recv+0x47>
    /* @todo: should calling netconn_recv on a TCP listen conn be fatal (ERR_CONN)?? */
    /* TCP listen conns don't have a recvmbox! */
    conn->err = ERR_CONN;
  80b989:	c6 43 0c f8          	movb   $0xf8,0xc(%ebx)
    return NULL;
  80b98d:	b8 00 00 00 00       	mov    $0x0,%eax
  80b992:	e9 58 01 00 00       	jmp    80baef <netconn_recv+0x19f>
  }

  if (ERR_IS_FATAL(conn->err)) {
  80b997:	80 7b 0c fc          	cmpb   $0xfc,0xc(%ebx)
  80b99b:	0f 8c 49 01 00 00    	jl     80baea <netconn_recv+0x19a>
    return NULL;
  }

  if (conn->type == NETCONN_TCP) {
  80b9a1:	83 3b 10             	cmpl   $0x10,(%ebx)
  80b9a4:	0f 85 f5 00 00 00    	jne    80ba9f <netconn_recv+0x14f>
#if LWIP_TCP
    if (conn->state == NETCONN_LISTEN) {
  80b9aa:	83 7b 04 02          	cmpl   $0x2,0x4(%ebx)
  80b9ae:	75 0e                	jne    80b9be <netconn_recv+0x6e>
      /* @todo: should calling netconn_recv on a TCP listen conn be fatal?? */
      conn->err = ERR_CONN;
  80b9b0:	c6 43 0c f8          	movb   $0xf8,0xc(%ebx)
      return NULL;
  80b9b4:	b8 00 00 00 00       	mov    $0x0,%eax
  80b9b9:	e9 31 01 00 00       	jmp    80baef <netconn_recv+0x19f>
    }

    buf = memp_malloc(MEMP_NETBUF);
  80b9be:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
  80b9c5:	e8 18 90 ff ff       	call   8049e2 <memp_malloc>
  80b9ca:	89 45 e0             	mov    %eax,-0x20(%ebp)

    if (buf == NULL) {
  80b9cd:	85 c0                	test   %eax,%eax
  80b9cf:	75 09                	jne    80b9da <netconn_recv+0x8a>
      conn->err = ERR_MEM;
  80b9d1:	c6 43 0c ff          	movb   $0xff,0xc(%ebx)
      return NULL;
  80b9d5:	e9 15 01 00 00       	jmp    80baef <netconn_recv+0x19f>
    if (sys_arch_mbox_fetch(conn->recvmbox, (void *)&p, conn->recv_timeout)==SYS_ARCH_TIMEOUT) {
      conn->err = ERR_TIMEOUT;
      p = NULL;
    }
#else
    sys_arch_mbox_fetch(conn->recvmbox, (void *)&p, 0);
  80b9da:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80b9e1:	00 
  80b9e2:	8d 45 dc             	lea    -0x24(%ebp),%eax
  80b9e5:	89 44 24 04          	mov    %eax,0x4(%esp)
  80b9e9:	8b 43 14             	mov    0x14(%ebx),%eax
  80b9ec:	89 04 24             	mov    %eax,(%esp)
  80b9ef:	e8 a4 f1 ff ff       	call   80ab98 <sys_arch_mbox_fetch>
#endif /* LWIP_SO_RCVTIMEO*/

    if (p != NULL) {
  80b9f4:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80b9f7:	85 c0                	test   %eax,%eax
  80b9f9:	74 0a                	je     80ba05 <netconn_recv+0xb5>
      len = p->tot_len;
  80b9fb:	0f b7 50 08          	movzwl 0x8(%eax),%edx
      SYS_ARCH_DEC(conn->recv_avail, len);
  80b9ff:	66 29 53 20          	sub    %dx,0x20(%ebx)
  80ba03:	eb 05                	jmp    80ba0a <netconn_recv+0xba>
    } else {
      len = 0;
  80ba05:	ba 00 00 00 00       	mov    $0x0,%edx
    }

    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVMINUS, len);
  80ba0a:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80ba0d:	85 c0                	test   %eax,%eax
  80ba0f:	74 14                	je     80ba25 <netconn_recv+0xd5>
  80ba11:	0f b7 d2             	movzwl %dx,%edx
  80ba14:	89 54 24 08          	mov    %edx,0x8(%esp)
  80ba18:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  80ba1f:	00 
  80ba20:	89 1c 24             	mov    %ebx,(%esp)
  80ba23:	ff d0                	call   *%eax

    /* If we are closed, we indicate that we no longer wish to use the socket */
    if (p == NULL) {
  80ba25:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80ba28:	85 c0                	test   %eax,%eax
  80ba2a:	75 2b                	jne    80ba57 <netconn_recv+0x107>
      memp_free(MEMP_NETBUF, buf);
  80ba2c:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80ba2f:	89 44 24 04          	mov    %eax,0x4(%esp)
  80ba33:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
  80ba3a:	e8 03 90 ff ff       	call   804a42 <memp_free>
      /* Avoid to lose any previous error code */
      if (conn->err == ERR_OK) {
        conn->err = ERR_CLSD;
      }
      return NULL;
  80ba3f:	b8 00 00 00 00       	mov    $0x0,%eax

    /* If we are closed, we indicate that we no longer wish to use the socket */
    if (p == NULL) {
      memp_free(MEMP_NETBUF, buf);
      /* Avoid to lose any previous error code */
      if (conn->err == ERR_OK) {
  80ba44:	80 7b 0c 00          	cmpb   $0x0,0xc(%ebx)
  80ba48:	0f 85 a1 00 00 00    	jne    80baef <netconn_recv+0x19f>
        conn->err = ERR_CLSD;
  80ba4e:	c6 43 0c f9          	movb   $0xf9,0xc(%ebx)
  80ba52:	e9 98 00 00 00       	jmp    80baef <netconn_recv+0x19f>
      }
      return NULL;
    }

    buf->p = p;
  80ba57:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80ba5a:	89 02                	mov    %eax,(%edx)
    buf->ptr = p;
  80ba5c:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80ba5f:	8b 55 dc             	mov    -0x24(%ebp),%edx
  80ba62:	89 50 04             	mov    %edx,0x4(%eax)
    buf->port = 0;
  80ba65:	66 c7 40 0c 00 00    	movw   $0x0,0xc(%eax)
    buf->addr = NULL;
  80ba6b:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)

    /* Let the stack know that we have taken the data. */
    msg.function = do_recv;
  80ba72:	c7 45 e4 12 cc 80 00 	movl   $0x80cc12,-0x1c(%ebp)
    msg.msg.conn = conn;
  80ba79:	89 5d e8             	mov    %ebx,-0x18(%ebp)
    if (buf != NULL) {
  80ba7c:	85 c0                	test   %eax,%eax
  80ba7e:	74 0c                	je     80ba8c <netconn_recv+0x13c>
      msg.msg.msg.r.len = buf->p->tot_len;
  80ba80:	8b 00                	mov    (%eax),%eax
  80ba82:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  80ba86:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
  80ba8a:	eb 06                	jmp    80ba92 <netconn_recv+0x142>
    } else {
      msg.msg.msg.r.len = 1;
  80ba8c:	66 c7 45 ec 01 00    	movw   $0x1,-0x14(%ebp)
    }
    TCPIP_APIMSG(&msg);
  80ba92:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80ba95:	89 04 24             	mov    %eax,(%esp)
  80ba98:	e8 8e 6c ff ff       	call   80272b <tcpip_apimsg>
  80ba9d:	eb 46                	jmp    80bae5 <netconn_recv+0x195>
#if LWIP_SO_RCVTIMEO
    if (sys_arch_mbox_fetch(conn->recvmbox, (void *)&buf, conn->recv_timeout)==SYS_ARCH_TIMEOUT) {
      buf = NULL;
    }
#else
    sys_arch_mbox_fetch(conn->recvmbox, (void *)&buf, 0);
  80ba9f:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80baa6:	00 
  80baa7:	8d 55 e0             	lea    -0x20(%ebp),%edx
  80baaa:	89 54 24 04          	mov    %edx,0x4(%esp)
  80baae:	89 04 24             	mov    %eax,(%esp)
  80bab1:	e8 e2 f0 ff ff       	call   80ab98 <sys_arch_mbox_fetch>
#endif /* LWIP_SO_RCVTIMEO*/
    if (buf!=NULL) {
  80bab6:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80bab9:	85 c0                	test   %eax,%eax
  80babb:	74 28                	je     80bae5 <netconn_recv+0x195>
      SYS_ARCH_DEC(conn->recv_avail, buf->p->tot_len);
  80babd:	8b 10                	mov    (%eax),%edx
  80babf:	0f b7 52 08          	movzwl 0x8(%edx),%edx
  80bac3:	66 29 53 20          	sub    %dx,0x20(%ebx)
      /* Register event with callback */
      API_EVENT(conn, NETCONN_EVT_RCVMINUS, buf->p->tot_len);
  80bac7:	8b 53 2c             	mov    0x2c(%ebx),%edx
  80baca:	85 d2                	test   %edx,%edx
  80bacc:	74 17                	je     80bae5 <netconn_recv+0x195>
  80bace:	8b 00                	mov    (%eax),%eax
  80bad0:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  80bad4:	89 44 24 08          	mov    %eax,0x8(%esp)
  80bad8:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  80badf:	00 
  80bae0:	89 1c 24             	mov    %ebx,(%esp)
  80bae3:	ff d2                	call   *%edx
#endif /* (LWIP_UDP || LWIP_RAW) */
  }

  LWIP_DEBUGF(API_LIB_DEBUG, ("netconn_recv: received %p (err %d)\n", (void *)buf, conn->err));

  return buf;
  80bae5:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80bae8:	eb 05                	jmp    80baef <netconn_recv+0x19f>
    conn->err = ERR_CONN;
    return NULL;
  }

  if (ERR_IS_FATAL(conn->err)) {
    return NULL;
  80baea:	b8 00 00 00 00       	mov    $0x0,%eax
  }

  LWIP_DEBUGF(API_LIB_DEBUG, ("netconn_recv: received %p (err %d)\n", (void *)buf, conn->err));

  return buf;
}
  80baef:	83 c4 34             	add    $0x34,%esp
  80baf2:	5b                   	pop    %ebx
  80baf3:	5d                   	pop    %ebp
  80baf4:	c3                   	ret    

0080baf5 <netconn_send>:
 * @param buf a netbuf containing the data to send
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t
netconn_send(struct netconn *conn, struct netbuf *buf)
{
  80baf5:	55                   	push   %ebp
  80baf6:	89 e5                	mov    %esp,%ebp
  80baf8:	53                   	push   %ebx
  80baf9:	83 ec 34             	sub    $0x34,%esp
  80bafc:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  LWIP_ERROR("netconn_send: invalid conn",  (conn != NULL), return ERR_ARG;);
  80baff:	85 db                	test   %ebx,%ebx
  80bb01:	75 1c                	jne    80bb1f <netconn_send+0x2a>
  80bb03:	c7 44 24 08 9a 3b 81 	movl   $0x813b9a,0x8(%esp)
  80bb0a:	00 
  80bb0b:	c7 44 24 04 b9 01 00 	movl   $0x1b9,0x4(%esp)
  80bb12:	00 
  80bb13:	c7 04 24 52 3a 81 00 	movl   $0x813a52,(%esp)
  80bb1a:	e8 5b 35 00 00       	call   80f07a <_panic>

  LWIP_DEBUGF(API_LIB_DEBUG, ("netconn_send: sending %d bytes\n", buf->p->tot_len));
  msg.function = do_send;
  80bb1f:	c7 45 e4 5a cb 80 00 	movl   $0x80cb5a,-0x1c(%ebp)
  msg.msg.conn = conn;
  80bb26:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.b = buf;
  80bb29:	8b 45 0c             	mov    0xc(%ebp),%eax
  80bb2c:	89 45 ec             	mov    %eax,-0x14(%ebp)
  TCPIP_APIMSG(&msg);
  80bb2f:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80bb32:	89 04 24             	mov    %eax,(%esp)
  80bb35:	e8 f1 6b ff ff       	call   80272b <tcpip_apimsg>
  return conn->err;
  80bb3a:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80bb3e:	83 c4 34             	add    $0x34,%esp
  80bb41:	5b                   	pop    %ebx
  80bb42:	5d                   	pop    %ebp
  80bb43:	c3                   	ret    

0080bb44 <netconn_sendto>:
 * @param port the remote port to which to send the data
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t
netconn_sendto(struct netconn *conn, struct netbuf *buf, struct ip_addr *addr, u16_t port)
{
  80bb44:	55                   	push   %ebp
  80bb45:	89 e5                	mov    %esp,%ebp
  80bb47:	83 ec 18             	sub    $0x18,%esp
  80bb4a:	8b 45 0c             	mov    0xc(%ebp),%eax
  80bb4d:	8b 55 14             	mov    0x14(%ebp),%edx
  if (buf != NULL) {
  80bb50:	85 c0                	test   %eax,%eax
  80bb52:	74 1b                	je     80bb6f <netconn_sendto+0x2b>
    buf->addr = addr;
  80bb54:	8b 4d 10             	mov    0x10(%ebp),%ecx
  80bb57:	89 48 08             	mov    %ecx,0x8(%eax)
    buf->port = port;
  80bb5a:	66 89 50 0c          	mov    %dx,0xc(%eax)
    return netconn_send(conn, buf);
  80bb5e:	89 44 24 04          	mov    %eax,0x4(%esp)
  80bb62:	8b 45 08             	mov    0x8(%ebp),%eax
  80bb65:	89 04 24             	mov    %eax,(%esp)
  80bb68:	e8 88 ff ff ff       	call   80baf5 <netconn_send>
  80bb6d:	eb 05                	jmp    80bb74 <netconn_sendto+0x30>
  }
  return ERR_VAL;
  80bb6f:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
}
  80bb74:	c9                   	leave  
  80bb75:	c3                   	ret    

0080bb76 <netconn_write>:
 * - NETCONN_MORE (0x02) for TCP connection, PSH flag will be set on last segment sent
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t
netconn_write(struct netconn *conn, const void *dataptr, int size, u8_t apiflags)
{
  80bb76:	55                   	push   %ebp
  80bb77:	89 e5                	mov    %esp,%ebp
  80bb79:	53                   	push   %ebx
  80bb7a:	83 ec 34             	sub    $0x34,%esp
  80bb7d:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80bb80:	8b 45 14             	mov    0x14(%ebp),%eax
  struct api_msg msg;

  LWIP_ERROR("netconn_write: invalid conn",  (conn != NULL), return ERR_ARG;);
  80bb83:	85 db                	test   %ebx,%ebx
  80bb85:	75 1c                	jne    80bba3 <netconn_write+0x2d>
  80bb87:	c7 44 24 08 b5 3b 81 	movl   $0x813bb5,0x8(%esp)
  80bb8e:	00 
  80bb8f:	c7 44 24 04 d3 01 00 	movl   $0x1d3,0x4(%esp)
  80bb96:	00 
  80bb97:	c7 04 24 52 3a 81 00 	movl   $0x813a52,(%esp)
  80bb9e:	e8 d7 34 00 00       	call   80f07a <_panic>
  LWIP_ERROR("netconn_write: invalid conn->type",  (conn->type == NETCONN_TCP), return ERR_VAL;);
  80bba3:	83 3b 10             	cmpl   $0x10,(%ebx)
  80bba6:	74 1c                	je     80bbc4 <netconn_write+0x4e>
  80bba8:	c7 44 24 08 30 3a 81 	movl   $0x813a30,0x8(%esp)
  80bbaf:	00 
  80bbb0:	c7 44 24 04 d4 01 00 	movl   $0x1d4,0x4(%esp)
  80bbb7:	00 
  80bbb8:	c7 04 24 52 3a 81 00 	movl   $0x813a52,(%esp)
  80bbbf:	e8 b6 34 00 00       	call   80f07a <_panic>

  msg.function = do_write;
  80bbc4:	c7 45 e4 53 cc 80 00 	movl   $0x80cc53,-0x1c(%ebp)
  msg.msg.conn = conn;
  80bbcb:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.w.dataptr = dataptr;
  80bbce:	8b 55 0c             	mov    0xc(%ebp),%edx
  80bbd1:	89 55 ec             	mov    %edx,-0x14(%ebp)
  msg.msg.msg.w.apiflags = apiflags;
  80bbd4:	88 45 f4             	mov    %al,-0xc(%ebp)
  msg.msg.msg.w.len = size;
  80bbd7:	8b 45 10             	mov    0x10(%ebp),%eax
  80bbda:	89 45 f0             	mov    %eax,-0x10(%ebp)
  /* For locking the core: this _can_ be delayed on low memory/low send buffer,
     but if it is, this is done inside api_msg.c:do_write(), so we can use the
     non-blocking version here. */
  TCPIP_APIMSG(&msg);
  80bbdd:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80bbe0:	89 04 24             	mov    %eax,(%esp)
  80bbe3:	e8 43 6b ff ff       	call   80272b <tcpip_apimsg>
  return conn->err;
  80bbe8:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80bbec:	83 c4 34             	add    $0x34,%esp
  80bbef:	5b                   	pop    %ebx
  80bbf0:	5d                   	pop    %ebp
  80bbf1:	c3                   	ret    

0080bbf2 <netconn_close>:
 * @param conn the TCP netconn to close
 * @return ERR_OK if the netconn was closed, any other err_t on error
 */
err_t
netconn_close(struct netconn *conn)
{
  80bbf2:	55                   	push   %ebp
  80bbf3:	89 e5                	mov    %esp,%ebp
  80bbf5:	53                   	push   %ebx
  80bbf6:	83 ec 34             	sub    $0x34,%esp
  80bbf9:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  LWIP_ERROR("netconn_close: invalid conn",  (conn != NULL), return ERR_ARG;);
  80bbfc:	85 db                	test   %ebx,%ebx
  80bbfe:	75 1c                	jne    80bc1c <netconn_close+0x2a>
  80bc00:	c7 44 24 08 d1 3b 81 	movl   $0x813bd1,0x8(%esp)
  80bc07:	00 
  80bc08:	c7 44 24 04 ed 01 00 	movl   $0x1ed,0x4(%esp)
  80bc0f:	00 
  80bc10:	c7 04 24 52 3a 81 00 	movl   $0x813a52,(%esp)
  80bc17:	e8 5e 34 00 00       	call   80f07a <_panic>

  msg.function = do_close;
  80bc1c:	c7 45 e4 61 cd 80 00 	movl   $0x80cd61,-0x1c(%ebp)
  msg.msg.conn = conn;
  80bc23:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  tcpip_apimsg(&msg);
  80bc26:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80bc29:	89 04 24             	mov    %eax,(%esp)
  80bc2c:	e8 fa 6a ff ff       	call   80272b <tcpip_apimsg>
  return conn->err;
  80bc31:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80bc35:	83 c4 34             	add    $0x34,%esp
  80bc38:	5b                   	pop    %ebx
  80bc39:	5d                   	pop    %ebp
  80bc3a:	c3                   	ret    
  80bc3b:	66 90                	xchg   %ax,%ax
  80bc3d:	66 90                	xchg   %ax,%ax
  80bc3f:	90                   	nop

0080bc40 <recv_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.recv) for parameters and return value
 */
static err_t
recv_tcp(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
{
  80bc40:	55                   	push   %ebp
  80bc41:	89 e5                	mov    %esp,%ebp
  80bc43:	56                   	push   %esi
  80bc44:	53                   	push   %ebx
  80bc45:	83 ec 10             	sub    $0x10,%esp
  80bc48:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80bc4b:	8b 45 0c             	mov    0xc(%ebp),%eax
  80bc4e:	8b 75 10             	mov    0x10(%ebp),%esi
  80bc51:	8b 55 14             	mov    0x14(%ebp),%edx
  struct netconn *conn;
  u16_t len;

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("recv_tcp must have a pcb argument", pcb != NULL);
  80bc54:	85 c0                	test   %eax,%eax
  80bc56:	75 1c                	jne    80bc74 <recv_tcp+0x34>
  80bc58:	c7 44 24 08 f0 3b 81 	movl   $0x813bf0,0x8(%esp)
  80bc5f:	00 
  80bc60:	c7 44 24 04 c1 00 00 	movl   $0xc1,0x4(%esp)
  80bc67:	00 
  80bc68:	c7 04 24 3a 3d 81 00 	movl   $0x813d3a,(%esp)
  80bc6f:	e8 06 34 00 00       	call   80f07a <_panic>
  LWIP_ASSERT("recv_tcp must have an argument", arg != NULL);
  80bc74:	85 db                	test   %ebx,%ebx
  80bc76:	75 1c                	jne    80bc94 <recv_tcp+0x54>
  80bc78:	c7 44 24 08 14 3c 81 	movl   $0x813c14,0x8(%esp)
  80bc7f:	00 
  80bc80:	c7 44 24 04 c2 00 00 	movl   $0xc2,0x4(%esp)
  80bc87:	00 
  80bc88:	c7 04 24 3a 3d 81 00 	movl   $0x813d3a,(%esp)
  80bc8f:	e8 e6 33 00 00       	call   80f07a <_panic>
  conn = arg;
  LWIP_ASSERT("recv_tcp: recv for wrong pcb!", conn->pcb.tcp == pcb);
  80bc94:	39 43 08             	cmp    %eax,0x8(%ebx)
  80bc97:	74 1c                	je     80bcb5 <recv_tcp+0x75>
  80bc99:	c7 44 24 08 51 3d 81 	movl   $0x813d51,0x8(%esp)
  80bca0:	00 
  80bca1:	c7 44 24 04 c4 00 00 	movl   $0xc4,0x4(%esp)
  80bca8:	00 
  80bca9:	c7 04 24 3a 3d 81 00 	movl   $0x813d3a,(%esp)
  80bcb0:	e8 c5 33 00 00       	call   80f07a <_panic>

  if ((conn == NULL) || (conn->recvmbox == SYS_MBOX_NULL)) {
  80bcb5:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80bcb9:	74 49                	je     80bd04 <recv_tcp+0xc4>
    return ERR_VAL;
  }

  conn->err = err;
  80bcbb:	88 53 0c             	mov    %dl,0xc(%ebx)
  if (p != NULL) {
  80bcbe:	85 f6                	test   %esi,%esi
  80bcc0:	74 0a                	je     80bccc <recv_tcp+0x8c>
    len = p->tot_len;
  80bcc2:	0f b7 56 08          	movzwl 0x8(%esi),%edx
    SYS_ARCH_INC(conn->recv_avail, len);
  80bcc6:	66 01 53 20          	add    %dx,0x20(%ebx)
  80bcca:	eb 05                	jmp    80bcd1 <recv_tcp+0x91>
  } else {
    len = 0;
  80bccc:	ba 00 00 00 00       	mov    $0x0,%edx
  }
  /* Register event with callback */
  API_EVENT(conn, NETCONN_EVT_RCVPLUS, len);
  80bcd1:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80bcd4:	85 c0                	test   %eax,%eax
  80bcd6:	74 14                	je     80bcec <recv_tcp+0xac>
  80bcd8:	0f b7 d2             	movzwl %dx,%edx
  80bcdb:	89 54 24 08          	mov    %edx,0x8(%esp)
  80bcdf:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80bce6:	00 
  80bce7:	89 1c 24             	mov    %ebx,(%esp)
  80bcea:	ff d0                	call   *%eax
  if (sys_mbox_trypost(conn->recvmbox, p) != ERR_OK) {
  80bcec:	89 74 24 04          	mov    %esi,0x4(%esp)
  80bcf0:	8b 43 14             	mov    0x14(%ebx),%eax
  80bcf3:	89 04 24             	mov    %eax,(%esp)
  80bcf6:	e8 91 ed ff ff       	call   80aa8c <sys_mbox_trypost>
  80bcfb:	84 c0                	test   %al,%al
  80bcfd:	0f 95 c0             	setne  %al
    return ERR_MEM;
  80bd00:	f7 d8                	neg    %eax
  80bd02:	eb 05                	jmp    80bd09 <recv_tcp+0xc9>
  LWIP_ASSERT("recv_tcp must have an argument", arg != NULL);
  conn = arg;
  LWIP_ASSERT("recv_tcp: recv for wrong pcb!", conn->pcb.tcp == pcb);

  if ((conn == NULL) || (conn->recvmbox == SYS_MBOX_NULL)) {
    return ERR_VAL;
  80bd04:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  if (sys_mbox_trypost(conn->recvmbox, p) != ERR_OK) {
    return ERR_MEM;
  }

  return ERR_OK;
}
  80bd09:	83 c4 10             	add    $0x10,%esp
  80bd0c:	5b                   	pop    %ebx
  80bd0d:	5e                   	pop    %esi
  80bd0e:	5d                   	pop    %ebp
  80bd0f:	c3                   	ret    

0080bd10 <recv_udp>:
 * @see udp.h (struct udp_pcb.recv) for parameters
 */
static void
recv_udp(void *arg, struct udp_pcb *pcb, struct pbuf *p,
   struct ip_addr *addr, u16_t port)
{
  80bd10:	55                   	push   %ebp
  80bd11:	89 e5                	mov    %esp,%ebp
  80bd13:	57                   	push   %edi
  80bd14:	56                   	push   %esi
  80bd15:	53                   	push   %ebx
  80bd16:	83 ec 1c             	sub    $0x1c,%esp
  80bd19:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80bd1c:	8b 45 0c             	mov    0xc(%ebp),%eax
  80bd1f:	8b 7d 10             	mov    0x10(%ebp),%edi
  80bd22:	8b 4d 18             	mov    0x18(%ebp),%ecx
  80bd25:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
#if LWIP_SO_RCVBUF
  int recv_avail;
#endif /* LWIP_SO_RCVBUF */

  LWIP_UNUSED_ARG(pcb); /* only used for asserts... */
  LWIP_ASSERT("recv_udp must have a pcb argument", pcb != NULL);
  80bd28:	85 c0                	test   %eax,%eax
  80bd2a:	75 1c                	jne    80bd48 <recv_udp+0x38>
  80bd2c:	c7 44 24 08 34 3c 81 	movl   $0x813c34,0x8(%esp)
  80bd33:	00 
  80bd34:	c7 44 24 04 8e 00 00 	movl   $0x8e,0x4(%esp)
  80bd3b:	00 
  80bd3c:	c7 04 24 3a 3d 81 00 	movl   $0x813d3a,(%esp)
  80bd43:	e8 32 33 00 00       	call   80f07a <_panic>
  LWIP_ASSERT("recv_udp must have an argument", arg != NULL);
  80bd48:	85 db                	test   %ebx,%ebx
  80bd4a:	75 1c                	jne    80bd68 <recv_udp+0x58>
  80bd4c:	c7 44 24 08 58 3c 81 	movl   $0x813c58,0x8(%esp)
  80bd53:	00 
  80bd54:	c7 44 24 04 8f 00 00 	movl   $0x8f,0x4(%esp)
  80bd5b:	00 
  80bd5c:	c7 04 24 3a 3d 81 00 	movl   $0x813d3a,(%esp)
  80bd63:	e8 12 33 00 00       	call   80f07a <_panic>
  conn = arg;
  LWIP_ASSERT("recv_udp: recv for wrong pcb!", conn->pcb.udp == pcb);
  80bd68:	39 43 08             	cmp    %eax,0x8(%ebx)
  80bd6b:	74 1c                	je     80bd89 <recv_udp+0x79>
  80bd6d:	c7 44 24 08 6f 3d 81 	movl   $0x813d6f,0x8(%esp)
  80bd74:	00 
  80bd75:	c7 44 24 04 91 00 00 	movl   $0x91,0x4(%esp)
  80bd7c:	00 
  80bd7d:	c7 04 24 3a 3d 81 00 	movl   $0x813d3a,(%esp)
  80bd84:	e8 f1 32 00 00       	call   80f07a <_panic>
#if LWIP_SO_RCVBUF
  SYS_ARCH_GET(conn->recv_avail, recv_avail);
  if ((conn == NULL) || (conn->recvmbox == SYS_MBOX_NULL) ||
      ((recv_avail + (int)(p->tot_len)) > conn->recv_bufsize)) {
#else  /* LWIP_SO_RCVBUF */
  if ((conn == NULL) || (conn->recvmbox == SYS_MBOX_NULL)) {
  80bd89:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80bd8d:	75 0a                	jne    80bd99 <recv_udp+0x89>
#endif /* LWIP_SO_RCVBUF */
    pbuf_free(p);
  80bd8f:	89 3c 24             	mov    %edi,(%esp)
  80bd92:	e8 5d 90 ff ff       	call   804df4 <pbuf_free>
    return;
  80bd97:	eb 6e                	jmp    80be07 <recv_udp+0xf7>
  }

  buf = memp_malloc(MEMP_NETBUF);
  80bd99:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
  80bda0:	e8 3d 8c ff ff       	call   8049e2 <memp_malloc>
  80bda5:	89 c6                	mov    %eax,%esi
  if (buf == NULL) {
  80bda7:	85 c0                	test   %eax,%eax
  80bda9:	75 0a                	jne    80bdb5 <recv_udp+0xa5>
    pbuf_free(p);
  80bdab:	89 3c 24             	mov    %edi,(%esp)
  80bdae:	e8 41 90 ff ff       	call   804df4 <pbuf_free>
    return;
  80bdb3:	eb 52                	jmp    80be07 <recv_udp+0xf7>
  } else {
    buf->p = p;
  80bdb5:	89 38                	mov    %edi,(%eax)
    buf->ptr = p;
  80bdb7:	89 78 04             	mov    %edi,0x4(%eax)
    buf->addr = addr;
  80bdba:	8b 45 14             	mov    0x14(%ebp),%eax
  80bdbd:	89 46 08             	mov    %eax,0x8(%esi)
    buf->port = port;
  80bdc0:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  80bdc4:	66 89 46 0c          	mov    %ax,0xc(%esi)
  }

  SYS_ARCH_INC(conn->recv_avail, p->tot_len);
  80bdc8:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  80bdcc:	66 01 43 20          	add    %ax,0x20(%ebx)
  /* Register event with callback */
  API_EVENT(conn, NETCONN_EVT_RCVPLUS, p->tot_len);
  80bdd0:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80bdd3:	85 c0                	test   %eax,%eax
  80bdd5:	74 15                	je     80bdec <recv_udp+0xdc>
  80bdd7:	0f b7 57 08          	movzwl 0x8(%edi),%edx
  80bddb:	89 54 24 08          	mov    %edx,0x8(%esp)
  80bddf:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80bde6:	00 
  80bde7:	89 1c 24             	mov    %ebx,(%esp)
  80bdea:	ff d0                	call   *%eax
  if (sys_mbox_trypost(conn->recvmbox, buf) != ERR_OK) {
  80bdec:	89 74 24 04          	mov    %esi,0x4(%esp)
  80bdf0:	8b 43 14             	mov    0x14(%ebx),%eax
  80bdf3:	89 04 24             	mov    %eax,(%esp)
  80bdf6:	e8 91 ec ff ff       	call   80aa8c <sys_mbox_trypost>
  80bdfb:	84 c0                	test   %al,%al
  80bdfd:	74 08                	je     80be07 <recv_udp+0xf7>
    netbuf_delete(buf);
  80bdff:	89 34 24             	mov    %esi,(%esp)
  80be02:	e8 45 6a ff ff       	call   80284c <netbuf_delete>
    return;
  }
}
  80be07:	83 c4 1c             	add    $0x1c,%esp
  80be0a:	5b                   	pop    %ebx
  80be0b:	5e                   	pop    %esi
  80be0c:	5f                   	pop    %edi
  80be0d:	5d                   	pop    %ebp
  80be0e:	c3                   	ret    

0080be0f <recv_raw>:
 * @see raw.h (struct raw_pcb.recv) for parameters and return value
 */
static u8_t
recv_raw(void *arg, struct raw_pcb *pcb, struct pbuf *p,
    struct ip_addr *addr)
{
  80be0f:	55                   	push   %ebp
  80be10:	89 e5                	mov    %esp,%ebp
  80be12:	57                   	push   %edi
  80be13:	56                   	push   %esi
  80be14:	53                   	push   %ebx
  80be15:	83 ec 1c             	sub    $0x1c,%esp
  80be18:	8b 5d 08             	mov    0x8(%ebp),%ebx
#if LWIP_SO_RCVBUF
  SYS_ARCH_GET(conn->recv_avail, recv_avail);
  if ((conn != NULL) && (conn->recvmbox != SYS_MBOX_NULL) &&
      ((recv_avail + (int)(p->tot_len)) <= conn->recv_bufsize)) {
#else  /* LWIP_SO_RCVBUF */
  if ((conn != NULL) && (conn->recvmbox != SYS_MBOX_NULL)) {
  80be1b:	85 db                	test   %ebx,%ebx
  80be1d:	0f 84 cd 00 00 00    	je     80bef0 <recv_raw+0xe1>
  80be23:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80be27:	0f 84 c3 00 00 00    	je     80bef0 <recv_raw+0xe1>
#endif /* LWIP_SO_RCVBUF */
    /* copy the whole packet into new pbufs */
    q = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
  80be2d:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80be34:	00 
  80be35:	8b 45 10             	mov    0x10(%ebp),%eax
  80be38:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  80be3c:	89 44 24 04          	mov    %eax,0x4(%esp)
  80be40:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  80be47:	e8 89 90 ff ff       	call   804ed5 <pbuf_alloc>
  80be4c:	89 c6                	mov    %eax,%esi
    if(q != NULL) {
  80be4e:	85 c0                	test   %eax,%eax
  80be50:	0f 84 9a 00 00 00    	je     80bef0 <recv_raw+0xe1>
      if (pbuf_copy(q, p) != ERR_OK) {
  80be56:	8b 45 10             	mov    0x10(%ebp),%eax
  80be59:	89 44 24 04          	mov    %eax,0x4(%esp)
  80be5d:	89 34 24             	mov    %esi,(%esp)
  80be60:	e8 9f 95 ff ff       	call   805404 <pbuf_copy>
  80be65:	84 c0                	test   %al,%al
  80be67:	74 73                	je     80bedc <recv_raw+0xcd>
        pbuf_free(q);
  80be69:	89 34 24             	mov    %esi,(%esp)
  80be6c:	e8 83 8f ff ff       	call   804df4 <pbuf_free>
  80be71:	eb 7d                	jmp    80bef0 <recv_raw+0xe1>
    }

    if(q != NULL) {
      buf = memp_malloc(MEMP_NETBUF);
      if (buf == NULL) {
        pbuf_free(q);
  80be73:	89 34 24             	mov    %esi,(%esp)
  80be76:	e8 79 8f ff ff       	call   804df4 <pbuf_free>
        return 0;
  80be7b:	90                   	nop
  80be7c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  80be80:	eb 6e                	jmp    80bef0 <recv_raw+0xe1>
      }

      buf->p = q;
  80be82:	89 37                	mov    %esi,(%edi)
      buf->ptr = q;
  80be84:	89 77 04             	mov    %esi,0x4(%edi)
      buf->addr = &(((struct ip_hdr*)(q->payload))->src);
  80be87:	8b 46 04             	mov    0x4(%esi),%eax
  80be8a:	83 c0 0c             	add    $0xc,%eax
  80be8d:	89 47 08             	mov    %eax,0x8(%edi)
      buf->port = pcb->protocol;
  80be90:	8b 45 0c             	mov    0xc(%ebp),%eax
  80be93:	0f b6 40 10          	movzbl 0x10(%eax),%eax
  80be97:	66 89 47 0c          	mov    %ax,0xc(%edi)

      SYS_ARCH_INC(conn->recv_avail, q->tot_len);
  80be9b:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  80be9f:	66 01 43 20          	add    %ax,0x20(%ebx)
      /* Register event with callback */
      API_EVENT(conn, NETCONN_EVT_RCVPLUS, q->tot_len);
  80bea3:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80bea6:	85 c0                	test   %eax,%eax
  80bea8:	74 15                	je     80bebf <recv_raw+0xb0>
  80beaa:	0f b7 56 08          	movzwl 0x8(%esi),%edx
  80beae:	89 54 24 08          	mov    %edx,0x8(%esp)
  80beb2:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80beb9:	00 
  80beba:	89 1c 24             	mov    %ebx,(%esp)
  80bebd:	ff d0                	call   *%eax
      if (sys_mbox_trypost(conn->recvmbox, buf) != ERR_OK) {
  80bebf:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80bec3:	8b 43 14             	mov    0x14(%ebx),%eax
  80bec6:	89 04 24             	mov    %eax,(%esp)
  80bec9:	e8 be eb ff ff       	call   80aa8c <sys_mbox_trypost>
  80bece:	84 c0                	test   %al,%al
  80bed0:	74 1e                	je     80bef0 <recv_raw+0xe1>
        netbuf_delete(buf);
  80bed2:	89 3c 24             	mov    %edi,(%esp)
  80bed5:	e8 72 69 ff ff       	call   80284c <netbuf_delete>
  80beda:	eb 14                	jmp    80bef0 <recv_raw+0xe1>
        q = NULL;
      }
    }

    if(q != NULL) {
      buf = memp_malloc(MEMP_NETBUF);
  80bedc:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
  80bee3:	e8 fa 8a ff ff       	call   8049e2 <memp_malloc>
  80bee8:	89 c7                	mov    %eax,%edi
      if (buf == NULL) {
  80beea:	85 c0                	test   %eax,%eax
  80beec:	75 94                	jne    80be82 <recv_raw+0x73>
  80beee:	eb 83                	jmp    80be73 <recv_raw+0x64>
      }
    }
  }

  return 0; /* do not eat the packet */
}
  80bef0:	b8 00 00 00 00       	mov    $0x0,%eax
  80bef5:	83 c4 1c             	add    $0x1c,%esp
  80bef8:	5b                   	pop    %ebx
  80bef9:	5e                   	pop    %esi
  80befa:	5f                   	pop    %edi
  80befb:	5d                   	pop    %ebp
  80befc:	c3                   	ret    

0080befd <setup_tcp>:
 *
 * @param conn the TCP netconn to setup
 */
static void
setup_tcp(struct netconn *conn)
{
  80befd:	55                   	push   %ebp
  80befe:	89 e5                	mov    %esp,%ebp
  80bf00:	53                   	push   %ebx
  80bf01:	83 ec 14             	sub    $0x14,%esp
  struct tcp_pcb *pcb;

  pcb = conn->pcb.tcp;
  80bf04:	8b 58 08             	mov    0x8(%eax),%ebx
  tcp_arg(pcb, conn);
  80bf07:	89 44 24 04          	mov    %eax,0x4(%esp)
  80bf0b:	89 1c 24             	mov    %ebx,(%esp)
  80bf0e:	e8 79 9f ff ff       	call   805e8c <tcp_arg>
  tcp_recv(pcb, recv_tcp);
  80bf13:	c7 44 24 04 40 bc 80 	movl   $0x80bc40,0x4(%esp)
  80bf1a:	00 
  80bf1b:	89 1c 24             	mov    %ebx,(%esp)
  80bf1e:	e8 77 9f ff ff       	call   805e9a <tcp_recv>
  tcp_sent(pcb, sent_tcp);
  80bf23:	c7 44 24 04 2c c4 80 	movl   $0x80c42c,0x4(%esp)
  80bf2a:	00 
  80bf2b:	89 1c 24             	mov    %ebx,(%esp)
  80bf2e:	e8 78 9f ff ff       	call   805eab <tcp_sent>
  tcp_poll(pcb, poll_tcp, 4);
  80bf33:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  80bf3a:	00 
  80bf3b:	c7 44 24 04 de c3 80 	movl   $0x80c3de,0x4(%esp)
  80bf42:	00 
  80bf43:	89 1c 24             	mov    %ebx,(%esp)
  80bf46:	e8 90 9f ff ff       	call   805edb <tcp_poll>
  tcp_err(pcb, err_tcp);
  80bf4b:	c7 44 24 04 a9 bf 80 	movl   $0x80bfa9,0x4(%esp)
  80bf52:	00 
  80bf53:	89 1c 24             	mov    %ebx,(%esp)
  80bf56:	e8 61 9f ff ff       	call   805ebc <tcp_err>
}
  80bf5b:	83 c4 14             	add    $0x14,%esp
  80bf5e:	5b                   	pop    %ebx
  80bf5f:	5d                   	pop    %ebp
  80bf60:	c3                   	ret    

0080bf61 <do_connected>:
 *
 * @see tcp.h (struct tcp_pcb.connected) for parameters and return values
 */
static err_t
do_connected(void *arg, struct tcp_pcb *pcb, err_t err)
{
  80bf61:	55                   	push   %ebp
  80bf62:	89 e5                	mov    %esp,%ebp
  80bf64:	53                   	push   %ebx
  80bf65:	83 ec 14             	sub    $0x14,%esp
  80bf68:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80bf6b:	8b 45 10             	mov    0x10(%ebp),%eax

  LWIP_UNUSED_ARG(pcb);

  conn = arg;

  if (conn == NULL) {
  80bf6e:	85 db                	test   %ebx,%ebx
  80bf70:	74 2c                	je     80bf9e <do_connected+0x3d>
    return ERR_VAL;
  }

  conn->err = err;
  80bf72:	88 43 0c             	mov    %al,0xc(%ebx)
  if ((conn->type == NETCONN_TCP) && (err == ERR_OK)) {
  80bf75:	83 3b 10             	cmpl   $0x10,(%ebx)
  80bf78:	75 0b                	jne    80bf85 <do_connected+0x24>
  80bf7a:	84 c0                	test   %al,%al
  80bf7c:	75 07                	jne    80bf85 <do_connected+0x24>
    setup_tcp(conn);
  80bf7e:	89 d8                	mov    %ebx,%eax
  80bf80:	e8 78 ff ff ff       	call   80befd <setup_tcp>
  }
  conn->state = NETCONN_NONE;
  80bf85:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  sys_sem_signal(conn->op_completed);
  80bf8c:	8b 43 10             	mov    0x10(%ebx),%eax
  80bf8f:	89 04 24             	mov    %eax,(%esp)
  80bf92:	e8 69 e9 ff ff       	call   80a900 <sys_sem_signal>
  return ERR_OK;
  80bf97:	b8 00 00 00 00       	mov    $0x0,%eax
  80bf9c:	eb 05                	jmp    80bfa3 <do_connected+0x42>
  LWIP_UNUSED_ARG(pcb);

  conn = arg;

  if (conn == NULL) {
    return ERR_VAL;
  80bf9e:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
    setup_tcp(conn);
  }
  conn->state = NETCONN_NONE;
  sys_sem_signal(conn->op_completed);
  return ERR_OK;
}
  80bfa3:	83 c4 14             	add    $0x14,%esp
  80bfa6:	5b                   	pop    %ebx
  80bfa7:	5d                   	pop    %ebp
  80bfa8:	c3                   	ret    

0080bfa9 <err_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.err) for parameters
 */
static void
err_tcp(void *arg, err_t err)
{
  80bfa9:	55                   	push   %ebp
  80bfaa:	89 e5                	mov    %esp,%ebp
  80bfac:	53                   	push   %ebx
  80bfad:	83 ec 14             	sub    $0x14,%esp
  80bfb0:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80bfb3:	8b 45 0c             	mov    0xc(%ebp),%eax
  struct netconn *conn;

  conn = arg;
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  80bfb6:	85 db                	test   %ebx,%ebx
  80bfb8:	75 1c                	jne    80bfd6 <err_tcp+0x2d>
  80bfba:	c7 44 24 08 8d 3d 81 	movl   $0x813d8d,0x8(%esp)
  80bfc1:	00 
  80bfc2:	c7 44 24 04 22 01 00 	movl   $0x122,0x4(%esp)
  80bfc9:	00 
  80bfca:	c7 04 24 3a 3d 81 00 	movl   $0x813d3a,(%esp)
  80bfd1:	e8 a4 30 00 00       	call   80f07a <_panic>

  conn->pcb.tcp = NULL;
  80bfd6:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)

  conn->err = err;
  80bfdd:	88 43 0c             	mov    %al,0xc(%ebx)
  if (conn->recvmbox != SYS_MBOX_NULL) {
  80bfe0:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80bfe4:	74 2f                	je     80c015 <err_tcp+0x6c>
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  80bfe6:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80bfe9:	85 c0                	test   %eax,%eax
  80bfeb:	74 15                	je     80c002 <err_tcp+0x59>
  80bfed:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80bff4:	00 
  80bff5:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80bffc:	00 
  80bffd:	89 1c 24             	mov    %ebx,(%esp)
  80c000:	ff d0                	call   *%eax
    sys_mbox_post(conn->recvmbox, NULL);
  80c002:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80c009:	00 
  80c00a:	8b 43 14             	mov    0x14(%ebx),%eax
  80c00d:	89 04 24             	mov    %eax,(%esp)
  80c010:	e8 41 eb ff ff       	call   80ab56 <sys_mbox_post>
  }
  if (conn->op_completed != SYS_SEM_NULL && conn->state == NETCONN_CONNECT) {
  80c015:	8b 43 10             	mov    0x10(%ebx),%eax
  80c018:	83 f8 ff             	cmp    $0xffffffff,%eax
  80c01b:	74 15                	je     80c032 <err_tcp+0x89>
  80c01d:	83 7b 04 03          	cmpl   $0x3,0x4(%ebx)
  80c021:	75 0f                	jne    80c032 <err_tcp+0x89>
    conn->state = NETCONN_NONE;
  80c023:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    sys_sem_signal(conn->op_completed);
  80c02a:	89 04 24             	mov    %eax,(%esp)
  80c02d:	e8 ce e8 ff ff       	call   80a900 <sys_sem_signal>
  }
  if (conn->acceptmbox != SYS_MBOX_NULL) {
  80c032:	83 7b 18 ff          	cmpl   $0xffffffff,0x18(%ebx)
  80c036:	74 2f                	je     80c067 <err_tcp+0xbe>
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  80c038:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80c03b:	85 c0                	test   %eax,%eax
  80c03d:	74 15                	je     80c054 <err_tcp+0xab>
  80c03f:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80c046:	00 
  80c047:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80c04e:	00 
  80c04f:	89 1c 24             	mov    %ebx,(%esp)
  80c052:	ff d0                	call   *%eax
    sys_mbox_post(conn->acceptmbox, NULL);
  80c054:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80c05b:	00 
  80c05c:	8b 43 18             	mov    0x18(%ebx),%eax
  80c05f:	89 04 24             	mov    %eax,(%esp)
  80c062:	e8 ef ea ff ff       	call   80ab56 <sys_mbox_post>
  }
  if ((conn->state == NETCONN_WRITE) || (conn->state == NETCONN_CLOSE)) {
  80c067:	8b 43 04             	mov    0x4(%ebx),%eax
  80c06a:	83 f8 04             	cmp    $0x4,%eax
  80c06d:	74 05                	je     80c074 <err_tcp+0xcb>
  80c06f:	83 f8 01             	cmp    $0x1,%eax
  80c072:	75 12                	jne    80c086 <err_tcp+0xdd>
    /* calling do_writemore/do_close_internal is not necessary
       since the pcb has already been deleted! */
    conn->state = NETCONN_NONE;
  80c074:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    /* wake up the waiting task */
    sys_sem_signal(conn->op_completed);
  80c07b:	8b 43 10             	mov    0x10(%ebx),%eax
  80c07e:	89 04 24             	mov    %eax,(%esp)
  80c081:	e8 7a e8 ff ff       	call   80a900 <sys_sem_signal>
  }
}
  80c086:	83 c4 14             	add    $0x14,%esp
  80c089:	5b                   	pop    %ebx
  80c08a:	5d                   	pop    %ebp
  80c08b:	c3                   	ret    

0080c08c <do_writemore>:
 * @return ERR_OK
 *         ERR_MEM if LWIP_TCPIP_CORE_LOCKING=1 and sending hasn't yet finished
 */
static err_t
do_writemore(struct netconn *conn)
{
  80c08c:	55                   	push   %ebp
  80c08d:	89 e5                	mov    %esp,%ebp
  80c08f:	57                   	push   %edi
  80c090:	56                   	push   %esi
  80c091:	53                   	push   %ebx
  80c092:	83 ec 1c             	sub    $0x1c,%esp
  80c095:	89 c3                	mov    %eax,%ebx
  err_t err;
  void *dataptr;
  u16_t len, available;
  u8_t write_finished = 0;

  LWIP_ASSERT("conn->state == NETCONN_WRITE", (conn->state == NETCONN_WRITE));
  80c097:	83 78 04 01          	cmpl   $0x1,0x4(%eax)
  80c09b:	74 1c                	je     80c0b9 <do_writemore+0x2d>
  80c09d:	c7 44 24 08 9a 3d 81 	movl   $0x813d9a,0x8(%esp)
  80c0a4:	00 
  80c0a5:	c7 44 24 04 b8 03 00 	movl   $0x3b8,0x4(%esp)
  80c0ac:	00 
  80c0ad:	c7 04 24 3a 3d 81 00 	movl   $0x813d3a,(%esp)
  80c0b4:	e8 c1 2f 00 00       	call   80f07a <_panic>

  dataptr = (u8_t*)conn->write_msg->msg.w.dataptr + conn->write_offset;
  80c0b9:	8b 40 24             	mov    0x24(%eax),%eax
  80c0bc:	8b 53 28             	mov    0x28(%ebx),%edx
  80c0bf:	89 d1                	mov    %edx,%ecx
  80c0c1:	03 48 04             	add    0x4(%eax),%ecx
  if ((conn->write_msg->msg.w.len - conn->write_offset > 0xffff)) { /* max_u16_t */
  80c0c4:	8b 78 08             	mov    0x8(%eax),%edi
  80c0c7:	89 fe                	mov    %edi,%esi
  80c0c9:	29 d6                	sub    %edx,%esi
    len = 0xffff;
#if LWIP_TCPIP_CORE_LOCKING
    conn->write_delayed = 1;
#endif
  } else {
    len = conn->write_msg->msg.w.len - conn->write_offset;
  80c0cb:	29 d7                	sub    %edx,%edi
  80c0cd:	81 fe ff ff 00 00    	cmp    $0xffff,%esi
  80c0d3:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  80c0d8:	0f 4f fa             	cmovg  %edx,%edi
  }
  available = tcp_sndbuf(conn->pcb.tcp);
  80c0db:	8b 53 08             	mov    0x8(%ebx),%edx
  80c0de:	0f b7 72 6e          	movzwl 0x6e(%edx),%esi
  80c0e2:	66 39 f7             	cmp    %si,%di
  80c0e5:	0f 46 f7             	cmovbe %edi,%esi
#if LWIP_TCPIP_CORE_LOCKING
    conn->write_delayed = 1;
#endif
  }

  err = tcp_write(conn->pcb.tcp, dataptr, len, conn->write_msg->msg.w.apiflags);
  80c0e8:	0f b7 f6             	movzwl %si,%esi
  80c0eb:	0f b6 40 0c          	movzbl 0xc(%eax),%eax
  80c0ef:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80c0f3:	89 74 24 08          	mov    %esi,0x8(%esp)
  80c0f7:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  80c0fb:	89 14 24             	mov    %edx,(%esp)
  80c0fe:	e8 f2 c5 ff ff       	call   8086f5 <tcp_write>
  LWIP_ASSERT("do_writemore: invalid length!", ((conn->write_offset + len) <= conn->write_msg->msg.w.len));
  80c103:	89 f2                	mov    %esi,%edx
  80c105:	03 53 28             	add    0x28(%ebx),%edx
  80c108:	8b 4b 24             	mov    0x24(%ebx),%ecx
  80c10b:	3b 51 08             	cmp    0x8(%ecx),%edx
  80c10e:	7e 1c                	jle    80c12c <do_writemore+0xa0>
  80c110:	c7 44 24 08 b7 3d 81 	movl   $0x813db7,0x8(%esp)
  80c117:	00 
  80c118:	c7 44 24 04 cd 03 00 	movl   $0x3cd,0x4(%esp)
  80c11f:	00 
  80c120:	c7 04 24 3a 3d 81 00 	movl   $0x813d3a,(%esp)
  80c127:	e8 4e 2f 00 00       	call   80f07a <_panic>
  if (err == ERR_OK) {
  80c12c:	84 c0                	test   %al,%al
  80c12e:	75 6f                	jne    80c19f <do_writemore+0x113>
    conn->write_offset += len;
  80c130:	89 53 28             	mov    %edx,0x28(%ebx)
do_writemore(struct netconn *conn)
{
  err_t err;
  void *dataptr;
  u16_t len, available;
  u8_t write_finished = 0;
  80c133:	bf 00 00 00 00       	mov    $0x0,%edi

  err = tcp_write(conn->pcb.tcp, dataptr, len, conn->write_msg->msg.w.apiflags);
  LWIP_ASSERT("do_writemore: invalid length!", ((conn->write_offset + len) <= conn->write_msg->msg.w.len));
  if (err == ERR_OK) {
    conn->write_offset += len;
    if (conn->write_offset == conn->write_msg->msg.w.len) {
  80c138:	3b 51 08             	cmp    0x8(%ecx),%edx
  80c13b:	75 13                	jne    80c150 <do_writemore+0xc4>
      /* everything was written */
      write_finished = 1;
      conn->write_msg = NULL;
  80c13d:	c7 43 24 00 00 00 00 	movl   $0x0,0x24(%ebx)
      conn->write_offset = 0;
  80c144:	c7 43 28 00 00 00 00 	movl   $0x0,0x28(%ebx)
  LWIP_ASSERT("do_writemore: invalid length!", ((conn->write_offset + len) <= conn->write_msg->msg.w.len));
  if (err == ERR_OK) {
    conn->write_offset += len;
    if (conn->write_offset == conn->write_msg->msg.w.len) {
      /* everything was written */
      write_finished = 1;
  80c14b:	bf 01 00 00 00       	mov    $0x1,%edi
      conn->write_msg = NULL;
      conn->write_offset = 0;
    }
    err = tcp_output_nagle(conn->pcb.tcp);
  80c150:	8b 43 08             	mov    0x8(%ebx),%eax
  80c153:	83 78 78 00          	cmpl   $0x0,0x78(%eax)
  80c157:	74 12                	je     80c16b <do_writemore+0xdf>
  80c159:	f6 40 20 40          	testb  $0x40,0x20(%eax)
  80c15d:	75 0c                	jne    80c16b <do_writemore+0xdf>
  80c15f:	8b 50 74             	mov    0x74(%eax),%edx
  80c162:	85 d2                	test   %edx,%edx
  80c164:	74 69                	je     80c1cf <do_writemore+0x143>
  80c166:	83 3a 00             	cmpl   $0x0,(%edx)
  80c169:	74 64                	je     80c1cf <do_writemore+0x143>
  80c16b:	89 04 24             	mov    %eax,(%esp)
  80c16e:	e8 ee c5 ff ff       	call   808761 <tcp_output>
    conn->err = err;
  80c173:	88 43 0c             	mov    %al,0xc(%ebx)
    if ((err == ERR_OK) && (tcp_sndbuf(conn->pcb.tcp) <= TCP_SNDLOWAT)) {
  80c176:	84 c0                	test   %al,%al
  80c178:	75 3b                	jne    80c1b5 <do_writemore+0x129>
  80c17a:	8b 43 08             	mov    0x8(%ebx),%eax
  80c17d:	66 81 78 6e a0 2d    	cmpw   $0x2da0,0x6e(%eax)
  80c183:	77 30                	ja     80c1b5 <do_writemore+0x129>
      API_EVENT(conn, NETCONN_EVT_SENDMINUS, len);
  80c185:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80c188:	85 c0                	test   %eax,%eax
  80c18a:	74 29                	je     80c1b5 <do_writemore+0x129>
  80c18c:	89 74 24 08          	mov    %esi,0x8(%esp)
  80c190:	c7 44 24 04 03 00 00 	movl   $0x3,0x4(%esp)
  80c197:	00 
  80c198:	89 1c 24             	mov    %ebx,(%esp)
  80c19b:	ff d0                	call   *%eax
  80c19d:	eb 16                	jmp    80c1b5 <do_writemore+0x129>
    }
  } else if (err == ERR_MEM) {
  80c19f:	3c ff                	cmp    $0xff,%al
  80c1a1:	75 0d                	jne    80c1b0 <do_writemore+0x124>
    /* If ERR_MEM, we wait for sent_tcp or poll_tcp to be called
       we do NOT return to the application thread, since ERR_MEM is
       only a temporary error! */

    /* tcp_enqueue returned ERR_MEM, try tcp_output anyway */
    err = tcp_output(conn->pcb.tcp);
  80c1a3:	8b 43 08             	mov    0x8(%ebx),%eax
  80c1a6:	89 04 24             	mov    %eax,(%esp)
  80c1a9:	e8 b3 c5 ff ff       	call   808761 <tcp_output>
  80c1ae:	eb 25                	jmp    80c1d5 <do_writemore+0x149>
    conn->write_delayed = 1;
#endif
  } else {
    /* On errors != ERR_MEM, we don't try writing any more but return
       the error to the application thread. */
    conn->err = err;
  80c1b0:	88 43 0c             	mov    %al,0xc(%ebx)
  80c1b3:	eb 06                	jmp    80c1bb <do_writemore+0x12f>
    write_finished = 1;
  }

  if (write_finished) {
  80c1b5:	89 f8                	mov    %edi,%eax
  80c1b7:	84 c0                	test   %al,%al
  80c1b9:	74 1a                	je     80c1d5 <do_writemore+0x149>
    /* everything was written: set back connection state
       and back to application task */
    conn->state = NETCONN_NONE;
  80c1bb:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
#if LWIP_TCPIP_CORE_LOCKING
    if (conn->write_delayed != 0)
#endif
    {
      sys_sem_signal(conn->op_completed);
  80c1c2:	8b 43 10             	mov    0x10(%ebx),%eax
  80c1c5:	89 04 24             	mov    %eax,(%esp)
  80c1c8:	e8 33 e7 ff ff       	call   80a900 <sys_sem_signal>
  80c1cd:	eb 06                	jmp    80c1d5 <do_writemore+0x149>
      write_finished = 1;
      conn->write_msg = NULL;
      conn->write_offset = 0;
    }
    err = tcp_output_nagle(conn->pcb.tcp);
    conn->err = err;
  80c1cf:	c6 43 0c 00          	movb   $0x0,0xc(%ebx)
  80c1d3:	eb a5                	jmp    80c17a <do_writemore+0xee>
#if LWIP_TCPIP_CORE_LOCKING
  else
    return ERR_MEM;
#endif
  return ERR_OK;
}
  80c1d5:	b8 00 00 00 00       	mov    $0x0,%eax
  80c1da:	83 c4 1c             	add    $0x1c,%esp
  80c1dd:	5b                   	pop    %ebx
  80c1de:	5e                   	pop    %esi
  80c1df:	5f                   	pop    %edi
  80c1e0:	5d                   	pop    %ebp
  80c1e1:	c3                   	ret    

0080c1e2 <do_close_internal>:
 *
 * @param conn the TCP netconn to close
 */
static void
do_close_internal(struct netconn *conn)
{
  80c1e2:	55                   	push   %ebp
  80c1e3:	89 e5                	mov    %esp,%ebp
  80c1e5:	53                   	push   %ebx
  80c1e6:	83 ec 14             	sub    $0x14,%esp
  80c1e9:	89 c3                	mov    %eax,%ebx
  err_t err;

  LWIP_ASSERT("invalid conn", (conn != NULL));
  80c1eb:	85 c0                	test   %eax,%eax
  80c1ed:	75 1c                	jne    80c20b <do_close_internal+0x29>
  80c1ef:	c7 44 24 08 a8 3b 81 	movl   $0x813ba8,0x8(%esp)
  80c1f6:	00 
  80c1f7:	c7 44 24 04 53 02 00 	movl   $0x253,0x4(%esp)
  80c1fe:	00 
  80c1ff:	c7 04 24 3a 3d 81 00 	movl   $0x813d3a,(%esp)
  80c206:	e8 6f 2e 00 00       	call   80f07a <_panic>
  LWIP_ASSERT("this is for tcp netconns only", (conn->type == NETCONN_TCP));
  80c20b:	83 38 10             	cmpl   $0x10,(%eax)
  80c20e:	74 1c                	je     80c22c <do_close_internal+0x4a>
  80c210:	c7 44 24 08 d5 3d 81 	movl   $0x813dd5,0x8(%esp)
  80c217:	00 
  80c218:	c7 44 24 04 54 02 00 	movl   $0x254,0x4(%esp)
  80c21f:	00 
  80c220:	c7 04 24 3a 3d 81 00 	movl   $0x813d3a,(%esp)
  80c227:	e8 4e 2e 00 00       	call   80f07a <_panic>
  LWIP_ASSERT("conn must be in state NETCONN_CLOSE", (conn->state == NETCONN_CLOSE));
  80c22c:	83 78 04 04          	cmpl   $0x4,0x4(%eax)
  80c230:	74 1c                	je     80c24e <do_close_internal+0x6c>
  80c232:	c7 44 24 08 78 3c 81 	movl   $0x813c78,0x8(%esp)
  80c239:	00 
  80c23a:	c7 44 24 04 55 02 00 	movl   $0x255,0x4(%esp)
  80c241:	00 
  80c242:	c7 04 24 3a 3d 81 00 	movl   $0x813d3a,(%esp)
  80c249:	e8 2c 2e 00 00       	call   80f07a <_panic>
  LWIP_ASSERT("pcb already closed", (conn->pcb.tcp != NULL));
  80c24e:	8b 40 08             	mov    0x8(%eax),%eax
  80c251:	85 c0                	test   %eax,%eax
  80c253:	75 1c                	jne    80c271 <do_close_internal+0x8f>
  80c255:	c7 44 24 08 f3 3d 81 	movl   $0x813df3,0x8(%esp)
  80c25c:	00 
  80c25d:	c7 44 24 04 56 02 00 	movl   $0x256,0x4(%esp)
  80c264:	00 
  80c265:	c7 04 24 3a 3d 81 00 	movl   $0x813d3a,(%esp)
  80c26c:	e8 09 2e 00 00       	call   80f07a <_panic>

  /* Set back some callback pointers */
  tcp_arg(conn->pcb.tcp, NULL);
  80c271:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80c278:	00 
  80c279:	89 04 24             	mov    %eax,(%esp)
  80c27c:	e8 0b 9c ff ff       	call   805e8c <tcp_arg>
  if (conn->pcb.tcp->state == LISTEN) {
  80c281:	8b 43 08             	mov    0x8(%ebx),%eax
  80c284:	83 78 10 01          	cmpl   $0x1,0x10(%eax)
  80c288:	75 12                	jne    80c29c <do_close_internal+0xba>
    tcp_accept(conn->pcb.tcp, NULL);
  80c28a:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80c291:	00 
  80c292:	89 04 24             	mov    %eax,(%esp)
  80c295:	e8 33 9c ff ff       	call   805ecd <tcp_accept>
  80c29a:	eb 64                	jmp    80c300 <do_close_internal+0x11e>
  } else {
    tcp_recv(conn->pcb.tcp, NULL);
  80c29c:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80c2a3:	00 
  80c2a4:	89 04 24             	mov    %eax,(%esp)
  80c2a7:	e8 ee 9b ff ff       	call   805e9a <tcp_recv>
    tcp_accept(conn->pcb.tcp, NULL);
  80c2ac:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80c2b3:	00 
  80c2b4:	8b 43 08             	mov    0x8(%ebx),%eax
  80c2b7:	89 04 24             	mov    %eax,(%esp)
  80c2ba:	e8 0e 9c ff ff       	call   805ecd <tcp_accept>
    /* some callbacks have to be reset if tcp_close is not successful */
    tcp_sent(conn->pcb.tcp, NULL);
  80c2bf:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80c2c6:	00 
  80c2c7:	8b 43 08             	mov    0x8(%ebx),%eax
  80c2ca:	89 04 24             	mov    %eax,(%esp)
  80c2cd:	e8 d9 9b ff ff       	call   805eab <tcp_sent>
    tcp_poll(conn->pcb.tcp, NULL, 4);
  80c2d2:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  80c2d9:	00 
  80c2da:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80c2e1:	00 
  80c2e2:	8b 43 08             	mov    0x8(%ebx),%eax
  80c2e5:	89 04 24             	mov    %eax,(%esp)
  80c2e8:	e8 ee 9b ff ff       	call   805edb <tcp_poll>
    tcp_err(conn->pcb.tcp, NULL);
  80c2ed:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80c2f4:	00 
  80c2f5:	8b 43 08             	mov    0x8(%ebx),%eax
  80c2f8:	89 04 24             	mov    %eax,(%esp)
  80c2fb:	e8 bc 9b ff ff       	call   805ebc <tcp_err>
  }
  /* Try to close the connection */
  err = tcp_close(conn->pcb.tcp);
  80c300:	8b 43 08             	mov    0x8(%ebx),%eax
  80c303:	89 04 24             	mov    %eax,(%esp)
  80c306:	e8 4e 9d ff ff       	call   806059 <tcp_close>
  if (err == ERR_OK) {
  80c30b:	84 c0                	test   %al,%al
  80c30d:	75 57                	jne    80c366 <do_close_internal+0x184>
    /* Closing succeeded */
    conn->state = NETCONN_NONE;
  80c30f:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    /* Set back some callback pointers as conn is going away */
    conn->pcb.tcp = NULL;
  80c316:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    conn->err = ERR_OK;
  80c31d:	c6 43 0c 00          	movb   $0x0,0xc(%ebx)
    /* Trigger select() in socket layer. This send should something else so the
       errorfd is set, not the read and write fd! */
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  80c321:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80c324:	85 c0                	test   %eax,%eax
  80c326:	74 31                	je     80c359 <do_close_internal+0x177>
  80c328:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80c32f:	00 
  80c330:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80c337:	00 
  80c338:	89 1c 24             	mov    %ebx,(%esp)
  80c33b:	ff d0                	call   *%eax
    API_EVENT(conn, NETCONN_EVT_SENDPLUS, 0);
  80c33d:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80c340:	85 c0                	test   %eax,%eax
  80c342:	74 15                	je     80c359 <do_close_internal+0x177>
  80c344:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80c34b:	00 
  80c34c:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
  80c353:	00 
  80c354:	89 1c 24             	mov    %ebx,(%esp)
  80c357:	ff d0                	call   *%eax
    /* wake up the application task */
    sys_sem_signal(conn->op_completed);
  80c359:	8b 43 10             	mov    0x10(%ebx),%eax
  80c35c:	89 04 24             	mov    %eax,(%esp)
  80c35f:	e8 9c e5 ff ff       	call   80a900 <sys_sem_signal>
  80c364:	eb 72                	jmp    80c3d8 <do_close_internal+0x1f6>
  } else {
    /* Closing failed, restore some of the callbacks */
    /* Closing of listen pcb will never fail! */
    LWIP_ASSERT("Closing a listen pcb may not fail!", (conn->pcb.tcp->state != LISTEN));
  80c366:	8b 43 08             	mov    0x8(%ebx),%eax
  80c369:	83 78 10 01          	cmpl   $0x1,0x10(%eax)
  80c36d:	75 1c                	jne    80c38b <do_close_internal+0x1a9>
  80c36f:	c7 44 24 08 9c 3c 81 	movl   $0x813c9c,0x8(%esp)
  80c376:	00 
  80c377:	c7 44 24 04 75 02 00 	movl   $0x275,0x4(%esp)
  80c37e:	00 
  80c37f:	c7 04 24 3a 3d 81 00 	movl   $0x813d3a,(%esp)
  80c386:	e8 ef 2c 00 00       	call   80f07a <_panic>
    tcp_sent(conn->pcb.tcp, sent_tcp);
  80c38b:	c7 44 24 04 2c c4 80 	movl   $0x80c42c,0x4(%esp)
  80c392:	00 
  80c393:	89 04 24             	mov    %eax,(%esp)
  80c396:	e8 10 9b ff ff       	call   805eab <tcp_sent>
    tcp_poll(conn->pcb.tcp, poll_tcp, 4);
  80c39b:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  80c3a2:	00 
  80c3a3:	c7 44 24 04 de c3 80 	movl   $0x80c3de,0x4(%esp)
  80c3aa:	00 
  80c3ab:	8b 43 08             	mov    0x8(%ebx),%eax
  80c3ae:	89 04 24             	mov    %eax,(%esp)
  80c3b1:	e8 25 9b ff ff       	call   805edb <tcp_poll>
    tcp_err(conn->pcb.tcp, err_tcp);
  80c3b6:	c7 44 24 04 a9 bf 80 	movl   $0x80bfa9,0x4(%esp)
  80c3bd:	00 
  80c3be:	8b 43 08             	mov    0x8(%ebx),%eax
  80c3c1:	89 04 24             	mov    %eax,(%esp)
  80c3c4:	e8 f3 9a ff ff       	call   805ebc <tcp_err>
    tcp_arg(conn->pcb.tcp, conn);
  80c3c9:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80c3cd:	8b 43 08             	mov    0x8(%ebx),%eax
  80c3d0:	89 04 24             	mov    %eax,(%esp)
  80c3d3:	e8 b4 9a ff ff       	call   805e8c <tcp_arg>
  }
  /* If closing didn't succeed, we get called again either
     from poll_tcp or from sent_tcp */
}
  80c3d8:	83 c4 14             	add    $0x14,%esp
  80c3db:	5b                   	pop    %ebx
  80c3dc:	5d                   	pop    %ebp
  80c3dd:	c3                   	ret    

0080c3de <poll_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.poll) for parameters and return value
 */
static err_t
poll_tcp(void *arg, struct tcp_pcb *pcb)
{
  80c3de:	55                   	push   %ebp
  80c3df:	89 e5                	mov    %esp,%ebp
  80c3e1:	83 ec 18             	sub    $0x18,%esp
  80c3e4:	8b 45 08             	mov    0x8(%ebp),%eax
  struct netconn *conn = arg;

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  80c3e7:	85 c0                	test   %eax,%eax
  80c3e9:	75 1c                	jne    80c407 <poll_tcp+0x29>
  80c3eb:	c7 44 24 08 8d 3d 81 	movl   $0x813d8d,0x8(%esp)
  80c3f2:	00 
  80c3f3:	c7 44 24 04 eb 00 00 	movl   $0xeb,0x4(%esp)
  80c3fa:	00 
  80c3fb:	c7 04 24 3a 3d 81 00 	movl   $0x813d3a,(%esp)
  80c402:	e8 73 2c 00 00       	call   80f07a <_panic>

  if (conn->state == NETCONN_WRITE) {
  80c407:	8b 50 04             	mov    0x4(%eax),%edx
  80c40a:	83 fa 01             	cmp    $0x1,%edx
  80c40d:	75 07                	jne    80c416 <poll_tcp+0x38>
    do_writemore(conn);
  80c40f:	e8 78 fc ff ff       	call   80c08c <do_writemore>
  80c414:	eb 0f                	jmp    80c425 <poll_tcp+0x47>
  } else if (conn->state == NETCONN_CLOSE) {
  80c416:	83 fa 04             	cmp    $0x4,%edx
  80c419:	75 0a                	jne    80c425 <poll_tcp+0x47>
    do_close_internal(conn);
  80c41b:	90                   	nop
  80c41c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  80c420:	e8 bd fd ff ff       	call   80c1e2 <do_close_internal>
  }

  return ERR_OK;
}
  80c425:	b8 00 00 00 00       	mov    $0x0,%eax
  80c42a:	c9                   	leave  
  80c42b:	c3                   	ret    

0080c42c <sent_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.sent) for parameters and return value
 */
static err_t
sent_tcp(void *arg, struct tcp_pcb *pcb, u16_t len)
{
  80c42c:	55                   	push   %ebp
  80c42d:	89 e5                	mov    %esp,%ebp
  80c42f:	56                   	push   %esi
  80c430:	53                   	push   %ebx
  80c431:	83 ec 10             	sub    $0x10,%esp
  80c434:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80c437:	8b 75 10             	mov    0x10(%ebp),%esi
  struct netconn *conn = arg;

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  80c43a:	85 db                	test   %ebx,%ebx
  80c43c:	75 1c                	jne    80c45a <sent_tcp+0x2e>
  80c43e:	c7 44 24 08 8d 3d 81 	movl   $0x813d8d,0x8(%esp)
  80c445:	00 
  80c446:	c7 44 24 04 03 01 00 	movl   $0x103,0x4(%esp)
  80c44d:	00 
  80c44e:	c7 04 24 3a 3d 81 00 	movl   $0x813d3a,(%esp)
  80c455:	e8 20 2c 00 00       	call   80f07a <_panic>

  if (conn->state == NETCONN_WRITE) {
  80c45a:	8b 43 04             	mov    0x4(%ebx),%eax
  80c45d:	83 f8 01             	cmp    $0x1,%eax
  80c460:	75 2b                	jne    80c48d <sent_tcp+0x61>
    LWIP_ASSERT("conn->pcb.tcp != NULL", conn->pcb.tcp != NULL);
  80c462:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
  80c466:	75 1c                	jne    80c484 <sent_tcp+0x58>
  80c468:	c7 44 24 08 06 3e 81 	movl   $0x813e06,0x8(%esp)
  80c46f:	00 
  80c470:	c7 44 24 04 06 01 00 	movl   $0x106,0x4(%esp)
  80c477:	00 
  80c478:	c7 04 24 3a 3d 81 00 	movl   $0x813d3a,(%esp)
  80c47f:	e8 f6 2b 00 00       	call   80f07a <_panic>
    do_writemore(conn);
  80c484:	89 d8                	mov    %ebx,%eax
  80c486:	e8 01 fc ff ff       	call   80c08c <do_writemore>
  80c48b:	eb 33                	jmp    80c4c0 <sent_tcp+0x94>
  } else if (conn->state == NETCONN_CLOSE) {
  80c48d:	83 f8 04             	cmp    $0x4,%eax
  80c490:	75 2e                	jne    80c4c0 <sent_tcp+0x94>
    do_close_internal(conn);
  80c492:	89 d8                	mov    %ebx,%eax
  80c494:	e8 49 fd ff ff       	call   80c1e2 <do_close_internal>
  80c499:	eb 25                	jmp    80c4c0 <sent_tcp+0x94>
  }

  if (conn) {
    if ((conn->pcb.tcp != NULL) && (tcp_sndbuf(conn->pcb.tcp) > TCP_SNDLOWAT)) {
  80c49b:	66 81 78 6e a0 2d    	cmpw   $0x2da0,0x6e(%eax)
  80c4a1:	76 24                	jbe    80c4c7 <sent_tcp+0x9b>
      API_EVENT(conn, NETCONN_EVT_SENDPLUS, len);
  80c4a3:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80c4a6:	85 c0                	test   %eax,%eax
  80c4a8:	74 1d                	je     80c4c7 <sent_tcp+0x9b>
  80c4aa:	0f b7 f6             	movzwl %si,%esi
  80c4ad:	89 74 24 08          	mov    %esi,0x8(%esp)
  80c4b1:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
  80c4b8:	00 
  80c4b9:	89 1c 24             	mov    %ebx,(%esp)
  80c4bc:	ff d0                	call   *%eax
  80c4be:	eb 07                	jmp    80c4c7 <sent_tcp+0x9b>
  } else if (conn->state == NETCONN_CLOSE) {
    do_close_internal(conn);
  }

  if (conn) {
    if ((conn->pcb.tcp != NULL) && (tcp_sndbuf(conn->pcb.tcp) > TCP_SNDLOWAT)) {
  80c4c0:	8b 43 08             	mov    0x8(%ebx),%eax
  80c4c3:	85 c0                	test   %eax,%eax
  80c4c5:	75 d4                	jne    80c49b <sent_tcp+0x6f>
      API_EVENT(conn, NETCONN_EVT_SENDPLUS, len);
    }
  }
  
  return ERR_OK;
}
  80c4c7:	b8 00 00 00 00       	mov    $0x0,%eax
  80c4cc:	83 c4 10             	add    $0x10,%esp
  80c4cf:	5b                   	pop    %ebx
  80c4d0:	5e                   	pop    %esi
  80c4d1:	5d                   	pop    %ebp
  80c4d2:	c3                   	ret    

0080c4d3 <do_newconn>:
 *
 * @param msg the api_msg_msg describing the connection type
 */
void
do_newconn(struct api_msg_msg *msg)
{
  80c4d3:	55                   	push   %ebp
  80c4d4:	89 e5                	mov    %esp,%ebp
  80c4d6:	56                   	push   %esi
  80c4d7:	53                   	push   %ebx
  80c4d8:	83 ec 10             	sub    $0x10,%esp
  80c4db:	8b 5d 08             	mov    0x8(%ebp),%ebx
   if(msg->conn->pcb.tcp == NULL) {
  80c4de:	8b 03                	mov    (%ebx),%eax
  80c4e0:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  80c4e4:	0f 85 dc 00 00 00    	jne    80c5c6 <do_newconn+0xf3>
 * @return msg->conn->err, but the return value is currently ignored
 */
static err_t
pcb_new(struct api_msg_msg *msg)
{
   msg->conn->err = ERR_OK;
  80c4ea:	c6 40 0c 00          	movb   $0x0,0xc(%eax)

   LWIP_ASSERT("pcb_new: pcb already allocated", msg->conn->pcb.tcp == NULL);
  80c4ee:	8b 33                	mov    (%ebx),%esi
  80c4f0:	83 7e 08 00          	cmpl   $0x0,0x8(%esi)
  80c4f4:	74 1c                	je     80c512 <do_newconn+0x3f>
  80c4f6:	c7 44 24 08 c0 3c 81 	movl   $0x813cc0,0x8(%esp)
  80c4fd:	00 
  80c4fe:	c7 44 24 04 8a 01 00 	movl   $0x18a,0x4(%esp)
  80c505:	00 
  80c506:	c7 04 24 3a 3d 81 00 	movl   $0x813d3a,(%esp)
  80c50d:	e8 68 2b 00 00       	call   80f07a <_panic>

   /* Allocate a PCB for this connection */
   switch(NETCONNTYPE_GROUP(msg->conn->type)) {
  80c512:	8b 06                	mov    (%esi),%eax
  80c514:	25 f0 00 00 00       	and    $0xf0,%eax
  80c519:	83 f8 20             	cmp    $0x20,%eax
  80c51c:	74 48                	je     80c566 <do_newconn+0x93>
  80c51e:	83 f8 40             	cmp    $0x40,%eax
  80c521:	74 0f                	je     80c532 <do_newconn+0x5f>
  80c523:	83 f8 10             	cmp    $0x10,%eax
  80c526:	0f 85 96 00 00 00    	jne    80c5c2 <do_newconn+0xef>
  80c52c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  80c530:	eb 6f                	jmp    80c5a1 <do_newconn+0xce>
#if LWIP_RAW
   case NETCONN_RAW:
     msg->conn->pcb.raw = raw_new(msg->msg.n.proto);
  80c532:	0f b6 43 04          	movzbl 0x4(%ebx),%eax
  80c536:	89 04 24             	mov    %eax,(%esp)
  80c539:	e8 12 25 00 00       	call   80ea50 <raw_new>
  80c53e:	89 46 08             	mov    %eax,0x8(%esi)
     if(msg->conn->pcb.raw == NULL) {
  80c541:	8b 03                	mov    (%ebx),%eax
  80c543:	8b 50 08             	mov    0x8(%eax),%edx
  80c546:	85 d2                	test   %edx,%edx
  80c548:	75 06                	jne    80c550 <do_newconn+0x7d>
       msg->conn->err = ERR_MEM;
  80c54a:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  80c54e:	eb 76                	jmp    80c5c6 <do_newconn+0xf3>
       break;
     }
     raw_recv(msg->conn->pcb.raw, recv_raw, msg->conn);
  80c550:	89 44 24 08          	mov    %eax,0x8(%esp)
  80c554:	c7 44 24 04 0f be 80 	movl   $0x80be0f,0x4(%esp)
  80c55b:	00 
  80c55c:	89 14 24             	mov    %edx,(%esp)
  80c55f:	e8 47 23 00 00       	call   80e8ab <raw_recv>
  80c564:	eb 60                	jmp    80c5c6 <do_newconn+0xf3>
     break;
#endif /* LWIP_RAW */
#if LWIP_UDP
   case NETCONN_UDP:
     msg->conn->pcb.udp = udp_new();
  80c566:	e8 b9 d2 ff ff       	call   809824 <udp_new>
  80c56b:	89 46 08             	mov    %eax,0x8(%esi)
     if(msg->conn->pcb.udp == NULL) {
  80c56e:	8b 03                	mov    (%ebx),%eax
  80c570:	8b 50 08             	mov    0x8(%eax),%edx
  80c573:	85 d2                	test   %edx,%edx
  80c575:	75 06                	jne    80c57d <do_newconn+0xaa>
       msg->conn->err = ERR_MEM;
  80c577:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  80c57b:	eb 49                	jmp    80c5c6 <do_newconn+0xf3>
#if LWIP_UDPLITE
     if (msg->conn->type==NETCONN_UDPLITE) {
       udp_setflags(msg->conn->pcb.udp, UDP_FLAGS_UDPLITE);
     }
#endif /* LWIP_UDPLITE */
     if (msg->conn->type==NETCONN_UDPNOCHKSUM) {
  80c57d:	83 38 22             	cmpl   $0x22,(%eax)
  80c580:	75 04                	jne    80c586 <do_newconn+0xb3>
       udp_setflags(msg->conn->pcb.udp, UDP_FLAGS_NOCHKSUM);
  80c582:	c6 42 10 01          	movb   $0x1,0x10(%edx)
     }
     udp_recv(msg->conn->pcb.udp, recv_udp, msg->conn);
  80c586:	8b 03                	mov    (%ebx),%eax
  80c588:	89 44 24 08          	mov    %eax,0x8(%esp)
  80c58c:	c7 44 24 04 10 bd 80 	movl   $0x80bd10,0x4(%esp)
  80c593:	00 
  80c594:	8b 40 08             	mov    0x8(%eax),%eax
  80c597:	89 04 24             	mov    %eax,(%esp)
  80c59a:	e8 2b d2 ff ff       	call   8097ca <udp_recv>
  80c59f:	eb 25                	jmp    80c5c6 <do_newconn+0xf3>
     break;
#endif /* LWIP_UDP */
#if LWIP_TCP
   case NETCONN_TCP:
     msg->conn->pcb.tcp = tcp_new();
  80c5a1:	e8 2f a3 ff ff       	call   8068d5 <tcp_new>
  80c5a6:	89 46 08             	mov    %eax,0x8(%esi)
     if(msg->conn->pcb.tcp == NULL) {
  80c5a9:	8b 03                	mov    (%ebx),%eax
  80c5ab:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  80c5af:	75 06                	jne    80c5b7 <do_newconn+0xe4>
       msg->conn->err = ERR_MEM;
  80c5b1:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  80c5b5:	eb 0f                	jmp    80c5c6 <do_newconn+0xf3>
       break;
     }
     setup_tcp(msg->conn);
  80c5b7:	e8 41 f9 ff ff       	call   80befd <setup_tcp>
  80c5bc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  80c5c0:	eb 04                	jmp    80c5c6 <do_newconn+0xf3>
     break;
#endif /* LWIP_TCP */
   default:
     /* Unsupported netconn type, e.g. protocol disabled */
     msg->conn->err = ERR_VAL;
  80c5c2:	c6 46 0c f7          	movb   $0xf7,0xc(%esi)
   }
   /* Else? This "new" connection already has a PCB allocated. */
   /* Is this an error condition? Should it be deleted? */
   /* We currently just are happy and return. */

   TCPIP_APIMSG_ACK(msg);
  80c5c6:	8b 03                	mov    (%ebx),%eax
  80c5c8:	8b 40 10             	mov    0x10(%eax),%eax
  80c5cb:	89 04 24             	mov    %eax,(%esp)
  80c5ce:	e8 2d e3 ff ff       	call   80a900 <sys_sem_signal>
}
  80c5d3:	83 c4 10             	add    $0x10,%esp
  80c5d6:	5b                   	pop    %ebx
  80c5d7:	5e                   	pop    %esi
  80c5d8:	5d                   	pop    %ebp
  80c5d9:	c3                   	ret    

0080c5da <netconn_alloc>:
 * @return a newly allocated struct netconn or
 *         NULL on memory error
 */
struct netconn*
netconn_alloc(enum netconn_type t, netconn_callback callback)
{
  80c5da:	55                   	push   %ebp
  80c5db:	89 e5                	mov    %esp,%ebp
  80c5dd:	53                   	push   %ebx
  80c5de:	83 ec 14             	sub    $0x14,%esp
  struct netconn *conn;
  int size;

  conn = memp_malloc(MEMP_NETCONN);
  80c5e1:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
  80c5e8:	e8 f5 83 ff ff       	call   8049e2 <memp_malloc>
  80c5ed:	89 c3                	mov    %eax,%ebx
  if (conn == NULL) {
  80c5ef:	85 c0                	test   %eax,%eax
  80c5f1:	0f 84 96 00 00 00    	je     80c68d <netconn_alloc+0xb3>
    return NULL;
  }

  conn->err = ERR_OK;
  80c5f7:	c6 40 0c 00          	movb   $0x0,0xc(%eax)
  conn->type = t;
  80c5fb:	8b 45 08             	mov    0x8(%ebp),%eax
  80c5fe:	89 03                	mov    %eax,(%ebx)
  conn->pcb.tcp = NULL;
  80c600:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    LWIP_ASSERT("netconn_alloc: undefined netconn_type", 0);
    break;
  }
#endif

  if ((conn->op_completed = sys_sem_new(0)) == SYS_SEM_NULL) {
  80c607:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80c60e:	e8 0b e0 ff ff       	call   80a61e <sys_sem_new>
  80c613:	89 43 10             	mov    %eax,0x10(%ebx)
  80c616:	83 f8 ff             	cmp    $0xffffffff,%eax
  80c619:	75 17                	jne    80c632 <netconn_alloc+0x58>
    memp_free(MEMP_NETCONN, conn);
  80c61b:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80c61f:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
  80c626:	e8 17 84 ff ff       	call   804a42 <memp_free>
    return NULL;
  80c62b:	b8 00 00 00 00       	mov    $0x0,%eax
  80c630:	eb 60                	jmp    80c692 <netconn_alloc+0xb8>
  }
  if ((conn->recvmbox = sys_mbox_new(size)) == SYS_MBOX_NULL) {
  80c632:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80c639:	e8 a8 e1 ff ff       	call   80a7e6 <sys_mbox_new>
  80c63e:	89 43 14             	mov    %eax,0x14(%ebx)
  80c641:	83 f8 ff             	cmp    $0xffffffff,%eax
  80c644:	75 22                	jne    80c668 <netconn_alloc+0x8e>
    sys_sem_free(conn->op_completed);
  80c646:	8b 43 10             	mov    0x10(%ebx),%eax
  80c649:	89 04 24             	mov    %eax,(%esp)
  80c64c:	e8 56 e0 ff ff       	call   80a6a7 <sys_sem_free>
    memp_free(MEMP_NETCONN, conn);
  80c651:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80c655:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
  80c65c:	e8 e1 83 ff ff       	call   804a42 <memp_free>
    return NULL;
  80c661:	b8 00 00 00 00       	mov    $0x0,%eax
  80c666:	eb 2a                	jmp    80c692 <netconn_alloc+0xb8>
  }

  conn->acceptmbox   = SYS_MBOX_NULL;
  80c668:	c7 43 18 ff ff ff ff 	movl   $0xffffffff,0x18(%ebx)
  conn->state        = NETCONN_NONE;
  80c66f:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  /* initialize socket to -1 since 0 is a valid socket */
  conn->socket       = -1;
  80c676:	c7 43 1c ff ff ff ff 	movl   $0xffffffff,0x1c(%ebx)
  conn->callback     = callback;
  80c67d:	8b 45 0c             	mov    0xc(%ebp),%eax
  80c680:	89 43 2c             	mov    %eax,0x2c(%ebx)
  conn->recv_avail   = 0;
  80c683:	66 c7 43 20 00 00    	movw   $0x0,0x20(%ebx)
  conn->recv_timeout = 0;
#endif /* LWIP_SO_RCVTIMEO */
#if LWIP_SO_RCVBUF
  conn->recv_bufsize = INT_MAX;
#endif /* LWIP_SO_RCVBUF */
  return conn;
  80c689:	89 d8                	mov    %ebx,%eax
  80c68b:	eb 05                	jmp    80c692 <netconn_alloc+0xb8>
  struct netconn *conn;
  int size;

  conn = memp_malloc(MEMP_NETCONN);
  if (conn == NULL) {
    return NULL;
  80c68d:	b8 00 00 00 00       	mov    $0x0,%eax
#endif /* LWIP_SO_RCVTIMEO */
#if LWIP_SO_RCVBUF
  conn->recv_bufsize = INT_MAX;
#endif /* LWIP_SO_RCVBUF */
  return conn;
}
  80c692:	83 c4 14             	add    $0x14,%esp
  80c695:	5b                   	pop    %ebx
  80c696:	5d                   	pop    %ebp
  80c697:	c3                   	ret    

0080c698 <netconn_free>:
 *
 * @param conn the netconn to free
 */
void
netconn_free(struct netconn *conn)
{
  80c698:	55                   	push   %ebp
  80c699:	89 e5                	mov    %esp,%ebp
  80c69b:	56                   	push   %esi
  80c69c:	53                   	push   %ebx
  80c69d:	83 ec 20             	sub    $0x20,%esp
  80c6a0:	8b 5d 08             	mov    0x8(%ebp),%ebx
  void *mem;
  LWIP_ASSERT("PCB must be deallocated outside this function", conn->pcb.tcp == NULL);
  80c6a3:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
  80c6a7:	74 1c                	je     80c6c5 <netconn_free+0x2d>
  80c6a9:	c7 44 24 08 e0 3c 81 	movl   $0x813ce0,0x8(%esp)
  80c6b0:	00 
  80c6b1:	c7 44 24 04 26 02 00 	movl   $0x226,0x4(%esp)
  80c6b8:	00 
  80c6b9:	c7 04 24 3a 3d 81 00 	movl   $0x813d3a,(%esp)
  80c6c0:	e8 b5 29 00 00       	call   80f07a <_panic>

  /* Drain the recvmbox. */
  if (conn->recvmbox != SYS_MBOX_NULL) {
    while (sys_mbox_tryfetch(conn->recvmbox, &mem) != SYS_MBOX_EMPTY) {
  80c6c5:	8d 75 f4             	lea    -0xc(%ebp),%esi
{
  void *mem;
  LWIP_ASSERT("PCB must be deallocated outside this function", conn->pcb.tcp == NULL);

  /* Drain the recvmbox. */
  if (conn->recvmbox != SYS_MBOX_NULL) {
  80c6c8:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80c6cc:	75 23                	jne    80c6f1 <netconn_free+0x59>
  80c6ce:	eb 47                	jmp    80c717 <netconn_free+0x7f>
    while (sys_mbox_tryfetch(conn->recvmbox, &mem) != SYS_MBOX_EMPTY) {
      if (conn->type == NETCONN_TCP) {
  80c6d0:	83 3b 10             	cmpl   $0x10,(%ebx)
  80c6d3:	75 11                	jne    80c6e6 <netconn_free+0x4e>
        if(mem != NULL) {
  80c6d5:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80c6d8:	85 c0                	test   %eax,%eax
  80c6da:	74 15                	je     80c6f1 <netconn_free+0x59>
          pbuf_free((struct pbuf *)mem);
  80c6dc:	89 04 24             	mov    %eax,(%esp)
  80c6df:	e8 10 87 ff ff       	call   804df4 <pbuf_free>
  80c6e4:	eb 0b                	jmp    80c6f1 <netconn_free+0x59>
        }
      } else {
        netbuf_delete((struct netbuf *)mem);
  80c6e6:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80c6e9:	89 04 24             	mov    %eax,(%esp)
  80c6ec:	e8 5b 61 ff ff       	call   80284c <netbuf_delete>
  void *mem;
  LWIP_ASSERT("PCB must be deallocated outside this function", conn->pcb.tcp == NULL);

  /* Drain the recvmbox. */
  if (conn->recvmbox != SYS_MBOX_NULL) {
    while (sys_mbox_tryfetch(conn->recvmbox, &mem) != SYS_MBOX_EMPTY) {
  80c6f1:	89 74 24 04          	mov    %esi,0x4(%esp)
  80c6f5:	8b 43 14             	mov    0x14(%ebx),%eax
  80c6f8:	89 04 24             	mov    %eax,(%esp)
  80c6fb:	e8 92 e5 ff ff       	call   80ac92 <sys_arch_mbox_tryfetch>
  80c700:	83 f8 ff             	cmp    $0xffffffff,%eax
  80c703:	75 cb                	jne    80c6d0 <netconn_free+0x38>
        }
      } else {
        netbuf_delete((struct netbuf *)mem);
      }
    }
    sys_mbox_free(conn->recvmbox);
  80c705:	8b 43 14             	mov    0x14(%ebx),%eax
  80c708:	89 04 24             	mov    %eax,(%esp)
  80c70b:	e8 2b e0 ff ff       	call   80a73b <sys_mbox_free>
    conn->recvmbox = SYS_MBOX_NULL;
  80c710:	c7 43 14 ff ff ff ff 	movl   $0xffffffff,0x14(%ebx)
  }

  /* Drain the acceptmbox. */
  if (conn->acceptmbox != SYS_MBOX_NULL) {
  80c717:	83 7b 18 ff          	cmpl   $0xffffffff,0x18(%ebx)
  80c71b:	74 36                	je     80c753 <netconn_free+0xbb>
    while (sys_mbox_tryfetch(conn->acceptmbox, &mem) != SYS_MBOX_EMPTY) {
  80c71d:	8d 75 f4             	lea    -0xc(%ebp),%esi
  80c720:	eb 0b                	jmp    80c72d <netconn_free+0x95>
      netconn_delete((struct netconn *)mem);
  80c722:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80c725:	89 04 24             	mov    %eax,(%esp)
  80c728:	e8 56 ef ff ff       	call   80b683 <netconn_delete>
    conn->recvmbox = SYS_MBOX_NULL;
  }

  /* Drain the acceptmbox. */
  if (conn->acceptmbox != SYS_MBOX_NULL) {
    while (sys_mbox_tryfetch(conn->acceptmbox, &mem) != SYS_MBOX_EMPTY) {
  80c72d:	89 74 24 04          	mov    %esi,0x4(%esp)
  80c731:	8b 43 18             	mov    0x18(%ebx),%eax
  80c734:	89 04 24             	mov    %eax,(%esp)
  80c737:	e8 56 e5 ff ff       	call   80ac92 <sys_arch_mbox_tryfetch>
  80c73c:	83 f8 ff             	cmp    $0xffffffff,%eax
  80c73f:	75 e1                	jne    80c722 <netconn_free+0x8a>
      netconn_delete((struct netconn *)mem);
    }
    sys_mbox_free(conn->acceptmbox);
  80c741:	8b 43 18             	mov    0x18(%ebx),%eax
  80c744:	89 04 24             	mov    %eax,(%esp)
  80c747:	e8 ef df ff ff       	call   80a73b <sys_mbox_free>
    conn->acceptmbox = SYS_MBOX_NULL;
  80c74c:	c7 43 18 ff ff ff ff 	movl   $0xffffffff,0x18(%ebx)
  }

  sys_sem_free(conn->op_completed);
  80c753:	8b 43 10             	mov    0x10(%ebx),%eax
  80c756:	89 04 24             	mov    %eax,(%esp)
  80c759:	e8 49 df ff ff       	call   80a6a7 <sys_sem_free>
  conn->op_completed = SYS_SEM_NULL;
  80c75e:	c7 43 10 ff ff ff ff 	movl   $0xffffffff,0x10(%ebx)

  memp_free(MEMP_NETCONN, conn);
  80c765:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80c769:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
  80c770:	e8 cd 82 ff ff       	call   804a42 <memp_free>
}
  80c775:	83 c4 20             	add    $0x20,%esp
  80c778:	5b                   	pop    %ebx
  80c779:	5e                   	pop    %esi
  80c77a:	5d                   	pop    %ebp
  80c77b:	c3                   	ret    

0080c77c <accept_function>:
 *
 * @see tcp.h (struct tcp_pcb_listen.accept) for parameters and return value
 */
static err_t
accept_function(void *arg, struct tcp_pcb *newpcb, err_t err)
{
  80c77c:	55                   	push   %ebp
  80c77d:	89 e5                	mov    %esp,%ebp
  80c77f:	57                   	push   %edi
  80c780:	56                   	push   %esi
  80c781:	53                   	push   %ebx
  80c782:	83 ec 1c             	sub    $0x1c,%esp
  80c785:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80c788:	8b 7d 10             	mov    0x10(%ebp),%edi
  tcp_debug_print_state(newpcb->state);
#endif /* TCP_DEBUG */
#endif /* API_MSG_DEBUG */
  conn = (struct netconn *)arg;

  LWIP_ERROR("accept_function: invalid conn->acceptmbox",
  80c78b:	83 7b 18 ff          	cmpl   $0xffffffff,0x18(%ebx)
  80c78f:	75 1c                	jne    80c7ad <accept_function+0x31>
  80c791:	c7 44 24 08 10 3d 81 	movl   $0x813d10,0x8(%esp)
  80c798:	00 
  80c799:	c7 44 24 04 65 01 00 	movl   $0x165,0x4(%esp)
  80c7a0:	00 
  80c7a1:	c7 04 24 3a 3d 81 00 	movl   $0x813d3a,(%esp)
  80c7a8:	e8 cd 28 00 00       	call   80f07a <_panic>
             conn->acceptmbox != SYS_MBOX_NULL, return ERR_VAL;);

  /* We have to set the callback here even though
   * the new socket is unknown. conn->socket is marked as -1. */
  newconn = netconn_alloc(conn->type, conn->callback);
  80c7ad:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80c7b0:	89 44 24 04          	mov    %eax,0x4(%esp)
  80c7b4:	8b 03                	mov    (%ebx),%eax
  80c7b6:	89 04 24             	mov    %eax,(%esp)
  80c7b9:	e8 1c fe ff ff       	call   80c5da <netconn_alloc>
  80c7be:	89 c6                	mov    %eax,%esi
  if (newconn == NULL) {
  80c7c0:	85 c0                	test   %eax,%eax
  80c7c2:	74 57                	je     80c81b <accept_function+0x9f>
    return ERR_MEM;
  }
  newconn->pcb.tcp = newpcb;
  80c7c4:	8b 45 0c             	mov    0xc(%ebp),%eax
  80c7c7:	89 46 08             	mov    %eax,0x8(%esi)
  setup_tcp(newconn);
  80c7ca:	89 f0                	mov    %esi,%eax
  80c7cc:	e8 2c f7 ff ff       	call   80befd <setup_tcp>
  newconn->err = err;
  80c7d1:	89 f8                	mov    %edi,%eax
  80c7d3:	88 46 0c             	mov    %al,0xc(%esi)
  /* Register event with callback */
  API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  80c7d6:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80c7d9:	85 c0                	test   %eax,%eax
  80c7db:	74 15                	je     80c7f2 <accept_function+0x76>
  80c7dd:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80c7e4:	00 
  80c7e5:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80c7ec:	00 
  80c7ed:	89 1c 24             	mov    %ebx,(%esp)
  80c7f0:	ff d0                	call   *%eax

  if (sys_mbox_trypost(conn->acceptmbox, newconn) != ERR_OK) {
  80c7f2:	89 74 24 04          	mov    %esi,0x4(%esp)
  80c7f6:	8b 43 18             	mov    0x18(%ebx),%eax
  80c7f9:	89 04 24             	mov    %eax,(%esp)
  80c7fc:	e8 8b e2 ff ff       	call   80aa8c <sys_mbox_trypost>
  80c801:	84 c0                	test   %al,%al
  80c803:	74 1d                	je     80c822 <accept_function+0xa6>
    /* When returning != ERR_OK, the connection is aborted in tcp_process(),
       so do nothing here! */
    newconn->pcb.tcp = NULL;
  80c805:	c7 46 08 00 00 00 00 	movl   $0x0,0x8(%esi)
    netconn_free(newconn);
  80c80c:	89 34 24             	mov    %esi,(%esp)
  80c80f:	e8 84 fe ff ff       	call   80c698 <netconn_free>
    return ERR_MEM;
  80c814:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80c819:	eb 0c                	jmp    80c827 <accept_function+0xab>

  /* We have to set the callback here even though
   * the new socket is unknown. conn->socket is marked as -1. */
  newconn = netconn_alloc(conn->type, conn->callback);
  if (newconn == NULL) {
    return ERR_MEM;
  80c81b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80c820:	eb 05                	jmp    80c827 <accept_function+0xab>
       so do nothing here! */
    newconn->pcb.tcp = NULL;
    netconn_free(newconn);
    return ERR_MEM;
  }
  return ERR_OK;
  80c822:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80c827:	83 c4 1c             	add    $0x1c,%esp
  80c82a:	5b                   	pop    %ebx
  80c82b:	5e                   	pop    %esi
  80c82c:	5f                   	pop    %edi
  80c82d:	5d                   	pop    %ebp
  80c82e:	c3                   	ret    

0080c82f <do_delconn>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_delconn(struct api_msg_msg *msg)
{
  80c82f:	55                   	push   %ebp
  80c830:	89 e5                	mov    %esp,%ebp
  80c832:	53                   	push   %ebx
  80c833:	83 ec 14             	sub    $0x14,%esp
  80c836:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (msg->conn->pcb.tcp != NULL) {
  80c839:	8b 03                	mov    (%ebx),%eax
  80c83b:	8b 48 08             	mov    0x8(%eax),%ecx
  80c83e:	85 c9                	test   %ecx,%ecx
  80c840:	74 4b                	je     80c88d <do_delconn+0x5e>
    switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80c842:	8b 10                	mov    (%eax),%edx
  80c844:	81 e2 f0 00 00 00    	and    $0xf0,%edx
  80c84a:	83 fa 20             	cmp    $0x20,%edx
  80c84d:	74 18                	je     80c867 <do_delconn+0x38>
  80c84f:	83 fa 40             	cmp    $0x40,%edx
  80c852:	74 07                	je     80c85b <do_delconn+0x2c>
  80c854:	83 fa 10             	cmp    $0x10,%edx
  80c857:	75 34                	jne    80c88d <do_delconn+0x5e>
  80c859:	eb 22                	jmp    80c87d <do_delconn+0x4e>
#if LWIP_RAW
    case NETCONN_RAW:
      raw_remove(msg->conn->pcb.raw);
  80c85b:	89 0c 24             	mov    %ecx,(%esp)
  80c85e:	66 90                	xchg   %ax,%ax
  80c860:	e8 a5 21 00 00       	call   80ea0a <raw_remove>
      break;
  80c865:	eb 26                	jmp    80c88d <do_delconn+0x5e>
#endif /* LWIP_RAW */
#if LWIP_UDP
    case NETCONN_UDP:
      msg->conn->pcb.udp->recv_arg = NULL;
  80c867:	c7 41 1c 00 00 00 00 	movl   $0x0,0x1c(%ecx)
      udp_remove(msg->conn->pcb.udp);
  80c86e:	8b 03                	mov    (%ebx),%eax
  80c870:	8b 40 08             	mov    0x8(%eax),%eax
  80c873:	89 04 24             	mov    %eax,(%esp)
  80c876:	e8 63 cf ff ff       	call   8097de <udp_remove>
      break;
  80c87b:	eb 10                	jmp    80c88d <do_delconn+0x5e>
#endif /* LWIP_UDP */
#if LWIP_TCP
    case NETCONN_TCP:
      msg->conn->state = NETCONN_CLOSE;
  80c87d:	c7 40 04 04 00 00 00 	movl   $0x4,0x4(%eax)
      do_close_internal(msg->conn);
  80c884:	8b 03                	mov    (%ebx),%eax
  80c886:	e8 57 f9 ff ff       	call   80c1e2 <do_close_internal>
      /* API_EVENT is called inside do_close_internal, before releasing
         the application thread, so we can return at this point! */
      return;
  80c88b:	eb 4e                	jmp    80c8db <do_delconn+0xac>
  }
  /* tcp netconns don't come here! */

  /* Trigger select() in socket layer. This send should something else so the
     errorfd is set, not the read and write fd! */
  API_EVENT(msg->conn, NETCONN_EVT_RCVPLUS, 0);
  80c88d:	8b 13                	mov    (%ebx),%edx
  80c88f:	8b 42 2c             	mov    0x2c(%edx),%eax
  80c892:	85 c0                	test   %eax,%eax
  80c894:	74 33                	je     80c8c9 <do_delconn+0x9a>
  80c896:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80c89d:	00 
  80c89e:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80c8a5:	00 
  80c8a6:	89 14 24             	mov    %edx,(%esp)
  80c8a9:	ff d0                	call   *%eax
  API_EVENT(msg->conn, NETCONN_EVT_SENDPLUS, 0);
  80c8ab:	8b 13                	mov    (%ebx),%edx
  80c8ad:	8b 42 2c             	mov    0x2c(%edx),%eax
  80c8b0:	85 c0                	test   %eax,%eax
  80c8b2:	74 15                	je     80c8c9 <do_delconn+0x9a>
  80c8b4:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80c8bb:	00 
  80c8bc:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
  80c8c3:	00 
  80c8c4:	89 14 24             	mov    %edx,(%esp)
  80c8c7:	ff d0                	call   *%eax

  if (msg->conn->op_completed != SYS_SEM_NULL) {
  80c8c9:	8b 03                	mov    (%ebx),%eax
  80c8cb:	8b 40 10             	mov    0x10(%eax),%eax
  80c8ce:	83 f8 ff             	cmp    $0xffffffff,%eax
  80c8d1:	74 08                	je     80c8db <do_delconn+0xac>
    sys_sem_signal(msg->conn->op_completed);
  80c8d3:	89 04 24             	mov    %eax,(%esp)
  80c8d6:	e8 25 e0 ff ff       	call   80a900 <sys_sem_signal>
  }
}
  80c8db:	83 c4 14             	add    $0x14,%esp
  80c8de:	5b                   	pop    %ebx
  80c8df:	5d                   	pop    %ebp
  80c8e0:	c3                   	ret    

0080c8e1 <do_bind>:
 * @param msg the api_msg_msg pointing to the connection and containing
 *            the IP address and port to bind to
 */
void
do_bind(struct api_msg_msg *msg)
{
  80c8e1:	55                   	push   %ebp
  80c8e2:	89 e5                	mov    %esp,%ebp
  80c8e4:	56                   	push   %esi
  80c8e5:	53                   	push   %ebx
  80c8e6:	83 ec 10             	sub    $0x10,%esp
  80c8e9:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80c8ec:	8b 33                	mov    (%ebx),%esi
  80c8ee:	80 7e 0c fc          	cmpb   $0xfc,0xc(%esi)
  80c8f2:	7c 6f                	jl     80c963 <do_bind+0x82>
    if (msg->conn->pcb.tcp != NULL) {
  80c8f4:	8b 56 08             	mov    0x8(%esi),%edx
  80c8f7:	85 d2                	test   %edx,%edx
  80c8f9:	74 64                	je     80c95f <do_bind+0x7e>
      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80c8fb:	8b 06                	mov    (%esi),%eax
  80c8fd:	25 f0 00 00 00       	and    $0xf0,%eax
  80c902:	83 f8 20             	cmp    $0x20,%eax
  80c905:	74 20                	je     80c927 <do_bind+0x46>
  80c907:	83 f8 40             	cmp    $0x40,%eax
  80c90a:	74 07                	je     80c913 <do_bind+0x32>
  80c90c:	83 f8 10             	cmp    $0x10,%eax
  80c90f:	75 52                	jne    80c963 <do_bind+0x82>
  80c911:	eb 30                	jmp    80c943 <do_bind+0x62>
#if LWIP_RAW
      case NETCONN_RAW:
        msg->conn->err = raw_bind(msg->conn->pcb.raw, msg->msg.bc.ipaddr);
  80c913:	8b 43 04             	mov    0x4(%ebx),%eax
  80c916:	89 44 24 04          	mov    %eax,0x4(%esp)
  80c91a:	89 14 24             	mov    %edx,(%esp)
  80c91d:	e8 4a 1f 00 00       	call   80e86c <raw_bind>
  80c922:	88 46 0c             	mov    %al,0xc(%esi)
        break;
  80c925:	eb 3c                	jmp    80c963 <do_bind+0x82>
#endif /* LWIP_RAW */
#if LWIP_UDP
      case NETCONN_UDP:
        msg->conn->err = udp_bind(msg->conn->pcb.udp, msg->msg.bc.ipaddr, msg->msg.bc.port);
  80c927:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  80c92b:	89 44 24 08          	mov    %eax,0x8(%esp)
  80c92f:	8b 43 04             	mov    0x4(%ebx),%eax
  80c932:	89 44 24 04          	mov    %eax,0x4(%esp)
  80c936:	89 14 24             	mov    %edx,(%esp)
  80c939:	e8 03 cb ff ff       	call   809441 <udp_bind>
  80c93e:	88 46 0c             	mov    %al,0xc(%esi)
        break;
  80c941:	eb 20                	jmp    80c963 <do_bind+0x82>
#endif /* LWIP_UDP */
#if LWIP_TCP
      case NETCONN_TCP:
        msg->conn->err = tcp_bind(msg->conn->pcb.tcp, msg->msg.bc.ipaddr, msg->msg.bc.port);
  80c943:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  80c947:	89 44 24 08          	mov    %eax,0x8(%esp)
  80c94b:	8b 43 04             	mov    0x4(%ebx),%eax
  80c94e:	89 44 24 04          	mov    %eax,0x4(%esp)
  80c952:	89 14 24             	mov    %edx,(%esp)
  80c955:	e8 a9 90 ff ff       	call   805a03 <tcp_bind>
  80c95a:	88 46 0c             	mov    %al,0xc(%esi)
        break;
  80c95d:	eb 04                	jmp    80c963 <do_bind+0x82>
      default:
        break;
      }
    } else {
      /* msg->conn->pcb is NULL */
      msg->conn->err = ERR_VAL;
  80c95f:	c6 46 0c f7          	movb   $0xf7,0xc(%esi)
    }
  }
  TCPIP_APIMSG_ACK(msg);
  80c963:	8b 03                	mov    (%ebx),%eax
  80c965:	8b 40 10             	mov    0x10(%eax),%eax
  80c968:	89 04 24             	mov    %eax,(%esp)
  80c96b:	e8 90 df ff ff       	call   80a900 <sys_sem_signal>
}
  80c970:	83 c4 10             	add    $0x10,%esp
  80c973:	5b                   	pop    %ebx
  80c974:	5e                   	pop    %esi
  80c975:	5d                   	pop    %ebp
  80c976:	c3                   	ret    

0080c977 <do_connect>:
 * @param msg the api_msg_msg pointing to the connection and containing
 *            the IP address and port to connect to
 */
void
do_connect(struct api_msg_msg *msg)
{
  80c977:	55                   	push   %ebp
  80c978:	89 e5                	mov    %esp,%ebp
  80c97a:	56                   	push   %esi
  80c97b:	53                   	push   %ebx
  80c97c:	83 ec 10             	sub    $0x10,%esp
  80c97f:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (msg->conn->pcb.tcp == NULL) {
  80c982:	8b 33                	mov    (%ebx),%esi
  80c984:	8b 56 08             	mov    0x8(%esi),%edx
  80c987:	85 d2                	test   %edx,%edx
  80c989:	75 10                	jne    80c99b <do_connect+0x24>
    sys_sem_signal(msg->conn->op_completed);
  80c98b:	8b 46 10             	mov    0x10(%esi),%eax
  80c98e:	89 04 24             	mov    %eax,(%esp)
  80c991:	e8 6a df ff ff       	call   80a900 <sys_sem_signal>
    return;
  80c996:	e9 9b 00 00 00       	jmp    80ca36 <do_connect+0xbf>
  }

  switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80c99b:	8b 06                	mov    (%esi),%eax
  80c99d:	25 f0 00 00 00       	and    $0xf0,%eax
  80c9a2:	83 f8 20             	cmp    $0x20,%eax
  80c9a5:	74 31                	je     80c9d8 <do_connect+0x61>
  80c9a7:	83 f8 40             	cmp    $0x40,%eax
  80c9aa:	74 0b                	je     80c9b7 <do_connect+0x40>
  80c9ac:	83 f8 10             	cmp    $0x10,%eax
  80c9af:	0f 85 81 00 00 00    	jne    80ca36 <do_connect+0xbf>
  80c9b5:	eb 4a                	jmp    80ca01 <do_connect+0x8a>
#if LWIP_RAW
  case NETCONN_RAW:
    msg->conn->err = raw_connect(msg->conn->pcb.raw, msg->msg.bc.ipaddr);
  80c9b7:	8b 43 04             	mov    0x4(%ebx),%eax
  80c9ba:	89 44 24 04          	mov    %eax,0x4(%esp)
  80c9be:	89 14 24             	mov    %edx,(%esp)
  80c9c1:	e8 c5 1e 00 00       	call   80e88b <raw_connect>
  80c9c6:	88 46 0c             	mov    %al,0xc(%esi)
    sys_sem_signal(msg->conn->op_completed);
  80c9c9:	8b 03                	mov    (%ebx),%eax
  80c9cb:	8b 40 10             	mov    0x10(%eax),%eax
  80c9ce:	89 04 24             	mov    %eax,(%esp)
  80c9d1:	e8 2a df ff ff       	call   80a900 <sys_sem_signal>
    break;
  80c9d6:	eb 5e                	jmp    80ca36 <do_connect+0xbf>
#endif /* LWIP_RAW */
#if LWIP_UDP
  case NETCONN_UDP:
    msg->conn->err = udp_connect(msg->conn->pcb.udp, msg->msg.bc.ipaddr, msg->msg.bc.port);
  80c9d8:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  80c9dc:	89 44 24 08          	mov    %eax,0x8(%esp)
  80c9e0:	8b 43 04             	mov    0x4(%ebx),%eax
  80c9e3:	89 44 24 04          	mov    %eax,0x4(%esp)
  80c9e7:	89 14 24             	mov    %edx,(%esp)
  80c9ea:	e8 46 cd ff ff       	call   809735 <udp_connect>
  80c9ef:	88 46 0c             	mov    %al,0xc(%esi)
    sys_sem_signal(msg->conn->op_completed);
  80c9f2:	8b 03                	mov    (%ebx),%eax
  80c9f4:	8b 40 10             	mov    0x10(%eax),%eax
  80c9f7:	89 04 24             	mov    %eax,(%esp)
  80c9fa:	e8 01 df ff ff       	call   80a900 <sys_sem_signal>
    break;
  80c9ff:	eb 35                	jmp    80ca36 <do_connect+0xbf>
#endif /* LWIP_UDP */
#if LWIP_TCP
  case NETCONN_TCP:
    msg->conn->state = NETCONN_CONNECT;
  80ca01:	c7 46 04 03 00 00 00 	movl   $0x3,0x4(%esi)
    setup_tcp(msg->conn);
  80ca08:	8b 03                	mov    (%ebx),%eax
  80ca0a:	e8 ee f4 ff ff       	call   80befd <setup_tcp>
    msg->conn->err = tcp_connect(msg->conn->pcb.tcp, msg->msg.bc.ipaddr, msg->msg.bc.port,
  80ca0f:	8b 33                	mov    (%ebx),%esi
  80ca11:	c7 44 24 0c 61 bf 80 	movl   $0x80bf61,0xc(%esp)
  80ca18:	00 
  80ca19:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  80ca1d:	89 44 24 08          	mov    %eax,0x8(%esp)
  80ca21:	8b 43 04             	mov    0x4(%ebx),%eax
  80ca24:	89 44 24 04          	mov    %eax,0x4(%esp)
  80ca28:	8b 46 08             	mov    0x8(%esi),%eax
  80ca2b:	89 04 24             	mov    %eax,(%esp)
  80ca2e:	e8 ed 9e ff ff       	call   806920 <tcp_connect>
  80ca33:	88 46 0c             	mov    %al,0xc(%esi)
    break;
#endif /* LWIP_TCP */
  default:
    break;
  }
}
  80ca36:	83 c4 10             	add    $0x10,%esp
  80ca39:	5b                   	pop    %ebx
  80ca3a:	5e                   	pop    %esi
  80ca3b:	5d                   	pop    %ebp
  80ca3c:	c3                   	ret    

0080ca3d <do_disconnect>:
 *
 * @param msg the api_msg_msg pointing to the connection to disconnect
 */
void
do_disconnect(struct api_msg_msg *msg)
{
  80ca3d:	55                   	push   %ebp
  80ca3e:	89 e5                	mov    %esp,%ebp
  80ca40:	53                   	push   %ebx
  80ca41:	83 ec 14             	sub    $0x14,%esp
  80ca44:	8b 5d 08             	mov    0x8(%ebp),%ebx
#if LWIP_UDP
  if (NETCONNTYPE_GROUP(msg->conn->type) == NETCONN_UDP) {
  80ca47:	8b 03                	mov    (%ebx),%eax
  80ca49:	8b 10                	mov    (%eax),%edx
  80ca4b:	81 e2 f0 00 00 00    	and    $0xf0,%edx
  80ca51:	83 fa 20             	cmp    $0x20,%edx
  80ca54:	75 0b                	jne    80ca61 <do_disconnect+0x24>
    udp_disconnect(msg->conn->pcb.udp);
  80ca56:	8b 40 08             	mov    0x8(%eax),%eax
  80ca59:	89 04 24             	mov    %eax,(%esp)
  80ca5c:	e8 4e cd ff ff       	call   8097af <udp_disconnect>
  }
#endif /* LWIP_UDP */
  TCPIP_APIMSG_ACK(msg);
  80ca61:	8b 03                	mov    (%ebx),%eax
  80ca63:	8b 40 10             	mov    0x10(%eax),%eax
  80ca66:	89 04 24             	mov    %eax,(%esp)
  80ca69:	e8 92 de ff ff       	call   80a900 <sys_sem_signal>
}
  80ca6e:	83 c4 14             	add    $0x14,%esp
  80ca71:	5b                   	pop    %ebx
  80ca72:	5d                   	pop    %ebp
  80ca73:	c3                   	ret    

0080ca74 <do_listen>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_listen(struct api_msg_msg *msg)
{
  80ca74:	55                   	push   %ebp
  80ca75:	89 e5                	mov    %esp,%ebp
  80ca77:	57                   	push   %edi
  80ca78:	56                   	push   %esi
  80ca79:	53                   	push   %ebx
  80ca7a:	83 ec 1c             	sub    $0x1c,%esp
  80ca7d:	8b 5d 08             	mov    0x8(%ebp),%ebx
#if LWIP_TCP
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80ca80:	8b 03                	mov    (%ebx),%eax
  80ca82:	80 78 0c fc          	cmpb   $0xfc,0xc(%eax)
  80ca86:	0f 8c b9 00 00 00    	jl     80cb45 <do_listen+0xd1>
    if (msg->conn->pcb.tcp != NULL) {
  80ca8c:	8b 50 08             	mov    0x8(%eax),%edx
  80ca8f:	85 d2                	test   %edx,%edx
  80ca91:	0f 84 ae 00 00 00    	je     80cb45 <do_listen+0xd1>
      if (msg->conn->type == NETCONN_TCP) {
  80ca97:	83 38 10             	cmpl   $0x10,(%eax)
  80ca9a:	0f 85 a5 00 00 00    	jne    80cb45 <do_listen+0xd1>
        if (msg->conn->pcb.tcp->state == CLOSED) {
  80caa0:	83 7a 10 00          	cmpl   $0x0,0x10(%edx)
  80caa4:	0f 85 97 00 00 00    	jne    80cb41 <do_listen+0xcd>
#if TCP_LISTEN_BACKLOG
          struct tcp_pcb* lpcb = tcp_listen_with_backlog(msg->conn->pcb.tcp, msg->msg.lb.backlog);
#else  /* TCP_LISTEN_BACKLOG */
          struct tcp_pcb* lpcb = tcp_listen(msg->conn->pcb.tcp);
  80caaa:	c7 44 24 04 ff 00 00 	movl   $0xff,0x4(%esp)
  80cab1:	00 
  80cab2:	89 14 24             	mov    %edx,(%esp)
  80cab5:	e8 0c 91 ff ff       	call   805bc6 <tcp_listen_with_backlog>
  80caba:	89 c6                	mov    %eax,%esi
#endif /* TCP_LISTEN_BACKLOG */
          if (lpcb == NULL) {
  80cabc:	85 c0                	test   %eax,%eax
  80cabe:	75 08                	jne    80cac8 <do_listen+0x54>
            msg->conn->err = ERR_MEM;
  80cac0:	8b 03                	mov    (%ebx),%eax
  80cac2:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  80cac6:	eb 7d                	jmp    80cb45 <do_listen+0xd1>
          } else {
            /* delete the recvmbox and allocate the acceptmbox */
            if (msg->conn->recvmbox != SYS_MBOX_NULL) {
  80cac8:	8b 03                	mov    (%ebx),%eax
  80caca:	8b 40 14             	mov    0x14(%eax),%eax
  80cacd:	83 f8 ff             	cmp    $0xffffffff,%eax
  80cad0:	74 11                	je     80cae3 <do_listen+0x6f>
              /** @todo: should we drain the recvmbox here? */
              sys_mbox_free(msg->conn->recvmbox);
  80cad2:	89 04 24             	mov    %eax,(%esp)
  80cad5:	e8 61 dc ff ff       	call   80a73b <sys_mbox_free>
              msg->conn->recvmbox = SYS_MBOX_NULL;
  80cada:	8b 03                	mov    (%ebx),%eax
  80cadc:	c7 40 14 ff ff ff ff 	movl   $0xffffffff,0x14(%eax)
            }
            if (msg->conn->acceptmbox == SYS_MBOX_NULL) {
  80cae3:	8b 3b                	mov    (%ebx),%edi
  80cae5:	83 7f 18 ff          	cmpl   $0xffffffff,0x18(%edi)
  80cae9:	75 1a                	jne    80cb05 <do_listen+0x91>
              if ((msg->conn->acceptmbox = sys_mbox_new(DEFAULT_ACCEPTMBOX_SIZE)) == SYS_MBOX_NULL) {
  80caeb:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80caf2:	e8 ef dc ff ff       	call   80a7e6 <sys_mbox_new>
  80caf7:	89 47 18             	mov    %eax,0x18(%edi)
  80cafa:	83 f8 ff             	cmp    $0xffffffff,%eax
  80cafd:	75 06                	jne    80cb05 <do_listen+0x91>
                msg->conn->err = ERR_MEM;
  80caff:	8b 03                	mov    (%ebx),%eax
  80cb01:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
              }
            }
            if (msg->conn->err == ERR_OK) {
  80cb05:	8b 03                	mov    (%ebx),%eax
  80cb07:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80cb0b:	75 38                	jne    80cb45 <do_listen+0xd1>
              msg->conn->state = NETCONN_LISTEN;
  80cb0d:	c7 40 04 02 00 00 00 	movl   $0x2,0x4(%eax)
              msg->conn->pcb.tcp = lpcb;
  80cb14:	8b 03                	mov    (%ebx),%eax
  80cb16:	89 70 08             	mov    %esi,0x8(%eax)
              tcp_arg(msg->conn->pcb.tcp, msg->conn);
  80cb19:	8b 03                	mov    (%ebx),%eax
  80cb1b:	89 44 24 04          	mov    %eax,0x4(%esp)
  80cb1f:	8b 40 08             	mov    0x8(%eax),%eax
  80cb22:	89 04 24             	mov    %eax,(%esp)
  80cb25:	e8 62 93 ff ff       	call   805e8c <tcp_arg>
              tcp_accept(msg->conn->pcb.tcp, accept_function);
  80cb2a:	c7 44 24 04 7c c7 80 	movl   $0x80c77c,0x4(%esp)
  80cb31:	00 
  80cb32:	8b 03                	mov    (%ebx),%eax
  80cb34:	8b 40 08             	mov    0x8(%eax),%eax
  80cb37:	89 04 24             	mov    %eax,(%esp)
  80cb3a:	e8 8e 93 ff ff       	call   805ecd <tcp_accept>
  80cb3f:	eb 04                	jmp    80cb45 <do_listen+0xd1>
            }
          }
        } else {
          msg->conn->err = ERR_CONN;
  80cb41:	c6 40 0c f8          	movb   $0xf8,0xc(%eax)
        }
      }
    }
  }
#endif /* LWIP_TCP */
  TCPIP_APIMSG_ACK(msg);
  80cb45:	8b 03                	mov    (%ebx),%eax
  80cb47:	8b 40 10             	mov    0x10(%eax),%eax
  80cb4a:	89 04 24             	mov    %eax,(%esp)
  80cb4d:	e8 ae dd ff ff       	call   80a900 <sys_sem_signal>
}
  80cb52:	83 c4 1c             	add    $0x1c,%esp
  80cb55:	5b                   	pop    %ebx
  80cb56:	5e                   	pop    %esi
  80cb57:	5f                   	pop    %edi
  80cb58:	5d                   	pop    %ebp
  80cb59:	c3                   	ret    

0080cb5a <do_send>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_send(struct api_msg_msg *msg)
{
  80cb5a:	55                   	push   %ebp
  80cb5b:	89 e5                	mov    %esp,%ebp
  80cb5d:	57                   	push   %edi
  80cb5e:	56                   	push   %esi
  80cb5f:	53                   	push   %ebx
  80cb60:	83 ec 1c             	sub    $0x1c,%esp
  80cb63:	8b 75 08             	mov    0x8(%ebp),%esi
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80cb66:	8b 1e                	mov    (%esi),%ebx
  80cb68:	80 7b 0c fc          	cmpb   $0xfc,0xc(%ebx)
  80cb6c:	0f 8c 8b 00 00 00    	jl     80cbfd <do_send+0xa3>
    if (msg->conn->pcb.tcp != NULL) {
  80cb72:	8b 43 08             	mov    0x8(%ebx),%eax
  80cb75:	85 c0                	test   %eax,%eax
  80cb77:	0f 84 80 00 00 00    	je     80cbfd <do_send+0xa3>
      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80cb7d:	8b 13                	mov    (%ebx),%edx
  80cb7f:	81 e2 f0 00 00 00    	and    $0xf0,%edx
  80cb85:	83 fa 20             	cmp    $0x20,%edx
  80cb88:	74 39                	je     80cbc3 <do_send+0x69>
  80cb8a:	83 fa 40             	cmp    $0x40,%edx
  80cb8d:	75 6e                	jne    80cbfd <do_send+0xa3>
#if LWIP_RAW
      case NETCONN_RAW:
        if (msg->msg.b->addr == NULL) {
  80cb8f:	8b 56 04             	mov    0x4(%esi),%edx
  80cb92:	8b 4a 08             	mov    0x8(%edx),%ecx
  80cb95:	85 c9                	test   %ecx,%ecx
  80cb97:	75 13                	jne    80cbac <do_send+0x52>
          msg->conn->err = raw_send(msg->conn->pcb.raw, msg->msg.b->p);
  80cb99:	8b 12                	mov    (%edx),%edx
  80cb9b:	89 54 24 04          	mov    %edx,0x4(%esp)
  80cb9f:	89 04 24             	mov    %eax,(%esp)
  80cba2:	e8 42 1e 00 00       	call   80e9e9 <raw_send>
  80cba7:	88 43 0c             	mov    %al,0xc(%ebx)
  80cbaa:	eb 51                	jmp    80cbfd <do_send+0xa3>
        } else {
          msg->conn->err = raw_sendto(msg->conn->pcb.raw, msg->msg.b->p, msg->msg.b->addr);
  80cbac:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  80cbb0:	8b 12                	mov    (%edx),%edx
  80cbb2:	89 54 24 04          	mov    %edx,0x4(%esp)
  80cbb6:	89 04 24             	mov    %eax,(%esp)
  80cbb9:	e8 01 1d 00 00       	call   80e8bf <raw_sendto>
  80cbbe:	88 43 0c             	mov    %al,0xc(%ebx)
  80cbc1:	eb 3a                	jmp    80cbfd <do_send+0xa3>
        }
        break;
#endif
#if LWIP_UDP
      case NETCONN_UDP:
        if (msg->msg.b->addr == NULL) {
  80cbc3:	8b 56 04             	mov    0x4(%esi),%edx
  80cbc6:	8b 4a 08             	mov    0x8(%edx),%ecx
  80cbc9:	85 c9                	test   %ecx,%ecx
  80cbcb:	75 13                	jne    80cbe0 <do_send+0x86>
          msg->conn->err = udp_send(msg->conn->pcb.udp, msg->msg.b->p);
  80cbcd:	8b 12                	mov    (%edx),%edx
  80cbcf:	89 54 24 04          	mov    %edx,0x4(%esp)
  80cbd3:	89 04 24             	mov    %eax,(%esp)
  80cbd6:	e8 31 cb ff ff       	call   80970c <udp_send>
  80cbdb:	88 43 0c             	mov    %al,0xc(%ebx)
  80cbde:	eb 1d                	jmp    80cbfd <do_send+0xa3>
        } else {
          msg->conn->err = udp_sendto(msg->conn->pcb.udp, msg->msg.b->p, msg->msg.b->addr, msg->msg.b->port);
  80cbe0:	0f b7 7a 0c          	movzwl 0xc(%edx),%edi
  80cbe4:	89 7c 24 0c          	mov    %edi,0xc(%esp)
  80cbe8:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  80cbec:	8b 12                	mov    (%edx),%edx
  80cbee:	89 54 24 04          	mov    %edx,0x4(%esp)
  80cbf2:	89 04 24             	mov    %eax,(%esp)
  80cbf5:	e8 c9 ca ff ff       	call   8096c3 <udp_sendto>
  80cbfa:	88 43 0c             	mov    %al,0xc(%ebx)
      default:
        break;
      }
    }
  }
  TCPIP_APIMSG_ACK(msg);
  80cbfd:	8b 06                	mov    (%esi),%eax
  80cbff:	8b 40 10             	mov    0x10(%eax),%eax
  80cc02:	89 04 24             	mov    %eax,(%esp)
  80cc05:	e8 f6 dc ff ff       	call   80a900 <sys_sem_signal>
}
  80cc0a:	83 c4 1c             	add    $0x1c,%esp
  80cc0d:	5b                   	pop    %ebx
  80cc0e:	5e                   	pop    %esi
  80cc0f:	5f                   	pop    %edi
  80cc10:	5d                   	pop    %ebp
  80cc11:	c3                   	ret    

0080cc12 <do_recv>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_recv(struct api_msg_msg *msg)
{
  80cc12:	55                   	push   %ebp
  80cc13:	89 e5                	mov    %esp,%ebp
  80cc15:	53                   	push   %ebx
  80cc16:	83 ec 14             	sub    $0x14,%esp
  80cc19:	8b 5d 08             	mov    0x8(%ebp),%ebx
#if LWIP_TCP
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80cc1c:	8b 03                	mov    (%ebx),%eax
  80cc1e:	80 78 0c fc          	cmpb   $0xfc,0xc(%eax)
  80cc22:	7c 1c                	jl     80cc40 <do_recv+0x2e>
    if (msg->conn->pcb.tcp != NULL) {
  80cc24:	8b 50 08             	mov    0x8(%eax),%edx
  80cc27:	85 d2                	test   %edx,%edx
  80cc29:	74 15                	je     80cc40 <do_recv+0x2e>
      if (msg->conn->type == NETCONN_TCP) {
  80cc2b:	83 38 10             	cmpl   $0x10,(%eax)
  80cc2e:	75 10                	jne    80cc40 <do_recv+0x2e>
        if (msg->conn->pcb.tcp->state == LISTEN) {
          tcp_accepted(msg->conn->pcb.tcp);
        } else
#endif /* TCP_LISTEN_BACKLOG */
        {
          tcp_recved(msg->conn->pcb.tcp, msg->msg.r.len);
  80cc30:	0f b7 43 04          	movzwl 0x4(%ebx),%eax
  80cc34:	89 44 24 04          	mov    %eax,0x4(%esp)
  80cc38:	89 14 24             	mov    %edx,(%esp)
  80cc3b:	e8 84 90 ff ff       	call   805cc4 <tcp_recved>
        }
      }
    }
  }
#endif /* LWIP_TCP */
  TCPIP_APIMSG_ACK(msg);
  80cc40:	8b 03                	mov    (%ebx),%eax
  80cc42:	8b 40 10             	mov    0x10(%eax),%eax
  80cc45:	89 04 24             	mov    %eax,(%esp)
  80cc48:	e8 b3 dc ff ff       	call   80a900 <sys_sem_signal>
}
  80cc4d:	83 c4 14             	add    $0x14,%esp
  80cc50:	5b                   	pop    %ebx
  80cc51:	5d                   	pop    %ebp
  80cc52:	c3                   	ret    

0080cc53 <do_write>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_write(struct api_msg_msg *msg)
{
  80cc53:	55                   	push   %ebp
  80cc54:	89 e5                	mov    %esp,%ebp
  80cc56:	83 ec 18             	sub    $0x18,%esp
  80cc59:	8b 55 08             	mov    0x8(%ebp),%edx
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80cc5c:	8b 02                	mov    (%edx),%eax
  80cc5e:	80 78 0c fc          	cmpb   $0xfc,0xc(%eax)
  80cc62:	7c 2d                	jl     80cc91 <do_write+0x3e>
    if ((msg->conn->pcb.tcp != NULL) && (msg->conn->type == NETCONN_TCP)) {
  80cc64:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  80cc68:	74 23                	je     80cc8d <do_write+0x3a>
  80cc6a:	83 38 10             	cmpl   $0x10,(%eax)
  80cc6d:	75 1e                	jne    80cc8d <do_write+0x3a>
#if LWIP_TCP
      msg->conn->state = NETCONN_WRITE;
  80cc6f:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
      /* set all the variables used by do_writemore */
      msg->conn->write_msg = msg;
  80cc76:	8b 02                	mov    (%edx),%eax
  80cc78:	89 50 24             	mov    %edx,0x24(%eax)
      msg->conn->write_offset = 0;
  80cc7b:	8b 02                	mov    (%edx),%eax
  80cc7d:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%eax)
        sys_arch_sem_wait(msg->conn->op_completed, 0);
        LOCK_TCPIP_CORE();
        LWIP_ASSERT("state!", msg->conn->state == NETCONN_NONE);
      }
#else
      do_writemore(msg->conn);
  80cc84:	8b 02                	mov    (%edx),%eax
  80cc86:	e8 01 f4 ff ff       	call   80c08c <do_writemore>
#endif
      /* for both cases: if do_writemore was called, don't ACK the APIMSG! */
      return;
  80cc8b:	eb 11                	jmp    80cc9e <do_write+0x4b>
#endif /* LWIP_TCP */
#if (LWIP_UDP || LWIP_RAW)
    } else {
      msg->conn->err = ERR_VAL;
  80cc8d:	c6 40 0c f7          	movb   $0xf7,0xc(%eax)
#endif /* (LWIP_UDP || LWIP_RAW) */
    }
  }
  TCPIP_APIMSG_ACK(msg);
  80cc91:	8b 02                	mov    (%edx),%eax
  80cc93:	8b 40 10             	mov    0x10(%eax),%eax
  80cc96:	89 04 24             	mov    %eax,(%esp)
  80cc99:	e8 62 dc ff ff       	call   80a900 <sys_sem_signal>
}
  80cc9e:	c9                   	leave  
  80cc9f:	c3                   	ret    

0080cca0 <do_getaddr>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_getaddr(struct api_msg_msg *msg)
{
  80cca0:	55                   	push   %ebp
  80cca1:	89 e5                	mov    %esp,%ebp
  80cca3:	83 ec 18             	sub    $0x18,%esp
  80cca6:	8b 45 08             	mov    0x8(%ebp),%eax
  if (msg->conn->pcb.ip != NULL) {
  80cca9:	8b 08                	mov    (%eax),%ecx
  80ccab:	8b 51 08             	mov    0x8(%ecx),%edx
  80ccae:	85 d2                	test   %edx,%edx
  80ccb0:	0f 84 98 00 00 00    	je     80cd4e <do_getaddr+0xae>
    *(msg->msg.ad.ipaddr) = (msg->msg.ad.local?msg->conn->pcb.ip->local_ip:msg->conn->pcb.ip->remote_ip);
  80ccb6:	8b 48 04             	mov    0x4(%eax),%ecx
  80ccb9:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80ccbd:	74 06                	je     80ccc5 <do_getaddr+0x25>
  80ccbf:	8b 12                	mov    (%edx),%edx
  80ccc1:	89 11                	mov    %edx,(%ecx)
  80ccc3:	eb 05                	jmp    80ccca <do_getaddr+0x2a>
  80ccc5:	8b 52 04             	mov    0x4(%edx),%edx
  80ccc8:	89 11                	mov    %edx,(%ecx)
    
    switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80ccca:	8b 08                	mov    (%eax),%ecx
  80cccc:	8b 11                	mov    (%ecx),%edx
  80ccce:	81 e2 f0 00 00 00    	and    $0xf0,%edx
  80ccd4:	83 fa 20             	cmp    $0x20,%edx
  80ccd7:	74 27                	je     80cd00 <do_getaddr+0x60>
  80ccd9:	83 fa 40             	cmp    $0x40,%edx
  80ccdc:	74 07                	je     80cce5 <do_getaddr+0x45>
  80ccde:	83 fa 10             	cmp    $0x10,%edx
  80cce1:	75 6f                	jne    80cd52 <do_getaddr+0xb2>
  80cce3:	eb 4b                	jmp    80cd30 <do_getaddr+0x90>
#if LWIP_RAW
    case NETCONN_RAW:
      if (msg->msg.ad.local) {
  80cce5:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80cce9:	74 0f                	je     80ccfa <do_getaddr+0x5a>
        *(msg->msg.ad.port) = msg->conn->pcb.raw->protocol;
  80cceb:	8b 50 08             	mov    0x8(%eax),%edx
  80ccee:	8b 49 08             	mov    0x8(%ecx),%ecx
  80ccf1:	0f b6 49 10          	movzbl 0x10(%ecx),%ecx
  80ccf5:	66 89 0a             	mov    %cx,(%edx)
  80ccf8:	eb 58                	jmp    80cd52 <do_getaddr+0xb2>
      } else {
        /* return an error as connecting is only a helper for upper layers */
        msg->conn->err = ERR_CONN;
  80ccfa:	c6 41 0c f8          	movb   $0xf8,0xc(%ecx)
  80ccfe:	eb 52                	jmp    80cd52 <do_getaddr+0xb2>
      }
      break;
#endif /* LWIP_RAW */
#if LWIP_UDP
    case NETCONN_UDP:
      if (msg->msg.ad.local) {
  80cd00:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80cd04:	74 0f                	je     80cd15 <do_getaddr+0x75>
        *(msg->msg.ad.port) = msg->conn->pcb.udp->local_port;
  80cd06:	8b 50 08             	mov    0x8(%eax),%edx
  80cd09:	8b 49 08             	mov    0x8(%ecx),%ecx
  80cd0c:	0f b7 49 12          	movzwl 0x12(%ecx),%ecx
  80cd10:	66 89 0a             	mov    %cx,(%edx)
  80cd13:	eb 3d                	jmp    80cd52 <do_getaddr+0xb2>
      } else {
        if ((msg->conn->pcb.udp->flags & UDP_FLAGS_CONNECTED) == 0) {
  80cd15:	8b 51 08             	mov    0x8(%ecx),%edx
  80cd18:	f6 42 10 04          	testb  $0x4,0x10(%edx)
  80cd1c:	75 06                	jne    80cd24 <do_getaddr+0x84>
          msg->conn->err = ERR_CONN;
  80cd1e:	c6 41 0c f8          	movb   $0xf8,0xc(%ecx)
  80cd22:	eb 2e                	jmp    80cd52 <do_getaddr+0xb2>
        } else {
          *(msg->msg.ad.port) = msg->conn->pcb.udp->remote_port;
  80cd24:	8b 48 08             	mov    0x8(%eax),%ecx
  80cd27:	0f b7 52 14          	movzwl 0x14(%edx),%edx
  80cd2b:	66 89 11             	mov    %dx,(%ecx)
  80cd2e:	eb 22                	jmp    80cd52 <do_getaddr+0xb2>
      }
      break;
#endif /* LWIP_UDP */
#if LWIP_TCP
    case NETCONN_TCP:
      *(msg->msg.ad.port) = (msg->msg.ad.local?msg->conn->pcb.tcp->local_port:msg->conn->pcb.tcp->remote_port);
  80cd30:	8b 50 08             	mov    0x8(%eax),%edx
  80cd33:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80cd37:	74 09                	je     80cd42 <do_getaddr+0xa2>
  80cd39:	8b 49 08             	mov    0x8(%ecx),%ecx
  80cd3c:	0f b7 49 1c          	movzwl 0x1c(%ecx),%ecx
  80cd40:	eb 07                	jmp    80cd49 <do_getaddr+0xa9>
  80cd42:	8b 49 08             	mov    0x8(%ecx),%ecx
  80cd45:	0f b7 49 1e          	movzwl 0x1e(%ecx),%ecx
  80cd49:	66 89 0a             	mov    %cx,(%edx)
      break;
  80cd4c:	eb 04                	jmp    80cd52 <do_getaddr+0xb2>
#endif /* LWIP_TCP */
    }
  } else {
    msg->conn->err = ERR_CONN;
  80cd4e:	c6 41 0c f8          	movb   $0xf8,0xc(%ecx)
  }
  TCPIP_APIMSG_ACK(msg);
  80cd52:	8b 00                	mov    (%eax),%eax
  80cd54:	8b 40 10             	mov    0x10(%eax),%eax
  80cd57:	89 04 24             	mov    %eax,(%esp)
  80cd5a:	e8 a1 db ff ff       	call   80a900 <sys_sem_signal>
}
  80cd5f:	c9                   	leave  
  80cd60:	c3                   	ret    

0080cd61 <do_close>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_close(struct api_msg_msg *msg)
{
  80cd61:	55                   	push   %ebp
  80cd62:	89 e5                	mov    %esp,%ebp
  80cd64:	83 ec 18             	sub    $0x18,%esp
  80cd67:	8b 55 08             	mov    0x8(%ebp),%edx
#if LWIP_TCP
  if ((msg->conn->pcb.tcp != NULL) && (msg->conn->type == NETCONN_TCP)) {
  80cd6a:	8b 02                	mov    (%edx),%eax
  80cd6c:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  80cd70:	74 15                	je     80cd87 <do_close+0x26>
  80cd72:	83 38 10             	cmpl   $0x10,(%eax)
  80cd75:	75 10                	jne    80cd87 <do_close+0x26>
      msg->conn->state = NETCONN_CLOSE;
  80cd77:	c7 40 04 04 00 00 00 	movl   $0x4,0x4(%eax)
      do_close_internal(msg->conn);
  80cd7e:	8b 02                	mov    (%edx),%eax
  80cd80:	e8 5d f4 ff ff       	call   80c1e2 <do_close_internal>
  80cd85:	eb 11                	jmp    80cd98 <do_close+0x37>
      /* for tcp netconns, do_close_internal ACKs the message */
  } else
#endif /* LWIP_TCP */
  {
    msg->conn->err = ERR_VAL;
  80cd87:	c6 40 0c f7          	movb   $0xf7,0xc(%eax)
    TCPIP_APIMSG_ACK(msg);
  80cd8b:	8b 02                	mov    (%edx),%eax
  80cd8d:	8b 40 10             	mov    0x10(%eax),%eax
  80cd90:	89 04 24             	mov    %eax,(%esp)
  80cd93:	e8 68 db ff ff       	call   80a900 <sys_sem_signal>
  }
}
  80cd98:	c9                   	leave  
  80cd99:	c3                   	ret    
  80cd9a:	66 90                	xchg   %ax,%ax
  80cd9c:	66 90                	xchg   %ax,%ax
  80cd9e:	66 90                	xchg   %ax,%ax

0080cda0 <tcp_parseopt>:
 *
 * @param pcb the tcp_pcb for which a segment arrived
 */
static void
tcp_parseopt(struct tcp_pcb *pcb)
{
  80cda0:	55                   	push   %ebp
  80cda1:	89 e5                	mov    %esp,%ebp
  80cda3:	57                   	push   %edi
  80cda4:	56                   	push   %esi
  80cda5:	53                   	push   %ebx
  80cda6:	83 ec 1c             	sub    $0x1c,%esp
  80cda9:	89 c7                	mov    %eax,%edi
  u8_t c;
  u8_t *opts, opt;
  u16_t mss;

  opts = (u8_t *)tcphdr + TCP_HLEN;
  80cdab:	8b 35 d0 c1 b3 00    	mov    0xb3c1d0,%esi

  /* Parse the TCP MSS option, if present. */
  if(TCPH_HDRLEN(tcphdr) > 0x5) {
  80cdb1:	0f b7 46 0c          	movzwl 0xc(%esi),%eax
  80cdb5:	89 04 24             	mov    %eax,(%esp)
  80cdb8:	e8 c6 af ff ff       	call   807d83 <ntohs>
  80cdbd:	66 3d ff 5f          	cmp    $0x5fff,%ax
  80cdc1:	76 7f                	jbe    80ce42 <tcp_parseopt+0xa2>
{
  u8_t c;
  u8_t *opts, opt;
  u16_t mss;

  opts = (u8_t *)tcphdr + TCP_HLEN;
  80cdc3:	83 c6 14             	add    $0x14,%esi
  80cdc6:	bb 00 00 00 00       	mov    $0x0,%ebx
  80cdcb:	eb 4f                	jmp    80ce1c <tcp_parseopt+0x7c>

  /* Parse the TCP MSS option, if present. */
  if(TCPH_HDRLEN(tcphdr) > 0x5) {
    for(c = 0; c < (TCPH_HDRLEN(tcphdr) - 5) << 2 ;) {
      opt = opts[c];
  80cdcd:	0f b6 d3             	movzbl %bl,%edx
  80cdd0:	0f b6 04 16          	movzbl (%esi,%edx,1),%eax
      if (opt == 0x00) {
  80cdd4:	84 c0                	test   %al,%al
  80cdd6:	74 6a                	je     80ce42 <tcp_parseopt+0xa2>
        /* End of options. */
        break;
      } else if (opt == 0x01) {
  80cdd8:	3c 01                	cmp    $0x1,%al
  80cdda:	75 05                	jne    80cde1 <tcp_parseopt+0x41>
        ++c;
  80cddc:	83 c3 01             	add    $0x1,%ebx
  80cddf:	eb 3b                	jmp    80ce1c <tcp_parseopt+0x7c>
        /* NOP option. */
      } else if (opt == 0x02 &&
  80cde1:	3c 02                	cmp    $0x2,%al
  80cde3:	75 2c                	jne    80ce11 <tcp_parseopt+0x71>
  80cde5:	80 7c 16 01 04       	cmpb   $0x4,0x1(%esi,%edx,1)
  80cdea:	75 25                	jne    80ce11 <tcp_parseopt+0x71>
        opts[c + 1] == 0x04) {
        /* An MSS option with the right option length. */
        mss = (opts[c + 2] << 8) | opts[c + 3];
  80cdec:	0f b6 44 16 02       	movzbl 0x2(%esi,%edx,1),%eax
  80cdf1:	c1 e0 08             	shl    $0x8,%eax
  80cdf4:	0f b6 54 16 03       	movzbl 0x3(%esi,%edx,1),%edx
  80cdf9:	09 d0                	or     %edx,%eax
        /* Limit the mss to the configured TCP_MSS and prevent division by zero */
        pcb->mss = ((mss > TCP_MSS) || (mss == 0)) ? TCP_MSS : mss;
  80cdfb:	8d 50 ff             	lea    -0x1(%eax),%edx
  80cdfe:	66 81 fa b4 05       	cmp    $0x5b4,%dx
  80ce03:	ba b4 05 00 00       	mov    $0x5b4,%edx
  80ce08:	0f 43 c2             	cmovae %edx,%eax
  80ce0b:	66 89 47 34          	mov    %ax,0x34(%edi)

        /* And we are done processing options. */
        break;
  80ce0f:	eb 31                	jmp    80ce42 <tcp_parseopt+0xa2>
      } else {
        if (opts[c + 1] == 0) {
  80ce11:	0f b6 44 16 01       	movzbl 0x1(%esi,%edx,1),%eax
  80ce16:	84 c0                	test   %al,%al
  80ce18:	74 28                	je     80ce42 <tcp_parseopt+0xa2>
             and we don't process them further. */
          break;
        }
        /* All other options have a length field, so that we easily
           can skip past them. */
        c += opts[c + 1];
  80ce1a:	01 c3                	add    %eax,%ebx

  opts = (u8_t *)tcphdr + TCP_HLEN;

  /* Parse the TCP MSS option, if present. */
  if(TCPH_HDRLEN(tcphdr) > 0x5) {
    for(c = 0; c < (TCPH_HDRLEN(tcphdr) - 5) << 2 ;) {
  80ce1c:	a1 d0 c1 b3 00       	mov    0xb3c1d0,%eax
  80ce21:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80ce25:	89 04 24             	mov    %eax,(%esp)
  80ce28:	e8 56 af ff ff       	call   807d83 <ntohs>
  80ce2d:	0f b6 d3             	movzbl %bl,%edx
  80ce30:	66 c1 e8 0c          	shr    $0xc,%ax
  80ce34:	0f b7 c0             	movzwl %ax,%eax
  80ce37:	8d 04 85 ec ff ff ff 	lea    -0x14(,%eax,4),%eax
  80ce3e:	39 c2                	cmp    %eax,%edx
  80ce40:	7c 8b                	jl     80cdcd <tcp_parseopt+0x2d>
           can skip past them. */
        c += opts[c + 1];
      }
    }
  }
}
  80ce42:	83 c4 1c             	add    $0x1c,%esp
  80ce45:	5b                   	pop    %ebx
  80ce46:	5e                   	pop    %esi
  80ce47:	5f                   	pop    %edi
  80ce48:	5d                   	pop    %ebp
  80ce49:	c3                   	ret    

0080ce4a <tcp_receive>:
 *
 * @return 1 if the incoming segment is the next in sequence, 0 if not
 */
static u8_t
tcp_receive(struct tcp_pcb *pcb)
{
  80ce4a:	55                   	push   %ebp
  80ce4b:	89 e5                	mov    %esp,%ebp
  80ce4d:	57                   	push   %edi
  80ce4e:	56                   	push   %esi
  80ce4f:	53                   	push   %ebx
  80ce50:	83 ec 2c             	sub    $0x2c,%esp
  80ce53:	89 c7                	mov    %eax,%edi
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;

  if (flags & TCP_ACK) {
  80ce55:	f6 05 c0 c1 b3 00 10 	testb  $0x10,0xb3c1c0
  80ce5c:	0f 84 45 04 00 00    	je     80d2a7 <tcp_receive+0x45d>
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl1;
  80ce62:	0f b7 58 5c          	movzwl 0x5c(%eax),%ebx
  80ce66:	8b 50 60             	mov    0x60(%eax),%edx

    /* Update window. */
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
  80ce69:	a1 c8 c1 b3 00       	mov    0xb3c1c8,%eax
  80ce6e:	39 c2                	cmp    %eax,%edx
  80ce70:	78 26                	js     80ce98 <tcp_receive+0x4e>
  80ce72:	39 c2                	cmp    %eax,%edx
  80ce74:	75 0b                	jne    80ce81 <tcp_receive+0x37>
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
  80ce76:	8b 0d c4 c1 b3 00    	mov    0xb3c1c4,%ecx
  80ce7c:	39 4f 64             	cmp    %ecx,0x64(%edi)
  80ce7f:	78 17                	js     80ce98 <tcp_receive+0x4e>
  80ce81:	8b 0d c4 c1 b3 00    	mov    0xb3c1c4,%ecx
  80ce87:	39 4f 64             	cmp    %ecx,0x64(%edi)
  80ce8a:	75 3a                	jne    80cec6 <tcp_receive+0x7c>
       (pcb->snd_wl2 == ackno && tcphdr->wnd > pcb->snd_wnd)) {
  80ce8c:	8b 0d d0 c1 b3 00    	mov    0xb3c1d0,%ecx
  80ce92:	66 3b 59 0e          	cmp    0xe(%ecx),%bx
  80ce96:	73 2e                	jae    80cec6 <tcp_receive+0x7c>
      pcb->snd_wnd = tcphdr->wnd;
  80ce98:	8b 0d d0 c1 b3 00    	mov    0xb3c1d0,%ecx
  80ce9e:	0f b7 49 0e          	movzwl 0xe(%ecx),%ecx
  80cea2:	66 89 4f 5c          	mov    %cx,0x5c(%edi)
      pcb->snd_wl1 = seqno;
  80cea6:	89 47 60             	mov    %eax,0x60(%edi)
      pcb->snd_wl2 = ackno;
  80cea9:	a1 c4 c1 b3 00       	mov    0xb3c1c4,%eax
  80ceae:	89 47 64             	mov    %eax,0x64(%edi)
      if (pcb->snd_wnd > 0 && pcb->persist_backoff > 0) {
  80ceb1:	66 85 c9             	test   %cx,%cx
  80ceb4:	74 10                	je     80cec6 <tcp_receive+0x7c>
  80ceb6:	80 bf a4 00 00 00 00 	cmpb   $0x0,0xa4(%edi)
  80cebd:	74 07                	je     80cec6 <tcp_receive+0x7c>
          pcb->persist_backoff = 0;
  80cebf:	c6 87 a4 00 00 00 00 	movb   $0x0,0xa4(%edi)
                               pcb->lastack, pcb->snd_max, ackno, pcb->snd_wl1, seqno, pcb->snd_wl2));
      }
#endif /* TCP_WND_DEBUG */
    }

    if (pcb->lastack == ackno) {
  80cec6:	8b 4f 48             	mov    0x48(%edi),%ecx
  80cec9:	a1 c4 c1 b3 00       	mov    0xb3c1c4,%eax
  80cece:	39 c1                	cmp    %eax,%ecx
  80ced0:	0f 85 a9 00 00 00    	jne    80cf7f <tcp_receive+0x135>
      pcb->acked = 0;
  80ced6:	66 c7 47 6c 00 00    	movw   $0x0,0x6c(%edi)

      if (pcb->snd_wl1 + pcb->snd_wnd == right_wnd_edge){
  80cedc:	0f b7 47 5c          	movzwl 0x5c(%edi),%eax
  80cee0:	03 47 60             	add    0x60(%edi),%eax
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;

  if (flags & TCP_ACK) {
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl1;
  80cee3:	0f b7 db             	movzwl %bx,%ebx
  80cee6:	01 da                	add    %ebx,%edx
    }

    if (pcb->lastack == ackno) {
      pcb->acked = 0;

      if (pcb->snd_wl1 + pcb->snd_wnd == right_wnd_edge){
  80cee8:	39 d0                	cmp    %edx,%eax
  80ceea:	0f 85 e9 02 00 00    	jne    80d1d9 <tcp_receive+0x38f>
        ++pcb->dupacks;
  80cef0:	0f b6 47 4c          	movzbl 0x4c(%edi),%eax
  80cef4:	83 c0 01             	add    $0x1,%eax
  80cef7:	88 47 4c             	mov    %al,0x4c(%edi)
        if (pcb->dupacks >= 3 && pcb->unacked != NULL) {
  80cefa:	3c 02                	cmp    $0x2,%al
  80cefc:	0f 86 d7 02 00 00    	jbe    80d1d9 <tcp_receive+0x38f>
  80cf02:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  80cf06:	0f 84 cd 02 00 00    	je     80d1d9 <tcp_receive+0x38f>
          if (!(pcb->flags & TF_INFR)) {
  80cf0c:	f6 47 20 04          	testb  $0x4,0x20(%edi)
  80cf10:	75 51                	jne    80cf63 <tcp_receive+0x119>
            /* This is fast retransmit. Retransmit the first unacked segment. */
            LWIP_DEBUGF(TCP_FR_DEBUG, ("tcp_receive: dupacks %"U16_F" (%"U32_F"), fast retransmit %"U32_F"\n",
                                       (u16_t)pcb->dupacks, pcb->lastack,
                                       ntohl(pcb->unacked->tcphdr->seqno)));
            tcp_rexmit(pcb);
  80cf12:	89 3c 24             	mov    %edi,(%esp)
  80cf15:	e8 8c be ff ff       	call   808da6 <tcp_rexmit>
            /* Set ssthresh to max (FlightSize / 2, 2*SMSS) */
            /*pcb->ssthresh = LWIP_MAX((pcb->snd_max -
                                      pcb->lastack) / 2,
                                      2 * pcb->mss);*/
            /* Set ssthresh to half of the minimum of the current cwnd and the advertised window */
            if (pcb->cwnd > pcb->snd_wnd)
  80cf1a:	0f b7 47 4e          	movzwl 0x4e(%edi),%eax
  80cf1e:	0f b7 57 5c          	movzwl 0x5c(%edi),%edx
  80cf22:	66 39 d0             	cmp    %dx,%ax
  80cf25:	76 09                	jbe    80cf30 <tcp_receive+0xe6>
              pcb->ssthresh = pcb->snd_wnd / 2;
  80cf27:	66 d1 ea             	shr    %dx
  80cf2a:	66 89 57 50          	mov    %dx,0x50(%edi)
  80cf2e:	eb 07                	jmp    80cf37 <tcp_receive+0xed>
            else
              pcb->ssthresh = pcb->cwnd / 2;
  80cf30:	66 d1 e8             	shr    %ax
  80cf33:	66 89 47 50          	mov    %ax,0x50(%edi)

            /* The minimum value for ssthresh should be 2 MSS */
            if (pcb->ssthresh < 2*pcb->mss) {
  80cf37:	0f b7 47 34          	movzwl 0x34(%edi),%eax
  80cf3b:	0f b7 4f 50          	movzwl 0x50(%edi),%ecx
  80cf3f:	0f b7 d0             	movzwl %ax,%edx
  80cf42:	01 d2                	add    %edx,%edx
  80cf44:	39 d1                	cmp    %edx,%ecx
  80cf46:	7d 07                	jge    80cf4f <tcp_receive+0x105>
              LWIP_DEBUGF(TCP_FR_DEBUG, ("tcp_receive: The minimum value for ssthresh %"U16_F" should be min 2 mss %"U16_F"...\n", pcb->ssthresh, 2*pcb->mss));
              pcb->ssthresh = 2*pcb->mss;
  80cf48:	8d 14 00             	lea    (%eax,%eax,1),%edx
  80cf4b:	66 89 57 50          	mov    %dx,0x50(%edi)
            }

            pcb->cwnd = pcb->ssthresh + 3 * pcb->mss;
  80cf4f:	8d 04 40             	lea    (%eax,%eax,2),%eax
  80cf52:	66 03 47 50          	add    0x50(%edi),%ax
  80cf56:	66 89 47 4e          	mov    %ax,0x4e(%edi)
            pcb->flags |= TF_INFR;
  80cf5a:	80 4f 20 04          	orb    $0x4,0x20(%edi)
  80cf5e:	e9 76 02 00 00       	jmp    80d1d9 <tcp_receive+0x38f>
          } else {
            /* Inflate the congestion window, but not if it means that
               the value overflows. */
            if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
  80cf63:	0f b7 57 4e          	movzwl 0x4e(%edi),%edx
  80cf67:	89 d0                	mov    %edx,%eax
  80cf69:	66 03 47 34          	add    0x34(%edi),%ax
  80cf6d:	66 39 c2             	cmp    %ax,%dx
  80cf70:	0f 83 63 02 00 00    	jae    80d1d9 <tcp_receive+0x38f>
              pcb->cwnd += pcb->mss;
  80cf76:	66 89 47 4e          	mov    %ax,0x4e(%edi)
  80cf7a:	e9 5a 02 00 00       	jmp    80d1d9 <tcp_receive+0x38f>
        }
      } else {
        LWIP_DEBUGF(TCP_FR_DEBUG, ("tcp_receive: dupack averted %"U32_F" %"U32_F"\n",
                                   pcb->snd_wl1 + pcb->snd_wnd, right_wnd_edge));
      }
    } else if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_max)){
  80cf7f:	8d 50 ff             	lea    -0x1(%eax),%edx
  80cf82:	39 ca                	cmp    %ecx,%edx
  80cf84:	0f 88 a1 01 00 00    	js     80d12b <tcp_receive+0x2e1>
  80cf8a:	89 c2                	mov    %eax,%edx
  80cf8c:	2b 57 58             	sub    0x58(%edi),%edx
  80cf8f:	85 d2                	test   %edx,%edx
  80cf91:	0f 8f 94 01 00 00    	jg     80d12b <tcp_receive+0x2e1>
      /* We come here when the ACK acknowledges new data. */
      
      /* Reset the "IN Fast Retransmit" flag, since we are no longer
         in fast retransmit. Also reset the congestion window to the
         slow start threshold. */
      if (pcb->flags & TF_INFR) {
  80cf97:	0f b6 57 20          	movzbl 0x20(%edi),%edx
  80cf9b:	f6 c2 04             	test   $0x4,%dl
  80cf9e:	74 0e                	je     80cfae <tcp_receive+0x164>
        pcb->flags &= ~TF_INFR;
  80cfa0:	83 e2 fb             	and    $0xfffffffb,%edx
  80cfa3:	88 57 20             	mov    %dl,0x20(%edi)
        pcb->cwnd = pcb->ssthresh;
  80cfa6:	0f b7 57 50          	movzwl 0x50(%edi),%edx
  80cfaa:	66 89 57 4e          	mov    %dx,0x4e(%edi)
      }

      /* Reset the number of retransmissions. */
      pcb->nrtx = 0;
  80cfae:	c6 47 46 00          	movb   $0x0,0x46(%edi)

      /* Reset the retransmission time-out. */
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
  80cfb2:	0f b7 57 40          	movzwl 0x40(%edi),%edx
  80cfb6:	66 c1 fa 03          	sar    $0x3,%dx
  80cfba:	66 03 57 42          	add    0x42(%edi),%dx
  80cfbe:	66 89 57 44          	mov    %dx,0x44(%edi)

      /* Update the send buffer space. Diff between the two can never exceed 64K? */
      pcb->acked = (u16_t)(ackno - pcb->lastack);
  80cfc2:	89 c2                	mov    %eax,%edx
  80cfc4:	29 ca                	sub    %ecx,%edx
  80cfc6:	66 89 57 6c          	mov    %dx,0x6c(%edi)

      pcb->snd_buf += pcb->acked;
  80cfca:	66 01 57 6e          	add    %dx,0x6e(%edi)

      /* Reset the fast retransmit variables. */
      pcb->dupacks = 0;
  80cfce:	c6 47 4c 00          	movb   $0x0,0x4c(%edi)
      pcb->lastack = ackno;
  80cfd2:	89 47 48             	mov    %eax,0x48(%edi)

      /* Update the congestion control variables (cwnd and
         ssthresh). */
      if (pcb->state >= ESTABLISHED) {
  80cfd5:	83 7f 10 03          	cmpl   $0x3,0x10(%edi)
  80cfd9:	0f 86 cd 00 00 00    	jbe    80d0ac <tcp_receive+0x262>
        if (pcb->cwnd < pcb->ssthresh) {
  80cfdf:	0f b7 4f 4e          	movzwl 0x4e(%edi),%ecx
  80cfe3:	66 3b 4f 50          	cmp    0x50(%edi),%cx
  80cfe7:	73 18                	jae    80d001 <tcp_receive+0x1b7>
          if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
  80cfe9:	89 c8                	mov    %ecx,%eax
  80cfeb:	66 03 47 34          	add    0x34(%edi),%ax
  80cfef:	66 39 c1             	cmp    %ax,%cx
  80cff2:	0f 83 b4 00 00 00    	jae    80d0ac <tcp_receive+0x262>
            pcb->cwnd += pcb->mss;
  80cff8:	66 89 47 4e          	mov    %ax,0x4e(%edi)
  80cffc:	e9 ab 00 00 00       	jmp    80d0ac <tcp_receive+0x262>
          }
          LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_receive: slow start cwnd %"U16_F"\n", pcb->cwnd));
        } else {
          u16_t new_cwnd = (pcb->cwnd + pcb->mss * pcb->mss / pcb->cwnd);
  80d001:	0f b7 47 34          	movzwl 0x34(%edi),%eax
  80d005:	0f af c0             	imul   %eax,%eax
  80d008:	0f b7 d9             	movzwl %cx,%ebx
  80d00b:	99                   	cltd   
  80d00c:	f7 fb                	idiv   %ebx
  80d00e:	01 c8                	add    %ecx,%eax
          if (new_cwnd > pcb->cwnd) {
  80d010:	66 39 c1             	cmp    %ax,%cx
  80d013:	0f 83 93 00 00 00    	jae    80d0ac <tcp_receive+0x262>
            pcb->cwnd = new_cwnd;
  80d019:	66 89 47 4e          	mov    %ax,0x4e(%edi)
  80d01d:	e9 8a 00 00 00       	jmp    80d0ac <tcp_receive+0x262>
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: removing %"U32_F":%"U32_F" from pcb->unacked\n",
                                      ntohl(pcb->unacked->tcphdr->seqno),
                                      ntohl(pcb->unacked->tcphdr->seqno) +
                                      TCP_TCPLEN(pcb->unacked)));

        next = pcb->unacked;
  80d022:	8b 5f 78             	mov    0x78(%edi),%ebx
        pcb->unacked = pcb->unacked->next;
  80d025:	8b 03                	mov    (%ebx),%eax
  80d027:	89 47 78             	mov    %eax,0x78(%edi)

        LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"U16_F" ... ", (u16_t)pcb->snd_queuelen));
        LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
  80d02a:	0f b7 77 70          	movzwl 0x70(%edi),%esi
  80d02e:	8b 43 04             	mov    0x4(%ebx),%eax
  80d031:	89 04 24             	mov    %eax,(%esp)
  80d034:	e8 51 82 ff ff       	call   80528a <pbuf_clen>
  80d039:	0f b6 c0             	movzbl %al,%eax
  80d03c:	66 39 c6             	cmp    %ax,%si
  80d03f:	73 1c                	jae    80d05d <tcp_receive+0x213>
  80d041:	c7 44 24 08 1c 3e 81 	movl   $0x813e1c,0x8(%esp)
  80d048:	00 
  80d049:	c7 44 24 04 55 03 00 	movl   $0x355,0x4(%esp)
  80d050:	00 
  80d051:	c7 04 24 88 3f 81 00 	movl   $0x813f88,(%esp)
  80d058:	e8 1d 20 00 00       	call   80f07a <_panic>
        pcb->snd_queuelen -= pbuf_clen(next->p);
  80d05d:	0f b7 77 70          	movzwl 0x70(%edi),%esi
  80d061:	8b 43 04             	mov    0x4(%ebx),%eax
  80d064:	89 04 24             	mov    %eax,(%esp)
  80d067:	e8 1e 82 ff ff       	call   80528a <pbuf_clen>
  80d06c:	0f b6 c0             	movzbl %al,%eax
  80d06f:	29 c6                	sub    %eax,%esi
  80d071:	66 89 77 70          	mov    %si,0x70(%edi)
        tcp_seg_free(next);
  80d075:	89 1c 24             	mov    %ebx,(%esp)
  80d078:	e8 4c 8d ff ff       	call   805dc9 <tcp_seg_free>

        LWIP_DEBUGF(TCP_QLEN_DEBUG, ("%"U16_F" (after freeing unacked)\n", (u16_t)pcb->snd_queuelen));
        if (pcb->snd_queuelen != 0) {
  80d07d:	66 83 7f 70 00       	cmpw   $0x0,0x70(%edi)
  80d082:	74 28                	je     80d0ac <tcp_receive+0x262>
          LWIP_ASSERT("tcp_receive: valid queue length", pcb->unacked != NULL ||
  80d084:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  80d088:	75 22                	jne    80d0ac <tcp_receive+0x262>
  80d08a:	83 7f 74 00          	cmpl   $0x0,0x74(%edi)
  80d08e:	75 1c                	jne    80d0ac <tcp_receive+0x262>
  80d090:	c7 44 24 08 44 3e 81 	movl   $0x813e44,0x8(%esp)
  80d097:	00 
  80d098:	c7 44 24 04 5c 03 00 	movl   $0x35c,0x4(%esp)
  80d09f:	00 
  80d0a0:	c7 04 24 88 3f 81 00 	movl   $0x813f88,(%esp)
  80d0a7:	e8 ce 1f 00 00       	call   80f07a <_panic>
                                    pcb->unacked != NULL?
                                    ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked): 0));

      /* Remove segment from the unacknowledged list if the incoming
         ACK acknowlegdes them. */
      while (pcb->unacked != NULL &&
  80d0ac:	8b 47 78             	mov    0x78(%edi),%eax
  80d0af:	85 c0                	test   %eax,%eax
  80d0b1:	74 61                	je     80d114 <tcp_receive+0x2ca>
             TCP_SEQ_LEQ(ntohl(pcb->unacked->tcphdr->seqno) +
  80d0b3:	8b 40 10             	mov    0x10(%eax),%eax
  80d0b6:	8b 40 04             	mov    0x4(%eax),%eax
  80d0b9:	89 04 24             	mov    %eax,(%esp)
  80d0bc:	e8 09 af ff ff       	call   807fca <ntohl>
  80d0c1:	89 c6                	mov    %eax,%esi
  80d0c3:	8b 47 78             	mov    0x78(%edi),%eax
  80d0c6:	0f b7 58 0c          	movzwl 0xc(%eax),%ebx
  80d0ca:	8b 40 10             	mov    0x10(%eax),%eax
  80d0cd:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d0d1:	89 04 24             	mov    %eax,(%esp)
  80d0d4:	e8 aa ac ff ff       	call   807d83 <ntohs>
  80d0d9:	ba 01 00 00 00       	mov    $0x1,%edx
  80d0de:	a8 01                	test   $0x1,%al
  80d0e0:	75 1a                	jne    80d0fc <tcp_receive+0x2b2>
  80d0e2:	8b 47 78             	mov    0x78(%edi),%eax
  80d0e5:	8b 40 10             	mov    0x10(%eax),%eax
  80d0e8:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d0ec:	89 04 24             	mov    %eax,(%esp)
  80d0ef:	e8 8f ac ff ff       	call   807d83 <ntohs>
  80d0f4:	66 d1 e8             	shr    %ax
  80d0f7:	89 c2                	mov    %eax,%edx
  80d0f9:	83 e2 01             	and    $0x1,%edx
  80d0fc:	2b 35 c4 c1 b3 00    	sub    0xb3c1c4,%esi
  80d102:	01 d3                	add    %edx,%ebx
  80d104:	01 de                	add    %ebx,%esi
                                    pcb->unacked != NULL?
                                    ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked): 0));

      /* Remove segment from the unacknowledged list if the incoming
         ACK acknowlegdes them. */
      while (pcb->unacked != NULL &&
  80d106:	85 f6                	test   %esi,%esi
  80d108:	0f 8e 14 ff ff ff    	jle    80d022 <tcp_receive+0x1d8>
        }
      }

      /* If there's nothing left to acknowledge, stop the retransmit
         timer, otherwise reset it to start again */
      if(pcb->unacked == NULL)
  80d10e:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  80d112:	75 08                	jne    80d11c <tcp_receive+0x2d2>
        pcb->rtime = -1;
  80d114:	66 c7 47 32 ff ff    	movw   $0xffff,0x32(%edi)
  80d11a:	eb 06                	jmp    80d122 <tcp_receive+0x2d8>
      else
        pcb->rtime = 0;
  80d11c:	66 c7 47 32 00 00    	movw   $0x0,0x32(%edi)

      pcb->polltmr = 0;
  80d122:	c6 47 30 00          	movb   $0x0,0x30(%edi)
  80d126:	e9 ae 00 00 00       	jmp    80d1d9 <tcp_receive+0x38f>
    } else {
      /* Fix bug bug #21582: out of sequence ACK, didn't really ack anything */
      pcb->acked = 0;
  80d12b:	66 c7 47 6c 00 00    	movw   $0x0,0x6c(%edi)
  80d131:	e9 a3 00 00 00       	jmp    80d1d9 <tcp_receive+0x38f>
           ) {
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: removing %"U32_F":%"U32_F" from pcb->unsent\n",
                                    ntohl(pcb->unsent->tcphdr->seqno), ntohl(pcb->unsent->tcphdr->seqno) +
                                    TCP_TCPLEN(pcb->unsent)));

      next = pcb->unsent;
  80d136:	8b 5f 74             	mov    0x74(%edi),%ebx
      pcb->unsent = pcb->unsent->next;
  80d139:	8b 03                	mov    (%ebx),%eax
  80d13b:	89 47 74             	mov    %eax,0x74(%edi)
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"U16_F" ... ", (u16_t)pcb->snd_queuelen));
      LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
  80d13e:	0f b7 77 70          	movzwl 0x70(%edi),%esi
  80d142:	8b 43 04             	mov    0x4(%ebx),%eax
  80d145:	89 04 24             	mov    %eax,(%esp)
  80d148:	e8 3d 81 ff ff       	call   80528a <pbuf_clen>
  80d14d:	0f b6 c0             	movzbl %al,%eax
  80d150:	66 39 c6             	cmp    %ax,%si
  80d153:	73 1c                	jae    80d171 <tcp_receive+0x327>
  80d155:	c7 44 24 08 1c 3e 81 	movl   $0x813e1c,0x8(%esp)
  80d15c:	00 
  80d15d:	c7 44 24 04 7f 03 00 	movl   $0x37f,0x4(%esp)
  80d164:	00 
  80d165:	c7 04 24 88 3f 81 00 	movl   $0x813f88,(%esp)
  80d16c:	e8 09 1f 00 00       	call   80f07a <_panic>
      pcb->snd_queuelen -= pbuf_clen(next->p);
  80d171:	0f b7 77 70          	movzwl 0x70(%edi),%esi
  80d175:	8b 43 04             	mov    0x4(%ebx),%eax
  80d178:	89 04 24             	mov    %eax,(%esp)
  80d17b:	e8 0a 81 ff ff       	call   80528a <pbuf_clen>
  80d180:	0f b6 c0             	movzbl %al,%eax
  80d183:	29 c6                	sub    %eax,%esi
  80d185:	66 89 77 70          	mov    %si,0x70(%edi)
      tcp_seg_free(next);
  80d189:	89 1c 24             	mov    %ebx,(%esp)
  80d18c:	e8 38 8c ff ff       	call   805dc9 <tcp_seg_free>
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("%"U16_F" (after freeing unsent)\n", (u16_t)pcb->snd_queuelen));
      if (pcb->snd_queuelen != 0) {
  80d191:	66 83 7f 70 00       	cmpw   $0x0,0x70(%edi)
  80d196:	74 29                	je     80d1c1 <tcp_receive+0x377>
        LWIP_ASSERT("tcp_receive: valid queue length",
  80d198:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  80d19c:	75 23                	jne    80d1c1 <tcp_receive+0x377>
  80d19e:	8b 47 74             	mov    0x74(%edi),%eax
  80d1a1:	85 c0                	test   %eax,%eax
  80d1a3:	75 23                	jne    80d1c8 <tcp_receive+0x37e>
  80d1a5:	c7 44 24 08 44 3e 81 	movl   $0x813e44,0x8(%esp)
  80d1ac:	00 
  80d1ad:	c7 44 24 04 85 03 00 	movl   $0x385,0x4(%esp)
  80d1b4:	00 
  80d1b5:	c7 04 24 88 3f 81 00 	movl   $0x813f88,(%esp)
  80d1bc:	e8 b9 1e 00 00       	call   80f07a <_panic>
          pcb->unacked != NULL || pcb->unsent != NULL);
      }

      if (pcb->unsent != NULL) {
  80d1c1:	8b 47 74             	mov    0x74(%edi),%eax
  80d1c4:	85 c0                	test   %eax,%eax
  80d1c6:	74 11                	je     80d1d9 <tcp_receive+0x38f>
        pcb->snd_nxt = htonl(pcb->unsent->tcphdr->seqno);
  80d1c8:	8b 40 10             	mov    0x10(%eax),%eax
  80d1cb:	8b 40 04             	mov    0x4(%eax),%eax
  80d1ce:	89 04 24             	mov    %eax,(%esp)
  80d1d1:	e8 ba ab ff ff       	call   807d90 <htonl>
  80d1d6:	89 47 54             	mov    %eax,0x54(%edi)
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
  80d1d9:	8b 47 74             	mov    0x74(%edi),%eax
  80d1dc:	85 c0                	test   %eax,%eax
  80d1de:	74 6b                	je     80d24b <tcp_receive+0x401>
           /*TCP_SEQ_LEQ(ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), ackno) &&
             TCP_SEQ_LEQ(ackno, pcb->snd_max)*/
           TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), pcb->snd_max)
  80d1e0:	8b 35 c4 c1 b3 00    	mov    0xb3c1c4,%esi
  80d1e6:	8b 40 10             	mov    0x10(%eax),%eax
  80d1e9:	8b 40 04             	mov    0x4(%eax),%eax
  80d1ec:	89 04 24             	mov    %eax,(%esp)
  80d1ef:	e8 d6 ad ff ff       	call   807fca <ntohl>
  80d1f4:	89 c3                	mov    %eax,%ebx
  80d1f6:	8b 47 74             	mov    0x74(%edi),%eax
  80d1f9:	0f b7 48 0c          	movzwl 0xc(%eax),%ecx
  80d1fd:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  80d200:	8b 40 10             	mov    0x10(%eax),%eax
  80d203:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d207:	89 04 24             	mov    %eax,(%esp)
  80d20a:	e8 74 ab ff ff       	call   807d83 <ntohs>
  80d20f:	ba 01 00 00 00       	mov    $0x1,%edx
  80d214:	a8 01                	test   $0x1,%al
  80d216:	75 1a                	jne    80d232 <tcp_receive+0x3e8>
  80d218:	8b 47 74             	mov    0x74(%edi),%eax
  80d21b:	8b 40 10             	mov    0x10(%eax),%eax
  80d21e:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d222:	89 04 24             	mov    %eax,(%esp)
  80d225:	e8 59 ab ff ff       	call   807d83 <ntohs>
  80d22a:	66 d1 e8             	shr    %ax
  80d22d:	89 c2                	mov    %eax,%edx
  80d22f:	83 e2 01             	and    $0x1,%edx
  80d232:	29 de                	sub    %ebx,%esi
  80d234:	03 55 e4             	add    -0x1c(%ebp),%edx
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
  80d237:	39 d6                	cmp    %edx,%esi
  80d239:	78 10                	js     80d24b <tcp_receive+0x401>
           /*TCP_SEQ_LEQ(ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), ackno) &&
             TCP_SEQ_LEQ(ackno, pcb->snd_max)*/
           TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), pcb->snd_max)
  80d23b:	a1 c4 c1 b3 00       	mov    0xb3c1c4,%eax
  80d240:	2b 47 58             	sub    0x58(%edi),%eax
  80d243:	85 c0                	test   %eax,%eax
  80d245:	0f 8e eb fe ff ff    	jle    80d136 <tcp_receive+0x2ec>
                                pcb->rttest, pcb->rtseq, ackno));

    /* RTT estimation calculations. This is done by checking if the
       incoming segment acknowledges the segment we use to take a
       round-trip time measurement. */
    if (pcb->rttest && TCP_SEQ_LT(pcb->rtseq, ackno)) {
  80d24b:	8b 47 38             	mov    0x38(%edi),%eax
  80d24e:	85 c0                	test   %eax,%eax
  80d250:	74 55                	je     80d2a7 <tcp_receive+0x45d>
  80d252:	8b 0d c4 c1 b3 00    	mov    0xb3c1c4,%ecx
  80d258:	39 4f 3c             	cmp    %ecx,0x3c(%edi)
  80d25b:	79 4a                	jns    80d2a7 <tcp_receive+0x45d>

      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: experienced rtt %"U16_F" ticks (%"U16_F" msec).\n",
                                  m, m * TCP_SLOW_INTERVAL));

      /* This is taken directly from VJs original code in his paper */
      m = m - (pcb->sa >> 3);
  80d25d:	0f b7 57 40          	movzwl 0x40(%edi),%edx
       incoming segment acknowledges the segment we use to take a
       round-trip time measurement. */
    if (pcb->rttest && TCP_SEQ_LT(pcb->rtseq, ackno)) {
      /* diff between this shouldn't exceed 32K since this are tcp timer ticks
         and a round-trip shouldn't be that long... */
      m = (s16_t)(tcp_ticks - pcb->rttest);
  80d261:	0f b7 0d 60 c2 b3 00 	movzwl 0xb3c260,%ecx
  80d268:	29 c1                	sub    %eax,%ecx
  80d26a:	89 c8                	mov    %ecx,%eax

      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: experienced rtt %"U16_F" ticks (%"U16_F" msec).\n",
                                  m, m * TCP_SLOW_INTERVAL));

      /* This is taken directly from VJs original code in his paper */
      m = m - (pcb->sa >> 3);
  80d26c:	89 d1                	mov    %edx,%ecx
  80d26e:	66 c1 f9 03          	sar    $0x3,%cx
  80d272:	29 c8                	sub    %ecx,%eax
      pcb->sa += m;
  80d274:	01 c2                	add    %eax,%edx
  80d276:	66 89 57 40          	mov    %dx,0x40(%edi)
      if (m < 0) {
        m = -m;
  80d27a:	89 c1                	mov    %eax,%ecx
  80d27c:	f7 d9                	neg    %ecx
  80d27e:	66 85 c0             	test   %ax,%ax
  80d281:	0f 48 c1             	cmovs  %ecx,%eax
      }
      m = m - (pcb->sv >> 2);
  80d284:	0f b7 4f 42          	movzwl 0x42(%edi),%ecx
  80d288:	89 cb                	mov    %ecx,%ebx
  80d28a:	66 c1 fb 02          	sar    $0x2,%bx
  80d28e:	29 d9                	sub    %ebx,%ecx
      pcb->sv += m;
  80d290:	01 c8                	add    %ecx,%eax
  80d292:	66 89 47 42          	mov    %ax,0x42(%edi)
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
  80d296:	66 c1 fa 03          	sar    $0x3,%dx
  80d29a:	01 d0                	add    %edx,%eax
  80d29c:	66 89 47 44          	mov    %ax,0x44(%edi)

      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: RTO %"U16_F" (%"U16_F" milliseconds)\n",
                                  pcb->rto, pcb->rto * TCP_SLOW_INTERVAL));

      pcb->rttest = 0;
  80d2a0:	c7 47 38 00 00 00 00 	movl   $0x0,0x38(%edi)
    }
  }

  /* If the incoming segment contains data, we must process it
     further. */
  if (tcplen > 0) {
  80d2a7:	0f b7 1d be c1 b3 00 	movzwl 0xb3c1be,%ebx
  80d2ae:	66 85 db             	test   %bx,%bx
  80d2b1:	0f 84 5b 07 00 00    	je     80da12 <tcp_receive+0xbc8>
       this if the sequence number of the incoming segment is less
       than rcv_nxt, and the sequence number plus the length of the
       segment is larger than rcv_nxt. */
    /*    if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
          if (TCP_SEQ_LT(pcb->rcv_nxt, seqno + tcplen)) {*/
    if (TCP_SEQ_BETWEEN(pcb->rcv_nxt, seqno + 1, seqno + tcplen - 1)){
  80d2b7:	8b 57 24             	mov    0x24(%edi),%edx
  80d2ba:	a1 c8 c1 b3 00       	mov    0xb3c1c8,%eax
  80d2bf:	89 d1                	mov    %edx,%ecx
  80d2c1:	29 c1                	sub    %eax,%ecx
  80d2c3:	89 ce                	mov    %ecx,%esi
  80d2c5:	83 ee 01             	sub    $0x1,%esi
  80d2c8:	0f 88 41 01 00 00    	js     80d40f <tcp_receive+0x5c5>
  80d2ce:	8d 72 01             	lea    0x1(%edx),%esi
  80d2d1:	29 c6                	sub    %eax,%esi
  80d2d3:	0f b7 db             	movzwl %bx,%ebx
  80d2d6:	29 de                	sub    %ebx,%esi
  80d2d8:	85 f6                	test   %esi,%esi
  80d2da:	0f 8f 2f 01 00 00    	jg     80d40f <tcp_receive+0x5c5>

         After we are done with adjusting the pbuf pointers we must
         adjust the ->data pointer in the seg and the segment
         length.*/

      off = pcb->rcv_nxt - seqno;
  80d2e0:	89 ca                	mov    %ecx,%edx
      p = inseg.p;
  80d2e2:	8b 1d d8 c1 b3 00    	mov    0xb3c1d8,%ebx
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
  80d2e8:	85 db                	test   %ebx,%ebx
  80d2ea:	75 1c                	jne    80d308 <tcp_receive+0x4be>
  80d2ec:	c7 44 24 08 9f 3f 81 	movl   $0x813f9f,0x8(%esp)
  80d2f3:	00 
  80d2f4:	c7 44 24 04 e5 03 00 	movl   $0x3e5,0x4(%esp)
  80d2fb:	00 
  80d2fc:	c7 04 24 88 3f 81 00 	movl   $0x813f88,(%esp)
  80d303:	e8 72 1d 00 00       	call   80f07a <_panic>
      LWIP_ASSERT("insane offset!", (off < 0x7fff));
  80d308:	81 f9 fe 7f 00 00    	cmp    $0x7ffe,%ecx
  80d30e:	7e 1c                	jle    80d32c <tcp_receive+0x4e2>
  80d310:	c7 44 24 08 af 3f 81 	movl   $0x813faf,0x8(%esp)
  80d317:	00 
  80d318:	c7 44 24 04 e6 03 00 	movl   $0x3e6,0x4(%esp)
  80d31f:	00 
  80d320:	c7 04 24 88 3f 81 00 	movl   $0x813f88,(%esp)
  80d327:	e8 4e 1d 00 00       	call   80f07a <_panic>
      if (inseg.p->len < off) {
  80d32c:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80d330:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80d333:	39 c1                	cmp    %eax,%ecx
  80d335:	7e 75                	jle    80d3ac <tcp_receive+0x562>
        LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
  80d337:	0f b7 73 08          	movzwl 0x8(%ebx),%esi
  80d33b:	0f b7 c6             	movzwl %si,%eax
  80d33e:	39 c1                	cmp    %eax,%ecx
  80d340:	7e 1c                	jle    80d35e <tcp_receive+0x514>
  80d342:	c7 44 24 08 be 3f 81 	movl   $0x813fbe,0x8(%esp)
  80d349:	00 
  80d34a:	c7 44 24 04 e8 03 00 	movl   $0x3e8,0x4(%esp)
  80d351:	00 
  80d352:	c7 04 24 88 3f 81 00 	movl   $0x813f88,(%esp)
  80d359:	e8 1c 1d 00 00       	call   80f07a <_panic>
        new_tot_len = (u16_t)(inseg.p->tot_len - off);
  80d35e:	29 ce                	sub    %ecx,%esi
  80d360:	89 f1                	mov    %esi,%ecx
  80d362:	8b 45 e4             	mov    -0x1c(%ebp),%eax
        while (p->len < off) {
          off -= p->len;
  80d365:	29 c2                	sub    %eax,%edx
          /* KJM following line changed (with addition of new_tot_len var)
             to fix bug #9076
             inseg.p->tot_len -= p->len; */
          p->tot_len = new_tot_len;
  80d367:	66 89 4b 08          	mov    %cx,0x8(%ebx)
          p->len = 0;
  80d36b:	66 c7 43 0a 00 00    	movw   $0x0,0xa(%ebx)
          p = p->next;
  80d371:	8b 1b                	mov    (%ebx),%ebx
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
      LWIP_ASSERT("insane offset!", (off < 0x7fff));
      if (inseg.p->len < off) {
        LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
        new_tot_len = (u16_t)(inseg.p->tot_len - off);
        while (p->len < off) {
  80d373:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80d377:	39 d0                	cmp    %edx,%eax
  80d379:	7c ea                	jl     80d365 <tcp_receive+0x51b>
             inseg.p->tot_len -= p->len; */
          p->tot_len = new_tot_len;
          p->len = 0;
          p = p->next;
        }
        if(pbuf_header(p, (s16_t)-off)) {
  80d37b:	f7 da                	neg    %edx
  80d37d:	0f bf c2             	movswl %dx,%eax
  80d380:	89 44 24 04          	mov    %eax,0x4(%esp)
  80d384:	89 1c 24             	mov    %ebx,(%esp)
  80d387:	e8 84 79 ff ff       	call   804d10 <pbuf_header>
  80d38c:	84 c0                	test   %al,%al
  80d38e:	74 4d                	je     80d3dd <tcp_receive+0x593>
          /* Do we need to cope with this failing?  Assert for now */
          LWIP_ASSERT("pbuf_header failed", 0);
  80d390:	c7 44 24 08 ce 3f 81 	movl   $0x813fce,0x8(%esp)
  80d397:	00 
  80d398:	c7 44 24 04 f5 03 00 	movl   $0x3f5,0x4(%esp)
  80d39f:	00 
  80d3a0:	c7 04 24 88 3f 81 00 	movl   $0x813f88,(%esp)
  80d3a7:	e8 ce 1c 00 00       	call   80f07a <_panic>
        }
      } else {
        if(pbuf_header(inseg.p, (s16_t)-off)) {
  80d3ac:	f7 d9                	neg    %ecx
  80d3ae:	0f bf c1             	movswl %cx,%eax
  80d3b1:	89 44 24 04          	mov    %eax,0x4(%esp)
  80d3b5:	89 1c 24             	mov    %ebx,(%esp)
  80d3b8:	e8 53 79 ff ff       	call   804d10 <pbuf_header>
  80d3bd:	84 c0                	test   %al,%al
  80d3bf:	74 1c                	je     80d3dd <tcp_receive+0x593>
          /* Do we need to cope with this failing?  Assert for now */
          LWIP_ASSERT("pbuf_header failed", 0);
  80d3c1:	c7 44 24 08 ce 3f 81 	movl   $0x813fce,0x8(%esp)
  80d3c8:	00 
  80d3c9:	c7 44 24 04 fa 03 00 	movl   $0x3fa,0x4(%esp)
  80d3d0:	00 
  80d3d1:	c7 04 24 88 3f 81 00 	movl   $0x813f88,(%esp)
  80d3d8:	e8 9d 1c 00 00       	call   80f07a <_panic>
        }
      }
      /* KJM following line changed to use p->payload rather than inseg->p->payload
         to fix bug #9076 */
      inseg.dataptr = p->payload;
  80d3dd:	8b 43 04             	mov    0x4(%ebx),%eax
  80d3e0:	a3 dc c1 b3 00       	mov    %eax,0xb3c1dc
      inseg.len -= (u16_t)(pcb->rcv_nxt - seqno);
  80d3e5:	8b 47 24             	mov    0x24(%edi),%eax
  80d3e8:	0f b7 15 e0 c1 b3 00 	movzwl 0xb3c1e0,%edx
  80d3ef:	66 03 15 c8 c1 b3 00 	add    0xb3c1c8,%dx
  80d3f6:	29 c2                	sub    %eax,%edx
  80d3f8:	66 89 15 e0 c1 b3 00 	mov    %dx,0xb3c1e0
      inseg.tcphdr->seqno = seqno = pcb->rcv_nxt;
  80d3ff:	a3 c8 c1 b3 00       	mov    %eax,0xb3c1c8
  80d404:	8b 15 e4 c1 b3 00    	mov    0xb3c1e4,%edx
  80d40a:	89 42 04             	mov    %eax,0x4(%edx)
  80d40d:	eb 10                	jmp    80d41f <tcp_receive+0x5d5>
    }
    else {
      if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
  80d40f:	39 d0                	cmp    %edx,%eax
  80d411:	79 1c                	jns    80d42f <tcp_receive+0x5e5>
        /* the whole segment is < rcv_nxt */
        /* must be a duplicate of a packet that has already been correctly handled */

        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: duplicate seqno %"U32_F"\n", seqno));
        tcp_ack_now(pcb);
  80d413:	80 4f 20 02          	orb    $0x2,0x20(%edi)
  80d417:	89 3c 24             	mov    %edi,(%esp)
  80d41a:	e8 42 b3 ff ff       	call   808761 <tcp_output>
    }

    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
  80d41f:	a1 c8 c1 b3 00       	mov    0xb3c1c8,%eax
  80d424:	8b 57 24             	mov    0x24(%edi),%edx
  80d427:	39 d0                	cmp    %edx,%eax
  80d429:	0f 88 d0 05 00 00    	js     80d9ff <tcp_receive+0xbb5>
  80d42f:	0f b7 4f 28          	movzwl 0x28(%edi),%ecx
  80d433:	89 c3                	mov    %eax,%ebx
  80d435:	29 cb                	sub    %ecx,%ebx
  80d437:	8d 4b 01             	lea    0x1(%ebx),%ecx
  80d43a:	29 d1                	sub    %edx,%ecx
  80d43c:	85 c9                	test   %ecx,%ecx
  80d43e:	0f 8f bb 05 00 00    	jg     80d9ff <tcp_receive+0xbb5>
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
  80d444:	39 d0                	cmp    %edx,%eax
  80d446:	0f 85 53 03 00 00    	jne    80d79f <tcp_receive+0x955>
        accepted_inseq = 1; 
        /* The incoming segment is the next in sequence. We check if
           we have to trim the end of the segment and update rcv_nxt
           and pass the data to the application. */
#if TCP_QUEUE_OOSEQ
        if (pcb->ooseq != NULL &&
  80d44c:	8b 57 7c             	mov    0x7c(%edi),%edx
  80d44f:	85 d2                	test   %edx,%edx
  80d451:	0f 84 83 00 00 00    	je     80d4da <tcp_receive+0x690>
                TCP_SEQ_LEQ(pcb->ooseq->tcphdr->seqno, seqno + inseg.len)) {
  80d457:	8b 4a 10             	mov    0x10(%edx),%ecx
  80d45a:	8b 49 04             	mov    0x4(%ecx),%ecx
  80d45d:	0f b7 1d e0 c1 b3 00 	movzwl 0xb3c1e0,%ebx
  80d464:	89 ce                	mov    %ecx,%esi
  80d466:	29 de                	sub    %ebx,%esi
  80d468:	89 f3                	mov    %esi,%ebx
  80d46a:	29 c3                	sub    %eax,%ebx
        accepted_inseq = 1; 
        /* The incoming segment is the next in sequence. We check if
           we have to trim the end of the segment and update rcv_nxt
           and pass the data to the application. */
#if TCP_QUEUE_OOSEQ
        if (pcb->ooseq != NULL &&
  80d46c:	85 db                	test   %ebx,%ebx
  80d46e:	7f 6a                	jg     80d4da <tcp_receive+0x690>
                TCP_SEQ_LEQ(pcb->ooseq->tcphdr->seqno, seqno + inseg.len)) {
          if (pcb->ooseq->len > 0) {
  80d470:	66 83 7a 0c 00       	cmpw   $0x0,0xc(%edx)
  80d475:	74 1f                	je     80d496 <tcp_receive+0x64c>
            /* We have to trim the second edge of the incoming
               segment. */
            inseg.len = (u16_t)(pcb->ooseq->tcphdr->seqno - seqno);
  80d477:	29 c1                	sub    %eax,%ecx
  80d479:	66 89 0d e0 c1 b3 00 	mov    %cx,0xb3c1e0
            pbuf_realloc(inseg.p, inseg.len);
  80d480:	0f b7 c9             	movzwl %cx,%ecx
  80d483:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  80d487:	a1 d8 c1 b3 00       	mov    0xb3c1d8,%eax
  80d48c:	89 04 24             	mov    %eax,(%esp)
  80d48f:	e8 d2 7c ff ff       	call   805166 <pbuf_realloc>
  80d494:	eb 44                	jmp    80d4da <tcp_receive+0x690>
          } else {
            /* does the ooseq segment contain only flags that are in inseg also? */
            if ((TCPH_FLAGS(inseg.tcphdr) & (TCP_FIN|TCP_SYN)) ==
  80d496:	a1 e4 c1 b3 00       	mov    0xb3c1e4,%eax
  80d49b:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d49f:	89 04 24             	mov    %eax,(%esp)
  80d4a2:	e8 dc a8 ff ff       	call   807d83 <ntohs>
  80d4a7:	89 c3                	mov    %eax,%ebx
                (TCPH_FLAGS(pcb->ooseq->tcphdr) & (TCP_FIN|TCP_SYN))) {
  80d4a9:	8b 47 7c             	mov    0x7c(%edi),%eax
  80d4ac:	8b 40 10             	mov    0x10(%eax),%eax
  80d4af:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d4b3:	89 04 24             	mov    %eax,(%esp)
  80d4b6:	e8 c8 a8 ff ff       	call   807d83 <ntohs>
               segment. */
            inseg.len = (u16_t)(pcb->ooseq->tcphdr->seqno - seqno);
            pbuf_realloc(inseg.p, inseg.len);
          } else {
            /* does the ooseq segment contain only flags that are in inseg also? */
            if ((TCPH_FLAGS(inseg.tcphdr) & (TCP_FIN|TCP_SYN)) ==
  80d4bb:	31 c3                	xor    %eax,%ebx
  80d4bd:	f6 c3 03             	test   $0x3,%bl
  80d4c0:	75 18                	jne    80d4da <tcp_receive+0x690>
                (TCPH_FLAGS(pcb->ooseq->tcphdr) & (TCP_FIN|TCP_SYN))) {
              struct tcp_seg *old_ooseq = pcb->ooseq;
  80d4c2:	8b 47 7c             	mov    0x7c(%edi),%eax
              pcb->ooseq = pcb->ooseq->next;
  80d4c5:	8b 10                	mov    (%eax),%edx
  80d4c7:	89 57 7c             	mov    %edx,0x7c(%edi)
              memp_free(MEMP_TCP_SEG, old_ooseq);
  80d4ca:	89 44 24 04          	mov    %eax,0x4(%esp)
  80d4ce:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
  80d4d5:	e8 68 75 ff ff       	call   804a42 <memp_free>
            }
          }
        }
#endif /* TCP_QUEUE_OOSEQ */

        tcplen = TCP_TCPLEN(&inseg);
  80d4da:	0f b7 1d e0 c1 b3 00 	movzwl 0xb3c1e0,%ebx
  80d4e1:	a1 e4 c1 b3 00       	mov    0xb3c1e4,%eax
  80d4e6:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d4ea:	89 04 24             	mov    %eax,(%esp)
  80d4ed:	e8 91 a8 ff ff       	call   807d83 <ntohs>
  80d4f2:	ba 01 00 00 00       	mov    $0x1,%edx
  80d4f7:	a8 01                	test   $0x1,%al
  80d4f9:	75 19                	jne    80d514 <tcp_receive+0x6ca>
  80d4fb:	a1 e4 c1 b3 00       	mov    0xb3c1e4,%eax
  80d500:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d504:	89 04 24             	mov    %eax,(%esp)
  80d507:	e8 77 a8 ff ff       	call   807d83 <ntohs>
  80d50c:	66 d1 e8             	shr    %ax
  80d50f:	89 c2                	mov    %eax,%edx
  80d511:	83 e2 01             	and    $0x1,%edx
  80d514:	8d 04 13             	lea    (%ebx,%edx,1),%eax
  80d517:	66 a3 be c1 b3 00    	mov    %ax,0xb3c1be

        /* First received FIN will be ACKed +1, on any successive (duplicate)
         * FINs we are already in CLOSE_WAIT and have already done +1.
         */
        if (pcb->state != CLOSE_WAIT) {
  80d51d:	83 7f 10 07          	cmpl   $0x7,0x10(%edi)
  80d521:	74 06                	je     80d529 <tcp_receive+0x6df>
          pcb->rcv_nxt += tcplen;
  80d523:	0f b7 d0             	movzwl %ax,%edx
  80d526:	01 57 24             	add    %edx,0x24(%edi)
        }

        /* Update the receiver's (our) window. */
        if (pcb->rcv_wnd < tcplen) {
  80d529:	0f b7 57 28          	movzwl 0x28(%edi),%edx
  80d52d:	66 39 d0             	cmp    %dx,%ax
  80d530:	76 08                	jbe    80d53a <tcp_receive+0x6f0>
          pcb->rcv_wnd = 0;
  80d532:	66 c7 47 28 00 00    	movw   $0x0,0x28(%edi)
  80d538:	eb 06                	jmp    80d540 <tcp_receive+0x6f6>
        } else {
          pcb->rcv_wnd -= tcplen;
  80d53a:	29 c2                	sub    %eax,%edx
  80d53c:	66 89 57 28          	mov    %dx,0x28(%edi)
        }

        if (pcb->rcv_ann_wnd < tcplen) {
  80d540:	0f b7 57 2a          	movzwl 0x2a(%edi),%edx
  80d544:	66 39 d0             	cmp    %dx,%ax
  80d547:	76 08                	jbe    80d551 <tcp_receive+0x707>
          pcb->rcv_ann_wnd = 0;
  80d549:	66 c7 47 2a 00 00    	movw   $0x0,0x2a(%edi)
  80d54f:	eb 06                	jmp    80d557 <tcp_receive+0x70d>
        } else {
          pcb->rcv_ann_wnd -= tcplen;
  80d551:	29 c2                	sub    %eax,%edx
  80d553:	66 89 57 2a          	mov    %dx,0x2a(%edi)
           chains its data on this pbuf as well.

           If the segment was a FIN, we set the TF_GOT_FIN flag that will
           be used to indicate to the application that the remote side has
           closed its end of the connection. */
        if (inseg.p->tot_len > 0) {
  80d557:	a1 d8 c1 b3 00       	mov    0xb3c1d8,%eax
  80d55c:	66 83 78 08 00       	cmpw   $0x0,0x8(%eax)
  80d561:	74 0f                	je     80d572 <tcp_receive+0x728>
          recv_data = inseg.p;
  80d563:	a3 b8 c1 b3 00       	mov    %eax,0xb3c1b8
          /* Since this pbuf now is the responsibility of the
             application, we delete our reference to it so that we won't
             (mistakingly) deallocate it. */
          inseg.p = NULL;
  80d568:	c7 05 d8 c1 b3 00 00 	movl   $0x0,0xb3c1d8
  80d56f:	00 00 00 
        }
        if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
  80d572:	a1 e4 c1 b3 00       	mov    0xb3c1e4,%eax
  80d577:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d57b:	89 04 24             	mov    %eax,(%esp)
  80d57e:	e8 00 a8 ff ff       	call   807d83 <ntohs>
  80d583:	a8 01                	test   $0x1,%al
  80d585:	0f 84 cb 01 00 00    	je     80d756 <tcp_receive+0x90c>
          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: received FIN.\n"));
          recv_flags = TF_GOT_FIN;
  80d58b:	c6 05 bc c1 b3 00 20 	movb   $0x20,0xb3c1bc
  80d592:	e9 bf 01 00 00       	jmp    80d756 <tcp_receive+0x90c>
           is now in sequence. */
        while (pcb->ooseq != NULL &&
               pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {

          cseg = pcb->ooseq;
          seqno = pcb->ooseq->tcphdr->seqno;
  80d597:	89 35 c8 c1 b3 00    	mov    %esi,0xb3c1c8

          pcb->rcv_nxt += TCP_TCPLEN(cseg);
  80d59d:	0f b7 4b 0c          	movzwl 0xc(%ebx),%ecx
  80d5a1:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  80d5a4:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d5a8:	89 04 24             	mov    %eax,(%esp)
  80d5ab:	e8 d3 a7 ff ff       	call   807d83 <ntohs>
  80d5b0:	ba 01 00 00 00       	mov    $0x1,%edx
  80d5b5:	a8 01                	test   $0x1,%al
  80d5b7:	75 17                	jne    80d5d0 <tcp_receive+0x786>
  80d5b9:	8b 43 10             	mov    0x10(%ebx),%eax
  80d5bc:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d5c0:	89 04 24             	mov    %eax,(%esp)
  80d5c3:	e8 bb a7 ff ff       	call   807d83 <ntohs>
  80d5c8:	66 d1 e8             	shr    %ax
  80d5cb:	89 c2                	mov    %eax,%edx
  80d5cd:	83 e2 01             	and    $0x1,%edx
  80d5d0:	03 55 e4             	add    -0x1c(%ebp),%edx
  80d5d3:	01 d6                	add    %edx,%esi
  80d5d5:	89 77 24             	mov    %esi,0x24(%edi)
          if (pcb->rcv_wnd < TCP_TCPLEN(cseg)) {
  80d5d8:	0f b7 47 28          	movzwl 0x28(%edi),%eax
  80d5dc:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80d5df:	0f b7 73 0c          	movzwl 0xc(%ebx),%esi
  80d5e3:	8b 43 10             	mov    0x10(%ebx),%eax
  80d5e6:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d5ea:	89 04 24             	mov    %eax,(%esp)
  80d5ed:	e8 91 a7 ff ff       	call   807d83 <ntohs>
  80d5f2:	ba 01 00 00 00       	mov    $0x1,%edx
  80d5f7:	a8 01                	test   $0x1,%al
  80d5f9:	75 17                	jne    80d612 <tcp_receive+0x7c8>
  80d5fb:	8b 43 10             	mov    0x10(%ebx),%eax
  80d5fe:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d602:	89 04 24             	mov    %eax,(%esp)
  80d605:	e8 79 a7 ff ff       	call   807d83 <ntohs>
  80d60a:	66 d1 e8             	shr    %ax
  80d60d:	89 c2                	mov    %eax,%edx
  80d60f:	83 e2 01             	and    $0x1,%edx
  80d612:	01 d6                	add    %edx,%esi
  80d614:	39 75 e4             	cmp    %esi,-0x1c(%ebp)
  80d617:	7d 08                	jge    80d621 <tcp_receive+0x7d7>
            pcb->rcv_wnd = 0;
  80d619:	66 c7 47 28 00 00    	movw   $0x0,0x28(%edi)
  80d61f:	eb 45                	jmp    80d666 <tcp_receive+0x81c>
          } else {
            pcb->rcv_wnd -= TCP_TCPLEN(cseg);
  80d621:	0f b7 77 28          	movzwl 0x28(%edi),%esi
  80d625:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80d629:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
  80d62d:	8b 43 10             	mov    0x10(%ebx),%eax
  80d630:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d634:	89 04 24             	mov    %eax,(%esp)
  80d637:	e8 47 a7 ff ff       	call   807d83 <ntohs>
  80d63c:	ba 01 00 00 00       	mov    $0x1,%edx
  80d641:	a8 01                	test   $0x1,%al
  80d643:	75 17                	jne    80d65c <tcp_receive+0x812>
  80d645:	8b 43 10             	mov    0x10(%ebx),%eax
  80d648:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d64c:	89 04 24             	mov    %eax,(%esp)
  80d64f:	e8 2f a7 ff ff       	call   807d83 <ntohs>
  80d654:	66 d1 e8             	shr    %ax
  80d657:	89 c2                	mov    %eax,%edx
  80d659:	83 e2 01             	and    $0x1,%edx
  80d65c:	66 2b 75 e4          	sub    -0x1c(%ebp),%si
  80d660:	29 d6                	sub    %edx,%esi
  80d662:	66 89 77 28          	mov    %si,0x28(%edi)
          }
          if (pcb->rcv_ann_wnd < TCP_TCPLEN(cseg)) {
  80d666:	0f b7 47 2a          	movzwl 0x2a(%edi),%eax
  80d66a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80d66d:	0f b7 73 0c          	movzwl 0xc(%ebx),%esi
  80d671:	8b 43 10             	mov    0x10(%ebx),%eax
  80d674:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d678:	89 04 24             	mov    %eax,(%esp)
  80d67b:	e8 03 a7 ff ff       	call   807d83 <ntohs>
  80d680:	ba 01 00 00 00       	mov    $0x1,%edx
  80d685:	a8 01                	test   $0x1,%al
  80d687:	75 17                	jne    80d6a0 <tcp_receive+0x856>
  80d689:	8b 43 10             	mov    0x10(%ebx),%eax
  80d68c:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d690:	89 04 24             	mov    %eax,(%esp)
  80d693:	e8 eb a6 ff ff       	call   807d83 <ntohs>
  80d698:	66 d1 e8             	shr    %ax
  80d69b:	89 c2                	mov    %eax,%edx
  80d69d:	83 e2 01             	and    $0x1,%edx
  80d6a0:	01 d6                	add    %edx,%esi
  80d6a2:	39 75 e4             	cmp    %esi,-0x1c(%ebp)
  80d6a5:	7d 08                	jge    80d6af <tcp_receive+0x865>
            pcb->rcv_ann_wnd = 0;
  80d6a7:	66 c7 47 2a 00 00    	movw   $0x0,0x2a(%edi)
  80d6ad:	eb 45                	jmp    80d6f4 <tcp_receive+0x8aa>
          } else {
            pcb->rcv_ann_wnd -= TCP_TCPLEN(cseg);
  80d6af:	0f b7 77 2a          	movzwl 0x2a(%edi),%esi
  80d6b3:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80d6b7:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
  80d6bb:	8b 43 10             	mov    0x10(%ebx),%eax
  80d6be:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d6c2:	89 04 24             	mov    %eax,(%esp)
  80d6c5:	e8 b9 a6 ff ff       	call   807d83 <ntohs>
  80d6ca:	ba 01 00 00 00       	mov    $0x1,%edx
  80d6cf:	a8 01                	test   $0x1,%al
  80d6d1:	75 17                	jne    80d6ea <tcp_receive+0x8a0>
  80d6d3:	8b 43 10             	mov    0x10(%ebx),%eax
  80d6d6:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d6da:	89 04 24             	mov    %eax,(%esp)
  80d6dd:	e8 a1 a6 ff ff       	call   807d83 <ntohs>
  80d6e2:	66 d1 e8             	shr    %ax
  80d6e5:	89 c2                	mov    %eax,%edx
  80d6e7:	83 e2 01             	and    $0x1,%edx
  80d6ea:	66 2b 75 e4          	sub    -0x1c(%ebp),%si
  80d6ee:	29 d6                	sub    %edx,%esi
  80d6f0:	66 89 77 2a          	mov    %si,0x2a(%edi)
          }

          if (cseg->p->tot_len > 0) {
  80d6f4:	8b 43 04             	mov    0x4(%ebx),%eax
  80d6f7:	66 83 78 08 00       	cmpw   $0x0,0x8(%eax)
  80d6fc:	74 24                	je     80d722 <tcp_receive+0x8d8>
            /* Chain this pbuf onto the pbuf that we will pass to
               the application. */
            if (recv_data) {
  80d6fe:	8b 15 b8 c1 b3 00    	mov    0xb3c1b8,%edx
  80d704:	85 d2                	test   %edx,%edx
  80d706:	74 0e                	je     80d716 <tcp_receive+0x8cc>
              pbuf_cat(recv_data, cseg->p);
  80d708:	89 44 24 04          	mov    %eax,0x4(%esp)
  80d70c:	89 14 24             	mov    %edx,(%esp)
  80d70f:	e8 9f 7b ff ff       	call   8052b3 <pbuf_cat>
  80d714:	eb 05                	jmp    80d71b <tcp_receive+0x8d1>
            } else {
              recv_data = cseg->p;
  80d716:	a3 b8 c1 b3 00       	mov    %eax,0xb3c1b8
            }
            cseg->p = NULL;
  80d71b:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
          }
          if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
  80d722:	8b 43 10             	mov    0x10(%ebx),%eax
  80d725:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d729:	89 04 24             	mov    %eax,(%esp)
  80d72c:	e8 52 a6 ff ff       	call   807d83 <ntohs>
  80d731:	a8 01                	test   $0x1,%al
  80d733:	74 14                	je     80d749 <tcp_receive+0x8ff>
            LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: dequeued FIN.\n"));
            recv_flags = TF_GOT_FIN;
  80d735:	c6 05 bc c1 b3 00 20 	movb   $0x20,0xb3c1bc
            if (pcb->state == ESTABLISHED) { /* force passive close or we can move to active close */
  80d73c:	83 7f 10 04          	cmpl   $0x4,0x10(%edi)
  80d740:	75 07                	jne    80d749 <tcp_receive+0x8ff>
              pcb->state = CLOSE_WAIT;
  80d742:	c7 47 10 07 00 00 00 	movl   $0x7,0x10(%edi)
            } 
          }


          pcb->ooseq = cseg->next;
  80d749:	8b 03                	mov    (%ebx),%eax
  80d74b:	89 47 7c             	mov    %eax,0x7c(%edi)
          tcp_seg_free(cseg);
  80d74e:	89 1c 24             	mov    %ebx,(%esp)
  80d751:	e8 73 86 ff ff       	call   805dc9 <tcp_seg_free>
        }

#if TCP_QUEUE_OOSEQ
        /* We now check if we have segments on the ->ooseq queue that
           is now in sequence. */
        while (pcb->ooseq != NULL &&
  80d756:	8b 5f 7c             	mov    0x7c(%edi),%ebx
  80d759:	85 db                	test   %ebx,%ebx
  80d75b:	74 0f                	je     80d76c <tcp_receive+0x922>
               pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {
  80d75d:	8b 43 10             	mov    0x10(%ebx),%eax
  80d760:	8b 70 04             	mov    0x4(%eax),%esi
        }

#if TCP_QUEUE_OOSEQ
        /* We now check if we have segments on the ->ooseq queue that
           is now in sequence. */
        while (pcb->ooseq != NULL &&
  80d763:	3b 77 24             	cmp    0x24(%edi),%esi
  80d766:	0f 84 2b fe ff ff    	je     80d597 <tcp_receive+0x74d>
        }
#endif /* TCP_QUEUE_OOSEQ */


        /* Acknowledge the segment(s). */
        tcp_ack(pcb);
  80d76c:	0f b6 47 20          	movzbl 0x20(%edi),%eax
  80d770:	a8 01                	test   $0x1,%al
  80d772:	74 1b                	je     80d78f <tcp_receive+0x945>
  80d774:	83 e0 fe             	and    $0xfffffffe,%eax
  80d777:	83 c8 02             	or     $0x2,%eax
  80d77a:	88 47 20             	mov    %al,0x20(%edi)
  80d77d:	89 3c 24             	mov    %edi,(%esp)
  80d780:	e8 dc af ff ff       	call   808761 <tcp_output>
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
        accepted_inseq = 1; 
  80d785:	b8 01 00 00 00       	mov    $0x1,%eax
  80d78a:	e9 e1 02 00 00       	jmp    80da70 <tcp_receive+0xc26>
        }
#endif /* TCP_QUEUE_OOSEQ */


        /* Acknowledge the segment(s). */
        tcp_ack(pcb);
  80d78f:	83 c8 01             	or     $0x1,%eax
  80d792:	88 47 20             	mov    %al,0x20(%edi)
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
        accepted_inseq = 1; 
  80d795:	b8 01 00 00 00       	mov    $0x1,%eax
  80d79a:	e9 d1 02 00 00       	jmp    80da70 <tcp_receive+0xc26>
        /* Acknowledge the segment(s). */
        tcp_ack(pcb);

      } else {
        /* We get here if the incoming segment is out-of-sequence. */
        tcp_ack_now(pcb);
  80d79f:	80 4f 20 02          	orb    $0x2,0x20(%edi)
  80d7a3:	89 3c 24             	mov    %edi,(%esp)
  80d7a6:	e8 b6 af ff ff       	call   808761 <tcp_output>
#if TCP_QUEUE_OOSEQ
        /* We queue the segment on the ->ooseq queue. */
        if (pcb->ooseq == NULL) {
  80d7ab:	8b 5f 7c             	mov    0x7c(%edi),%ebx
  80d7ae:	85 db                	test   %ebx,%ebx
  80d7b0:	75 19                	jne    80d7cb <tcp_receive+0x981>
          pcb->ooseq = tcp_seg_copy(&inseg);
  80d7b2:	c7 04 24 d4 c1 b3 00 	movl   $0xb3c1d4,(%esp)
  80d7b9:	e8 8b 86 ff ff       	call   805e49 <tcp_seg_copy>
  80d7be:	89 47 7c             	mov    %eax,0x7c(%edi)
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;
  80d7c1:	b8 00 00 00 00       	mov    $0x0,%eax
  80d7c6:	e9 a5 02 00 00       	jmp    80da70 <tcp_receive+0xc26>
             segment on the ->ooseq queue, we discard the segment that
             contains less data. */

          prev = NULL;
          for(next = pcb->ooseq; next != NULL; next = next->next) {
            if (seqno == next->tcphdr->seqno) {
  80d7cb:	8b 0d c8 c1 b3 00    	mov    0xb3c1c8,%ecx
                  break;
                }
              } else 
                /*if (TCP_SEQ_LT(prev->tcphdr->seqno, seqno) &&
                  TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {*/
                if(TCP_SEQ_BETWEEN(seqno, prev->tcphdr->seqno+1, next->tcphdr->seqno-1)){
  80d7d1:	8d 41 ff             	lea    -0x1(%ecx),%eax
  80d7d4:	8d 51 01             	lea    0x1(%ecx),%edx
  80d7d7:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  80d7da:	be 00 00 00 00       	mov    $0x0,%esi
  80d7df:	89 7d e0             	mov    %edi,-0x20(%ebp)
  80d7e2:	89 c7                	mov    %eax,%edi
             segment on the ->ooseq queue, we discard the segment that
             contains less data. */

          prev = NULL;
          for(next = pcb->ooseq; next != NULL; next = next->next) {
            if (seqno == next->tcphdr->seqno) {
  80d7e4:	8b 43 10             	mov    0x10(%ebx),%eax
  80d7e7:	8b 40 04             	mov    0x4(%eax),%eax
  80d7ea:	39 c8                	cmp    %ecx,%eax
  80d7ec:	0f 85 9e 00 00 00    	jne    80d890 <tcp_receive+0xa46>
  80d7f2:	8b 7d e0             	mov    -0x20(%ebp),%edi
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;
  80d7f5:	b8 00 00 00 00       	mov    $0x0,%eax
            if (seqno == next->tcphdr->seqno) {
              /* The sequence number of the incoming segment is the
                 same as the sequence number of the segment on
                 ->ooseq. We check the lengths to see which one to
                 discard. */
              if (inseg.len > next->len) {
  80d7fa:	0f b7 4b 0c          	movzwl 0xc(%ebx),%ecx
  80d7fe:	66 39 0d e0 c1 b3 00 	cmp    %cx,0xb3c1e0
  80d805:	0f 86 65 02 00 00    	jbe    80da70 <tcp_receive+0xc26>
                /* The incoming segment is larger than the old
                   segment. We replace the old segment with the new
                   one. */
                cseg = tcp_seg_copy(&inseg);
  80d80b:	c7 04 24 d4 c1 b3 00 	movl   $0xb3c1d4,(%esp)
  80d812:	e8 32 86 ff ff       	call   805e49 <tcp_seg_copy>
  80d817:	89 c1                	mov    %eax,%ecx
  80d819:	89 45 e4             	mov    %eax,-0x1c(%ebp)
                if (cseg != NULL) {
  80d81c:	85 c0                	test   %eax,%eax
  80d81e:	0f 84 1d 02 00 00    	je     80da41 <tcp_receive+0xbf7>
                  cseg->next = next->next;
  80d824:	8b 03                	mov    (%ebx),%eax
  80d826:	89 01                	mov    %eax,(%ecx)
                  if (prev != NULL) {
  80d828:	85 f6                	test   %esi,%esi
  80d82a:	74 04                	je     80d830 <tcp_receive+0x9e6>
                    prev->next = cseg;
  80d82c:	89 0e                	mov    %ecx,(%esi)
  80d82e:	eb 06                	jmp    80d836 <tcp_receive+0x9ec>
                  } else {
                    pcb->ooseq = cseg;
  80d830:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80d833:	89 47 7c             	mov    %eax,0x7c(%edi)
                  }
                  tcp_seg_free(next);
  80d836:	89 1c 24             	mov    %ebx,(%esp)
  80d839:	e8 8b 85 ff ff       	call   805dc9 <tcp_seg_free>
                  if (cseg->next != NULL) {
  80d83e:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  80d841:	8b 06                	mov    (%esi),%eax
  80d843:	85 c0                	test   %eax,%eax
  80d845:	0f 84 fd 01 00 00    	je     80da48 <tcp_receive+0xbfe>
                    next = cseg->next;
                    if (TCP_SEQ_GT(seqno + cseg->len, next->tcphdr->seqno)) {
  80d84b:	8b 15 c8 c1 b3 00    	mov    0xb3c1c8,%edx
  80d851:	8b 40 10             	mov    0x10(%eax),%eax
  80d854:	8b 48 04             	mov    0x4(%eax),%ecx
  80d857:	0f b7 5e 0c          	movzwl 0xc(%esi),%ebx
  80d85b:	29 cb                	sub    %ecx,%ebx
  80d85d:	01 d3                	add    %edx,%ebx
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;
  80d85f:	b8 00 00 00 00       	mov    $0x0,%eax
                    pcb->ooseq = cseg;
                  }
                  tcp_seg_free(next);
                  if (cseg->next != NULL) {
                    next = cseg->next;
                    if (TCP_SEQ_GT(seqno + cseg->len, next->tcphdr->seqno)) {
  80d864:	85 db                	test   %ebx,%ebx
  80d866:	0f 8e 04 02 00 00    	jle    80da70 <tcp_receive+0xc26>
                      /* We need to trim the incoming segment. */
                      cseg->len = (u16_t)(next->tcphdr->seqno - seqno);
  80d86c:	89 c8                	mov    %ecx,%eax
  80d86e:	29 d0                	sub    %edx,%eax
  80d870:	66 89 46 0c          	mov    %ax,0xc(%esi)
                      pbuf_realloc(cseg->p, cseg->len);
  80d874:	0f b7 c0             	movzwl %ax,%eax
  80d877:	89 44 24 04          	mov    %eax,0x4(%esp)
  80d87b:	8b 46 04             	mov    0x4(%esi),%eax
  80d87e:	89 04 24             	mov    %eax,(%esp)
  80d881:	e8 e0 78 ff ff       	call   805166 <pbuf_realloc>
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;
  80d886:	b8 00 00 00 00       	mov    $0x0,%eax
  80d88b:	e9 e0 01 00 00       	jmp    80da70 <tcp_receive+0xc26>
                   segment was smaller than the old one; in either
                   case, we ditch the incoming segment. */
                break;
              }
            } else {
              if (prev == NULL) {
  80d890:	85 f6                	test   %esi,%esi
  80d892:	75 59                	jne    80d8ed <tcp_receive+0xaa3>
                if (TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {
  80d894:	39 c1                	cmp    %eax,%ecx
  80d896:	0f 89 f2 00 00 00    	jns    80d98e <tcp_receive+0xb44>
  80d89c:	8b 7d e0             	mov    -0x20(%ebp),%edi
                  /* The sequence number of the incoming segment is lower
                     than the sequence number of the first segment on the
                     queue. We put the incoming segment first on the
                     queue. */

                  if (TCP_SEQ_GT(seqno + inseg.len, next->tcphdr->seqno)) {
  80d89f:	0f b7 15 e0 c1 b3 00 	movzwl 0xb3c1e0,%edx
  80d8a6:	01 ca                	add    %ecx,%edx
  80d8a8:	29 c2                	sub    %eax,%edx
  80d8aa:	85 d2                	test   %edx,%edx
  80d8ac:	7e 1c                	jle    80d8ca <tcp_receive+0xa80>
                    /* We need to trim the incoming segment. */
                    inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
  80d8ae:	29 c8                	sub    %ecx,%eax
  80d8b0:	66 a3 e0 c1 b3 00    	mov    %ax,0xb3c1e0
                    pbuf_realloc(inseg.p, inseg.len);
  80d8b6:	0f b7 c0             	movzwl %ax,%eax
  80d8b9:	89 44 24 04          	mov    %eax,0x4(%esp)
  80d8bd:	a1 d8 c1 b3 00       	mov    0xb3c1d8,%eax
  80d8c2:	89 04 24             	mov    %eax,(%esp)
  80d8c5:	e8 9c 78 ff ff       	call   805166 <pbuf_realloc>
                  }
                  cseg = tcp_seg_copy(&inseg);
  80d8ca:	c7 04 24 d4 c1 b3 00 	movl   $0xb3c1d4,(%esp)
  80d8d1:	e8 73 85 ff ff       	call   805e49 <tcp_seg_copy>
                  if (cseg != NULL) {
  80d8d6:	85 c0                	test   %eax,%eax
  80d8d8:	0f 84 71 01 00 00    	je     80da4f <tcp_receive+0xc05>
                    cseg->next = next;
  80d8de:	89 18                	mov    %ebx,(%eax)
                    pcb->ooseq = cseg;
  80d8e0:	89 47 7c             	mov    %eax,0x7c(%edi)
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;
  80d8e3:	b8 00 00 00 00       	mov    $0x0,%eax
  80d8e8:	e9 83 01 00 00       	jmp    80da70 <tcp_receive+0xc26>
                  break;
                }
              } else 
                /*if (TCP_SEQ_LT(prev->tcphdr->seqno, seqno) &&
                  TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {*/
                if(TCP_SEQ_BETWEEN(seqno, prev->tcphdr->seqno+1, next->tcphdr->seqno-1)){
  80d8ed:	8b 56 10             	mov    0x10(%esi),%edx
  80d8f0:	3b 7a 04             	cmp    0x4(%edx),%edi
  80d8f3:	0f 88 95 00 00 00    	js     80d98e <tcp_receive+0xb44>
  80d8f9:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80d8fc:	29 c2                	sub    %eax,%edx
  80d8fe:	85 d2                	test   %edx,%edx
  80d900:	0f 8f 88 00 00 00    	jg     80d98e <tcp_receive+0xb44>
                /* The sequence number of the incoming segment is in
                   between the sequence numbers of the previous and
                   the next segment on ->ooseq. We trim and insert the
                   incoming segment and trim the previous segment, if
                   needed. */
                if (TCP_SEQ_GT(seqno + inseg.len, next->tcphdr->seqno)) {
  80d906:	0f b7 15 e0 c1 b3 00 	movzwl 0xb3c1e0,%edx
  80d90d:	01 ca                	add    %ecx,%edx
  80d90f:	29 c2                	sub    %eax,%edx
  80d911:	85 d2                	test   %edx,%edx
  80d913:	7e 1c                	jle    80d931 <tcp_receive+0xae7>
                  /* We need to trim the incoming segment. */
                  inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
  80d915:	29 c8                	sub    %ecx,%eax
  80d917:	66 a3 e0 c1 b3 00    	mov    %ax,0xb3c1e0
                  pbuf_realloc(inseg.p, inseg.len);
  80d91d:	0f b7 c0             	movzwl %ax,%eax
  80d920:	89 44 24 04          	mov    %eax,0x4(%esp)
  80d924:	a1 d8 c1 b3 00       	mov    0xb3c1d8,%eax
  80d929:	89 04 24             	mov    %eax,(%esp)
  80d92c:	e8 35 78 ff ff       	call   805166 <pbuf_realloc>
                }

                cseg = tcp_seg_copy(&inseg);
  80d931:	c7 04 24 d4 c1 b3 00 	movl   $0xb3c1d4,(%esp)
  80d938:	e8 0c 85 ff ff       	call   805e49 <tcp_seg_copy>
                if (cseg != NULL) {
  80d93d:	85 c0                	test   %eax,%eax
  80d93f:	0f 84 11 01 00 00    	je     80da56 <tcp_receive+0xc0c>
                  cseg->next = next;
  80d945:	89 18                	mov    %ebx,(%eax)
                  prev->next = cseg;
  80d947:	89 06                	mov    %eax,(%esi)
                  if (TCP_SEQ_GT(prev->tcphdr->seqno + prev->len, seqno)) {
  80d949:	8b 46 10             	mov    0x10(%esi),%eax
  80d94c:	8b 50 04             	mov    0x4(%eax),%edx
  80d94f:	8b 0d c8 c1 b3 00    	mov    0xb3c1c8,%ecx
  80d955:	0f b7 5e 0c          	movzwl 0xc(%esi),%ebx
  80d959:	29 cb                	sub    %ecx,%ebx
  80d95b:	01 d3                	add    %edx,%ebx
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;
  80d95d:	b8 00 00 00 00       	mov    $0x0,%eax

                cseg = tcp_seg_copy(&inseg);
                if (cseg != NULL) {
                  cseg->next = next;
                  prev->next = cseg;
                  if (TCP_SEQ_GT(prev->tcphdr->seqno + prev->len, seqno)) {
  80d962:	85 db                	test   %ebx,%ebx
  80d964:	0f 8e 06 01 00 00    	jle    80da70 <tcp_receive+0xc26>
                    /* We need to trim the prev segment. */
                    prev->len = (u16_t)(seqno - prev->tcphdr->seqno);
  80d96a:	89 c8                	mov    %ecx,%eax
  80d96c:	29 d0                	sub    %edx,%eax
  80d96e:	66 89 46 0c          	mov    %ax,0xc(%esi)
                    pbuf_realloc(prev->p, prev->len);
  80d972:	0f b7 c0             	movzwl %ax,%eax
  80d975:	89 44 24 04          	mov    %eax,0x4(%esp)
  80d979:	8b 46 04             	mov    0x4(%esi),%eax
  80d97c:	89 04 24             	mov    %eax,(%esp)
  80d97f:	e8 e2 77 ff ff       	call   805166 <pbuf_realloc>
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;
  80d984:	b8 00 00 00 00       	mov    $0x0,%eax
  80d989:	e9 e2 00 00 00       	jmp    80da70 <tcp_receive+0xc26>
                break;
              }
              /* If the "next" segment is the last segment on the
                 ooseq queue, we add the incoming segment to the end
                 of the list. */
              if (next->next == NULL &&
  80d98e:	8b 13                	mov    (%ebx),%edx
  80d990:	85 d2                	test   %edx,%edx
  80d992:	75 62                	jne    80d9f6 <tcp_receive+0xbac>
                  TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
  80d994:	29 c1                	sub    %eax,%ecx
                break;
              }
              /* If the "next" segment is the last segment on the
                 ooseq queue, we add the incoming segment to the end
                 of the list. */
              if (next->next == NULL &&
  80d996:	85 c9                	test   %ecx,%ecx
  80d998:	0f 8e bf 00 00 00    	jle    80da5d <tcp_receive+0xc13>
                  TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
                next->next = tcp_seg_copy(&inseg);
  80d99e:	c7 04 24 d4 c1 b3 00 	movl   $0xb3c1d4,(%esp)
  80d9a5:	e8 9f 84 ff ff       	call   805e49 <tcp_seg_copy>
  80d9aa:	89 03                	mov    %eax,(%ebx)
                if (next->next != NULL) {
  80d9ac:	85 c0                	test   %eax,%eax
  80d9ae:	0f 84 b0 00 00 00    	je     80da64 <tcp_receive+0xc1a>
                  if (TCP_SEQ_GT(next->tcphdr->seqno + next->len, seqno)) {
  80d9b4:	8b 43 10             	mov    0x10(%ebx),%eax
  80d9b7:	8b 50 04             	mov    0x4(%eax),%edx
  80d9ba:	8b 0d c8 c1 b3 00    	mov    0xb3c1c8,%ecx
  80d9c0:	0f b7 73 0c          	movzwl 0xc(%ebx),%esi
  80d9c4:	29 ce                	sub    %ecx,%esi
  80d9c6:	01 d6                	add    %edx,%esi
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;
  80d9c8:	b8 00 00 00 00       	mov    $0x0,%eax
                 of the list. */
              if (next->next == NULL &&
                  TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
                next->next = tcp_seg_copy(&inseg);
                if (next->next != NULL) {
                  if (TCP_SEQ_GT(next->tcphdr->seqno + next->len, seqno)) {
  80d9cd:	85 f6                	test   %esi,%esi
  80d9cf:	0f 8e 9b 00 00 00    	jle    80da70 <tcp_receive+0xc26>
                    /* We need to trim the last segment. */
                    next->len = (u16_t)(seqno - next->tcphdr->seqno);
  80d9d5:	89 c8                	mov    %ecx,%eax
  80d9d7:	29 d0                	sub    %edx,%eax
  80d9d9:	66 89 43 0c          	mov    %ax,0xc(%ebx)
                    pbuf_realloc(next->p, next->len);
  80d9dd:	0f b7 c0             	movzwl %ax,%eax
  80d9e0:	89 44 24 04          	mov    %eax,0x4(%esp)
  80d9e4:	8b 43 04             	mov    0x4(%ebx),%eax
  80d9e7:	89 04 24             	mov    %eax,(%esp)
  80d9ea:	e8 77 77 ff ff       	call   805166 <pbuf_realloc>
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;
  80d9ef:	b8 00 00 00 00       	mov    $0x0,%eax
  80d9f4:	eb 7a                	jmp    80da70 <tcp_receive+0xc26>
                break;
              }
              /* If the "next" segment is the last segment on the
                 ooseq queue, we add the incoming segment to the end
                 of the list. */
              if (next->next == NULL &&
  80d9f6:	89 de                	mov    %ebx,%esi
  80d9f8:	89 d3                	mov    %edx,%ebx
  80d9fa:	e9 e5 fd ff ff       	jmp    80d7e4 <tcp_receive+0x99a>
        }
#endif /* TCP_QUEUE_OOSEQ */

      }
    } else {
      tcp_ack_now(pcb);
  80d9ff:	80 4f 20 02          	orb    $0x2,0x20(%edi)
  80da03:	89 3c 24             	mov    %edi,(%esp)
  80da06:	e8 56 ad ff ff       	call   808761 <tcp_output>
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;
  80da0b:	b8 00 00 00 00       	mov    $0x0,%eax
  80da10:	eb 5e                	jmp    80da70 <tcp_receive+0xc26>
  } else {
    /* Segments with length 0 is taken care of here. Segments that
       fall out of the window are ACKed. */
    /*if (TCP_SEQ_GT(pcb->rcv_nxt, seqno) ||
      TCP_SEQ_GEQ(seqno, pcb->rcv_nxt + pcb->rcv_wnd)) {*/
    if(!TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd-1)){
  80da12:	8b 15 c8 c1 b3 00    	mov    0xb3c1c8,%edx
  80da18:	8b 47 24             	mov    0x24(%edi),%eax
  80da1b:	39 c2                	cmp    %eax,%edx
  80da1d:	78 0f                	js     80da2e <tcp_receive+0xbe4>
  80da1f:	83 c2 01             	add    $0x1,%edx
  80da22:	29 c2                	sub    %eax,%edx
  80da24:	0f b7 47 28          	movzwl 0x28(%edi),%eax
  80da28:	29 c2                	sub    %eax,%edx
  80da2a:	85 d2                	test   %edx,%edx
  80da2c:	7e 3d                	jle    80da6b <tcp_receive+0xc21>
      tcp_ack_now(pcb);
  80da2e:	80 4f 20 02          	orb    $0x2,0x20(%edi)
  80da32:	89 3c 24             	mov    %edi,(%esp)
  80da35:	e8 27 ad ff ff       	call   808761 <tcp_output>
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;
  80da3a:	b8 00 00 00 00       	mov    $0x0,%eax
  80da3f:	eb 2f                	jmp    80da70 <tcp_receive+0xc26>
  80da41:	b8 00 00 00 00       	mov    $0x0,%eax
  80da46:	eb 28                	jmp    80da70 <tcp_receive+0xc26>
  80da48:	b8 00 00 00 00       	mov    $0x0,%eax
  80da4d:	eb 21                	jmp    80da70 <tcp_receive+0xc26>
  80da4f:	b8 00 00 00 00       	mov    $0x0,%eax
  80da54:	eb 1a                	jmp    80da70 <tcp_receive+0xc26>
  80da56:	b8 00 00 00 00       	mov    $0x0,%eax
  80da5b:	eb 13                	jmp    80da70 <tcp_receive+0xc26>
  80da5d:	b8 00 00 00 00       	mov    $0x0,%eax
  80da62:	eb 0c                	jmp    80da70 <tcp_receive+0xc26>
  80da64:	b8 00 00 00 00       	mov    $0x0,%eax
  80da69:	eb 05                	jmp    80da70 <tcp_receive+0xc26>
  80da6b:	b8 00 00 00 00       	mov    $0x0,%eax
    if(!TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd-1)){
      tcp_ack_now(pcb);
    }
  }
  return accepted_inseq;
}
  80da70:	83 c4 2c             	add    $0x2c,%esp
  80da73:	5b                   	pop    %ebx
  80da74:	5e                   	pop    %esi
  80da75:	5f                   	pop    %edi
  80da76:	5d                   	pop    %ebp
  80da77:	c3                   	ret    

0080da78 <tcp_input>:
 * @param p received TCP segment to process (p->payload pointing to the IP header)
 * @param inp network interface on which this segment was received
 */
void
tcp_input(struct pbuf *p, struct netif *inp)
{
  80da78:	55                   	push   %ebp
  80da79:	89 e5                	mov    %esp,%ebp
  80da7b:	57                   	push   %edi
  80da7c:	56                   	push   %esi
  80da7d:	53                   	push   %ebx
  80da7e:	83 ec 4c             	sub    $0x4c,%esp
  80da81:	8b 75 08             	mov    0x8(%ebp),%esi
  PERF_START;

  TCP_STATS_INC(tcp.recv);
  snmp_inc_tcpinsegs();

  iphdr = p->payload;
  80da84:	8b 5e 04             	mov    0x4(%esi),%ebx
  80da87:	89 1d cc c1 b3 00    	mov    %ebx,0xb3c1cc
  tcphdr = (struct tcp_hdr *)((u8_t *)p->payload + IPH_HL(iphdr) * 4);
  80da8d:	0f b7 03             	movzwl (%ebx),%eax
  80da90:	89 04 24             	mov    %eax,(%esp)
  80da93:	e8 eb a2 ff ff       	call   807d83 <ntohs>
  80da98:	66 c1 e8 08          	shr    $0x8,%ax
  80da9c:	83 e0 0f             	and    $0xf,%eax
  80da9f:	8d 04 83             	lea    (%ebx,%eax,4),%eax
  80daa2:	a3 d0 c1 b3 00       	mov    %eax,0xb3c1d0
#if TCP_INPUT_DEBUG
  tcp_debug_print(tcphdr);
#endif

  /* remove header from payload */
  if (pbuf_header(p, -((s16_t)(IPH_HL(iphdr) * 4))) || (p->tot_len < sizeof(struct tcp_hdr))) {
  80daa7:	a1 cc c1 b3 00       	mov    0xb3c1cc,%eax
  80daac:	0f b7 00             	movzwl (%eax),%eax
  80daaf:	89 04 24             	mov    %eax,(%esp)
  80dab2:	e8 cc a2 ff ff       	call   807d83 <ntohs>
  80dab7:	66 c1 e8 06          	shr    $0x6,%ax
  80dabb:	83 e0 3c             	and    $0x3c,%eax
  80dabe:	f7 d8                	neg    %eax
  80dac0:	98                   	cwtl   
  80dac1:	89 44 24 04          	mov    %eax,0x4(%esp)
  80dac5:	89 34 24             	mov    %esi,(%esp)
  80dac8:	e8 43 72 ff ff       	call   804d10 <pbuf_header>
  80dacd:	84 c0                	test   %al,%al
  80dacf:	75 07                	jne    80dad8 <tcp_input+0x60>
  80dad1:	66 83 7e 08 13       	cmpw   $0x13,0x8(%esi)
  80dad6:	77 0d                	ja     80dae5 <tcp_input+0x6d>
    /* drop short packets */
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: short packet (%"U16_F" bytes) discarded\n", p->tot_len));
    TCP_STATS_INC(tcp.lenerr);
    TCP_STATS_INC(tcp.drop);
    snmp_inc_tcpinerrs();
    pbuf_free(p);
  80dad8:	89 34 24             	mov    %esi,(%esp)
  80dadb:	e8 14 73 ff ff       	call   804df4 <pbuf_free>
    return;
  80dae0:	e9 cc 0c 00 00       	jmp    80e7b1 <tcp_input+0xd39>
  }

  /* Don't even process incoming broadcasts/multicasts. */
  if (ip_addr_isbroadcast(&(iphdr->dest), inp) ||
  80dae5:	8b 45 0c             	mov    0xc(%ebp),%eax
  80dae8:	89 44 24 04          	mov    %eax,0x4(%esp)
  80daec:	a1 cc c1 b3 00       	mov    0xb3c1cc,%eax
  80daf1:	83 c0 10             	add    $0x10,%eax
  80daf4:	89 04 24             	mov    %eax,(%esp)
  80daf7:	e8 95 8f ff ff       	call   806a91 <ip_addr_isbroadcast>
  80dafc:	84 c0                	test   %al,%al
  80dafe:	75 26                	jne    80db26 <tcp_input+0xae>
      ip_addr_ismulticast(&(iphdr->dest))) {
  80db00:	a1 cc c1 b3 00       	mov    0xb3c1cc,%eax
  80db05:	8b 58 10             	mov    0x10(%eax),%ebx
  80db08:	c7 04 24 00 00 00 f0 	movl   $0xf0000000,(%esp)
  80db0f:	e8 b6 a4 ff ff       	call   807fca <ntohl>
  80db14:	21 c3                	and    %eax,%ebx
  80db16:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  80db1d:	e8 a8 a4 ff ff       	call   807fca <ntohl>
    pbuf_free(p);
    return;
  }

  /* Don't even process incoming broadcasts/multicasts. */
  if (ip_addr_isbroadcast(&(iphdr->dest), inp) ||
  80db22:	39 c3                	cmp    %eax,%ebx
  80db24:	75 0f                	jne    80db35 <tcp_input+0xbd>
      ip_addr_ismulticast(&(iphdr->dest))) {
    TCP_STATS_INC(tcp.proterr);
    TCP_STATS_INC(tcp.drop);
    snmp_inc_tcpinerrs();
    pbuf_free(p);
  80db26:	89 34 24             	mov    %esi,(%esp)
  80db29:	e8 c6 72 ff ff       	call   804df4 <pbuf_free>
    return;
  80db2e:	66 90                	xchg   %ax,%ax
  80db30:	e9 7c 0c 00 00       	jmp    80e7b1 <tcp_input+0xd39>
  }

#if CHECKSUM_CHECK_TCP
  /* Verify TCP checksum. */
  if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
      (struct ip_addr *)&(iphdr->dest),
  80db35:	a1 cc c1 b3 00       	mov    0xb3c1cc,%eax
    return;
  }

#if CHECKSUM_CHECK_TCP
  /* Verify TCP checksum. */
  if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
  80db3a:	0f b7 56 08          	movzwl 0x8(%esi),%edx
  80db3e:	89 54 24 10          	mov    %edx,0x10(%esp)
  80db42:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
  80db49:	00 
  80db4a:	8d 50 10             	lea    0x10(%eax),%edx
  80db4d:	89 54 24 08          	mov    %edx,0x8(%esp)
  80db51:	83 c0 0c             	add    $0xc,%eax
  80db54:	89 44 24 04          	mov    %eax,0x4(%esp)
  80db58:	89 34 24             	mov    %esi,(%esp)
  80db5b:	e8 ce 9e ff ff       	call   807a2e <inet_chksum_pseudo>
  80db60:	66 85 c0             	test   %ax,%ax
  80db63:	74 0d                	je     80db72 <tcp_input+0xfa>
    tcp_debug_print(tcphdr);
#endif /* TCP_DEBUG */
    TCP_STATS_INC(tcp.chkerr);
    TCP_STATS_INC(tcp.drop);
    snmp_inc_tcpinerrs();
    pbuf_free(p);
  80db65:	89 34 24             	mov    %esi,(%esp)
  80db68:	e8 87 72 ff ff       	call   804df4 <pbuf_free>
    return;
  80db6d:	e9 3f 0c 00 00       	jmp    80e7b1 <tcp_input+0xd39>
  }
#endif

  /* Move the payload pointer in the pbuf so that it points to the
     TCP data instead of the TCP header. */
  hdrlen = TCPH_HDRLEN(tcphdr);
  80db72:	a1 d0 c1 b3 00       	mov    0xb3c1d0,%eax
  80db77:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80db7b:	89 04 24             	mov    %eax,(%esp)
  80db7e:	e8 00 a2 ff ff       	call   807d83 <ntohs>
  80db83:	66 c1 e8 0c          	shr    $0xc,%ax
  if(pbuf_header(p, -(hdrlen * 4))){
  80db87:	f7 d8                	neg    %eax
  80db89:	c1 e0 02             	shl    $0x2,%eax
  80db8c:	98                   	cwtl   
  80db8d:	89 44 24 04          	mov    %eax,0x4(%esp)
  80db91:	89 34 24             	mov    %esi,(%esp)
  80db94:	e8 77 71 ff ff       	call   804d10 <pbuf_header>
  80db99:	84 c0                	test   %al,%al
  80db9b:	74 0d                	je     80dbaa <tcp_input+0x132>
    /* drop short packets */
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: short packet\n"));
    TCP_STATS_INC(tcp.lenerr);
    TCP_STATS_INC(tcp.drop);
    snmp_inc_tcpinerrs();
    pbuf_free(p);
  80db9d:	89 34 24             	mov    %esi,(%esp)
  80dba0:	e8 4f 72 ff ff       	call   804df4 <pbuf_free>
    return;
  80dba5:	e9 07 0c 00 00       	jmp    80e7b1 <tcp_input+0xd39>
  }

  /* Convert fields in TCP header to host byte order. */
  tcphdr->src = ntohs(tcphdr->src);
  80dbaa:	8b 1d d0 c1 b3 00    	mov    0xb3c1d0,%ebx
  80dbb0:	0f b7 03             	movzwl (%ebx),%eax
  80dbb3:	89 04 24             	mov    %eax,(%esp)
  80dbb6:	e8 c8 a1 ff ff       	call   807d83 <ntohs>
  80dbbb:	66 89 03             	mov    %ax,(%ebx)
  tcphdr->dest = ntohs(tcphdr->dest);
  80dbbe:	8b 1d d0 c1 b3 00    	mov    0xb3c1d0,%ebx
  80dbc4:	0f b7 43 02          	movzwl 0x2(%ebx),%eax
  80dbc8:	89 04 24             	mov    %eax,(%esp)
  80dbcb:	e8 b3 a1 ff ff       	call   807d83 <ntohs>
  80dbd0:	66 89 43 02          	mov    %ax,0x2(%ebx)
  seqno = tcphdr->seqno = ntohl(tcphdr->seqno);
  80dbd4:	8b 1d d0 c1 b3 00    	mov    0xb3c1d0,%ebx
  80dbda:	8b 43 04             	mov    0x4(%ebx),%eax
  80dbdd:	89 04 24             	mov    %eax,(%esp)
  80dbe0:	e8 e5 a3 ff ff       	call   807fca <ntohl>
  80dbe5:	89 43 04             	mov    %eax,0x4(%ebx)
  80dbe8:	a3 c8 c1 b3 00       	mov    %eax,0xb3c1c8
  ackno = tcphdr->ackno = ntohl(tcphdr->ackno);
  80dbed:	8b 1d d0 c1 b3 00    	mov    0xb3c1d0,%ebx
  80dbf3:	8b 43 08             	mov    0x8(%ebx),%eax
  80dbf6:	89 04 24             	mov    %eax,(%esp)
  80dbf9:	e8 cc a3 ff ff       	call   807fca <ntohl>
  80dbfe:	89 43 08             	mov    %eax,0x8(%ebx)
  80dc01:	a3 c4 c1 b3 00       	mov    %eax,0xb3c1c4
  tcphdr->wnd = ntohs(tcphdr->wnd);
  80dc06:	8b 1d d0 c1 b3 00    	mov    0xb3c1d0,%ebx
  80dc0c:	0f b7 43 0e          	movzwl 0xe(%ebx),%eax
  80dc10:	89 04 24             	mov    %eax,(%esp)
  80dc13:	e8 6b a1 ff ff       	call   807d83 <ntohs>
  80dc18:	66 89 43 0e          	mov    %ax,0xe(%ebx)

  flags = TCPH_FLAGS(tcphdr) & TCP_FLAGS;
  80dc1c:	a1 d0 c1 b3 00       	mov    0xb3c1d0,%eax
  80dc21:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80dc25:	89 04 24             	mov    %eax,(%esp)
  80dc28:	e8 56 a1 ff ff       	call   807d83 <ntohs>
  80dc2d:	89 c1                	mov    %eax,%ecx
  80dc2f:	66 89 45 d4          	mov    %ax,-0x2c(%ebp)
  80dc33:	83 e0 3f             	and    $0x3f,%eax
  80dc36:	a2 c0 c1 b3 00       	mov    %al,0xb3c1c0
  tcplen = p->tot_len + ((flags & TCP_FIN || flags & TCP_SYN)? 1: 0);
  80dc3b:	f6 c1 03             	test   $0x3,%cl
  80dc3e:	0f 95 c0             	setne  %al
  80dc41:	0f b6 c0             	movzbl %al,%eax
  80dc44:	66 03 46 08          	add    0x8(%esi),%ax
  80dc48:	66 89 45 d6          	mov    %ax,-0x2a(%ebp)
  80dc4c:	66 a3 be c1 b3 00    	mov    %ax,0xb3c1be
  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80dc52:	a1 5c c2 b3 00       	mov    0xb3c25c,%eax
  80dc57:	89 45 d0             	mov    %eax,-0x30(%ebp)
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
    if (pcb->remote_port == tcphdr->src &&
  80dc5a:	8b 15 d0 c1 b3 00    	mov    0xb3c1d0,%edx
       pcb->local_port == tcphdr->dest &&
       ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
  80dc60:	8b 0d cc c1 b3 00    	mov    0xb3c1cc,%ecx
  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80dc66:	89 c3                	mov    %eax,%ebx
  flags = TCPH_FLAGS(tcphdr) & TCP_FLAGS;
  tcplen = p->tot_len + ((flags & TCP_FIN || flags & TCP_SYN)? 1: 0);

  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;
  80dc68:	bf 00 00 00 00       	mov    $0x0,%edi

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80dc6d:	e9 ea 00 00 00       	jmp    80dd5c <tcp_input+0x2e4>
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
  80dc72:	8b 43 10             	mov    0x10(%ebx),%eax
  80dc75:	85 c0                	test   %eax,%eax
  80dc77:	75 1c                	jne    80dc95 <tcp_input+0x21d>
  80dc79:	c7 44 24 08 64 3e 81 	movl   $0x813e64,0x8(%esp)
  80dc80:	00 
  80dc81:	c7 44 24 04 b5 00 00 	movl   $0xb5,0x4(%esp)
  80dc88:	00 
  80dc89:	c7 04 24 88 3f 81 00 	movl   $0x813f88,(%esp)
  80dc90:	e8 e5 13 00 00       	call   80f07a <_panic>
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
  80dc95:	83 f8 0a             	cmp    $0xa,%eax
  80dc98:	75 1c                	jne    80dcb6 <tcp_input+0x23e>
  80dc9a:	c7 44 24 08 8c 3e 81 	movl   $0x813e8c,0x8(%esp)
  80dca1:	00 
  80dca2:	c7 44 24 04 b6 00 00 	movl   $0xb6,0x4(%esp)
  80dca9:	00 
  80dcaa:	c7 04 24 88 3f 81 00 	movl   $0x813f88,(%esp)
  80dcb1:	e8 c4 13 00 00       	call   80f07a <_panic>
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
  80dcb6:	83 f8 01             	cmp    $0x1,%eax
  80dcb9:	75 1c                	jne    80dcd7 <tcp_input+0x25f>
  80dcbb:	c7 44 24 08 b8 3e 81 	movl   $0x813eb8,0x8(%esp)
  80dcc2:	00 
  80dcc3:	c7 44 24 04 b7 00 00 	movl   $0xb7,0x4(%esp)
  80dcca:	00 
  80dccb:	c7 04 24 88 3f 81 00 	movl   $0x813f88,(%esp)
  80dcd2:	e8 a3 13 00 00       	call   80f07a <_panic>
    if (pcb->remote_port == tcphdr->src &&
  80dcd7:	0f b7 02             	movzwl (%edx),%eax
  80dcda:	66 39 43 1e          	cmp    %ax,0x1e(%ebx)
  80dcde:	75 77                	jne    80dd57 <tcp_input+0x2df>
  80dce0:	0f b7 42 02          	movzwl 0x2(%edx),%eax
  80dce4:	66 39 43 1c          	cmp    %ax,0x1c(%ebx)
  80dce8:	75 6d                	jne    80dd57 <tcp_input+0x2df>
       pcb->local_port == tcphdr->dest &&
  80dcea:	8b 41 0c             	mov    0xc(%ecx),%eax
  80dced:	39 43 04             	cmp    %eax,0x4(%ebx)
  80dcf0:	75 65                	jne    80dd57 <tcp_input+0x2df>
       ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
  80dcf2:	8b 41 10             	mov    0x10(%ecx),%eax
  80dcf5:	39 03                	cmp    %eax,(%ebx)
  80dcf7:	75 5e                	jne    80dd57 <tcp_input+0x2df>
       ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest))) {

      /* Move this PCB to the front of the list so that subsequent
         lookups will be faster (we exploit locality in TCP segment
         arrivals). */
      LWIP_ASSERT("tcp_input: pcb->next != pcb (before cache)", pcb->next != pcb);
  80dcf9:	8b 43 0c             	mov    0xc(%ebx),%eax
  80dcfc:	39 d8                	cmp    %ebx,%eax
  80dcfe:	75 1c                	jne    80dd1c <tcp_input+0x2a4>
  80dd00:	c7 44 24 08 e0 3e 81 	movl   $0x813ee0,0x8(%esp)
  80dd07:	00 
  80dd08:	c7 44 24 04 c0 00 00 	movl   $0xc0,0x4(%esp)
  80dd0f:	00 
  80dd10:	c7 04 24 88 3f 81 00 	movl   $0x813f88,(%esp)
  80dd17:	e8 5e 13 00 00       	call   80f07a <_panic>
      if (prev != NULL) {
  80dd1c:	85 ff                	test   %edi,%edi
  80dd1e:	0f 84 06 0a 00 00    	je     80e72a <tcp_input+0xcb2>
        prev->next = pcb->next;
  80dd24:	89 47 0c             	mov    %eax,0xc(%edi)
        pcb->next = tcp_active_pcbs;
  80dd27:	8b 45 d0             	mov    -0x30(%ebp),%eax
  80dd2a:	89 43 0c             	mov    %eax,0xc(%ebx)
        tcp_active_pcbs = pcb;
  80dd2d:	89 1d 5c c2 b3 00    	mov    %ebx,0xb3c25c
      }
      LWIP_ASSERT("tcp_input: pcb->next != pcb (after cache)", pcb->next != pcb);
  80dd33:	39 d8                	cmp    %ebx,%eax
  80dd35:	0f 85 ef 09 00 00    	jne    80e72a <tcp_input+0xcb2>
  80dd3b:	c7 44 24 08 0c 3f 81 	movl   $0x813f0c,0x8(%esp)
  80dd42:	00 
  80dd43:	c7 44 24 04 c6 00 00 	movl   $0xc6,0x4(%esp)
  80dd4a:	00 
  80dd4b:	c7 04 24 88 3f 81 00 	movl   $0x813f88,(%esp)
  80dd52:	e8 23 13 00 00       	call   80f07a <_panic>
  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80dd57:	89 df                	mov    %ebx,%edi
  80dd59:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  80dd5c:	85 db                	test   %ebx,%ebx
  80dd5e:	0f 85 0e ff ff ff    	jne    80dc72 <tcp_input+0x1fa>
  }

  if (pcb == NULL) {
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  80dd64:	8b 1d 70 c2 b3 00    	mov    0xb3c270,%ebx
  80dd6a:	e9 85 00 00 00       	jmp    80ddf4 <tcp_input+0x37c>
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
  80dd6f:	83 7b 10 0a          	cmpl   $0xa,0x10(%ebx)
  80dd73:	74 1c                	je     80dd91 <tcp_input+0x319>
  80dd75:	c7 44 24 08 38 3f 81 	movl   $0x813f38,0x8(%esp)
  80dd7c:	00 
  80dd7d:	c7 44 24 04 d0 00 00 	movl   $0xd0,0x4(%esp)
  80dd84:	00 
  80dd85:	c7 04 24 88 3f 81 00 	movl   $0x813f88,(%esp)
  80dd8c:	e8 e9 12 00 00       	call   80f07a <_panic>
      if (pcb->remote_port == tcphdr->src &&
  80dd91:	0f b7 02             	movzwl (%edx),%eax
  80dd94:	66 39 43 1e          	cmp    %ax,0x1e(%ebx)
  80dd98:	75 57                	jne    80ddf1 <tcp_input+0x379>
  80dd9a:	0f b7 42 02          	movzwl 0x2(%edx),%eax
  80dd9e:	66 39 43 1c          	cmp    %ax,0x1c(%ebx)
  80dda2:	75 4d                	jne    80ddf1 <tcp_input+0x379>
         pcb->local_port == tcphdr->dest &&
  80dda4:	8b 41 0c             	mov    0xc(%ecx),%eax
  80dda7:	39 43 04             	cmp    %eax,0x4(%ebx)
  80ddaa:	75 45                	jne    80ddf1 <tcp_input+0x379>
         ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
  80ddac:	8b 41 10             	mov    0x10(%ecx),%eax
  80ddaf:	39 03                	cmp    %eax,(%ebx)
  80ddb1:	75 3e                	jne    80ddf1 <tcp_input+0x379>
 *       involved is passed as a parameter to this function
 */
static err_t
tcp_timewait_input(struct tcp_pcb *pcb)
{
  if (TCP_SEQ_GT(seqno + tcplen, pcb->rcv_nxt)) {
  80ddb3:	0f b7 45 d6          	movzwl -0x2a(%ebp),%eax
  80ddb7:	03 05 c8 c1 b3 00    	add    0xb3c1c8,%eax
  80ddbd:	89 c2                	mov    %eax,%edx
  80ddbf:	2b 53 24             	sub    0x24(%ebx),%edx
  80ddc2:	85 d2                	test   %edx,%edx
  80ddc4:	7e 03                	jle    80ddc9 <tcp_input+0x351>
    pcb->rcv_nxt = seqno + tcplen;
  80ddc6:	89 43 24             	mov    %eax,0x24(%ebx)
  }
  if (tcplen > 0) {
  80ddc9:	66 83 7d d6 00       	cmpw   $0x0,-0x2a(%ebp)
  80ddce:	74 0c                	je     80dddc <tcp_input+0x364>
    tcp_ack_now(pcb);
  80ddd0:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80ddd4:	89 1c 24             	mov    %ebx,(%esp)
  80ddd7:	e8 85 a9 ff ff       	call   808761 <tcp_output>
  }
  return tcp_output(pcb);
  80dddc:	89 1c 24             	mov    %ebx,(%esp)
  80dddf:	e8 7d a9 ff ff       	call   808761 <tcp_output>
        /* We don't really care enough to move this PCB to the front
           of the list since we are not very likely to receive that
           many segments for connections in TIME-WAIT. */
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packed for TIME_WAITing connection.\n"));
        tcp_timewait_input(pcb);
        pbuf_free(p);
  80dde4:	89 34 24             	mov    %esi,(%esp)
  80dde7:	e8 08 70 ff ff       	call   804df4 <pbuf_free>
        return;
  80ddec:	e9 c0 09 00 00       	jmp    80e7b1 <tcp_input+0xd39>
  }

  if (pcb == NULL) {
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  80ddf1:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  80ddf4:	85 db                	test   %ebx,%ebx
  80ddf6:	0f 85 73 ff ff ff    	jne    80dd6f <tcp_input+0x2f7>
    }

  /* Finally, if we still did not get a match, we check all PCBs that
     are LISTENing for incoming connections. */
    prev = NULL;
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  80ddfc:	a1 64 c2 b3 00       	mov    0xb3c264,%eax
  80de01:	89 45 d0             	mov    %eax,-0x30(%ebp)
  80de04:	89 c3                	mov    %eax,%ebx
      }
    }

  /* Finally, if we still did not get a match, we check all PCBs that
     are LISTENing for incoming connections. */
    prev = NULL;
  80de06:	bf 00 00 00 00       	mov    $0x0,%edi
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  80de0b:	e9 af 01 00 00       	jmp    80dfbf <tcp_input+0x547>
      if ((ip_addr_isany(&(lpcb->local_ip)) ||
  80de10:	85 db                	test   %ebx,%ebx
  80de12:	74 0f                	je     80de23 <tcp_input+0x3ab>
  80de14:	8b 03                	mov    (%ebx),%eax
  80de16:	85 c0                	test   %eax,%eax
  80de18:	74 09                	je     80de23 <tcp_input+0x3ab>
  80de1a:	3b 41 10             	cmp    0x10(%ecx),%eax
  80de1d:	0f 85 97 01 00 00    	jne    80dfba <tcp_input+0x542>
        ip_addr_cmp(&(lpcb->local_ip), &(iphdr->dest))) &&
  80de23:	0f b7 42 02          	movzwl 0x2(%edx),%eax
  80de27:	66 39 43 1c          	cmp    %ax,0x1c(%ebx)
  80de2b:	0f 85 89 01 00 00    	jne    80dfba <tcp_input+0x542>
        lpcb->local_port == tcphdr->dest) {
        /* Move this PCB to the front of the list so that subsequent
           lookups will be faster (we exploit locality in TCP segment
           arrivals). */
        if (prev != NULL) {
  80de31:	85 ff                	test   %edi,%edi
  80de33:	74 12                	je     80de47 <tcp_input+0x3cf>
          ((struct tcp_pcb_listen *)prev)->next = lpcb->next;
  80de35:	8b 43 0c             	mov    0xc(%ebx),%eax
  80de38:	89 47 0c             	mov    %eax,0xc(%edi)
                /* our successor is the remainder of the listening list */
          lpcb->next = tcp_listen_pcbs.listen_pcbs;
  80de3b:	8b 45 d0             	mov    -0x30(%ebp),%eax
  80de3e:	89 43 0c             	mov    %eax,0xc(%ebx)
                /* put this listening pcb at the head of the listening list */
          tcp_listen_pcbs.listen_pcbs = lpcb;
  80de41:	89 1d 64 c2 b3 00    	mov    %ebx,0xb3c264
  struct tcp_pcb *npcb;
  u32_t optdata;

  /* In the LISTEN state, we check for incoming SYN segments,
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
  80de47:	f6 45 d4 10          	testb  $0x10,-0x2c(%ebp)
  80de4b:	74 45                	je     80de92 <tcp_input+0x41a>
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst(ackno + 1, seqno + tcplen,
      &(iphdr->dest), &(iphdr->src),
  80de4d:	a1 cc c1 b3 00       	mov    0xb3c1cc,%eax
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst(ackno + 1, seqno + tcplen,
  80de52:	0f b7 0a             	movzwl (%edx),%ecx
  80de55:	89 4c 24 14          	mov    %ecx,0x14(%esp)
  80de59:	0f b7 52 02          	movzwl 0x2(%edx),%edx
  80de5d:	89 54 24 10          	mov    %edx,0x10(%esp)
  80de61:	8d 50 0c             	lea    0xc(%eax),%edx
  80de64:	89 54 24 0c          	mov    %edx,0xc(%esp)
  80de68:	83 c0 10             	add    $0x10,%eax
  80de6b:	89 44 24 08          	mov    %eax,0x8(%esp)
  80de6f:	0f b7 45 d6          	movzwl -0x2a(%ebp),%eax
  80de73:	03 05 c8 c1 b3 00    	add    0xb3c1c8,%eax
  80de79:	89 44 24 04          	mov    %eax,0x4(%esp)
  80de7d:	a1 c4 c1 b3 00       	mov    0xb3c1c4,%eax
  80de82:	83 c0 01             	add    $0x1,%eax
  80de85:	89 04 24             	mov    %eax,(%esp)
  80de88:	e8 68 ad ff ff       	call   808bf5 <tcp_rst>
  80de8d:	e9 1b 01 00 00       	jmp    80dfad <tcp_input+0x535>
      &(iphdr->dest), &(iphdr->src),
      tcphdr->dest, tcphdr->src);
  } else if (flags & TCP_SYN) {
  80de92:	f6 45 d4 02          	testb  $0x2,-0x2c(%ebp)
  80de96:	0f 84 11 01 00 00    	je     80dfad <tcp_input+0x535>
#if TCP_LISTEN_BACKLOG
    if (pcb->accepts_pending >= pcb->backlog) {
      return ERR_ABRT;
    }
#endif /* TCP_LISTEN_BACKLOG */
    npcb = tcp_alloc(pcb->prio);
  80de9c:	0f b6 43 14          	movzbl 0x14(%ebx),%eax
  80dea0:	89 04 24             	mov    %eax,(%esp)
  80dea3:	e8 b2 88 ff ff       	call   80675a <tcp_alloc>
  80dea8:	89 c7                	mov    %eax,%edi
    /* If a new PCB could not be created (probably due to lack of memory),
       we don't do anything, but rely on the sender will retransmit the
       SYN at a time when we have more memory available. */
    if (npcb == NULL) {
  80deaa:	85 c0                	test   %eax,%eax
  80deac:	0f 84 fb 00 00 00    	je     80dfad <tcp_input+0x535>
    }
#if TCP_LISTEN_BACKLOG
    pcb->accepts_pending++;
#endif /* TCP_LISTEN_BACKLOG */
    /* Set up the new PCB. */
    ip_addr_set(&(npcb->local_ip), &(iphdr->dest));
  80deb2:	a1 cc c1 b3 00       	mov    0xb3c1cc,%eax
  80deb7:	83 f8 f0             	cmp    $0xfffffff0,%eax
  80deba:	74 05                	je     80dec1 <tcp_input+0x449>
  80debc:	8b 50 10             	mov    0x10(%eax),%edx
  80debf:	eb 05                	jmp    80dec6 <tcp_input+0x44e>
  80dec1:	ba 00 00 00 00       	mov    $0x0,%edx
  80dec6:	89 17                	mov    %edx,(%edi)
    npcb->local_port = pcb->local_port;
  80dec8:	0f b7 53 1c          	movzwl 0x1c(%ebx),%edx
  80decc:	66 89 57 1c          	mov    %dx,0x1c(%edi)
    ip_addr_set(&(npcb->remote_ip), &(iphdr->src));
  80ded0:	83 f8 f4             	cmp    $0xfffffff4,%eax
  80ded3:	74 05                	je     80deda <tcp_input+0x462>
  80ded5:	8b 40 0c             	mov    0xc(%eax),%eax
  80ded8:	eb 05                	jmp    80dedf <tcp_input+0x467>
  80deda:	b8 00 00 00 00       	mov    $0x0,%eax
  80dedf:	89 47 04             	mov    %eax,0x4(%edi)
    npcb->remote_port = tcphdr->src;
  80dee2:	8b 15 d0 c1 b3 00    	mov    0xb3c1d0,%edx
  80dee8:	0f b7 02             	movzwl (%edx),%eax
  80deeb:	66 89 47 1e          	mov    %ax,0x1e(%edi)
    npcb->state = SYN_RCVD;
  80deef:	c7 47 10 03 00 00 00 	movl   $0x3,0x10(%edi)
    npcb->rcv_nxt = seqno + 1;
  80def6:	a1 c8 c1 b3 00       	mov    0xb3c1c8,%eax
  80defb:	8d 48 01             	lea    0x1(%eax),%ecx
  80defe:	89 4f 24             	mov    %ecx,0x24(%edi)
    npcb->snd_wnd = tcphdr->wnd;
  80df01:	0f b7 52 0e          	movzwl 0xe(%edx),%edx
  80df05:	66 89 57 5c          	mov    %dx,0x5c(%edi)
    npcb->ssthresh = npcb->snd_wnd;
  80df09:	66 89 57 50          	mov    %dx,0x50(%edi)
    npcb->snd_wl1 = seqno - 1;/* initialise to seqno-1 to force window update */
  80df0d:	83 e8 01             	sub    $0x1,%eax
  80df10:	89 47 60             	mov    %eax,0x60(%edi)
    npcb->callback_arg = pcb->callback_arg;
  80df13:	8b 43 18             	mov    0x18(%ebx),%eax
  80df16:	89 47 18             	mov    %eax,0x18(%edi)
#if LWIP_CALLBACK_API
    npcb->accept = pcb->accept;
  80df19:	8b 43 20             	mov    0x20(%ebx),%eax
  80df1c:	89 87 90 00 00 00    	mov    %eax,0x90(%edi)
#endif /* LWIP_CALLBACK_API */
    /* inherit socket options */
    npcb->so_options = pcb->so_options & (SOF_DEBUG|SOF_DONTROUTE|SOF_KEEPALIVE|SOF_OOBINLINE|SOF_LINGER);
  80df22:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  80df26:	66 25 99 01          	and    $0x199,%ax
  80df2a:	66 89 47 08          	mov    %ax,0x8(%edi)
    /* Register the new PCB so that we can begin receiving segments
       for it. */
    TCP_REG(&tcp_active_pcbs, npcb);
  80df2e:	a1 5c c2 b3 00       	mov    0xb3c25c,%eax
  80df33:	89 47 0c             	mov    %eax,0xc(%edi)
  80df36:	89 3d 5c c2 b3 00    	mov    %edi,0xb3c25c
  80df3c:	e8 31 46 ff ff       	call   802572 <tcp_timer_needed>

    /* Parse any options in the SYN. */
    tcp_parseopt(npcb);
  80df41:	89 f8                	mov    %edi,%eax
  80df43:	e8 58 ee ff ff       	call   80cda0 <tcp_parseopt>
#if TCP_CALCULATE_EFF_SEND_MSS
    npcb->mss = tcp_eff_send_mss(npcb->mss, &(npcb->remote_ip));
  80df48:	8d 47 04             	lea    0x4(%edi),%eax
  80df4b:	89 44 24 04          	mov    %eax,0x4(%esp)
  80df4f:	0f b7 47 34          	movzwl 0x34(%edi),%eax
  80df53:	89 04 24             	mov    %eax,(%esp)
  80df56:	e8 8e 89 ff ff       	call   8068e9 <tcp_eff_send_mss>
  80df5b:	66 89 47 34          	mov    %ax,0x34(%edi)
#endif /* TCP_CALCULATE_EFF_SEND_MSS */

    snmp_inc_tcppassiveopens();

    /* Build an MSS option. */
    optdata = TCP_BUILD_MSS_OPTION();
  80df5f:	c7 04 24 b4 05 04 02 	movl   $0x20405b4,(%esp)
  80df66:	e8 25 9e ff ff       	call   807d90 <htonl>
  80df6b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    /* Send a SYN|ACK together with the MSS option. */
    tcp_enqueue(npcb, NULL, 0, TCP_SYN | TCP_ACK, 0, (u8_t *)&optdata, 4);
  80df6e:	c7 44 24 18 04 00 00 	movl   $0x4,0x18(%esp)
  80df75:	00 
  80df76:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80df79:	89 44 24 14          	mov    %eax,0x14(%esp)
  80df7d:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  80df84:	00 
  80df85:	c7 44 24 0c 12 00 00 	movl   $0x12,0xc(%esp)
  80df8c:	00 
  80df8d:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80df94:	00 
  80df95:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80df9c:	00 
  80df9d:	89 3c 24             	mov    %edi,(%esp)
  80dfa0:	e8 3b a0 ff ff       	call   807fe0 <tcp_enqueue>
    return tcp_output(npcb);
  80dfa5:	89 3c 24             	mov    %edi,(%esp)
  80dfa8:	e8 b4 a7 ff ff       	call   808761 <tcp_output>
          tcp_listen_pcbs.listen_pcbs = lpcb;
        }
      
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packed for LISTENing connection.\n"));
        tcp_listen_input(lpcb);
        pbuf_free(p);
  80dfad:	89 34 24             	mov    %esi,(%esp)
  80dfb0:	e8 3f 6e ff ff       	call   804df4 <pbuf_free>
        return;
  80dfb5:	e9 f7 07 00 00       	jmp    80e7b1 <tcp_input+0xd39>
  80dfba:	89 df                	mov    %ebx,%edi
    }

  /* Finally, if we still did not get a match, we check all PCBs that
     are LISTENing for incoming connections. */
    prev = NULL;
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  80dfbc:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  80dfbf:	85 db                	test   %ebx,%ebx
  80dfc1:	0f 85 49 fe ff ff    	jne    80de10 <tcp_input+0x398>
  80dfc7:	e9 ae 07 00 00       	jmp    80e77a <tcp_input+0xd02>

    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
      /* Notify again application with data previously received. */
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: notify kept packet\n"));
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  80dfcc:	8b 83 88 00 00 00    	mov    0x88(%ebx),%eax
  80dfd2:	85 c0                	test   %eax,%eax
  80dfd4:	74 1e                	je     80dff4 <tcp_input+0x57c>
  80dfd6:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  80dfdd:	00 
  80dfde:	89 54 24 08          	mov    %edx,0x8(%esp)
  80dfe2:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80dfe6:	8b 53 18             	mov    0x18(%ebx),%edx
  80dfe9:	89 14 24             	mov    %edx,(%esp)
  80dfec:	ff d0                	call   *%eax
      if (err == ERR_OK) {
  80dfee:	84 c0                	test   %al,%al
  80dff0:	74 0a                	je     80dffc <tcp_input+0x584>
  80dff2:	eb 14                	jmp    80e008 <tcp_input+0x590>

    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
      /* Notify again application with data previously received. */
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: notify kept packet\n"));
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  80dff4:	89 14 24             	mov    %edx,(%esp)
  80dff7:	e8 f8 6d ff ff       	call   804df4 <pbuf_free>
      if (err == ERR_OK) {
        pcb->refused_data = NULL;
  80dffc:	c7 83 80 00 00 00 00 	movl   $0x0,0x80(%ebx)
  80e003:	00 00 00 
  80e006:	eb 0d                	jmp    80e015 <tcp_input+0x59d>
      } else {
        /* drop incoming packets, because pcb is "full" */
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: drop incoming packets, because pcb is \"full\"\n"));
        TCP_STATS_INC(tcp.drop);
        snmp_inc_tcpinerrs();
        pbuf_free(p);
  80e008:	89 34 24             	mov    %esi,(%esp)
  80e00b:	e8 e4 6d ff ff       	call   804df4 <pbuf_free>
        return;
  80e010:	e9 9c 07 00 00       	jmp    80e7b1 <tcp_input+0xd39>
      }
    }

    tcp_input_pcb = pcb;
  80e015:	89 1d 78 c2 b3 00    	mov    %ebx,0xb3c278
  u8_t accepted_inseq;

  err = ERR_OK;

  /* Process incoming RST segments. */
  if (flags & TCP_RST) {
  80e01b:	0f b6 05 c0 c1 b3 00 	movzbl 0xb3c1c0,%eax
  80e022:	a8 04                	test   $0x4,%al
  80e024:	74 64                	je     80e08a <tcp_input+0x612>
    /* First, determine if the reset is acceptable. */
    if (pcb->state == SYN_SENT) {
  80e026:	8b 43 10             	mov    0x10(%ebx),%eax
  80e029:	83 f8 02             	cmp    $0x2,%eax
  80e02c:	75 0f                	jne    80e03d <tcp_input+0x5c5>
                          pcb->rcv_nxt+pcb->rcv_wnd)) {
        acceptable = 1;
      }
    }

    if (acceptable) {
  80e02e:	a1 c4 c1 b3 00       	mov    0xb3c1c4,%eax
  80e033:	39 43 54             	cmp    %eax,0x54(%ebx)
  80e036:	74 42                	je     80e07a <tcp_input+0x602>
  80e038:	e9 38 05 00 00       	jmp    80e575 <tcp_input+0xafd>
    if (pcb->state == SYN_SENT) {
      if (ackno == pcb->snd_nxt) {
        acceptable = 1;
      }
    } else {
      if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
  80e03d:	8b 15 c8 c1 b3 00    	mov    0xb3c1c8,%edx
  80e043:	2b 53 24             	sub    0x24(%ebx),%edx
  80e046:	0f 88 43 07 00 00    	js     80e78f <tcp_input+0xd17>
  80e04c:	0f b7 4b 28          	movzwl 0x28(%ebx),%ecx
  80e050:	29 ca                	sub    %ecx,%edx
                          pcb->rcv_nxt+pcb->rcv_wnd)) {
        acceptable = 1;
      }
    }

    if (acceptable) {
  80e052:	85 d2                	test   %edx,%edx
  80e054:	0f 8f 35 07 00 00    	jg     80e78f <tcp_input+0xd17>
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_process: Connection RESET\n"));
      LWIP_ASSERT("tcp_input: pcb->state != CLOSED", pcb->state != CLOSED);
  80e05a:	85 c0                	test   %eax,%eax
  80e05c:	75 1c                	jne    80e07a <tcp_input+0x602>
  80e05e:	c7 44 24 08 68 3f 81 	movl   $0x813f68,0x8(%esp)
  80e065:	00 
  80e066:	c7 44 24 04 09 02 00 	movl   $0x209,0x4(%esp)
  80e06d:	00 
  80e06e:	c7 04 24 88 3f 81 00 	movl   $0x813f88,(%esp)
  80e075:	e8 00 10 00 00       	call   80f07a <_panic>
      recv_flags = TF_RESET;
  80e07a:	c6 05 bc c1 b3 00 08 	movb   $0x8,0xb3c1bc
      pcb->flags &= ~TF_ACK_DELAY;
  80e081:	80 63 20 fe          	andb   $0xfe,0x20(%ebx)
  80e085:	e9 05 07 00 00       	jmp    80e78f <tcp_input+0xd17>
      return ERR_OK;
    }
  }

  /* Update the PCB (in)activity timer. */
  pcb->tmr = tcp_ticks;
  80e08a:	8b 15 60 c2 b3 00    	mov    0xb3c260,%edx
  80e090:	89 53 2c             	mov    %edx,0x2c(%ebx)
  pcb->keep_cnt_sent = 0;
  80e093:	c6 83 a5 00 00 00 00 	movb   $0x0,0xa5(%ebx)

  /* Do different things depending on the TCP state. */
  switch (pcb->state) {
  80e09a:	83 7b 10 09          	cmpl   $0x9,0x10(%ebx)
  80e09e:	0f 87 d1 04 00 00    	ja     80e575 <tcp_input+0xafd>
  80e0a4:	8b 53 10             	mov    0x10(%ebx),%edx
  80e0a7:	ff 24 95 0c 40 81 00 	jmp    *0x81400c(,%edx,4)
  case SYN_SENT:
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("SYN-SENT: ackno %"U32_F" pcb->snd_nxt %"U32_F" unacked %"U32_F"\n", ackno,
     pcb->snd_nxt, ntohl(pcb->unacked->tcphdr->seqno)));
    /* received SYN ACK with expected sequence number? */
    if ((flags & TCP_ACK) && (flags & TCP_SYN)
  80e0ae:	83 e0 12             	and    $0x12,%eax
  80e0b1:	3c 12                	cmp    $0x12,%al
  80e0b3:	0f 85 03 01 00 00    	jne    80e1bc <tcp_input+0x744>
        && ackno == ntohl(pcb->unacked->tcphdr->seqno) + 1) {
  80e0b9:	8b 43 78             	mov    0x78(%ebx),%eax
  80e0bc:	8b 40 10             	mov    0x10(%eax),%eax
  80e0bf:	8b 40 04             	mov    0x4(%eax),%eax
  80e0c2:	89 04 24             	mov    %eax,(%esp)
  80e0c5:	e8 00 9f ff ff       	call   807fca <ntohl>
  80e0ca:	8d 50 01             	lea    0x1(%eax),%edx
  80e0cd:	3b 15 c4 c1 b3 00    	cmp    0xb3c1c4,%edx
  80e0d3:	0f 85 e3 00 00 00    	jne    80e1bc <tcp_input+0x744>
      pcb->snd_buf++;
  80e0d9:	66 83 43 6e 01       	addw   $0x1,0x6e(%ebx)
      pcb->rcv_nxt = seqno + 1;
  80e0de:	a1 c8 c1 b3 00       	mov    0xb3c1c8,%eax
  80e0e3:	8d 48 01             	lea    0x1(%eax),%ecx
  80e0e6:	89 4b 24             	mov    %ecx,0x24(%ebx)
      pcb->lastack = ackno;
  80e0e9:	89 53 48             	mov    %edx,0x48(%ebx)
      pcb->snd_wnd = tcphdr->wnd;
  80e0ec:	8b 15 d0 c1 b3 00    	mov    0xb3c1d0,%edx
  80e0f2:	0f b7 52 0e          	movzwl 0xe(%edx),%edx
  80e0f6:	66 89 53 5c          	mov    %dx,0x5c(%ebx)
      pcb->snd_wl1 = seqno - 1; /* initialise to seqno - 1 to force window update */
  80e0fa:	83 e8 01             	sub    $0x1,%eax
  80e0fd:	89 43 60             	mov    %eax,0x60(%ebx)
      pcb->state = ESTABLISHED;
  80e100:	c7 43 10 04 00 00 00 	movl   $0x4,0x10(%ebx)

      /* Parse any options in the SYNACK before using pcb->mss since that
       * can be changed by the received options! */
      tcp_parseopt(pcb);
  80e107:	89 d8                	mov    %ebx,%eax
  80e109:	e8 92 ec ff ff       	call   80cda0 <tcp_parseopt>
#if TCP_CALCULATE_EFF_SEND_MSS
      pcb->mss = tcp_eff_send_mss(pcb->mss, &(pcb->remote_ip));
  80e10e:	8d 43 04             	lea    0x4(%ebx),%eax
  80e111:	89 44 24 04          	mov    %eax,0x4(%esp)
  80e115:	0f b7 43 34          	movzwl 0x34(%ebx),%eax
  80e119:	89 04 24             	mov    %eax,(%esp)
  80e11c:	e8 c8 87 ff ff       	call   8068e9 <tcp_eff_send_mss>
  80e121:	66 89 43 34          	mov    %ax,0x34(%ebx)
#endif /* TCP_CALCULATE_EFF_SEND_MSS */

      /* Set ssthresh again after changing pcb->mss (already set in tcp_connect
       * but for the default value of pcb->mss) */
      pcb->ssthresh = pcb->mss * 10;
  80e125:	6b d0 0a             	imul   $0xa,%eax,%edx
  80e128:	66 89 53 50          	mov    %dx,0x50(%ebx)

      pcb->cwnd = ((pcb->cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
  80e12c:	8d 14 00             	lea    (%eax,%eax,1),%edx
  80e12f:	66 83 7b 4e 01       	cmpw   $0x1,0x4e(%ebx)
  80e134:	0f 44 c2             	cmove  %edx,%eax
  80e137:	66 89 43 4e          	mov    %ax,0x4e(%ebx)
      LWIP_ASSERT("pcb->snd_queuelen > 0", (pcb->snd_queuelen > 0));
  80e13b:	0f b7 43 70          	movzwl 0x70(%ebx),%eax
  80e13f:	66 85 c0             	test   %ax,%ax
  80e142:	75 1c                	jne    80e160 <tcp_input+0x6e8>
  80e144:	c7 44 24 08 e1 3f 81 	movl   $0x813fe1,0x8(%esp)
  80e14b:	00 
  80e14c:	c7 44 24 04 35 02 00 	movl   $0x235,0x4(%esp)
  80e153:	00 
  80e154:	c7 04 24 88 3f 81 00 	movl   $0x813f88,(%esp)
  80e15b:	e8 1a 0f 00 00       	call   80f07a <_panic>
      --pcb->snd_queuelen;
  80e160:	83 e8 01             	sub    $0x1,%eax
  80e163:	66 89 43 70          	mov    %ax,0x70(%ebx)
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_process: SYN-SENT --queuelen %"U16_F"\n", (u16_t)pcb->snd_queuelen));
      rseg = pcb->unacked;
  80e167:	8b 43 78             	mov    0x78(%ebx),%eax
      pcb->unacked = rseg->next;
  80e16a:	8b 10                	mov    (%eax),%edx
  80e16c:	89 53 78             	mov    %edx,0x78(%ebx)

      /* If there's nothing left to acknowledge, stop the retransmit
         timer, otherwise reset it to start again */
      if(pcb->unacked == NULL)
  80e16f:	85 d2                	test   %edx,%edx
  80e171:	75 08                	jne    80e17b <tcp_input+0x703>
        pcb->rtime = -1;
  80e173:	66 c7 43 32 ff ff    	movw   $0xffff,0x32(%ebx)
  80e179:	eb 0a                	jmp    80e185 <tcp_input+0x70d>
      else {
        pcb->rtime = 0;
  80e17b:	66 c7 43 32 00 00    	movw   $0x0,0x32(%ebx)
        pcb->nrtx = 0;
  80e181:	c6 43 46 00          	movb   $0x0,0x46(%ebx)
      }

      tcp_seg_free(rseg);
  80e185:	89 04 24             	mov    %eax,(%esp)
  80e188:	e8 3c 7c ff ff       	call   805dc9 <tcp_seg_free>

      /* Call the user specified function to call when sucessfully
       * connected. */
      TCP_EVENT_CONNECTED(pcb, ERR_OK, err);
  80e18d:	8b 83 8c 00 00 00    	mov    0x8c(%ebx),%eax
  80e193:	85 c0                	test   %eax,%eax
  80e195:	74 14                	je     80e1ab <tcp_input+0x733>
  80e197:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80e19e:	00 
  80e19f:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80e1a3:	8b 53 18             	mov    0x18(%ebx),%edx
  80e1a6:	89 14 24             	mov    %edx,(%esp)
  80e1a9:	ff d0                	call   *%eax
      tcp_ack_now(pcb);
  80e1ab:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80e1af:	89 1c 24             	mov    %ebx,(%esp)
  80e1b2:	e8 aa a5 ff ff       	call   808761 <tcp_output>
  80e1b7:	e9 d3 05 00 00       	jmp    80e78f <tcp_input+0xd17>
    }
    /* received ACK? possibly a half-open connection */
    else if (flags & TCP_ACK) {
  80e1bc:	f6 05 c0 c1 b3 00 10 	testb  $0x10,0xb3c1c0
  80e1c3:	0f 84 c6 05 00 00    	je     80e78f <tcp_input+0xd17>
      /* send a RST to bring the other side in a non-synchronized state. */
      tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
        tcphdr->dest, tcphdr->src);
  80e1c9:	8b 15 d0 c1 b3 00    	mov    0xb3c1d0,%edx
      tcp_ack_now(pcb);
    }
    /* received ACK? possibly a half-open connection */
    else if (flags & TCP_ACK) {
      /* send a RST to bring the other side in a non-synchronized state. */
      tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
  80e1cf:	a1 cc c1 b3 00       	mov    0xb3c1cc,%eax
  80e1d4:	0f b7 0a             	movzwl (%edx),%ecx
  80e1d7:	89 4c 24 14          	mov    %ecx,0x14(%esp)
  80e1db:	0f b7 52 02          	movzwl 0x2(%edx),%edx
  80e1df:	89 54 24 10          	mov    %edx,0x10(%esp)
  80e1e3:	8d 50 0c             	lea    0xc(%eax),%edx
  80e1e6:	89 54 24 0c          	mov    %edx,0xc(%esp)
  80e1ea:	83 c0 10             	add    $0x10,%eax
  80e1ed:	89 44 24 08          	mov    %eax,0x8(%esp)
  80e1f1:	0f b7 05 be c1 b3 00 	movzwl 0xb3c1be,%eax
  80e1f8:	03 05 c8 c1 b3 00    	add    0xb3c1c8,%eax
  80e1fe:	89 44 24 04          	mov    %eax,0x4(%esp)
  80e202:	a1 c4 c1 b3 00       	mov    0xb3c1c4,%eax
  80e207:	89 04 24             	mov    %eax,(%esp)
  80e20a:	e8 e6 a9 ff ff       	call   808bf5 <tcp_rst>
  80e20f:	e9 7b 05 00 00       	jmp    80e78f <tcp_input+0xd17>
        tcphdr->dest, tcphdr->src);
    }
    break;
  case SYN_RCVD:
    if (flags & TCP_ACK &&
  80e214:	83 e0 14             	and    $0x14,%eax
  80e217:	3c 10                	cmp    $0x10,%al
  80e219:	0f 85 70 05 00 00    	jne    80e78f <tcp_input+0xd17>
       !(flags & TCP_RST)) {
      /* expected ACK number? */
      if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)) {
  80e21f:	a1 c4 c1 b3 00       	mov    0xb3c1c4,%eax
  80e224:	8d 50 ff             	lea    -0x1(%eax),%edx
  80e227:	3b 53 48             	cmp    0x48(%ebx),%edx
  80e22a:	0f 88 b8 00 00 00    	js     80e2e8 <tcp_input+0x870>
  80e230:	89 c2                	mov    %eax,%edx
  80e232:	2b 53 54             	sub    0x54(%ebx),%edx
  80e235:	85 d2                	test   %edx,%edx
  80e237:	0f 8f ab 00 00 00    	jg     80e2e8 <tcp_input+0x870>
        u16_t old_cwnd;
        pcb->state = ESTABLISHED;
  80e23d:	c7 43 10 04 00 00 00 	movl   $0x4,0x10(%ebx)
        LWIP_DEBUGF(TCP_DEBUG, ("TCP connection established %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
#if LWIP_CALLBACK_API
        LWIP_ASSERT("pcb->accept != NULL", pcb->accept != NULL);
  80e244:	8b 83 90 00 00 00    	mov    0x90(%ebx),%eax
  80e24a:	85 c0                	test   %eax,%eax
  80e24c:	75 1c                	jne    80e26a <tcp_input+0x7f2>
  80e24e:	c7 44 24 08 f7 3f 81 	movl   $0x813ff7,0x8(%esp)
  80e255:	00 
  80e256:	c7 44 24 04 5b 02 00 	movl   $0x25b,0x4(%esp)
  80e25d:	00 
  80e25e:	c7 04 24 88 3f 81 00 	movl   $0x813f88,(%esp)
  80e265:	e8 10 0e 00 00       	call   80f07a <_panic>
#endif
        /* Call the accept function. */
        TCP_EVENT_ACCEPT(pcb, ERR_OK, err);
  80e26a:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80e271:	00 
  80e272:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80e276:	8b 53 18             	mov    0x18(%ebx),%edx
  80e279:	89 14 24             	mov    %edx,(%esp)
  80e27c:	ff d0                	call   *%eax
        if (err != ERR_OK) {
  80e27e:	84 c0                	test   %al,%al
  80e280:	74 17                	je     80e299 <tcp_input+0x821>
          /* If the accept function returns with an error, we abort
           * the connection. */
          tcp_abort(pcb);
  80e282:	89 1c 24             	mov    %ebx,(%esp)
  80e285:	e8 4f 7f ff ff       	call   8061d9 <tcp_abort>
      }
    }

    tcp_input_pcb = pcb;
    err = tcp_process(pcb);
    tcp_input_pcb = NULL;
  80e28a:	c7 05 78 c2 b3 00 00 	movl   $0x0,0xb3c278
  80e291:	00 00 00 
  80e294:	e9 1a 04 00 00       	jmp    80e6b3 <tcp_input+0xc3b>
          /* If the accept function returns with an error, we abort
           * the connection. */
          tcp_abort(pcb);
          return ERR_ABRT;
        }
        old_cwnd = pcb->cwnd;
  80e299:	0f b7 73 4e          	movzwl 0x4e(%ebx),%esi
        /* If there was any data contained within this ACK,
         * we'd better pass it on to the application as well. */
        accepted_inseq = tcp_receive(pcb);
  80e29d:	89 d8                	mov    %ebx,%eax
  80e29f:	e8 a6 eb ff ff       	call   80ce4a <tcp_receive>

        pcb->cwnd = ((old_cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
  80e2a4:	66 83 fe 01          	cmp    $0x1,%si
  80e2a8:	75 09                	jne    80e2b3 <tcp_input+0x83b>
  80e2aa:	0f b7 4b 34          	movzwl 0x34(%ebx),%ecx
  80e2ae:	8d 14 09             	lea    (%ecx,%ecx,1),%edx
  80e2b1:	eb 04                	jmp    80e2b7 <tcp_input+0x83f>
  80e2b3:	0f b7 53 34          	movzwl 0x34(%ebx),%edx
  80e2b7:	66 89 53 4e          	mov    %dx,0x4e(%ebx)

        if ((flags & TCP_FIN) && accepted_inseq) {
  80e2bb:	f6 05 c0 c1 b3 00 01 	testb  $0x1,0xb3c1c0
  80e2c2:	0f 84 c7 04 00 00    	je     80e78f <tcp_input+0xd17>
  80e2c8:	84 c0                	test   %al,%al
  80e2ca:	0f 84 bf 04 00 00    	je     80e78f <tcp_input+0xd17>
          tcp_ack_now(pcb);
  80e2d0:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80e2d4:	89 1c 24             	mov    %ebx,(%esp)
  80e2d7:	e8 85 a4 ff ff       	call   808761 <tcp_output>
          pcb->state = CLOSE_WAIT;
  80e2dc:	c7 43 10 07 00 00 00 	movl   $0x7,0x10(%ebx)
  80e2e3:	e9 a7 04 00 00       	jmp    80e78f <tcp_input+0xd17>
      }
      /* incorrect ACK number */
      else {
        /* send RST */
        tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
                tcphdr->dest, tcphdr->src);
  80e2e8:	8b 0d d0 c1 b3 00    	mov    0xb3c1d0,%ecx
        }
      }
      /* incorrect ACK number */
      else {
        /* send RST */
        tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
  80e2ee:	8b 15 cc c1 b3 00    	mov    0xb3c1cc,%edx
  80e2f4:	0f b7 31             	movzwl (%ecx),%esi
  80e2f7:	89 74 24 14          	mov    %esi,0x14(%esp)
  80e2fb:	0f b7 49 02          	movzwl 0x2(%ecx),%ecx
  80e2ff:	89 4c 24 10          	mov    %ecx,0x10(%esp)
  80e303:	8d 4a 0c             	lea    0xc(%edx),%ecx
  80e306:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
  80e30a:	83 c2 10             	add    $0x10,%edx
  80e30d:	89 54 24 08          	mov    %edx,0x8(%esp)
  80e311:	0f b7 15 be c1 b3 00 	movzwl 0xb3c1be,%edx
  80e318:	03 15 c8 c1 b3 00    	add    0xb3c1c8,%edx
  80e31e:	89 54 24 04          	mov    %edx,0x4(%esp)
  80e322:	89 04 24             	mov    %eax,(%esp)
  80e325:	e8 cb a8 ff ff       	call   808bf5 <tcp_rst>
  80e32a:	e9 60 04 00 00       	jmp    80e78f <tcp_input+0xd17>
    }
    break;
  case CLOSE_WAIT:
    /* FALLTHROUGH */
  case ESTABLISHED:
    accepted_inseq = tcp_receive(pcb);
  80e32f:	89 d8                	mov    %ebx,%eax
  80e331:	e8 14 eb ff ff       	call   80ce4a <tcp_receive>
    if ((flags & TCP_FIN) && accepted_inseq) { /* passive close */
  80e336:	f6 05 c0 c1 b3 00 01 	testb  $0x1,0xb3c1c0
  80e33d:	0f 84 4c 04 00 00    	je     80e78f <tcp_input+0xd17>
  80e343:	84 c0                	test   %al,%al
  80e345:	0f 84 44 04 00 00    	je     80e78f <tcp_input+0xd17>
      tcp_ack_now(pcb);
  80e34b:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80e34f:	89 1c 24             	mov    %ebx,(%esp)
  80e352:	e8 0a a4 ff ff       	call   808761 <tcp_output>
      pcb->state = CLOSE_WAIT;
  80e357:	c7 43 10 07 00 00 00 	movl   $0x7,0x10(%ebx)
  80e35e:	e9 2c 04 00 00       	jmp    80e78f <tcp_input+0xd17>
    }
    break;
  case FIN_WAIT_1:
    tcp_receive(pcb);
  80e363:	89 d8                	mov    %ebx,%eax
  80e365:	e8 e0 ea ff ff       	call   80ce4a <tcp_receive>
    if (flags & TCP_FIN) {
  80e36a:	0f b6 05 c0 c1 b3 00 	movzbl 0xb3c1c0,%eax
  80e371:	a8 01                	test   $0x1,%al
  80e373:	0f 84 96 00 00 00    	je     80e40f <tcp_input+0x997>
      if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  80e379:	a8 10                	test   $0x10,%al
  80e37b:	74 7a                	je     80e3f7 <tcp_input+0x97f>
  80e37d:	a1 c4 c1 b3 00       	mov    0xb3c1c4,%eax
  80e382:	39 43 54             	cmp    %eax,0x54(%ebx)
  80e385:	75 70                	jne    80e3f7 <tcp_input+0x97f>
        LWIP_DEBUGF(TCP_DEBUG,
          ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
        tcp_ack_now(pcb);
  80e387:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80e38b:	89 1c 24             	mov    %ebx,(%esp)
  80e38e:	e8 ce a3 ff ff       	call   808761 <tcp_output>
        tcp_pcb_purge(pcb);
  80e393:	89 1c 24             	mov    %ebx,(%esp)
  80e396:	e8 57 7b ff ff       	call   805ef2 <tcp_pcb_purge>
        TCP_RMV(&tcp_active_pcbs, pcb);
  80e39b:	a1 5c c2 b3 00       	mov    0xb3c25c,%eax
  80e3a0:	39 c3                	cmp    %eax,%ebx
  80e3a2:	75 0a                	jne    80e3ae <tcp_input+0x936>
  80e3a4:	8b 43 0c             	mov    0xc(%ebx),%eax
  80e3a7:	a3 5c c2 b3 00       	mov    %eax,0xb3c25c
  80e3ac:	eb 2a                	jmp    80e3d8 <tcp_input+0x960>
  80e3ae:	a3 68 c2 b3 00       	mov    %eax,0xb3c268
  80e3b3:	eb 1a                	jmp    80e3cf <tcp_input+0x957>
  80e3b5:	8b 50 0c             	mov    0xc(%eax),%edx
  80e3b8:	85 d2                	test   %edx,%edx
  80e3ba:	74 11                	je     80e3cd <tcp_input+0x955>
  80e3bc:	39 d3                	cmp    %edx,%ebx
  80e3be:	75 0d                	jne    80e3cd <tcp_input+0x955>
  80e3c0:	a3 68 c2 b3 00       	mov    %eax,0xb3c268
  80e3c5:	8b 53 0c             	mov    0xc(%ebx),%edx
  80e3c8:	89 50 0c             	mov    %edx,0xc(%eax)
  80e3cb:	eb 0b                	jmp    80e3d8 <tcp_input+0x960>
  80e3cd:	89 d0                	mov    %edx,%eax
  80e3cf:	85 c0                	test   %eax,%eax
  80e3d1:	75 e2                	jne    80e3b5 <tcp_input+0x93d>
  80e3d3:	a3 68 c2 b3 00       	mov    %eax,0xb3c268
        pcb->state = TIME_WAIT;
  80e3d8:	c7 43 10 0a 00 00 00 	movl   $0xa,0x10(%ebx)
        TCP_REG(&tcp_tw_pcbs, pcb);
  80e3df:	a1 70 c2 b3 00       	mov    0xb3c270,%eax
  80e3e4:	89 43 0c             	mov    %eax,0xc(%ebx)
  80e3e7:	89 1d 70 c2 b3 00    	mov    %ebx,0xb3c270
  80e3ed:	e8 80 41 ff ff       	call   802572 <tcp_timer_needed>
  80e3f2:	e9 98 03 00 00       	jmp    80e78f <tcp_input+0xd17>
      } else {
        tcp_ack_now(pcb);
  80e3f7:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80e3fb:	89 1c 24             	mov    %ebx,(%esp)
  80e3fe:	e8 5e a3 ff ff       	call   808761 <tcp_output>
        pcb->state = CLOSING;
  80e403:	c7 43 10 08 00 00 00 	movl   $0x8,0x10(%ebx)
  80e40a:	e9 80 03 00 00       	jmp    80e78f <tcp_input+0xd17>
      }
    } else if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  80e40f:	a8 10                	test   $0x10,%al
  80e411:	0f 84 78 03 00 00    	je     80e78f <tcp_input+0xd17>
  80e417:	a1 c4 c1 b3 00       	mov    0xb3c1c4,%eax
  80e41c:	39 43 54             	cmp    %eax,0x54(%ebx)
  80e41f:	0f 85 6a 03 00 00    	jne    80e78f <tcp_input+0xd17>
      pcb->state = FIN_WAIT_2;
  80e425:	c7 43 10 06 00 00 00 	movl   $0x6,0x10(%ebx)
  80e42c:	e9 5e 03 00 00       	jmp    80e78f <tcp_input+0xd17>
    }
    break;
  case FIN_WAIT_2:
    tcp_receive(pcb);
  80e431:	89 d8                	mov    %ebx,%eax
  80e433:	e8 12 ea ff ff       	call   80ce4a <tcp_receive>
    if (flags & TCP_FIN) {
  80e438:	f6 05 c0 c1 b3 00 01 	testb  $0x1,0xb3c1c0
  80e43f:	0f 84 4a 03 00 00    	je     80e78f <tcp_input+0xd17>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_ack_now(pcb);
  80e445:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80e449:	89 1c 24             	mov    %ebx,(%esp)
  80e44c:	e8 10 a3 ff ff       	call   808761 <tcp_output>
      tcp_pcb_purge(pcb);
  80e451:	89 1c 24             	mov    %ebx,(%esp)
  80e454:	e8 99 7a ff ff       	call   805ef2 <tcp_pcb_purge>
      TCP_RMV(&tcp_active_pcbs, pcb);
  80e459:	a1 5c c2 b3 00       	mov    0xb3c25c,%eax
  80e45e:	39 c3                	cmp    %eax,%ebx
  80e460:	75 0a                	jne    80e46c <tcp_input+0x9f4>
  80e462:	8b 43 0c             	mov    0xc(%ebx),%eax
  80e465:	a3 5c c2 b3 00       	mov    %eax,0xb3c25c
  80e46a:	eb 2a                	jmp    80e496 <tcp_input+0xa1e>
  80e46c:	a3 68 c2 b3 00       	mov    %eax,0xb3c268
  80e471:	eb 1a                	jmp    80e48d <tcp_input+0xa15>
  80e473:	8b 50 0c             	mov    0xc(%eax),%edx
  80e476:	85 d2                	test   %edx,%edx
  80e478:	74 11                	je     80e48b <tcp_input+0xa13>
  80e47a:	39 d3                	cmp    %edx,%ebx
  80e47c:	75 0d                	jne    80e48b <tcp_input+0xa13>
  80e47e:	a3 68 c2 b3 00       	mov    %eax,0xb3c268
  80e483:	8b 53 0c             	mov    0xc(%ebx),%edx
  80e486:	89 50 0c             	mov    %edx,0xc(%eax)
  80e489:	eb 0b                	jmp    80e496 <tcp_input+0xa1e>
  80e48b:	89 d0                	mov    %edx,%eax
  80e48d:	85 c0                	test   %eax,%eax
  80e48f:	75 e2                	jne    80e473 <tcp_input+0x9fb>
  80e491:	a3 68 c2 b3 00       	mov    %eax,0xb3c268
      pcb->state = TIME_WAIT;
  80e496:	c7 43 10 0a 00 00 00 	movl   $0xa,0x10(%ebx)
      TCP_REG(&tcp_tw_pcbs, pcb);
  80e49d:	a1 70 c2 b3 00       	mov    0xb3c270,%eax
  80e4a2:	89 43 0c             	mov    %eax,0xc(%ebx)
  80e4a5:	89 1d 70 c2 b3 00    	mov    %ebx,0xb3c270
  80e4ab:	e8 c2 40 ff ff       	call   802572 <tcp_timer_needed>
  80e4b0:	e9 da 02 00 00       	jmp    80e78f <tcp_input+0xd17>
    }
    break;
  case CLOSING:
    tcp_receive(pcb);
  80e4b5:	89 d8                	mov    %ebx,%eax
  80e4b7:	e8 8e e9 ff ff       	call   80ce4a <tcp_receive>
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  80e4bc:	f6 05 c0 c1 b3 00 10 	testb  $0x10,0xb3c1c0
  80e4c3:	0f 84 c6 02 00 00    	je     80e78f <tcp_input+0xd17>
  80e4c9:	a1 c4 c1 b3 00       	mov    0xb3c1c4,%eax
  80e4ce:	39 43 54             	cmp    %eax,0x54(%ebx)
  80e4d1:	0f 85 b8 02 00 00    	jne    80e78f <tcp_input+0xd17>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_ack_now(pcb);
  80e4d7:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80e4db:	89 1c 24             	mov    %ebx,(%esp)
  80e4de:	e8 7e a2 ff ff       	call   808761 <tcp_output>
      tcp_pcb_purge(pcb);
  80e4e3:	89 1c 24             	mov    %ebx,(%esp)
  80e4e6:	e8 07 7a ff ff       	call   805ef2 <tcp_pcb_purge>
      TCP_RMV(&tcp_active_pcbs, pcb);
  80e4eb:	a1 5c c2 b3 00       	mov    0xb3c25c,%eax
  80e4f0:	39 c3                	cmp    %eax,%ebx
  80e4f2:	75 0a                	jne    80e4fe <tcp_input+0xa86>
  80e4f4:	8b 43 0c             	mov    0xc(%ebx),%eax
  80e4f7:	a3 5c c2 b3 00       	mov    %eax,0xb3c25c
  80e4fc:	eb 2a                	jmp    80e528 <tcp_input+0xab0>
  80e4fe:	a3 68 c2 b3 00       	mov    %eax,0xb3c268
  80e503:	eb 1a                	jmp    80e51f <tcp_input+0xaa7>
  80e505:	8b 50 0c             	mov    0xc(%eax),%edx
  80e508:	85 d2                	test   %edx,%edx
  80e50a:	74 11                	je     80e51d <tcp_input+0xaa5>
  80e50c:	39 d3                	cmp    %edx,%ebx
  80e50e:	75 0d                	jne    80e51d <tcp_input+0xaa5>
  80e510:	a3 68 c2 b3 00       	mov    %eax,0xb3c268
  80e515:	8b 53 0c             	mov    0xc(%ebx),%edx
  80e518:	89 50 0c             	mov    %edx,0xc(%eax)
  80e51b:	eb 0b                	jmp    80e528 <tcp_input+0xab0>
  80e51d:	89 d0                	mov    %edx,%eax
  80e51f:	85 c0                	test   %eax,%eax
  80e521:	75 e2                	jne    80e505 <tcp_input+0xa8d>
  80e523:	a3 68 c2 b3 00       	mov    %eax,0xb3c268
      pcb->state = TIME_WAIT;
  80e528:	c7 43 10 0a 00 00 00 	movl   $0xa,0x10(%ebx)
      TCP_REG(&tcp_tw_pcbs, pcb);
  80e52f:	a1 70 c2 b3 00       	mov    0xb3c270,%eax
  80e534:	89 43 0c             	mov    %eax,0xc(%ebx)
  80e537:	89 1d 70 c2 b3 00    	mov    %ebx,0xb3c270
  80e53d:	e8 30 40 ff ff       	call   802572 <tcp_timer_needed>
  80e542:	e9 48 02 00 00       	jmp    80e78f <tcp_input+0xd17>
    }
    break;
  case LAST_ACK:
    tcp_receive(pcb);
  80e547:	89 d8                	mov    %ebx,%eax
  80e549:	e8 fc e8 ff ff       	call   80ce4a <tcp_receive>
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  80e54e:	f6 05 c0 c1 b3 00 10 	testb  $0x10,0xb3c1c0
  80e555:	0f 84 34 02 00 00    	je     80e78f <tcp_input+0xd17>
  80e55b:	a1 c4 c1 b3 00       	mov    0xb3c1c4,%eax
  80e560:	39 43 54             	cmp    %eax,0x54(%ebx)
  80e563:	0f 85 26 02 00 00    	jne    80e78f <tcp_input+0xd17>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      /* bugfix #21699: don't set pcb->state to CLOSED here or we risk leaking segments */
      recv_flags = TF_CLOSED;
  80e569:	c6 05 bc c1 b3 00 10 	movb   $0x10,0xb3c1bc
  80e570:	e9 1a 02 00 00       	jmp    80e78f <tcp_input+0xd17>
      }
    }

    tcp_input_pcb = pcb;
    err = tcp_process(pcb);
    tcp_input_pcb = NULL;
  80e575:	c7 05 78 c2 b3 00 00 	movl   $0x0,0xb3c278
  80e57c:	00 00 00 
    /* A return value of ERR_ABRT means that tcp_abort() was called
       and that the pcb has been freed. If so, we don't do anything. */
    if (err != ERR_ABRT) {
      if (recv_flags & TF_RESET) {
  80e57f:	0f b6 05 bc c1 b3 00 	movzbl 0xb3c1bc,%eax
  80e586:	a8 08                	test   $0x8,%al
  80e588:	74 3f                	je     80e5c9 <tcp_input+0xb51>
        /* TF_RESET means that the connection was reset by the other
           end. We then call the error callback to inform the
           application that the connection is dead before we
           deallocate the PCB. */
        TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_RST);
  80e58a:	8b 83 98 00 00 00    	mov    0x98(%ebx),%eax
  80e590:	85 c0                	test   %eax,%eax
  80e592:	74 10                	je     80e5a4 <tcp_input+0xb2c>
  80e594:	c7 44 24 04 fa ff ff 	movl   $0xfffffffa,0x4(%esp)
  80e59b:	ff 
  80e59c:	8b 53 18             	mov    0x18(%ebx),%edx
  80e59f:	89 14 24             	mov    %edx,(%esp)
  80e5a2:	ff d0                	call   *%eax
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
  80e5a4:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80e5a8:	c7 04 24 5c c2 b3 00 	movl   $0xb3c25c,(%esp)
  80e5af:	e8 b3 79 ff ff       	call   805f67 <tcp_pcb_remove>
        memp_free(MEMP_TCP_PCB, pcb);
  80e5b4:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80e5b8:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  80e5bf:	e8 7e 64 ff ff       	call   804a42 <memp_free>
  80e5c4:	e9 ea 00 00 00       	jmp    80e6b3 <tcp_input+0xc3b>
      } else if (recv_flags & TF_CLOSED) {
  80e5c9:	a8 10                	test   $0x10,%al
  80e5cb:	74 25                	je     80e5f2 <tcp_input+0xb7a>
        /* The connection has been closed and we will deallocate the
           PCB. */
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
  80e5cd:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80e5d1:	c7 04 24 5c c2 b3 00 	movl   $0xb3c25c,(%esp)
  80e5d8:	e8 8a 79 ff ff       	call   805f67 <tcp_pcb_remove>
        memp_free(MEMP_TCP_PCB, pcb);
  80e5dd:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80e5e1:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  80e5e8:	e8 55 64 ff ff       	call   804a42 <memp_free>
  80e5ed:	e9 c1 00 00 00       	jmp    80e6b3 <tcp_input+0xc3b>
      } else {
        err = ERR_OK;
        /* If the application has registered a "sent" function to be
           called when new send buffer space is available, we call it
           now. */
        if (pcb->acked > 0) {
  80e5f2:	0f b7 53 6c          	movzwl 0x6c(%ebx),%edx
        /* The connection has been closed and we will deallocate the
           PCB. */
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
        memp_free(MEMP_TCP_PCB, pcb);
      } else {
        err = ERR_OK;
  80e5f6:	b8 00 00 00 00       	mov    $0x0,%eax
        /* If the application has registered a "sent" function to be
           called when new send buffer space is available, we call it
           now. */
        if (pcb->acked > 0) {
  80e5fb:	66 85 d2             	test   %dx,%dx
  80e5fe:	74 1d                	je     80e61d <tcp_input+0xba5>
          TCP_EVENT_SENT(pcb, pcb->acked, err);
  80e600:	8b 8b 84 00 00 00    	mov    0x84(%ebx),%ecx
  80e606:	85 c9                	test   %ecx,%ecx
  80e608:	74 13                	je     80e61d <tcp_input+0xba5>
  80e60a:	0f b7 d2             	movzwl %dx,%edx
  80e60d:	89 54 24 08          	mov    %edx,0x8(%esp)
  80e611:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80e615:	8b 43 18             	mov    0x18(%ebx),%eax
  80e618:	89 04 24             	mov    %eax,(%esp)
  80e61b:	ff d1                	call   *%ecx
        }
      
        if (recv_data != NULL) {
  80e61d:	8b 15 b8 c1 b3 00    	mov    0xb3c1b8,%edx
  80e623:	85 d2                	test   %edx,%edx
  80e625:	74 51                	je     80e678 <tcp_input+0xc00>
          if(flags & TCP_PSH) {
  80e627:	f6 05 c0 c1 b3 00 08 	testb  $0x8,0xb3c1c0
  80e62e:	0f 84 6a 01 00 00    	je     80e79e <tcp_input+0xd26>
            recv_data->flags |= PBUF_FLAG_PUSH;
  80e634:	80 4a 0d 01          	orb    $0x1,0xd(%edx)
  80e638:	e9 61 01 00 00       	jmp    80e79e <tcp_input+0xd26>
          }

          /* Notify application that data has been received. */
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
  80e63d:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  80e644:	00 
  80e645:	89 54 24 08          	mov    %edx,0x8(%esp)
  80e649:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80e64d:	8b 53 18             	mov    0x18(%ebx),%edx
  80e650:	89 14 24             	mov    %edx,(%esp)
  80e653:	ff d0                	call   *%eax

          /* If the upper layer can't receive this data, store it */
          if (err != ERR_OK) {
  80e655:	84 c0                	test   %al,%al
  80e657:	75 13                	jne    80e66c <tcp_input+0xbf4>
  80e659:	eb 1d                	jmp    80e678 <tcp_input+0xc00>
          if(flags & TCP_PSH) {
            recv_data->flags |= PBUF_FLAG_PUSH;
          }

          /* Notify application that data has been received. */
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
  80e65b:	89 14 24             	mov    %edx,(%esp)
  80e65e:	66 90                	xchg   %ax,%ax
  80e660:	e8 8f 67 ff ff       	call   804df4 <pbuf_free>
  80e665:	b8 00 00 00 00       	mov    $0x0,%eax
  80e66a:	eb 0c                	jmp    80e678 <tcp_input+0xc00>

          /* If the upper layer can't receive this data, store it */
          if (err != ERR_OK) {
            pcb->refused_data = recv_data;
  80e66c:	8b 15 b8 c1 b3 00    	mov    0xb3c1b8,%edx
  80e672:	89 93 80 00 00 00    	mov    %edx,0x80(%ebx)
          }
        }

        /* If a FIN segment was received, we call the callback
           function with a NULL buffer to indicate EOF. */
        if (recv_flags & TF_GOT_FIN) {
  80e678:	f6 05 bc c1 b3 00 20 	testb  $0x20,0xb3c1bc
  80e67f:	74 26                	je     80e6a7 <tcp_input+0xc2f>
          TCP_EVENT_RECV(pcb, NULL, ERR_OK, err);
  80e681:	8b 83 88 00 00 00    	mov    0x88(%ebx),%eax
  80e687:	85 c0                	test   %eax,%eax
  80e689:	74 20                	je     80e6ab <tcp_input+0xc33>
  80e68b:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  80e692:	00 
  80e693:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80e69a:	00 
  80e69b:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80e69f:	8b 53 18             	mov    0x18(%ebx),%edx
  80e6a2:	89 14 24             	mov    %edx,(%esp)
  80e6a5:	ff d0                	call   *%eax
        }

        /* If there were no errors, we try to send something out. */
        if (err == ERR_OK) {
  80e6a7:	84 c0                	test   %al,%al
  80e6a9:	75 08                	jne    80e6b3 <tcp_input+0xc3b>
          tcp_output(pcb);
  80e6ab:	89 1c 24             	mov    %ebx,(%esp)
  80e6ae:	e8 ae a0 ff ff       	call   808761 <tcp_output>
      }
    }


    /* give up our reference to inseg.p */
    if (inseg.p != NULL)
  80e6b3:	a1 d8 c1 b3 00       	mov    0xb3c1d8,%eax
  80e6b8:	85 c0                	test   %eax,%eax
  80e6ba:	0f 84 f1 00 00 00    	je     80e7b1 <tcp_input+0xd39>
    {
      pbuf_free(inseg.p);
  80e6c0:	89 04 24             	mov    %eax,(%esp)
  80e6c3:	e8 2c 67 ff ff       	call   804df4 <pbuf_free>
      inseg.p = NULL;
  80e6c8:	c7 05 d8 c1 b3 00 00 	movl   $0x0,0xb3c1d8
  80e6cf:	00 00 00 
  80e6d2:	e9 da 00 00 00       	jmp    80e7b1 <tcp_input+0xd39>
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(ackno, seqno + tcplen,
        &(iphdr->dest), &(iphdr->src),
        tcphdr->dest, tcphdr->src);
  80e6d7:	8b 15 d0 c1 b3 00    	mov    0xb3c1d0,%edx
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(ackno, seqno + tcplen,
        &(iphdr->dest), &(iphdr->src),
  80e6dd:	a1 cc c1 b3 00       	mov    0xb3c1cc,%eax
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(ackno, seqno + tcplen,
  80e6e2:	0f b7 0a             	movzwl (%edx),%ecx
  80e6e5:	89 4c 24 14          	mov    %ecx,0x14(%esp)
  80e6e9:	0f b7 52 02          	movzwl 0x2(%edx),%edx
  80e6ed:	89 54 24 10          	mov    %edx,0x10(%esp)
  80e6f1:	8d 50 0c             	lea    0xc(%eax),%edx
  80e6f4:	89 54 24 0c          	mov    %edx,0xc(%esp)
  80e6f8:	83 c0 10             	add    $0x10,%eax
  80e6fb:	89 44 24 08          	mov    %eax,0x8(%esp)
  80e6ff:	0f b7 05 be c1 b3 00 	movzwl 0xb3c1be,%eax
  80e706:	03 05 c8 c1 b3 00    	add    0xb3c1c8,%eax
  80e70c:	89 44 24 04          	mov    %eax,0x4(%esp)
  80e710:	a1 c4 c1 b3 00       	mov    0xb3c1c4,%eax
  80e715:	89 04 24             	mov    %eax,(%esp)
  80e718:	e8 d8 a4 ff ff       	call   808bf5 <tcp_rst>
        &(iphdr->dest), &(iphdr->src),
        tcphdr->dest, tcphdr->src);
    }
    pbuf_free(p);
  80e71d:	89 34 24             	mov    %esi,(%esp)
  80e720:	e8 cf 66 ff ff       	call   804df4 <pbuf_free>
  80e725:	e9 87 00 00 00       	jmp    80e7b1 <tcp_input+0xd39>
    tcp_debug_print_state(pcb->state);
#endif /* TCP_DEBUG */
#endif /* TCP_INPUT_DEBUG */

    /* Set up a tcp_seg structure. */
    inseg.next = NULL;
  80e72a:	c7 05 d4 c1 b3 00 00 	movl   $0x0,0xb3c1d4
  80e731:	00 00 00 
    inseg.len = p->tot_len;
  80e734:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  80e738:	66 a3 e0 c1 b3 00    	mov    %ax,0xb3c1e0
    inseg.dataptr = p->payload;
  80e73e:	8b 46 04             	mov    0x4(%esi),%eax
  80e741:	a3 dc c1 b3 00       	mov    %eax,0xb3c1dc
    inseg.p = p;
  80e746:	89 35 d8 c1 b3 00    	mov    %esi,0xb3c1d8
    inseg.tcphdr = tcphdr;
  80e74c:	a1 d0 c1 b3 00       	mov    0xb3c1d0,%eax
  80e751:	a3 e4 c1 b3 00       	mov    %eax,0xb3c1e4

    recv_data = NULL;
  80e756:	c7 05 b8 c1 b3 00 00 	movl   $0x0,0xb3c1b8
  80e75d:	00 00 00 
    recv_flags = 0;
  80e760:	c6 05 bc c1 b3 00 00 	movb   $0x0,0xb3c1bc

    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
  80e767:	8b 93 80 00 00 00    	mov    0x80(%ebx),%edx
  80e76d:	85 d2                	test   %edx,%edx
  80e76f:	0f 85 57 f8 ff ff    	jne    80dfcc <tcp_input+0x554>
  80e775:	e9 9b f8 ff ff       	jmp    80e015 <tcp_input+0x59d>
  } else {

    /* If no matching PCB was found, send a TCP RST (reset) to the
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
  80e77a:	0f b7 42 0c          	movzwl 0xc(%edx),%eax
  80e77e:	89 04 24             	mov    %eax,(%esp)
  80e781:	e8 fd 95 ff ff       	call   807d83 <ntohs>
  80e786:	a8 04                	test   $0x4,%al
  80e788:	75 93                	jne    80e71d <tcp_input+0xca5>
  80e78a:	e9 48 ff ff ff       	jmp    80e6d7 <tcp_input+0xc5f>
      }
    }

    tcp_input_pcb = pcb;
    err = tcp_process(pcb);
    tcp_input_pcb = NULL;
  80e78f:	c7 05 78 c2 b3 00 00 	movl   $0x0,0xb3c278
  80e796:	00 00 00 
  80e799:	e9 e1 fd ff ff       	jmp    80e57f <tcp_input+0xb07>
          if(flags & TCP_PSH) {
            recv_data->flags |= PBUF_FLAG_PUSH;
          }

          /* Notify application that data has been received. */
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
  80e79e:	8b 83 88 00 00 00    	mov    0x88(%ebx),%eax
  80e7a4:	85 c0                	test   %eax,%eax
  80e7a6:	0f 85 91 fe ff ff    	jne    80e63d <tcp_input+0xbc5>
  80e7ac:	e9 aa fe ff ff       	jmp    80e65b <tcp_input+0xbe3>
    pbuf_free(p);
  }

  LWIP_ASSERT("tcp_input: tcp_pcbs_sane()", tcp_pcbs_sane());
  PERF_STOP("tcp_input");
}
  80e7b1:	83 c4 4c             	add    $0x4c,%esp
  80e7b4:	5b                   	pop    %ebx
  80e7b5:	5e                   	pop    %esi
  80e7b6:	5f                   	pop    %edi
  80e7b7:	5d                   	pop    %ebp
  80e7b8:	c3                   	ret    

0080e7b9 <raw_input>:
 *           caller).
 *
 */
u8_t
raw_input(struct pbuf *p, struct netif *inp)
{
  80e7b9:	55                   	push   %ebp
  80e7ba:	89 e5                	mov    %esp,%ebp
  80e7bc:	57                   	push   %edi
  80e7bd:	56                   	push   %esi
  80e7be:	53                   	push   %ebx
  80e7bf:	83 ec 2c             	sub    $0x2c,%esp
  s16_t proto;
  u8_t eaten = 0;

  LWIP_UNUSED_ARG(inp);

  iphdr = p->payload;
  80e7c2:	8b 45 08             	mov    0x8(%ebp),%eax
  80e7c5:	8b 40 04             	mov    0x4(%eax),%eax
  proto = IPH_PROTO(iphdr);
  80e7c8:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80e7cb:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  80e7cf:	89 04 24             	mov    %eax,(%esp)
  80e7d2:	e8 ac 95 ff ff       	call   807d83 <ntohs>

  prev = NULL;
  pcb = raw_pcbs;
  80e7d7:	8b 1d e8 c1 b3 00    	mov    0xb3c1e8,%ebx
raw_input(struct pbuf *p, struct netif *inp)
{
  struct raw_pcb *pcb, *prev;
  struct ip_hdr *iphdr;
  s16_t proto;
  u8_t eaten = 0;
  80e7dd:	c6 45 e7 00          	movb   $0x0,-0x19(%ebp)
  LWIP_UNUSED_ARG(inp);

  iphdr = p->payload;
  proto = IPH_PROTO(iphdr);

  prev = NULL;
  80e7e1:	be 00 00 00 00       	mov    $0x0,%esi
  pcb = raw_pcbs;
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
    if (pcb->protocol == proto) {
  80e7e6:	0f b6 f8             	movzbl %al,%edi
      /* receive callback function available? */
      if (pcb->recv != NULL) {
        /* the receive callback function did not eat the packet? */
        if (pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src)) != 0)
  80e7e9:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80e7ec:	83 c0 0c             	add    $0xc,%eax
  80e7ef:	89 45 e0             	mov    %eax,-0x20(%ebp)

  prev = NULL;
  pcb = raw_pcbs;
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
  80e7f2:	eb 62                	jmp    80e856 <raw_input+0x9d>
    if (pcb->protocol == proto) {
  80e7f4:	0f b6 43 10          	movzbl 0x10(%ebx),%eax
  80e7f8:	39 f8                	cmp    %edi,%eax
  80e7fa:	75 55                	jne    80e851 <raw_input+0x98>
      /* receive callback function available? */
      if (pcb->recv != NULL) {
  80e7fc:	8b 43 14             	mov    0x14(%ebx),%eax
  80e7ff:	85 c0                	test   %eax,%eax
  80e801:	74 4e                	je     80e851 <raw_input+0x98>
        /* the receive callback function did not eat the packet? */
        if (pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src)) != 0)
  80e803:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  80e806:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
  80e80a:	8b 55 08             	mov    0x8(%ebp),%edx
  80e80d:	89 54 24 08          	mov    %edx,0x8(%esp)
  80e811:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80e815:	8b 53 18             	mov    0x18(%ebx),%edx
  80e818:	89 14 24             	mov    %edx,(%esp)
  80e81b:	ff d0                	call   *%eax
  80e81d:	84 c0                	test   %al,%al
  80e81f:	74 30                	je     80e851 <raw_input+0x98>
        {
          /* receive function ate the packet */
          p = NULL;
          eaten = 1;
          if (prev != NULL) {
  80e821:	85 f6                	test   %esi,%esi
  80e823:	74 21                	je     80e846 <raw_input+0x8d>
          /* move the pcb to the front of raw_pcbs so that is
             found faster next time */
            prev->next = pcb->next;
  80e825:	8b 43 0c             	mov    0xc(%ebx),%eax
  80e828:	89 46 0c             	mov    %eax,0xc(%esi)
            pcb->next = raw_pcbs;
  80e82b:	a1 e8 c1 b3 00       	mov    0xb3c1e8,%eax
  80e830:	89 43 0c             	mov    %eax,0xc(%ebx)
            raw_pcbs = pcb;
  80e833:	89 1d e8 c1 b3 00    	mov    %ebx,0xb3c1e8
        /* the receive callback function did not eat the packet? */
        if (pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src)) != 0)
        {
          /* receive function ate the packet */
          p = NULL;
          eaten = 1;
  80e839:	c6 45 e7 01          	movb   $0x1,-0x19(%ebp)
      if (pcb->recv != NULL) {
        /* the receive callback function did not eat the packet? */
        if (pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src)) != 0)
        {
          /* receive function ate the packet */
          p = NULL;
  80e83d:	c7 45 08 00 00 00 00 	movl   $0x0,0x8(%ebp)
  80e844:	eb 0b                	jmp    80e851 <raw_input+0x98>
          eaten = 1;
  80e846:	c6 45 e7 01          	movb   $0x1,-0x19(%ebp)
      if (pcb->recv != NULL) {
        /* the receive callback function did not eat the packet? */
        if (pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src)) != 0)
        {
          /* receive function ate the packet */
          p = NULL;
  80e84a:	c7 45 08 00 00 00 00 	movl   $0x0,0x8(%ebp)
        }
      }
      /* no receive callback function was set for this raw PCB */
      /* drop the packet */
    }
    prev = pcb;
  80e851:	89 de                	mov    %ebx,%esi
    pcb = pcb->next;
  80e853:	8b 5b 0c             	mov    0xc(%ebx),%ebx

  prev = NULL;
  pcb = raw_pcbs;
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
  80e856:	85 db                	test   %ebx,%ebx
  80e858:	74 06                	je     80e860 <raw_input+0xa7>
  80e85a:	80 7d e7 00          	cmpb   $0x0,-0x19(%ebp)
  80e85e:	74 94                	je     80e7f4 <raw_input+0x3b>
    }
    prev = pcb;
    pcb = pcb->next;
  }
  return eaten;
}
  80e860:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
  80e864:	83 c4 2c             	add    $0x2c,%esp
  80e867:	5b                   	pop    %ebx
  80e868:	5e                   	pop    %esi
  80e869:	5f                   	pop    %edi
  80e86a:	5d                   	pop    %ebp
  80e86b:	c3                   	ret    

0080e86c <raw_bind>:
 *
 * @see raw_disconnect()
 */
err_t
raw_bind(struct raw_pcb *pcb, struct ip_addr *ipaddr)
{
  80e86c:	55                   	push   %ebp
  80e86d:	89 e5                	mov    %esp,%ebp
  80e86f:	8b 45 0c             	mov    0xc(%ebp),%eax
  ip_addr_set(&pcb->local_ip, ipaddr);
  80e872:	85 c0                	test   %eax,%eax
  80e874:	74 04                	je     80e87a <raw_bind+0xe>
  80e876:	8b 10                	mov    (%eax),%edx
  80e878:	eb 05                	jmp    80e87f <raw_bind+0x13>
  80e87a:	ba 00 00 00 00       	mov    $0x0,%edx
  80e87f:	8b 45 08             	mov    0x8(%ebp),%eax
  80e882:	89 10                	mov    %edx,(%eax)
  return ERR_OK;
}
  80e884:	b8 00 00 00 00       	mov    $0x0,%eax
  80e889:	5d                   	pop    %ebp
  80e88a:	c3                   	ret    

0080e88b <raw_connect>:
 *
 * @see raw_disconnect() and raw_sendto()
 */
err_t
raw_connect(struct raw_pcb *pcb, struct ip_addr *ipaddr)
{
  80e88b:	55                   	push   %ebp
  80e88c:	89 e5                	mov    %esp,%ebp
  80e88e:	8b 45 0c             	mov    0xc(%ebp),%eax
  ip_addr_set(&pcb->remote_ip, ipaddr);
  80e891:	85 c0                	test   %eax,%eax
  80e893:	74 04                	je     80e899 <raw_connect+0xe>
  80e895:	8b 10                	mov    (%eax),%edx
  80e897:	eb 05                	jmp    80e89e <raw_connect+0x13>
  80e899:	ba 00 00 00 00       	mov    $0x0,%edx
  80e89e:	8b 45 08             	mov    0x8(%ebp),%eax
  80e8a1:	89 50 04             	mov    %edx,0x4(%eax)
  return ERR_OK;
}
  80e8a4:	b8 00 00 00 00       	mov    $0x0,%eax
  80e8a9:	5d                   	pop    %ebp
  80e8aa:	c3                   	ret    

0080e8ab <raw_recv>:
void
raw_recv(struct raw_pcb *pcb,
         u8_t (* recv)(void *arg, struct raw_pcb *upcb, struct pbuf *p,
                      struct ip_addr *addr),
         void *recv_arg)
{
  80e8ab:	55                   	push   %ebp
  80e8ac:	89 e5                	mov    %esp,%ebp
  80e8ae:	8b 45 08             	mov    0x8(%ebp),%eax
  /* remember recv() callback and user data */
  pcb->recv = recv;
  80e8b1:	8b 55 0c             	mov    0xc(%ebp),%edx
  80e8b4:	89 50 14             	mov    %edx,0x14(%eax)
  pcb->recv_arg = recv_arg;
  80e8b7:	8b 55 10             	mov    0x10(%ebp),%edx
  80e8ba:	89 50 18             	mov    %edx,0x18(%eax)
}
  80e8bd:	5d                   	pop    %ebp
  80e8be:	c3                   	ret    

0080e8bf <raw_sendto>:
 * @param ipaddr the destination address of the IP packet
 *
 */
err_t
raw_sendto(struct raw_pcb *pcb, struct pbuf *p, struct ip_addr *ipaddr)
{
  80e8bf:	55                   	push   %ebp
  80e8c0:	89 e5                	mov    %esp,%ebp
  80e8c2:	57                   	push   %edi
  80e8c3:	56                   	push   %esi
  80e8c4:	53                   	push   %ebx
  80e8c5:	83 ec 2c             	sub    $0x2c,%esp
  80e8c8:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80e8cb:	8b 7d 0c             	mov    0xc(%ebp),%edi
  struct pbuf *q; /* q will be sent down the stack */
  
  LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 3, ("raw_sendto\n"));
  
  /* not enough space to add an IP header to first pbuf in given p chain? */
  if (pbuf_header(p, IP_HLEN)) {
  80e8ce:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  80e8d5:	00 
  80e8d6:	89 3c 24             	mov    %edi,(%esp)
  80e8d9:	e8 32 64 ff ff       	call   804d10 <pbuf_header>
  80e8de:	84 c0                	test   %al,%al
  80e8e0:	74 43                	je     80e925 <raw_sendto+0x66>
    /* allocate header in new pbuf */
    q = pbuf_alloc(PBUF_IP, 0, PBUF_RAM);
  80e8e2:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80e8e9:	00 
  80e8ea:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80e8f1:	00 
  80e8f2:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  80e8f9:	e8 d7 65 ff ff       	call   804ed5 <pbuf_alloc>
  80e8fe:	89 c6                	mov    %eax,%esi
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
  80e900:	85 c0                	test   %eax,%eax
  80e902:	0f 84 b8 00 00 00    	je     80e9c0 <raw_sendto+0x101>
      LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 2, ("raw_sendto: could not allocate header\n"));
      return ERR_MEM;
    }
    /* chain header q in front of given pbuf p */
    pbuf_chain(q, p);
  80e908:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80e90c:	89 04 24             	mov    %eax,(%esp)
  80e90f:	e8 16 6a ff ff       	call   80532a <pbuf_chain>
      LWIP_ASSERT("Can't restore header we just removed!", 0);
      return ERR_MEM;
    }
  }
  
  if ((netif = ip_route(ipaddr)) == NULL) {
  80e914:	8b 45 10             	mov    0x10(%ebp),%eax
  80e917:	89 04 24             	mov    %eax,(%esp)
  80e91a:	e8 c1 81 ff ff       	call   806ae0 <ip_route>
  80e91f:	85 c0                	test   %eax,%eax
  80e921:	75 4e                	jne    80e971 <raw_sendto+0xb2>
  80e923:	eb 34                	jmp    80e959 <raw_sendto+0x9a>
    /* { first pbuf q points to header pbuf } */
    LWIP_DEBUGF(RAW_DEBUG, ("raw_sendto: added header pbuf %p before given pbuf %p\n", (void *)q, (void *)p));
  }  else {
    /* first pbuf q equals given pbuf */
    q = p;
    if(pbuf_header(q, -IP_HLEN)) {
  80e925:	c7 44 24 04 ec ff ff 	movl   $0xffffffec,0x4(%esp)
  80e92c:	ff 
  80e92d:	89 3c 24             	mov    %edi,(%esp)
  80e930:	e8 db 63 ff ff       	call   804d10 <pbuf_header>
  80e935:	84 c0                	test   %al,%al
  80e937:	0f 84 91 00 00 00    	je     80e9ce <raw_sendto+0x10f>
      LWIP_ASSERT("Can't restore header we just removed!", 0);
  80e93d:	c7 44 24 08 34 40 81 	movl   $0x814034,0x8(%esp)
  80e944:	00 
  80e945:	c7 44 24 04 e3 00 00 	movl   $0xe3,0x4(%esp)
  80e94c:	00 
  80e94d:	c7 04 24 5a 40 81 00 	movl   $0x81405a,(%esp)
  80e954:	e8 21 07 00 00       	call   80f07a <_panic>
    LWIP_DEBUGF(RAW_DEBUG | 1, ("raw_sendto: No route to 0x%"X32_F"\n", ipaddr->addr));
    /* free any temporary header pbuf allocated by pbuf_header() */
    if (q != p) {
      pbuf_free(q);
    }
    return ERR_RTE;
  80e959:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  }
  
  if ((netif = ip_route(ipaddr)) == NULL) {
    LWIP_DEBUGF(RAW_DEBUG | 1, ("raw_sendto: No route to 0x%"X32_F"\n", ipaddr->addr));
    /* free any temporary header pbuf allocated by pbuf_header() */
    if (q != p) {
  80e95e:	39 f7                	cmp    %esi,%edi
  80e960:	74 7f                	je     80e9e1 <raw_sendto+0x122>
      pbuf_free(q);
  80e962:	89 34 24             	mov    %esi,(%esp)
  80e965:	e8 8a 64 ff ff       	call   804df4 <pbuf_free>
    }
    return ERR_RTE;
  80e96a:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  80e96f:	eb 70                	jmp    80e9e1 <raw_sendto+0x122>
  }

  if (ip_addr_isany(&pcb->local_ip)) {
  80e971:	89 da                	mov    %ebx,%edx
  80e973:	85 db                	test   %ebx,%ebx
  80e975:	74 05                	je     80e97c <raw_sendto+0xbd>
  80e977:	83 3b 00             	cmpl   $0x0,(%ebx)
  80e97a:	75 03                	jne    80e97f <raw_sendto+0xc0>
    /* use outgoing network interface IP address as source address */
    src_ip = &(netif->ip_addr);
  80e97c:	8d 50 04             	lea    0x4(%eax),%edx
  }

#if LWIP_NETIF_HWADDRHINT
  netif->addr_hint = &(pcb->addr_hint);
#endif /* LWIP_NETIF_HWADDRHINT*/
  err = ip_output_if (q, src_ip, ipaddr, pcb->ttl, pcb->tos, pcb->protocol, netif);
  80e97f:	89 44 24 18          	mov    %eax,0x18(%esp)
  80e983:	0f b6 43 10          	movzbl 0x10(%ebx),%eax
  80e987:	89 44 24 14          	mov    %eax,0x14(%esp)
  80e98b:	0f b6 43 0a          	movzbl 0xa(%ebx),%eax
  80e98f:	89 44 24 10          	mov    %eax,0x10(%esp)
  80e993:	0f b6 43 0b          	movzbl 0xb(%ebx),%eax
  80e997:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80e99b:	8b 45 10             	mov    0x10(%ebp),%eax
  80e99e:	89 44 24 08          	mov    %eax,0x8(%esp)
  80e9a2:	89 54 24 04          	mov    %edx,0x4(%esp)
  80e9a6:	89 34 24             	mov    %esi,(%esp)
  80e9a9:	e8 70 84 ff ff       	call   806e1e <ip_output_if>
  80e9ae:	89 c3                	mov    %eax,%ebx
#if LWIP_NETIF_HWADDRHINT
  netif->addr_hint = NULL;
#endif /* LWIP_NETIF_HWADDRHINT*/

  /* did we chain a header earlier? */
  if (q != p) {
  80e9b0:	39 fe                	cmp    %edi,%esi
  80e9b2:	74 2d                	je     80e9e1 <raw_sendto+0x122>
    /* free the header */
    pbuf_free(q);
  80e9b4:	89 34 24             	mov    %esi,(%esp)
  80e9b7:	e8 38 64 ff ff       	call   804df4 <pbuf_free>
  }
  return err;
  80e9bc:	89 d8                	mov    %ebx,%eax
  80e9be:	eb 21                	jmp    80e9e1 <raw_sendto+0x122>
    /* allocate header in new pbuf */
    q = pbuf_alloc(PBUF_IP, 0, PBUF_RAM);
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
      LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 2, ("raw_sendto: could not allocate header\n"));
      return ERR_MEM;
  80e9c0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80e9c5:	eb 1a                	jmp    80e9e1 <raw_sendto+0x122>
    LWIP_DEBUGF(RAW_DEBUG | 1, ("raw_sendto: No route to 0x%"X32_F"\n", ipaddr->addr));
    /* free any temporary header pbuf allocated by pbuf_header() */
    if (q != p) {
      pbuf_free(q);
    }
    return ERR_RTE;
  80e9c7:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  80e9cc:	eb 13                	jmp    80e9e1 <raw_sendto+0x122>
      LWIP_ASSERT("Can't restore header we just removed!", 0);
      return ERR_MEM;
    }
  }
  
  if ((netif = ip_route(ipaddr)) == NULL) {
  80e9ce:	8b 45 10             	mov    0x10(%ebp),%eax
  80e9d1:	89 04 24             	mov    %eax,(%esp)
  80e9d4:	e8 07 81 ff ff       	call   806ae0 <ip_route>
  80e9d9:	85 c0                	test   %eax,%eax
  80e9db:	74 ea                	je     80e9c7 <raw_sendto+0x108>
    pbuf_chain(q, p);
    /* { first pbuf q points to header pbuf } */
    LWIP_DEBUGF(RAW_DEBUG, ("raw_sendto: added header pbuf %p before given pbuf %p\n", (void *)q, (void *)p));
  }  else {
    /* first pbuf q equals given pbuf */
    q = p;
  80e9dd:	89 fe                	mov    %edi,%esi
  80e9df:	eb 90                	jmp    80e971 <raw_sendto+0xb2>
  if (q != p) {
    /* free the header */
    pbuf_free(q);
  }
  return err;
}
  80e9e1:	83 c4 2c             	add    $0x2c,%esp
  80e9e4:	5b                   	pop    %ebx
  80e9e5:	5e                   	pop    %esi
  80e9e6:	5f                   	pop    %edi
  80e9e7:	5d                   	pop    %ebp
  80e9e8:	c3                   	ret    

0080e9e9 <raw_send>:
 * @param p the IP payload to send
 *
 */
err_t
raw_send(struct raw_pcb *pcb, struct pbuf *p)
{
  80e9e9:	55                   	push   %ebp
  80e9ea:	89 e5                	mov    %esp,%ebp
  80e9ec:	83 ec 18             	sub    $0x18,%esp
  80e9ef:	8b 45 08             	mov    0x8(%ebp),%eax
  return raw_sendto(pcb, p, &pcb->remote_ip);
  80e9f2:	8d 50 04             	lea    0x4(%eax),%edx
  80e9f5:	89 54 24 08          	mov    %edx,0x8(%esp)
  80e9f9:	8b 55 0c             	mov    0xc(%ebp),%edx
  80e9fc:	89 54 24 04          	mov    %edx,0x4(%esp)
  80ea00:	89 04 24             	mov    %eax,(%esp)
  80ea03:	e8 b7 fe ff ff       	call   80e8bf <raw_sendto>
}
  80ea08:	c9                   	leave  
  80ea09:	c3                   	ret    

0080ea0a <raw_remove>:
 *
 * @see raw_new()
 */
void
raw_remove(struct raw_pcb *pcb)
{
  80ea0a:	55                   	push   %ebp
  80ea0b:	89 e5                	mov    %esp,%ebp
  80ea0d:	83 ec 18             	sub    $0x18,%esp
  80ea10:	8b 4d 08             	mov    0x8(%ebp),%ecx
  struct raw_pcb *pcb2;
  /* pcb to be removed is first in list? */
  if (raw_pcbs == pcb) {
  80ea13:	a1 e8 c1 b3 00       	mov    0xb3c1e8,%eax
  80ea18:	39 c8                	cmp    %ecx,%eax
  80ea1a:	75 1e                	jne    80ea3a <raw_remove+0x30>
    /* make list start at 2nd pcb */
    raw_pcbs = raw_pcbs->next;
  80ea1c:	8b 40 0c             	mov    0xc(%eax),%eax
  80ea1f:	a3 e8 c1 b3 00       	mov    %eax,0xb3c1e8
  80ea24:	eb 18                	jmp    80ea3e <raw_remove+0x34>
    /* pcb not 1st in list */
  } else {
    for(pcb2 = raw_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
      /* find pcb in raw_pcbs list */
      if (pcb2->next != NULL && pcb2->next == pcb) {
  80ea26:	8b 50 0c             	mov    0xc(%eax),%edx
  80ea29:	85 d2                	test   %edx,%edx
  80ea2b:	74 0a                	je     80ea37 <raw_remove+0x2d>
  80ea2d:	39 d1                	cmp    %edx,%ecx
  80ea2f:	75 06                	jne    80ea37 <raw_remove+0x2d>
        /* remove pcb from list */
        pcb2->next = pcb->next;
  80ea31:	8b 51 0c             	mov    0xc(%ecx),%edx
  80ea34:	89 50 0c             	mov    %edx,0xc(%eax)
  if (raw_pcbs == pcb) {
    /* make list start at 2nd pcb */
    raw_pcbs = raw_pcbs->next;
    /* pcb not 1st in list */
  } else {
    for(pcb2 = raw_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
  80ea37:	8b 40 0c             	mov    0xc(%eax),%eax
  80ea3a:	85 c0                	test   %eax,%eax
  80ea3c:	75 e8                	jne    80ea26 <raw_remove+0x1c>
        /* remove pcb from list */
        pcb2->next = pcb->next;
      }
    }
  }
  memp_free(MEMP_RAW_PCB, pcb);
  80ea3e:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  80ea42:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80ea49:	e8 f4 5f ff ff       	call   804a42 <memp_free>
}
  80ea4e:	c9                   	leave  
  80ea4f:	c3                   	ret    

0080ea50 <raw_new>:
 * @param proto the protocol number of the IPs payload (e.g. IP_PROTO_ICMP)
 *
 * @see raw_remove()
 */
struct raw_pcb *
raw_new(u8_t proto) {
  80ea50:	55                   	push   %ebp
  80ea51:	89 e5                	mov    %esp,%ebp
  80ea53:	56                   	push   %esi
  80ea54:	53                   	push   %ebx
  80ea55:	83 ec 10             	sub    $0x10,%esp
  80ea58:	8b 75 08             	mov    0x8(%ebp),%esi
  struct raw_pcb *pcb;

  LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 3, ("raw_new\n"));

  pcb = memp_malloc(MEMP_RAW_PCB);
  80ea5b:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80ea62:	e8 7b 5f ff ff       	call   8049e2 <memp_malloc>
  80ea67:	89 c3                	mov    %eax,%ebx
  /* could allocate RAW PCB? */
  if (pcb != NULL) {
  80ea69:	85 c0                	test   %eax,%eax
  80ea6b:	74 2f                	je     80ea9c <raw_new+0x4c>
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct raw_pcb));
  80ea6d:	c7 44 24 08 1c 00 00 	movl   $0x1c,0x8(%esp)
  80ea74:	00 
  80ea75:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80ea7c:	00 
  80ea7d:	89 04 24             	mov    %eax,(%esp)
  80ea80:	e8 62 0e 00 00       	call   80f8e7 <memset>
    pcb->protocol = proto;
  80ea85:	89 f0                	mov    %esi,%eax
  80ea87:	88 43 10             	mov    %al,0x10(%ebx)
    pcb->ttl = RAW_TTL;
  80ea8a:	c6 43 0b ff          	movb   $0xff,0xb(%ebx)
    pcb->next = raw_pcbs;
  80ea8e:	a1 e8 c1 b3 00       	mov    0xb3c1e8,%eax
  80ea93:	89 43 0c             	mov    %eax,0xc(%ebx)
    raw_pcbs = pcb;
  80ea96:	89 1d e8 c1 b3 00    	mov    %ebx,0xb3c1e8
  }
  return pcb;
}
  80ea9c:	89 d8                	mov    %ebx,%eax
  80ea9e:	83 c4 10             	add    $0x10,%esp
  80eaa1:	5b                   	pop    %ebx
  80eaa2:	5e                   	pop    %esi
  80eaa3:	5d                   	pop    %ebp
  80eaa4:	c3                   	ret    
  80eaa5:	66 90                	xchg   %ax,%ax
  80eaa7:	66 90                	xchg   %ax,%ax
  80eaa9:	66 90                	xchg   %ax,%ax
  80eaab:	66 90                	xchg   %ax,%ax
  80eaad:	66 90                	xchg   %ax,%ax
  80eaaf:	90                   	nop

0080eab0 <icmp_input>:
 * @param p the icmp echo request packet, p->payload pointing to the ip header
 * @param inp the netif on which this packet was received
 */
void
icmp_input(struct pbuf *p, struct netif *inp)
{
  80eab0:	55                   	push   %ebp
  80eab1:	89 e5                	mov    %esp,%ebp
  80eab3:	57                   	push   %edi
  80eab4:	56                   	push   %esi
  80eab5:	53                   	push   %ebx
  80eab6:	83 ec 3c             	sub    $0x3c,%esp
  80eab9:	8b 5d 08             	mov    0x8(%ebp),%ebx

  ICMP_STATS_INC(icmp.recv);
  snmp_inc_icmpinmsgs();


  iphdr = p->payload;
  80eabc:	8b 73 04             	mov    0x4(%ebx),%esi
  hlen = IPH_HL(iphdr) * 4;
  80eabf:	0f b7 06             	movzwl (%esi),%eax
  80eac2:	89 04 24             	mov    %eax,(%esp)
  80eac5:	e8 b9 92 ff ff       	call   807d83 <ntohs>
  80eaca:	66 c1 e8 06          	shr    $0x6,%ax
  80eace:	83 e0 3c             	and    $0x3c,%eax
  80ead1:	66 89 45 e6          	mov    %ax,-0x1a(%ebp)
  if (pbuf_header(p, -hlen) || (p->tot_len < sizeof(u16_t)*2)) {
  80ead5:	89 c7                	mov    %eax,%edi
  80ead7:	f7 df                	neg    %edi
  80ead9:	0f bf ff             	movswl %di,%edi
  80eadc:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80eae0:	89 1c 24             	mov    %ebx,(%esp)
  80eae3:	e8 28 62 ff ff       	call   804d10 <pbuf_header>
  80eae8:	84 c0                	test   %al,%al
  80eaea:	0f 85 eb 02 00 00    	jne    80eddb <icmp_input+0x32b>
  80eaf0:	66 83 7b 08 03       	cmpw   $0x3,0x8(%ebx)
  80eaf5:	0f 86 e0 02 00 00    	jbe    80eddb <icmp_input+0x32b>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: short ICMP (%"U16_F" bytes) received\n", p->tot_len));
    goto lenerr;
  }

  type = *((u8_t *)p->payload);
  80eafb:	8b 43 04             	mov    0x4(%ebx),%eax
#ifdef LWIP_DEBUG
  code = *(((u8_t *)p->payload)+1);
#endif /* LWIP_DEBUG */
  switch (type) {
  80eafe:	80 38 08             	cmpb   $0x8,(%eax)
  80eb01:	0f 85 ca 02 00 00    	jne    80edd1 <icmp_input+0x321>
  case ICMP_ECHO:
    /* broadcast or multicast destination address? */
    if (ip_addr_isbroadcast(&iphdr->dest, inp) || ip_addr_ismulticast(&iphdr->dest)) {
  80eb07:	8b 45 0c             	mov    0xc(%ebp),%eax
  80eb0a:	89 44 24 04          	mov    %eax,0x4(%esp)
  80eb0e:	8d 46 10             	lea    0x10(%esi),%eax
  80eb11:	89 04 24             	mov    %eax,(%esp)
  80eb14:	e8 78 7f ff ff       	call   806a91 <ip_addr_isbroadcast>
  80eb19:	84 c0                	test   %al,%al
  80eb1b:	75 29                	jne    80eb46 <icmp_input+0x96>
  80eb1d:	8b 46 10             	mov    0x10(%esi),%eax
  80eb20:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80eb23:	c7 04 24 00 00 00 f0 	movl   $0xf0000000,(%esp)
  80eb2a:	e8 9b 94 ff ff       	call   807fca <ntohl>
  80eb2f:	23 45 e0             	and    -0x20(%ebp),%eax
  80eb32:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80eb35:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  80eb3c:	e8 89 94 ff ff       	call   807fca <ntohl>
  80eb41:	39 45 e0             	cmp    %eax,-0x20(%ebp)
  80eb44:	75 0f                	jne    80eb55 <icmp_input+0xa5>
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: Not echoing to multicast or broadcast pings\n"));
      ICMP_STATS_INC(icmp.err);
      pbuf_free(p);
  80eb46:	89 1c 24             	mov    %ebx,(%esp)
  80eb49:	e8 a6 62 ff ff       	call   804df4 <pbuf_free>
      return;
  80eb4e:	66 90                	xchg   %ax,%ax
  80eb50:	e9 98 02 00 00       	jmp    80eded <icmp_input+0x33d>
    }
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ping\n"));
    if (p->tot_len < sizeof(struct icmp_echo_hdr)) {
  80eb55:	66 83 7b 08 07       	cmpw   $0x7,0x8(%ebx)
  80eb5a:	0f 86 7b 02 00 00    	jbe    80eddb <icmp_input+0x32b>
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: bad ICMP echo received\n"));
      goto lenerr;
    }
    if (inet_chksum_pbuf(p) != 0) {
  80eb60:	89 1c 24             	mov    %ebx,(%esp)
  80eb63:	e8 cf 90 ff ff       	call   807c37 <inet_chksum_pbuf>
  80eb68:	66 85 c0             	test   %ax,%ax
  80eb6b:	74 0d                	je     80eb7a <icmp_input+0xca>
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: checksum failed for received ICMP echo\n"));
      pbuf_free(p);
  80eb6d:	89 1c 24             	mov    %ebx,(%esp)
  80eb70:	e8 7f 62 ff ff       	call   804df4 <pbuf_free>
      ICMP_STATS_INC(icmp.chkerr);
      snmp_inc_icmpinerrors();
      return;
  80eb75:	e9 73 02 00 00       	jmp    80eded <icmp_input+0x33d>
    }
    if (pbuf_header(p, (PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
  80eb7a:	c7 44 24 04 22 00 00 	movl   $0x22,0x4(%esp)
  80eb81:	00 
  80eb82:	89 1c 24             	mov    %ebx,(%esp)
  80eb85:	e8 86 61 ff ff       	call   804d10 <pbuf_header>
  80eb8a:	84 c0                	test   %al,%al
  80eb8c:	0f 84 f0 00 00 00    	je     80ec82 <icmp_input+0x1d2>
      /* p is not big enough to contain link headers
       * allocate a new one and copy p into it
       */
      struct pbuf *r;
      /* switch p->payload to ip header */
      if (pbuf_header(p, hlen)) {
  80eb92:	0f bf 45 e6          	movswl -0x1a(%ebp),%eax
  80eb96:	89 44 24 04          	mov    %eax,0x4(%esp)
  80eb9a:	89 1c 24             	mov    %ebx,(%esp)
  80eb9d:	e8 6e 61 ff ff       	call   804d10 <pbuf_header>
  80eba2:	84 c0                	test   %al,%al
  80eba4:	74 1c                	je     80ebc2 <icmp_input+0x112>
        LWIP_ASSERT("icmp_input: moving p->payload to ip header failed\n", 0);
  80eba6:	c7 44 24 08 70 40 81 	movl   $0x814070,0x8(%esp)
  80ebad:	00 
  80ebae:	c7 44 24 04 7b 00 00 	movl   $0x7b,0x4(%esp)
  80ebb5:	00 
  80ebb6:	c7 04 24 64 41 81 00 	movl   $0x814164,(%esp)
  80ebbd:	e8 b8 04 00 00       	call   80f07a <_panic>
        goto memerr;
      }
      /* allocate new packet buffer with space for link headers */
      r = pbuf_alloc(PBUF_LINK, p->tot_len, PBUF_RAM);
  80ebc2:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  80ebc6:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80ebcd:	00 
  80ebce:	89 44 24 04          	mov    %eax,0x4(%esp)
  80ebd2:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  80ebd9:	e8 f7 62 ff ff       	call   804ed5 <pbuf_alloc>
  80ebde:	89 45 e0             	mov    %eax,-0x20(%ebp)
      if (r == NULL) {
  80ebe1:	85 c0                	test   %eax,%eax
  80ebe3:	0f 84 fc 01 00 00    	je     80ede5 <icmp_input+0x335>
        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: allocating new pbuf failed\n"));
        goto memerr;
      }
      LWIP_ASSERT("check that first pbuf can hold struct the ICMP header",
  80ebe9:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
  80ebed:	0f bf 45 e6          	movswl -0x1a(%ebp),%eax
  80ebf1:	83 c0 08             	add    $0x8,%eax
  80ebf4:	39 c2                	cmp    %eax,%edx
  80ebf6:	73 1c                	jae    80ec14 <icmp_input+0x164>
  80ebf8:	c7 44 24 08 a4 40 81 	movl   $0x8140a4,0x8(%esp)
  80ebff:	00 
  80ec00:	c7 44 24 04 85 00 00 	movl   $0x85,0x4(%esp)
  80ec07:	00 
  80ec08:	c7 04 24 64 41 81 00 	movl   $0x814164,(%esp)
  80ec0f:	e8 66 04 00 00       	call   80f07a <_panic>
                  (r->len >= hlen + sizeof(struct icmp_echo_hdr)));
      /* copy the whole packet including ip header */
      if (pbuf_copy(r, p) != ERR_OK) {
  80ec14:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80ec18:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80ec1b:	89 04 24             	mov    %eax,(%esp)
  80ec1e:	e8 e1 67 ff ff       	call   805404 <pbuf_copy>
  80ec23:	84 c0                	test   %al,%al
  80ec25:	74 1c                	je     80ec43 <icmp_input+0x193>
        LWIP_ASSERT("icmp_input: copying to new pbuf failed\n", 0);
  80ec27:	c7 44 24 08 dc 40 81 	movl   $0x8140dc,0x8(%esp)
  80ec2e:	00 
  80ec2f:	c7 44 24 04 88 00 00 	movl   $0x88,0x4(%esp)
  80ec36:	00 
  80ec37:	c7 04 24 64 41 81 00 	movl   $0x814164,(%esp)
  80ec3e:	e8 37 04 00 00       	call   80f07a <_panic>
        goto memerr;
      }
      iphdr = r->payload;
  80ec43:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80ec46:	8b 70 04             	mov    0x4(%eax),%esi
      /* switch r->payload back to icmp header */
      if (pbuf_header(r, -hlen)) {
  80ec49:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80ec4d:	89 04 24             	mov    %eax,(%esp)
  80ec50:	e8 bb 60 ff ff       	call   804d10 <pbuf_header>
  80ec55:	84 c0                	test   %al,%al
  80ec57:	74 1c                	je     80ec75 <icmp_input+0x1c5>
        LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
  80ec59:	c7 44 24 08 04 41 81 	movl   $0x814104,0x8(%esp)
  80ec60:	00 
  80ec61:	c7 44 24 04 8e 00 00 	movl   $0x8e,0x4(%esp)
  80ec68:	00 
  80ec69:	c7 04 24 64 41 81 00 	movl   $0x814164,(%esp)
  80ec70:	e8 05 04 00 00       	call   80f07a <_panic>
        goto memerr;
      }
      /* free the original p */
      pbuf_free(p);
  80ec75:	89 1c 24             	mov    %ebx,(%esp)
  80ec78:	e8 77 61 ff ff       	call   804df4 <pbuf_free>
      /* we now have an identical copy of p that has room for link headers */
      p = r;
  80ec7d:	8b 5d e0             	mov    -0x20(%ebp),%ebx
  80ec80:	eb 30                	jmp    80ecb2 <icmp_input+0x202>
    } else {
      /* restore p->payload to point to icmp header */
      if (pbuf_header(p, -(s16_t)(PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
  80ec82:	c7 44 24 04 de ff ff 	movl   $0xffffffde,0x4(%esp)
  80ec89:	ff 
  80ec8a:	89 1c 24             	mov    %ebx,(%esp)
  80ec8d:	e8 7e 60 ff ff       	call   804d10 <pbuf_header>
  80ec92:	84 c0                	test   %al,%al
  80ec94:	74 1c                	je     80ecb2 <icmp_input+0x202>
        LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
  80ec96:	c7 44 24 08 04 41 81 	movl   $0x814104,0x8(%esp)
  80ec9d:	00 
  80ec9e:	c7 44 24 04 98 00 00 	movl   $0x98,0x4(%esp)
  80eca5:	00 
  80eca6:	c7 04 24 64 41 81 00 	movl   $0x814164,(%esp)
  80ecad:	e8 c8 03 00 00       	call   80f07a <_panic>
      }
    }
    /* At this point, all checks are OK. */
    /* We generate an answer by switching the dest and src ip addresses,
     * setting the icmp type to ECHO_RESPONSE and updating the checksum. */
    iecho = p->payload;
  80ecb2:	8b 7b 04             	mov    0x4(%ebx),%edi
    tmpaddr.addr = iphdr->src.addr;
  80ecb5:	8b 46 0c             	mov    0xc(%esi),%eax
    iphdr->src.addr = iphdr->dest.addr;
  80ecb8:	8b 56 10             	mov    0x10(%esi),%edx
  80ecbb:	89 56 0c             	mov    %edx,0xc(%esi)
    iphdr->dest.addr = tmpaddr.addr;
  80ecbe:	89 46 10             	mov    %eax,0x10(%esi)
    ICMPH_TYPE_SET(iecho, ICMP_ER);
  80ecc1:	0f b7 07             	movzwl (%edi),%eax
  80ecc4:	89 04 24             	mov    %eax,(%esp)
  80ecc7:	e8 b7 90 ff ff       	call   807d83 <ntohs>
  80eccc:	0f b6 c0             	movzbl %al,%eax
  80eccf:	89 04 24             	mov    %eax,(%esp)
  80ecd2:	e8 9f 90 ff ff       	call   807d76 <htons>
  80ecd7:	66 89 07             	mov    %ax,(%edi)
    /* adjust the checksum */
    if (iecho->chksum >= htons(0xffff - (ICMP_ECHO << 8))) {
  80ecda:	0f b7 47 02          	movzwl 0x2(%edi),%eax
  80ecde:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
  80ece2:	c7 04 24 ff f7 00 00 	movl   $0xf7ff,(%esp)
  80ece9:	e8 88 90 ff ff       	call   807d76 <htons>
  80ecee:	66 39 45 e0          	cmp    %ax,-0x20(%ebp)
  80ecf2:	72 22                	jb     80ed16 <icmp_input+0x266>
      iecho->chksum += htons(ICMP_ECHO << 8) + 1;
  80ecf4:	0f b7 47 02          	movzwl 0x2(%edi),%eax
  80ecf8:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
  80ecfc:	c7 04 24 00 08 00 00 	movl   $0x800,(%esp)
  80ed03:	e8 6e 90 ff ff       	call   807d76 <htons>
  80ed08:	0f b7 4d e0          	movzwl -0x20(%ebp),%ecx
  80ed0c:	8d 44 01 01          	lea    0x1(%ecx,%eax,1),%eax
  80ed10:	66 89 47 02          	mov    %ax,0x2(%edi)
  80ed14:	eb 1c                	jmp    80ed32 <icmp_input+0x282>
    } else {
      iecho->chksum += htons(ICMP_ECHO << 8);
  80ed16:	0f b7 47 02          	movzwl 0x2(%edi),%eax
  80ed1a:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
  80ed1e:	c7 04 24 00 08 00 00 	movl   $0x800,(%esp)
  80ed25:	e8 4c 90 ff ff       	call   807d76 <htons>
  80ed2a:	66 03 45 e0          	add    -0x20(%ebp),%ax
  80ed2e:	66 89 47 02          	mov    %ax,0x2(%edi)
    }

    /* Set the correct TTL and recalculate the header checksum. */
    IPH_TTL_SET(iphdr, ICMP_TTL);
  80ed32:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  80ed36:	89 04 24             	mov    %eax,(%esp)
  80ed39:	e8 45 90 ff ff       	call   807d83 <ntohs>
  80ed3e:	66 0d 00 ff          	or     $0xff00,%ax
  80ed42:	0f b7 c0             	movzwl %ax,%eax
  80ed45:	89 04 24             	mov    %eax,(%esp)
  80ed48:	e8 29 90 ff ff       	call   807d76 <htons>
  80ed4d:	66 89 46 08          	mov    %ax,0x8(%esi)
    IPH_CHKSUM_SET(iphdr, 0);
  80ed51:	66 c7 46 0a 00 00    	movw   $0x0,0xa(%esi)
#if CHECKSUM_GEN_IP
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
  80ed57:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  80ed5e:	00 
  80ed5f:	89 34 24             	mov    %esi,(%esp)
  80ed62:	e8 ba 8e ff ff       	call   807c21 <inet_chksum>
  80ed67:	66 89 46 0a          	mov    %ax,0xa(%esi)
    /* increase number of messages attempted to send */
    snmp_inc_icmpoutmsgs();
    /* increase number of echo replies attempted to send */
    snmp_inc_icmpoutechoreps();

    if(pbuf_header(p, hlen)) {
  80ed6b:	0f bf 45 e6          	movswl -0x1a(%ebp),%eax
  80ed6f:	89 44 24 04          	mov    %eax,0x4(%esp)
  80ed73:	89 1c 24             	mov    %ebx,(%esp)
  80ed76:	e8 95 5f ff ff       	call   804d10 <pbuf_header>
  80ed7b:	84 c0                	test   %al,%al
  80ed7d:	74 1c                	je     80ed9b <icmp_input+0x2eb>
      LWIP_ASSERT("Can't move over header in packet", 0);
  80ed7f:	c7 44 24 08 d0 31 81 	movl   $0x8131d0,0x8(%esp)
  80ed86:	00 
  80ed87:	c7 44 24 04 b9 00 00 	movl   $0xb9,0x4(%esp)
  80ed8e:	00 
  80ed8f:	c7 04 24 64 41 81 00 	movl   $0x814164,(%esp)
  80ed96:	e8 df 02 00 00       	call   80f07a <_panic>
    } else {
      err_t ret;
      ret = ip_output_if(p, &(iphdr->src), IP_HDRINCL,
  80ed9b:	8b 45 0c             	mov    0xc(%ebp),%eax
  80ed9e:	89 44 24 18          	mov    %eax,0x18(%esp)
  80eda2:	c7 44 24 14 01 00 00 	movl   $0x1,0x14(%esp)
  80eda9:	00 
  80edaa:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  80edb1:	00 
  80edb2:	c7 44 24 0c ff 00 00 	movl   $0xff,0xc(%esp)
  80edb9:	00 
  80edba:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80edc1:	00 
  80edc2:	83 c6 0c             	add    $0xc,%esi
  80edc5:	89 74 24 04          	mov    %esi,0x4(%esp)
  80edc9:	89 1c 24             	mov    %ebx,(%esp)
  80edcc:	e8 4d 80 ff ff       	call   806e1e <ip_output_if>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ICMP type %"S16_F" code %"S16_F" not supported.\n", 
                (s16_t)type, (s16_t)code));
    ICMP_STATS_INC(icmp.proterr);
    ICMP_STATS_INC(icmp.drop);
  }
  pbuf_free(p);
  80edd1:	89 1c 24             	mov    %ebx,(%esp)
  80edd4:	e8 1b 60 ff ff       	call   804df4 <pbuf_free>
  return;
  80edd9:	eb 12                	jmp    80eded <icmp_input+0x33d>
lenerr:
  pbuf_free(p);
  80eddb:	89 1c 24             	mov    %ebx,(%esp)
  80edde:	e8 11 60 ff ff       	call   804df4 <pbuf_free>
  ICMP_STATS_INC(icmp.lenerr);
  snmp_inc_icmpinerrors();
  return;
  80ede3:	eb 08                	jmp    80eded <icmp_input+0x33d>
memerr:
  pbuf_free(p);
  80ede5:	89 1c 24             	mov    %ebx,(%esp)
  80ede8:	e8 07 60 ff ff       	call   804df4 <pbuf_free>
  ICMP_STATS_INC(icmp.err);
  snmp_inc_icmpinerrors();
  return;
}
  80eded:	83 c4 3c             	add    $0x3c,%esp
  80edf0:	5b                   	pop    %ebx
  80edf1:	5e                   	pop    %esi
  80edf2:	5f                   	pop    %edi
  80edf3:	5d                   	pop    %ebp
  80edf4:	c3                   	ret    

0080edf5 <icmp_dest_unreach>:
 *          p->payload pointing to the IP header
 * @param t type of the 'unreachable' packet
 */
void
icmp_dest_unreach(struct pbuf *p, enum icmp_dur_type t)
{
  80edf5:	55                   	push   %ebp
  80edf6:	89 e5                	mov    %esp,%ebp
  80edf8:	57                   	push   %edi
  80edf9:	56                   	push   %esi
  80edfa:	53                   	push   %ebx
  80edfb:	83 ec 2c             	sub    $0x2c,%esp
  80edfe:	8b 7d 08             	mov    0x8(%ebp),%edi
  struct pbuf *q;
  struct ip_hdr *iphdr;
  struct icmp_dur_hdr *idur;

  /* ICMP header + IP header + 8 bytes of data */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
  80ee01:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80ee08:	00 
  80ee09:	c7 44 24 04 24 00 00 	movl   $0x24,0x4(%esp)
  80ee10:	00 
  80ee11:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  80ee18:	e8 b8 60 ff ff       	call   804ed5 <pbuf_alloc>
  80ee1d:	89 c3                	mov    %eax,%ebx
                 PBUF_RAM);
  if (q == NULL) {
  80ee1f:	85 c0                	test   %eax,%eax
  80ee21:	0f 84 d8 00 00 00    	je     80eeff <icmp_dest_unreach+0x10a>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_dest_unreach: failed to allocate pbuf for ICMP packet.\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold icmp message",
  80ee27:	66 83 78 0a 23       	cmpw   $0x23,0xa(%eax)
  80ee2c:	77 1c                	ja     80ee4a <icmp_dest_unreach+0x55>
  80ee2e:	c7 44 24 08 38 41 81 	movl   $0x814138,0x8(%esp)
  80ee35:	00 
  80ee36:	c7 44 24 04 ef 00 00 	movl   $0xef,0x4(%esp)
  80ee3d:	00 
  80ee3e:	c7 04 24 64 41 81 00 	movl   $0x814164,(%esp)
  80ee45:	e8 30 02 00 00       	call   80f07a <_panic>
             (q->len >= (sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE)));

  iphdr = p->payload;
  80ee4a:	8b 47 04             	mov    0x4(%edi),%eax
  80ee4d:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  idur = q->payload;
  80ee50:	8b 73 04             	mov    0x4(%ebx),%esi
  ICMPH_TYPE_SET(idur, ICMP_DUR);
  80ee53:	0f b7 06             	movzwl (%esi),%eax
  80ee56:	89 04 24             	mov    %eax,(%esp)
  80ee59:	e8 25 8f ff ff       	call   807d83 <ntohs>
  80ee5e:	0f b6 c0             	movzbl %al,%eax
  80ee61:	80 cc 03             	or     $0x3,%ah
  80ee64:	89 04 24             	mov    %eax,(%esp)
  80ee67:	e8 0a 8f ff ff       	call   807d76 <htons>
  80ee6c:	66 89 06             	mov    %ax,(%esi)
  ICMPH_CODE_SET(idur, t);
  80ee6f:	0f b7 c0             	movzwl %ax,%eax
  80ee72:	89 04 24             	mov    %eax,(%esp)
  80ee75:	e8 09 8f ff ff       	call   807d83 <ntohs>
  80ee7a:	b0 00                	mov    $0x0,%al
  80ee7c:	66 0b 45 0c          	or     0xc(%ebp),%ax
  80ee80:	0f b7 c0             	movzwl %ax,%eax
  80ee83:	89 04 24             	mov    %eax,(%esp)
  80ee86:	e8 eb 8e ff ff       	call   807d76 <htons>
  80ee8b:	66 89 06             	mov    %ax,(%esi)

  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_dur_hdr), p->payload,
  80ee8e:	c7 44 24 08 1c 00 00 	movl   $0x1c,0x8(%esp)
  80ee95:	00 
  80ee96:	8b 47 04             	mov    0x4(%edi),%eax
  80ee99:	89 44 24 04          	mov    %eax,0x4(%esp)
  80ee9d:	8b 53 04             	mov    0x4(%ebx),%edx
  80eea0:	8d 42 08             	lea    0x8(%edx),%eax
  80eea3:	89 04 24             	mov    %eax,(%esp)
  80eea6:	e8 f1 0a 00 00       	call   80f99c <memcpy>
          IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);

  /* calculate checksum */
  idur->chksum = 0;
  80eeab:	66 c7 46 02 00 00    	movw   $0x0,0x2(%esi)
  idur->chksum = inet_chksum(idur, q->len);
  80eeb1:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80eeb5:	89 44 24 04          	mov    %eax,0x4(%esp)
  80eeb9:	89 34 24             	mov    %esi,(%esp)
  80eebc:	e8 60 8d ff ff       	call   807c21 <inet_chksum>
  80eec1:	66 89 46 02          	mov    %ax,0x2(%esi)
  /* increase number of messages attempted to send */
  snmp_inc_icmpoutmsgs();
  /* increase number of destination unreachable messages attempted to send */
  snmp_inc_icmpoutdestunreachs();

  ip_output(q, NULL, &(iphdr->src), ICMP_TTL, 0, IP_PROTO_ICMP);
  80eec5:	c7 44 24 14 01 00 00 	movl   $0x1,0x14(%esp)
  80eecc:	00 
  80eecd:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  80eed4:	00 
  80eed5:	c7 44 24 0c ff 00 00 	movl   $0xff,0xc(%esp)
  80eedc:	00 
  80eedd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80eee0:	83 c0 0c             	add    $0xc,%eax
  80eee3:	89 44 24 08          	mov    %eax,0x8(%esp)
  80eee7:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80eeee:	00 
  80eeef:	89 1c 24             	mov    %ebx,(%esp)
  80eef2:	e8 b9 80 ff ff       	call   806fb0 <ip_output>
  pbuf_free(q);
  80eef7:	89 1c 24             	mov    %ebx,(%esp)
  80eefa:	e8 f5 5e ff ff       	call   804df4 <pbuf_free>
}
  80eeff:	83 c4 2c             	add    $0x2c,%esp
  80ef02:	5b                   	pop    %ebx
  80ef03:	5e                   	pop    %esi
  80ef04:	5f                   	pop    %edi
  80ef05:	5d                   	pop    %ebp
  80ef06:	c3                   	ret    

0080ef07 <icmp_time_exceeded>:
 *          p->payload pointing to the IP header
 * @param t type of the 'time exceeded' packet
 */
void
icmp_time_exceeded(struct pbuf *p, enum icmp_te_type t)
{
  80ef07:	55                   	push   %ebp
  80ef08:	89 e5                	mov    %esp,%ebp
  80ef0a:	57                   	push   %edi
  80ef0b:	56                   	push   %esi
  80ef0c:	53                   	push   %ebx
  80ef0d:	83 ec 2c             	sub    $0x2c,%esp
  80ef10:	8b 7d 08             	mov    0x8(%ebp),%edi
  struct pbuf *q;
  struct ip_hdr *iphdr;
  struct icmp_te_hdr *tehdr;

  /* ICMP header + IP header + 8 bytes of data */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
  80ef13:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80ef1a:	00 
  80ef1b:	c7 44 24 04 24 00 00 	movl   $0x24,0x4(%esp)
  80ef22:	00 
  80ef23:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  80ef2a:	e8 a6 5f ff ff       	call   804ed5 <pbuf_alloc>
  80ef2f:	89 c3                	mov    %eax,%ebx
                 PBUF_RAM);
  if (q == NULL) {
  80ef31:	85 c0                	test   %eax,%eax
  80ef33:	0f 84 d8 00 00 00    	je     80f011 <icmp_time_exceeded+0x10a>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_time_exceeded: failed to allocate pbuf for ICMP packet.\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold icmp message",
  80ef39:	66 83 78 0a 23       	cmpw   $0x23,0xa(%eax)
  80ef3e:	77 1c                	ja     80ef5c <icmp_time_exceeded+0x55>
  80ef40:	c7 44 24 08 38 41 81 	movl   $0x814138,0x8(%esp)
  80ef47:	00 
  80ef48:	c7 44 24 04 1e 01 00 	movl   $0x11e,0x4(%esp)
  80ef4f:	00 
  80ef50:	c7 04 24 64 41 81 00 	movl   $0x814164,(%esp)
  80ef57:	e8 1e 01 00 00       	call   80f07a <_panic>
             (q->len >= (sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE)));

  iphdr = p->payload;
  80ef5c:	8b 47 04             	mov    0x4(%edi),%eax
  80ef5f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  ip_addr_debug_print(ICMP_DEBUG, &(iphdr->src));
  LWIP_DEBUGF(ICMP_DEBUG, (" to "));
  ip_addr_debug_print(ICMP_DEBUG, &(iphdr->dest));
  LWIP_DEBUGF(ICMP_DEBUG, ("\n"));

  tehdr = q->payload;
  80ef62:	8b 73 04             	mov    0x4(%ebx),%esi
  ICMPH_TYPE_SET(tehdr, ICMP_TE);
  80ef65:	0f b7 06             	movzwl (%esi),%eax
  80ef68:	89 04 24             	mov    %eax,(%esp)
  80ef6b:	e8 13 8e ff ff       	call   807d83 <ntohs>
  80ef70:	0f b6 c0             	movzbl %al,%eax
  80ef73:	80 cc 0b             	or     $0xb,%ah
  80ef76:	89 04 24             	mov    %eax,(%esp)
  80ef79:	e8 f8 8d ff ff       	call   807d76 <htons>
  80ef7e:	66 89 06             	mov    %ax,(%esi)
  ICMPH_CODE_SET(tehdr, t);
  80ef81:	0f b7 c0             	movzwl %ax,%eax
  80ef84:	89 04 24             	mov    %eax,(%esp)
  80ef87:	e8 f7 8d ff ff       	call   807d83 <ntohs>
  80ef8c:	b0 00                	mov    $0x0,%al
  80ef8e:	66 0b 45 0c          	or     0xc(%ebp),%ax
  80ef92:	0f b7 c0             	movzwl %ax,%eax
  80ef95:	89 04 24             	mov    %eax,(%esp)
  80ef98:	e8 d9 8d ff ff       	call   807d76 <htons>
  80ef9d:	66 89 06             	mov    %ax,(%esi)

  /* copy fields from original packet */
  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_dur_hdr), (u8_t *)p->payload,
  80efa0:	c7 44 24 08 1c 00 00 	movl   $0x1c,0x8(%esp)
  80efa7:	00 
  80efa8:	8b 47 04             	mov    0x4(%edi),%eax
  80efab:	89 44 24 04          	mov    %eax,0x4(%esp)
  80efaf:	8b 53 04             	mov    0x4(%ebx),%edx
  80efb2:	8d 42 08             	lea    0x8(%edx),%eax
  80efb5:	89 04 24             	mov    %eax,(%esp)
  80efb8:	e8 df 09 00 00       	call   80f99c <memcpy>
          IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);

  /* calculate checksum */
  tehdr->chksum = 0;
  80efbd:	66 c7 46 02 00 00    	movw   $0x0,0x2(%esi)
  tehdr->chksum = inet_chksum(tehdr, q->len);
  80efc3:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80efc7:	89 44 24 04          	mov    %eax,0x4(%esp)
  80efcb:	89 34 24             	mov    %esi,(%esp)
  80efce:	e8 4e 8c ff ff       	call   807c21 <inet_chksum>
  80efd3:	66 89 46 02          	mov    %ax,0x2(%esi)
  ICMP_STATS_INC(icmp.xmit);
  /* increase number of messages attempted to send */
  snmp_inc_icmpoutmsgs();
  /* increase number of destination unreachable messages attempted to send */
  snmp_inc_icmpouttimeexcds();
  ip_output(q, NULL, &(iphdr->src), ICMP_TTL, 0, IP_PROTO_ICMP);
  80efd7:	c7 44 24 14 01 00 00 	movl   $0x1,0x14(%esp)
  80efde:	00 
  80efdf:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  80efe6:	00 
  80efe7:	c7 44 24 0c ff 00 00 	movl   $0xff,0xc(%esp)
  80efee:	00 
  80efef:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80eff2:	83 c0 0c             	add    $0xc,%eax
  80eff5:	89 44 24 08          	mov    %eax,0x8(%esp)
  80eff9:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80f000:	00 
  80f001:	89 1c 24             	mov    %ebx,(%esp)
  80f004:	e8 a7 7f ff ff       	call   806fb0 <ip_output>
  pbuf_free(q);
  80f009:	89 1c 24             	mov    %ebx,(%esp)
  80f00c:	e8 e3 5d ff ff       	call   804df4 <pbuf_free>
}
  80f011:	83 c4 2c             	add    $0x2c,%esp
  80f014:	5b                   	pop    %ebx
  80f015:	5e                   	pop    %esi
  80f016:	5f                   	pop    %edi
  80f017:	5d                   	pop    %ebp
  80f018:	c3                   	ret    

0080f019 <libmain>:
const volatile struct Env *thisenv;
const char *binaryname = "<unknown>";

void
libmain(int argc, char **argv)
{
  80f019:	55                   	push   %ebp
  80f01a:	89 e5                	mov    %esp,%ebp
  80f01c:	56                   	push   %esi
  80f01d:	53                   	push   %ebx
  80f01e:	83 ec 10             	sub    $0x10,%esp
  80f021:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80f024:	8b 75 0c             	mov    0xc(%ebp),%esi
	// set thisenv to point at our Env structure in envs[].
	// LAB 3: Your code here.
	//cprintf("adjfkadjfk %d\n", sys_getenvid());
	thisenv = &envs[ENVX(sys_getenvid())];
  80f027:	e8 49 0b 00 00       	call   80fb75 <sys_getenvid>
  80f02c:	25 ff 03 00 00       	and    $0x3ff,%eax
  80f031:	6b c0 7c             	imul   $0x7c,%eax,%eax
  80f034:	05 00 00 c0 ee       	add    $0xeec00000,%eax
  80f039:	a3 7c c2 b3 00       	mov    %eax,0xb3c27c

	// save the name of the program so that panic() can use it
	if (argc > 0)
  80f03e:	85 db                	test   %ebx,%ebx
  80f040:	7e 07                	jle    80f049 <libmain+0x30>
		binaryname = argv[0];
  80f042:	8b 06                	mov    (%esi),%eax
  80f044:	a3 e8 52 81 00       	mov    %eax,0x8152e8

	// call user main routine
	umain(argc, argv);
  80f049:	89 74 24 04          	mov    %esi,0x4(%esp)
  80f04d:	89 1c 24             	mov    %ebx,(%esp)
  80f050:	e8 fa 15 ff ff       	call   80064f <umain>

	// exit gracefully
	exit();
  80f055:	e8 07 00 00 00       	call   80f061 <exit>
}
  80f05a:	83 c4 10             	add    $0x10,%esp
  80f05d:	5b                   	pop    %ebx
  80f05e:	5e                   	pop    %esi
  80f05f:	5d                   	pop    %ebp
  80f060:	c3                   	ret    

0080f061 <exit>:

#include <inc/lib.h>

void
exit(void)
{
  80f061:	55                   	push   %ebp
  80f062:	89 e5                	mov    %esp,%ebp
  80f064:	83 ec 18             	sub    $0x18,%esp
	close_all();
  80f067:	e8 7e 14 00 00       	call   8104ea <close_all>
	sys_env_destroy(0);
  80f06c:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80f073:	e8 ab 0a 00 00       	call   80fb23 <sys_env_destroy>
}
  80f078:	c9                   	leave  
  80f079:	c3                   	ret    

0080f07a <_panic>:
 * It prints "panic: <message>", then causes a breakpoint exception,
 * which causes JOS to enter the JOS kernel monitor.
 */
void
_panic(const char *file, int line, const char *fmt, ...)
{
  80f07a:	55                   	push   %ebp
  80f07b:	89 e5                	mov    %esp,%ebp
  80f07d:	56                   	push   %esi
  80f07e:	53                   	push   %ebx
  80f07f:	83 ec 20             	sub    $0x20,%esp
	va_list ap;

	va_start(ap, fmt);
  80f082:	8d 5d 14             	lea    0x14(%ebp),%ebx

	// Print the panic message
	cprintf("[%08x] user panic in %s at %s:%d: ",
  80f085:	8b 35 e8 52 81 00    	mov    0x8152e8,%esi
  80f08b:	e8 e5 0a 00 00       	call   80fb75 <sys_getenvid>
  80f090:	8b 55 0c             	mov    0xc(%ebp),%edx
  80f093:	89 54 24 10          	mov    %edx,0x10(%esp)
  80f097:	8b 55 08             	mov    0x8(%ebp),%edx
  80f09a:	89 54 24 0c          	mov    %edx,0xc(%esp)
  80f09e:	89 74 24 08          	mov    %esi,0x8(%esp)
  80f0a2:	89 44 24 04          	mov    %eax,0x4(%esp)
  80f0a6:	c7 04 24 88 41 81 00 	movl   $0x814188,(%esp)
  80f0ad:	e8 c1 00 00 00       	call   80f173 <cprintf>
		sys_getenvid(), binaryname, file, line);
	vcprintf(fmt, ap);
  80f0b2:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80f0b6:	8b 45 10             	mov    0x10(%ebp),%eax
  80f0b9:	89 04 24             	mov    %eax,(%esp)
  80f0bc:	e8 51 00 00 00       	call   80f112 <vcprintf>
	cprintf("\n");
  80f0c1:	c7 04 24 48 1d 81 00 	movl   $0x811d48,(%esp)
  80f0c8:	e8 a6 00 00 00       	call   80f173 <cprintf>

	// Cause a breakpoint exception
	while (1)
		asm volatile("int3");
  80f0cd:	cc                   	int3   
  80f0ce:	eb fd                	jmp    80f0cd <_panic+0x53>

0080f0d0 <putch>:
};


static void
putch(int ch, struct printbuf *b)
{
  80f0d0:	55                   	push   %ebp
  80f0d1:	89 e5                	mov    %esp,%ebp
  80f0d3:	53                   	push   %ebx
  80f0d4:	83 ec 14             	sub    $0x14,%esp
  80f0d7:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	b->buf[b->idx++] = ch;
  80f0da:	8b 13                	mov    (%ebx),%edx
  80f0dc:	8d 42 01             	lea    0x1(%edx),%eax
  80f0df:	89 03                	mov    %eax,(%ebx)
  80f0e1:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80f0e4:	88 4c 13 08          	mov    %cl,0x8(%ebx,%edx,1)
	if (b->idx == 256-1) {
  80f0e8:	3d ff 00 00 00       	cmp    $0xff,%eax
  80f0ed:	75 19                	jne    80f108 <putch+0x38>
		sys_cputs(b->buf, b->idx);
  80f0ef:	c7 44 24 04 ff 00 00 	movl   $0xff,0x4(%esp)
  80f0f6:	00 
  80f0f7:	8d 43 08             	lea    0x8(%ebx),%eax
  80f0fa:	89 04 24             	mov    %eax,(%esp)
  80f0fd:	e8 e4 09 00 00       	call   80fae6 <sys_cputs>
		b->idx = 0;
  80f102:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
	}
	b->cnt++;
  80f108:	83 43 04 01          	addl   $0x1,0x4(%ebx)
}
  80f10c:	83 c4 14             	add    $0x14,%esp
  80f10f:	5b                   	pop    %ebx
  80f110:	5d                   	pop    %ebp
  80f111:	c3                   	ret    

0080f112 <vcprintf>:

int
vcprintf(const char *fmt, va_list ap)
{
  80f112:	55                   	push   %ebp
  80f113:	89 e5                	mov    %esp,%ebp
  80f115:	81 ec 28 01 00 00    	sub    $0x128,%esp
	struct printbuf b;

	b.idx = 0;
  80f11b:	c7 85 f0 fe ff ff 00 	movl   $0x0,-0x110(%ebp)
  80f122:	00 00 00 
	b.cnt = 0;
  80f125:	c7 85 f4 fe ff ff 00 	movl   $0x0,-0x10c(%ebp)
  80f12c:	00 00 00 
	vprintfmt((void*)putch, &b, fmt, ap);
  80f12f:	8b 45 0c             	mov    0xc(%ebp),%eax
  80f132:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80f136:	8b 45 08             	mov    0x8(%ebp),%eax
  80f139:	89 44 24 08          	mov    %eax,0x8(%esp)
  80f13d:	8d 85 f0 fe ff ff    	lea    -0x110(%ebp),%eax
  80f143:	89 44 24 04          	mov    %eax,0x4(%esp)
  80f147:	c7 04 24 d0 f0 80 00 	movl   $0x80f0d0,(%esp)
  80f14e:	e8 ab 01 00 00       	call   80f2fe <vprintfmt>
	sys_cputs(b.buf, b.idx);
  80f153:	8b 85 f0 fe ff ff    	mov    -0x110(%ebp),%eax
  80f159:	89 44 24 04          	mov    %eax,0x4(%esp)
  80f15d:	8d 85 f8 fe ff ff    	lea    -0x108(%ebp),%eax
  80f163:	89 04 24             	mov    %eax,(%esp)
  80f166:	e8 7b 09 00 00       	call   80fae6 <sys_cputs>

	return b.cnt;
}
  80f16b:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
  80f171:	c9                   	leave  
  80f172:	c3                   	ret    

0080f173 <cprintf>:

int
cprintf(const char *fmt, ...)
{
  80f173:	55                   	push   %ebp
  80f174:	89 e5                	mov    %esp,%ebp
  80f176:	83 ec 18             	sub    $0x18,%esp
	va_list ap;
	int cnt;

	va_start(ap, fmt);
  80f179:	8d 45 0c             	lea    0xc(%ebp),%eax
	cnt = vcprintf(fmt, ap);
  80f17c:	89 44 24 04          	mov    %eax,0x4(%esp)
  80f180:	8b 45 08             	mov    0x8(%ebp),%eax
  80f183:	89 04 24             	mov    %eax,(%esp)
  80f186:	e8 87 ff ff ff       	call   80f112 <vcprintf>
	va_end(ap);

	return cnt;
}
  80f18b:	c9                   	leave  
  80f18c:	c3                   	ret    
  80f18d:	66 90                	xchg   %ax,%ax
  80f18f:	90                   	nop

0080f190 <printnum>:
 * using specified putch function and associated pointer putdat.
 */
static void
printnum(void (*putch)(int, void*), void *putdat,
	 unsigned long long num, unsigned base, int width, int padc)
{
  80f190:	55                   	push   %ebp
  80f191:	89 e5                	mov    %esp,%ebp
  80f193:	57                   	push   %edi
  80f194:	56                   	push   %esi
  80f195:	53                   	push   %ebx
  80f196:	83 ec 3c             	sub    $0x3c,%esp
  80f199:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80f19c:	89 d7                	mov    %edx,%edi
  80f19e:	8b 45 08             	mov    0x8(%ebp),%eax
  80f1a1:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80f1a4:	8b 45 0c             	mov    0xc(%ebp),%eax
  80f1a7:	89 c3                	mov    %eax,%ebx
  80f1a9:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  80f1ac:	8b 45 10             	mov    0x10(%ebp),%eax
  80f1af:	8b 75 14             	mov    0x14(%ebp),%esi
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
  80f1b2:	b9 00 00 00 00       	mov    $0x0,%ecx
  80f1b7:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80f1ba:	89 4d dc             	mov    %ecx,-0x24(%ebp)
  80f1bd:	39 d9                	cmp    %ebx,%ecx
  80f1bf:	72 05                	jb     80f1c6 <printnum+0x36>
  80f1c1:	3b 45 e0             	cmp    -0x20(%ebp),%eax
  80f1c4:	77 69                	ja     80f22f <printnum+0x9f>
		printnum(putch, putdat, num / base, base, width - 1, padc);
  80f1c6:	8b 4d 18             	mov    0x18(%ebp),%ecx
  80f1c9:	89 4c 24 10          	mov    %ecx,0x10(%esp)
  80f1cd:	83 ee 01             	sub    $0x1,%esi
  80f1d0:	89 74 24 0c          	mov    %esi,0xc(%esp)
  80f1d4:	89 44 24 08          	mov    %eax,0x8(%esp)
  80f1d8:	8b 44 24 08          	mov    0x8(%esp),%eax
  80f1dc:	8b 54 24 0c          	mov    0xc(%esp),%edx
  80f1e0:	89 c3                	mov    %eax,%ebx
  80f1e2:	89 d6                	mov    %edx,%esi
  80f1e4:	8b 55 d8             	mov    -0x28(%ebp),%edx
  80f1e7:	8b 4d dc             	mov    -0x24(%ebp),%ecx
  80f1ea:	89 54 24 08          	mov    %edx,0x8(%esp)
  80f1ee:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
  80f1f2:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80f1f5:	89 04 24             	mov    %eax,(%esp)
  80f1f8:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  80f1fb:	89 44 24 04          	mov    %eax,0x4(%esp)
  80f1ff:	e8 1c 27 00 00       	call   811920 <__udivdi3>
  80f204:	89 d9                	mov    %ebx,%ecx
  80f206:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  80f20a:	89 74 24 0c          	mov    %esi,0xc(%esp)
  80f20e:	89 04 24             	mov    %eax,(%esp)
  80f211:	89 54 24 04          	mov    %edx,0x4(%esp)
  80f215:	89 fa                	mov    %edi,%edx
  80f217:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80f21a:	e8 71 ff ff ff       	call   80f190 <printnum>
  80f21f:	eb 1b                	jmp    80f23c <printnum+0xac>
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
			putch(padc, putdat);
  80f221:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80f225:	8b 45 18             	mov    0x18(%ebp),%eax
  80f228:	89 04 24             	mov    %eax,(%esp)
  80f22b:	ff d3                	call   *%ebx
  80f22d:	eb 03                	jmp    80f232 <printnum+0xa2>
  80f22f:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
		printnum(putch, putdat, num / base, base, width - 1, padc);
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
  80f232:	83 ee 01             	sub    $0x1,%esi
  80f235:	85 f6                	test   %esi,%esi
  80f237:	7f e8                	jg     80f221 <printnum+0x91>
  80f239:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
			putch(padc, putdat);
	}

	// then print this (the least significant) digit
	putch("0123456789abcdef"[num % base], putdat);
  80f23c:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80f240:	8b 7c 24 04          	mov    0x4(%esp),%edi
  80f244:	8b 45 d8             	mov    -0x28(%ebp),%eax
  80f247:	8b 55 dc             	mov    -0x24(%ebp),%edx
  80f24a:	89 44 24 08          	mov    %eax,0x8(%esp)
  80f24e:	89 54 24 0c          	mov    %edx,0xc(%esp)
  80f252:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80f255:	89 04 24             	mov    %eax,(%esp)
  80f258:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  80f25b:	89 44 24 04          	mov    %eax,0x4(%esp)
  80f25f:	e8 ec 27 00 00       	call   811a50 <__umoddi3>
  80f264:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80f268:	0f be 80 ab 41 81 00 	movsbl 0x8141ab(%eax),%eax
  80f26f:	89 04 24             	mov    %eax,(%esp)
  80f272:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80f275:	ff d0                	call   *%eax
}
  80f277:	83 c4 3c             	add    $0x3c,%esp
  80f27a:	5b                   	pop    %ebx
  80f27b:	5e                   	pop    %esi
  80f27c:	5f                   	pop    %edi
  80f27d:	5d                   	pop    %ebp
  80f27e:	c3                   	ret    

0080f27f <getuint>:

// Get an unsigned int of various possible sizes from a varargs list,
// depending on the lflag parameter.
static unsigned long long
getuint(va_list *ap, int lflag)
{
  80f27f:	55                   	push   %ebp
  80f280:	89 e5                	mov    %esp,%ebp
	if (lflag >= 2)
  80f282:	83 fa 01             	cmp    $0x1,%edx
  80f285:	7e 0e                	jle    80f295 <getuint+0x16>
		return va_arg(*ap, unsigned long long);
  80f287:	8b 10                	mov    (%eax),%edx
  80f289:	8d 4a 08             	lea    0x8(%edx),%ecx
  80f28c:	89 08                	mov    %ecx,(%eax)
  80f28e:	8b 02                	mov    (%edx),%eax
  80f290:	8b 52 04             	mov    0x4(%edx),%edx
  80f293:	eb 22                	jmp    80f2b7 <getuint+0x38>
	else if (lflag)
  80f295:	85 d2                	test   %edx,%edx
  80f297:	74 10                	je     80f2a9 <getuint+0x2a>
		return va_arg(*ap, unsigned long);
  80f299:	8b 10                	mov    (%eax),%edx
  80f29b:	8d 4a 04             	lea    0x4(%edx),%ecx
  80f29e:	89 08                	mov    %ecx,(%eax)
  80f2a0:	8b 02                	mov    (%edx),%eax
  80f2a2:	ba 00 00 00 00       	mov    $0x0,%edx
  80f2a7:	eb 0e                	jmp    80f2b7 <getuint+0x38>
	else
		return va_arg(*ap, unsigned int);
  80f2a9:	8b 10                	mov    (%eax),%edx
  80f2ab:	8d 4a 04             	lea    0x4(%edx),%ecx
  80f2ae:	89 08                	mov    %ecx,(%eax)
  80f2b0:	8b 02                	mov    (%edx),%eax
  80f2b2:	ba 00 00 00 00       	mov    $0x0,%edx
}
  80f2b7:	5d                   	pop    %ebp
  80f2b8:	c3                   	ret    

0080f2b9 <sprintputch>:
	int cnt;
};

static void
sprintputch(int ch, struct sprintbuf *b)
{
  80f2b9:	55                   	push   %ebp
  80f2ba:	89 e5                	mov    %esp,%ebp
  80f2bc:	8b 45 0c             	mov    0xc(%ebp),%eax
	b->cnt++;
  80f2bf:	83 40 08 01          	addl   $0x1,0x8(%eax)
	if (b->buf < b->ebuf)
  80f2c3:	8b 10                	mov    (%eax),%edx
  80f2c5:	3b 50 04             	cmp    0x4(%eax),%edx
  80f2c8:	73 0a                	jae    80f2d4 <sprintputch+0x1b>
		*b->buf++ = ch;
  80f2ca:	8d 4a 01             	lea    0x1(%edx),%ecx
  80f2cd:	89 08                	mov    %ecx,(%eax)
  80f2cf:	8b 45 08             	mov    0x8(%ebp),%eax
  80f2d2:	88 02                	mov    %al,(%edx)
}
  80f2d4:	5d                   	pop    %ebp
  80f2d5:	c3                   	ret    

0080f2d6 <printfmt>:
	}
}

void
printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...)
{
  80f2d6:	55                   	push   %ebp
  80f2d7:	89 e5                	mov    %esp,%ebp
  80f2d9:	83 ec 18             	sub    $0x18,%esp
	va_list ap;

	va_start(ap, fmt);
  80f2dc:	8d 45 14             	lea    0x14(%ebp),%eax
	vprintfmt(putch, putdat, fmt, ap);
  80f2df:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80f2e3:	8b 45 10             	mov    0x10(%ebp),%eax
  80f2e6:	89 44 24 08          	mov    %eax,0x8(%esp)
  80f2ea:	8b 45 0c             	mov    0xc(%ebp),%eax
  80f2ed:	89 44 24 04          	mov    %eax,0x4(%esp)
  80f2f1:	8b 45 08             	mov    0x8(%ebp),%eax
  80f2f4:	89 04 24             	mov    %eax,(%esp)
  80f2f7:	e8 02 00 00 00       	call   80f2fe <vprintfmt>
	va_end(ap);
}
  80f2fc:	c9                   	leave  
  80f2fd:	c3                   	ret    

0080f2fe <vprintfmt>:
// Main function to format and print a string.
void printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...);

void
vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap)
{
  80f2fe:	55                   	push   %ebp
  80f2ff:	89 e5                	mov    %esp,%ebp
  80f301:	57                   	push   %edi
  80f302:	56                   	push   %esi
  80f303:	53                   	push   %ebx
  80f304:	83 ec 3c             	sub    $0x3c,%esp
  80f307:	8b 7d 0c             	mov    0xc(%ebp),%edi
  80f30a:	8b 5d 10             	mov    0x10(%ebp),%ebx
  80f30d:	eb 14                	jmp    80f323 <vprintfmt+0x25>
	int base, lflag, width, precision, altflag;
	char padc;

	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
			if (ch == '\0')
  80f30f:	85 c0                	test   %eax,%eax
  80f311:	0f 84 b3 03 00 00    	je     80f6ca <vprintfmt+0x3cc>
				return;
			putch(ch, putdat);
  80f317:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80f31b:	89 04 24             	mov    %eax,(%esp)
  80f31e:	ff 55 08             	call   *0x8(%ebp)
	unsigned long long num;
	int base, lflag, width, precision, altflag;
	char padc;

	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
  80f321:	89 f3                	mov    %esi,%ebx
  80f323:	8d 73 01             	lea    0x1(%ebx),%esi
  80f326:	0f b6 03             	movzbl (%ebx),%eax
  80f329:	83 f8 25             	cmp    $0x25,%eax
  80f32c:	75 e1                	jne    80f30f <vprintfmt+0x11>
  80f32e:	c6 45 d8 20          	movb   $0x20,-0x28(%ebp)
  80f332:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  80f339:	c7 45 d4 ff ff ff ff 	movl   $0xffffffff,-0x2c(%ebp)
  80f340:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,-0x24(%ebp)
  80f347:	ba 00 00 00 00       	mov    $0x0,%edx
  80f34c:	eb 1d                	jmp    80f36b <vprintfmt+0x6d>
		width = -1;
		precision = -1;
		lflag = 0;
		altflag = 0;
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  80f34e:	89 de                	mov    %ebx,%esi

		// flag to pad on the right
		case '-':
			padc = '-';
  80f350:	c6 45 d8 2d          	movb   $0x2d,-0x28(%ebp)
  80f354:	eb 15                	jmp    80f36b <vprintfmt+0x6d>
		width = -1;
		precision = -1;
		lflag = 0;
		altflag = 0;
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  80f356:	89 de                	mov    %ebx,%esi
			padc = '-';
			goto reswitch;

		// flag to pad with 0's instead of spaces
		case '0':
			padc = '0';
  80f358:	c6 45 d8 30          	movb   $0x30,-0x28(%ebp)
  80f35c:	eb 0d                	jmp    80f36b <vprintfmt+0x6d>
			altflag = 1;
			goto reswitch;

		process_precision:
			if (width < 0)
				width = precision, precision = -1;
  80f35e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  80f361:	89 45 dc             	mov    %eax,-0x24(%ebp)
  80f364:	c7 45 d4 ff ff ff ff 	movl   $0xffffffff,-0x2c(%ebp)
		width = -1;
		precision = -1;
		lflag = 0;
		altflag = 0;
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  80f36b:	8d 5e 01             	lea    0x1(%esi),%ebx
  80f36e:	0f b6 0e             	movzbl (%esi),%ecx
  80f371:	0f b6 c1             	movzbl %cl,%eax
  80f374:	83 e9 23             	sub    $0x23,%ecx
  80f377:	80 f9 55             	cmp    $0x55,%cl
  80f37a:	0f 87 2a 03 00 00    	ja     80f6aa <vprintfmt+0x3ac>
  80f380:	0f b6 c9             	movzbl %cl,%ecx
  80f383:	ff 24 8d e0 42 81 00 	jmp    *0x8142e0(,%ecx,4)
  80f38a:	89 de                	mov    %ebx,%esi
  80f38c:	b9 00 00 00 00       	mov    $0x0,%ecx
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
				precision = precision * 10 + ch - '0';
  80f391:	8d 0c 89             	lea    (%ecx,%ecx,4),%ecx
  80f394:	8d 4c 48 d0          	lea    -0x30(%eax,%ecx,2),%ecx
				ch = *fmt;
  80f398:	0f be 06             	movsbl (%esi),%eax
				if (ch < '0' || ch > '9')
  80f39b:	8d 58 d0             	lea    -0x30(%eax),%ebx
  80f39e:	83 fb 09             	cmp    $0x9,%ebx
  80f3a1:	77 36                	ja     80f3d9 <vprintfmt+0xdb>
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
  80f3a3:	83 c6 01             	add    $0x1,%esi
				precision = precision * 10 + ch - '0';
				ch = *fmt;
				if (ch < '0' || ch > '9')
					break;
			}
  80f3a6:	eb e9                	jmp    80f391 <vprintfmt+0x93>
			goto process_precision;

		case '*':
			precision = va_arg(ap, int);
  80f3a8:	8b 45 14             	mov    0x14(%ebp),%eax
  80f3ab:	8d 48 04             	lea    0x4(%eax),%ecx
  80f3ae:	89 4d 14             	mov    %ecx,0x14(%ebp)
  80f3b1:	8b 00                	mov    (%eax),%eax
  80f3b3:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		width = -1;
		precision = -1;
		lflag = 0;
		altflag = 0;
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  80f3b6:	89 de                	mov    %ebx,%esi
			}
			goto process_precision;

		case '*':
			precision = va_arg(ap, int);
			goto process_precision;
  80f3b8:	eb 22                	jmp    80f3dc <vprintfmt+0xde>
  80f3ba:	8b 4d dc             	mov    -0x24(%ebp),%ecx
  80f3bd:	85 c9                	test   %ecx,%ecx
  80f3bf:	b8 00 00 00 00       	mov    $0x0,%eax
  80f3c4:	0f 49 c1             	cmovns %ecx,%eax
  80f3c7:	89 45 dc             	mov    %eax,-0x24(%ebp)
		width = -1;
		precision = -1;
		lflag = 0;
		altflag = 0;
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  80f3ca:	89 de                	mov    %ebx,%esi
  80f3cc:	eb 9d                	jmp    80f36b <vprintfmt+0x6d>
  80f3ce:	89 de                	mov    %ebx,%esi
			if (width < 0)
				width = 0;
			goto reswitch;

		case '#':
			altflag = 1;
  80f3d0:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
			goto reswitch;
  80f3d7:	eb 92                	jmp    80f36b <vprintfmt+0x6d>
  80f3d9:	89 4d d4             	mov    %ecx,-0x2c(%ebp)

		process_precision:
			if (width < 0)
  80f3dc:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
  80f3e0:	79 89                	jns    80f36b <vprintfmt+0x6d>
  80f3e2:	e9 77 ff ff ff       	jmp    80f35e <vprintfmt+0x60>
				width = precision, precision = -1;
			goto reswitch;

		// long flag (doubled for long long)
		case 'l':
			lflag++;
  80f3e7:	83 c2 01             	add    $0x1,%edx
		width = -1;
		precision = -1;
		lflag = 0;
		altflag = 0;
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  80f3ea:	89 de                	mov    %ebx,%esi
			goto reswitch;

		// long flag (doubled for long long)
		case 'l':
			lflag++;
			goto reswitch;
  80f3ec:	e9 7a ff ff ff       	jmp    80f36b <vprintfmt+0x6d>

		// character
		case 'c':
			putch(va_arg(ap, int), putdat);
  80f3f1:	8b 45 14             	mov    0x14(%ebp),%eax
  80f3f4:	8d 50 04             	lea    0x4(%eax),%edx
  80f3f7:	89 55 14             	mov    %edx,0x14(%ebp)
  80f3fa:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80f3fe:	8b 00                	mov    (%eax),%eax
  80f400:	89 04 24             	mov    %eax,(%esp)
  80f403:	ff 55 08             	call   *0x8(%ebp)
			break;
  80f406:	e9 18 ff ff ff       	jmp    80f323 <vprintfmt+0x25>

		// error message
		case 'e':
			err = va_arg(ap, int);
  80f40b:	8b 45 14             	mov    0x14(%ebp),%eax
  80f40e:	8d 50 04             	lea    0x4(%eax),%edx
  80f411:	89 55 14             	mov    %edx,0x14(%ebp)
  80f414:	8b 00                	mov    (%eax),%eax
  80f416:	99                   	cltd   
  80f417:	31 d0                	xor    %edx,%eax
  80f419:	29 d0                	sub    %edx,%eax
			if (err < 0)
				err = -err;
			if (err >= MAXERROR || (p = error_string[err]) == NULL)
  80f41b:	83 f8 0f             	cmp    $0xf,%eax
  80f41e:	7f 0b                	jg     80f42b <vprintfmt+0x12d>
  80f420:	8b 14 85 40 44 81 00 	mov    0x814440(,%eax,4),%edx
  80f427:	85 d2                	test   %edx,%edx
  80f429:	75 20                	jne    80f44b <vprintfmt+0x14d>
				printfmt(putch, putdat, "error %d", err);
  80f42b:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80f42f:	c7 44 24 08 c3 41 81 	movl   $0x8141c3,0x8(%esp)
  80f436:	00 
  80f437:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80f43b:	8b 45 08             	mov    0x8(%ebp),%eax
  80f43e:	89 04 24             	mov    %eax,(%esp)
  80f441:	e8 90 fe ff ff       	call   80f2d6 <printfmt>
  80f446:	e9 d8 fe ff ff       	jmp    80f323 <vprintfmt+0x25>
			else
				printfmt(putch, putdat, "%s", p);
  80f44b:	89 54 24 0c          	mov    %edx,0xc(%esp)
  80f44f:	c7 44 24 08 91 33 81 	movl   $0x813391,0x8(%esp)
  80f456:	00 
  80f457:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80f45b:	8b 45 08             	mov    0x8(%ebp),%eax
  80f45e:	89 04 24             	mov    %eax,(%esp)
  80f461:	e8 70 fe ff ff       	call   80f2d6 <printfmt>
  80f466:	e9 b8 fe ff ff       	jmp    80f323 <vprintfmt+0x25>
		width = -1;
		precision = -1;
		lflag = 0;
		altflag = 0;
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  80f46b:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
  80f46e:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80f471:	89 45 d0             	mov    %eax,-0x30(%ebp)
				printfmt(putch, putdat, "%s", p);
			break;

		// string
		case 's':
			if ((p = va_arg(ap, char *)) == NULL)
  80f474:	8b 45 14             	mov    0x14(%ebp),%eax
  80f477:	8d 50 04             	lea    0x4(%eax),%edx
  80f47a:	89 55 14             	mov    %edx,0x14(%ebp)
  80f47d:	8b 30                	mov    (%eax),%esi
				p = "(null)";
  80f47f:	85 f6                	test   %esi,%esi
  80f481:	b8 bc 41 81 00       	mov    $0x8141bc,%eax
  80f486:	0f 44 f0             	cmove  %eax,%esi
			if (width > 0 && padc != '-')
  80f489:	80 7d d8 2d          	cmpb   $0x2d,-0x28(%ebp)
  80f48d:	0f 84 97 00 00 00    	je     80f52a <vprintfmt+0x22c>
  80f493:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
  80f497:	0f 8e 9b 00 00 00    	jle    80f538 <vprintfmt+0x23a>
				for (width -= strnlen(p, precision); width > 0; width--)
  80f49d:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  80f4a1:	89 34 24             	mov    %esi,(%esp)
  80f4a4:	e8 cf 02 00 00       	call   80f778 <strnlen>
  80f4a9:	8b 55 d0             	mov    -0x30(%ebp),%edx
  80f4ac:	29 c2                	sub    %eax,%edx
  80f4ae:	89 55 d0             	mov    %edx,-0x30(%ebp)
					putch(padc, putdat);
  80f4b1:	0f be 45 d8          	movsbl -0x28(%ebp),%eax
  80f4b5:	89 45 dc             	mov    %eax,-0x24(%ebp)
  80f4b8:	89 75 d8             	mov    %esi,-0x28(%ebp)
  80f4bb:	8b 75 08             	mov    0x8(%ebp),%esi
  80f4be:	89 5d 10             	mov    %ebx,0x10(%ebp)
  80f4c1:	89 d3                	mov    %edx,%ebx
		// string
		case 's':
			if ((p = va_arg(ap, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
  80f4c3:	eb 0f                	jmp    80f4d4 <vprintfmt+0x1d6>
					putch(padc, putdat);
  80f4c5:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80f4c9:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80f4cc:	89 04 24             	mov    %eax,(%esp)
  80f4cf:	ff d6                	call   *%esi
		// string
		case 's':
			if ((p = va_arg(ap, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
  80f4d1:	83 eb 01             	sub    $0x1,%ebx
  80f4d4:	85 db                	test   %ebx,%ebx
  80f4d6:	7f ed                	jg     80f4c5 <vprintfmt+0x1c7>
  80f4d8:	8b 75 d8             	mov    -0x28(%ebp),%esi
  80f4db:	8b 55 d0             	mov    -0x30(%ebp),%edx
  80f4de:	85 d2                	test   %edx,%edx
  80f4e0:	b8 00 00 00 00       	mov    $0x0,%eax
  80f4e5:	0f 49 c2             	cmovns %edx,%eax
  80f4e8:	29 c2                	sub    %eax,%edx
  80f4ea:	89 7d 0c             	mov    %edi,0xc(%ebp)
  80f4ed:	89 d7                	mov    %edx,%edi
  80f4ef:	8b 5d d4             	mov    -0x2c(%ebp),%ebx
  80f4f2:	eb 50                	jmp    80f544 <vprintfmt+0x246>
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
				if (altflag && (ch < ' ' || ch > '~'))
  80f4f4:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
  80f4f8:	74 1e                	je     80f518 <vprintfmt+0x21a>
  80f4fa:	0f be d2             	movsbl %dl,%edx
  80f4fd:	83 ea 20             	sub    $0x20,%edx
  80f500:	83 fa 5e             	cmp    $0x5e,%edx
  80f503:	76 13                	jbe    80f518 <vprintfmt+0x21a>
					putch('?', putdat);
  80f505:	8b 45 0c             	mov    0xc(%ebp),%eax
  80f508:	89 44 24 04          	mov    %eax,0x4(%esp)
  80f50c:	c7 04 24 3f 00 00 00 	movl   $0x3f,(%esp)
  80f513:	ff 55 08             	call   *0x8(%ebp)
  80f516:	eb 0d                	jmp    80f525 <vprintfmt+0x227>
				else
					putch(ch, putdat);
  80f518:	8b 55 0c             	mov    0xc(%ebp),%edx
  80f51b:	89 54 24 04          	mov    %edx,0x4(%esp)
  80f51f:	89 04 24             	mov    %eax,(%esp)
  80f522:	ff 55 08             	call   *0x8(%ebp)
			if ((p = va_arg(ap, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
  80f525:	83 ef 01             	sub    $0x1,%edi
  80f528:	eb 1a                	jmp    80f544 <vprintfmt+0x246>
  80f52a:	89 7d 0c             	mov    %edi,0xc(%ebp)
  80f52d:	8b 7d dc             	mov    -0x24(%ebp),%edi
  80f530:	89 5d 10             	mov    %ebx,0x10(%ebp)
  80f533:	8b 5d d4             	mov    -0x2c(%ebp),%ebx
  80f536:	eb 0c                	jmp    80f544 <vprintfmt+0x246>
  80f538:	89 7d 0c             	mov    %edi,0xc(%ebp)
  80f53b:	8b 7d dc             	mov    -0x24(%ebp),%edi
  80f53e:	89 5d 10             	mov    %ebx,0x10(%ebp)
  80f541:	8b 5d d4             	mov    -0x2c(%ebp),%ebx
  80f544:	83 c6 01             	add    $0x1,%esi
  80f547:	0f b6 56 ff          	movzbl -0x1(%esi),%edx
  80f54b:	0f be c2             	movsbl %dl,%eax
  80f54e:	85 c0                	test   %eax,%eax
  80f550:	74 27                	je     80f579 <vprintfmt+0x27b>
  80f552:	85 db                	test   %ebx,%ebx
  80f554:	78 9e                	js     80f4f4 <vprintfmt+0x1f6>
  80f556:	83 eb 01             	sub    $0x1,%ebx
  80f559:	79 99                	jns    80f4f4 <vprintfmt+0x1f6>
  80f55b:	89 f8                	mov    %edi,%eax
  80f55d:	8b 7d 0c             	mov    0xc(%ebp),%edi
  80f560:	8b 75 08             	mov    0x8(%ebp),%esi
  80f563:	89 c3                	mov    %eax,%ebx
  80f565:	eb 1a                	jmp    80f581 <vprintfmt+0x283>
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
				putch(' ', putdat);
  80f567:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80f56b:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
  80f572:	ff d6                	call   *%esi
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
  80f574:	83 eb 01             	sub    $0x1,%ebx
  80f577:	eb 08                	jmp    80f581 <vprintfmt+0x283>
  80f579:	89 fb                	mov    %edi,%ebx
  80f57b:	8b 75 08             	mov    0x8(%ebp),%esi
  80f57e:	8b 7d 0c             	mov    0xc(%ebp),%edi
  80f581:	85 db                	test   %ebx,%ebx
  80f583:	7f e2                	jg     80f567 <vprintfmt+0x269>
  80f585:	89 75 08             	mov    %esi,0x8(%ebp)
  80f588:	8b 5d 10             	mov    0x10(%ebp),%ebx
  80f58b:	e9 93 fd ff ff       	jmp    80f323 <vprintfmt+0x25>
// Same as getuint but signed - can't use getuint
// because of sign extension
static long long
getint(va_list *ap, int lflag)
{
	if (lflag >= 2)
  80f590:	83 fa 01             	cmp    $0x1,%edx
  80f593:	7e 16                	jle    80f5ab <vprintfmt+0x2ad>
		return va_arg(*ap, long long);
  80f595:	8b 45 14             	mov    0x14(%ebp),%eax
  80f598:	8d 50 08             	lea    0x8(%eax),%edx
  80f59b:	89 55 14             	mov    %edx,0x14(%ebp)
  80f59e:	8b 50 04             	mov    0x4(%eax),%edx
  80f5a1:	8b 00                	mov    (%eax),%eax
  80f5a3:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80f5a6:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  80f5a9:	eb 32                	jmp    80f5dd <vprintfmt+0x2df>
	else if (lflag)
  80f5ab:	85 d2                	test   %edx,%edx
  80f5ad:	74 18                	je     80f5c7 <vprintfmt+0x2c9>
		return va_arg(*ap, long);
  80f5af:	8b 45 14             	mov    0x14(%ebp),%eax
  80f5b2:	8d 50 04             	lea    0x4(%eax),%edx
  80f5b5:	89 55 14             	mov    %edx,0x14(%ebp)
  80f5b8:	8b 30                	mov    (%eax),%esi
  80f5ba:	89 75 e0             	mov    %esi,-0x20(%ebp)
  80f5bd:	89 f0                	mov    %esi,%eax
  80f5bf:	c1 f8 1f             	sar    $0x1f,%eax
  80f5c2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80f5c5:	eb 16                	jmp    80f5dd <vprintfmt+0x2df>
	else
		return va_arg(*ap, int);
  80f5c7:	8b 45 14             	mov    0x14(%ebp),%eax
  80f5ca:	8d 50 04             	lea    0x4(%eax),%edx
  80f5cd:	89 55 14             	mov    %edx,0x14(%ebp)
  80f5d0:	8b 30                	mov    (%eax),%esi
  80f5d2:	89 75 e0             	mov    %esi,-0x20(%ebp)
  80f5d5:	89 f0                	mov    %esi,%eax
  80f5d7:	c1 f8 1f             	sar    $0x1f,%eax
  80f5da:	89 45 e4             	mov    %eax,-0x1c(%ebp)
				putch(' ', putdat);
			break;

		// (signed) decimal
		case 'd':
			num = getint(&ap, lflag);
  80f5dd:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80f5e0:	8b 55 e4             	mov    -0x1c(%ebp),%edx
			if ((long long) num < 0) {
				putch('-', putdat);
				num = -(long long) num;
			}
			base = 10;
  80f5e3:	b9 0a 00 00 00       	mov    $0xa,%ecx
			break;

		// (signed) decimal
		case 'd':
			num = getint(&ap, lflag);
			if ((long long) num < 0) {
  80f5e8:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
  80f5ec:	0f 89 80 00 00 00    	jns    80f672 <vprintfmt+0x374>
				putch('-', putdat);
  80f5f2:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80f5f6:	c7 04 24 2d 00 00 00 	movl   $0x2d,(%esp)
  80f5fd:	ff 55 08             	call   *0x8(%ebp)
				num = -(long long) num;
  80f600:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80f603:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80f606:	f7 d8                	neg    %eax
  80f608:	83 d2 00             	adc    $0x0,%edx
  80f60b:	f7 da                	neg    %edx
			}
			base = 10;
  80f60d:	b9 0a 00 00 00       	mov    $0xa,%ecx
  80f612:	eb 5e                	jmp    80f672 <vprintfmt+0x374>
			goto number;

		// unsigned decimal
		case 'u':
			num = getuint(&ap, lflag);
  80f614:	8d 45 14             	lea    0x14(%ebp),%eax
  80f617:	e8 63 fc ff ff       	call   80f27f <getuint>
			base = 10;
  80f61c:	b9 0a 00 00 00       	mov    $0xa,%ecx
			goto number;
  80f621:	eb 4f                	jmp    80f672 <vprintfmt+0x374>

		// (unsigned) octal
		case 'o':
			num = getuint(&ap, lflag);
  80f623:	8d 45 14             	lea    0x14(%ebp),%eax
  80f626:	e8 54 fc ff ff       	call   80f27f <getuint>
			base = 8;
  80f62b:	b9 08 00 00 00       	mov    $0x8,%ecx
			goto number;
  80f630:	eb 40                	jmp    80f672 <vprintfmt+0x374>

		// pointer
		case 'p':
			putch('0', putdat);
  80f632:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80f636:	c7 04 24 30 00 00 00 	movl   $0x30,(%esp)
  80f63d:	ff 55 08             	call   *0x8(%ebp)
			putch('x', putdat);
  80f640:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80f644:	c7 04 24 78 00 00 00 	movl   $0x78,(%esp)
  80f64b:	ff 55 08             	call   *0x8(%ebp)
			num = (unsigned long long)
				(uintptr_t) va_arg(ap, void *);
  80f64e:	8b 45 14             	mov    0x14(%ebp),%eax
  80f651:	8d 50 04             	lea    0x4(%eax),%edx
  80f654:	89 55 14             	mov    %edx,0x14(%ebp)

		// pointer
		case 'p':
			putch('0', putdat);
			putch('x', putdat);
			num = (unsigned long long)
  80f657:	8b 00                	mov    (%eax),%eax
  80f659:	ba 00 00 00 00       	mov    $0x0,%edx
				(uintptr_t) va_arg(ap, void *);
			base = 16;
  80f65e:	b9 10 00 00 00       	mov    $0x10,%ecx
			goto number;
  80f663:	eb 0d                	jmp    80f672 <vprintfmt+0x374>

		// (unsigned) hexadecimal
		case 'x':
			num = getuint(&ap, lflag);
  80f665:	8d 45 14             	lea    0x14(%ebp),%eax
  80f668:	e8 12 fc ff ff       	call   80f27f <getuint>
			base = 16;
  80f66d:	b9 10 00 00 00       	mov    $0x10,%ecx
		number:
			printnum(putch, putdat, num, base, width, padc);
  80f672:	0f be 75 d8          	movsbl -0x28(%ebp),%esi
  80f676:	89 74 24 10          	mov    %esi,0x10(%esp)
  80f67a:	8b 75 dc             	mov    -0x24(%ebp),%esi
  80f67d:	89 74 24 0c          	mov    %esi,0xc(%esp)
  80f681:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  80f685:	89 04 24             	mov    %eax,(%esp)
  80f688:	89 54 24 04          	mov    %edx,0x4(%esp)
  80f68c:	89 fa                	mov    %edi,%edx
  80f68e:	8b 45 08             	mov    0x8(%ebp),%eax
  80f691:	e8 fa fa ff ff       	call   80f190 <printnum>
			break;
  80f696:	e9 88 fc ff ff       	jmp    80f323 <vprintfmt+0x25>

		// escaped '%' character
		case '%':
			putch(ch, putdat);
  80f69b:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80f69f:	89 04 24             	mov    %eax,(%esp)
  80f6a2:	ff 55 08             	call   *0x8(%ebp)
			break;
  80f6a5:	e9 79 fc ff ff       	jmp    80f323 <vprintfmt+0x25>

		// unrecognized escape sequence - just print it literally
		default:
			putch('%', putdat);
  80f6aa:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80f6ae:	c7 04 24 25 00 00 00 	movl   $0x25,(%esp)
  80f6b5:	ff 55 08             	call   *0x8(%ebp)
			for (fmt--; fmt[-1] != '%'; fmt--)
  80f6b8:	89 f3                	mov    %esi,%ebx
  80f6ba:	eb 03                	jmp    80f6bf <vprintfmt+0x3c1>
  80f6bc:	83 eb 01             	sub    $0x1,%ebx
  80f6bf:	80 7b ff 25          	cmpb   $0x25,-0x1(%ebx)
  80f6c3:	75 f7                	jne    80f6bc <vprintfmt+0x3be>
  80f6c5:	e9 59 fc ff ff       	jmp    80f323 <vprintfmt+0x25>
				/* do nothing */;
			break;
		}
	}
}
  80f6ca:	83 c4 3c             	add    $0x3c,%esp
  80f6cd:	5b                   	pop    %ebx
  80f6ce:	5e                   	pop    %esi
  80f6cf:	5f                   	pop    %edi
  80f6d0:	5d                   	pop    %ebp
  80f6d1:	c3                   	ret    

0080f6d2 <vsnprintf>:
		*b->buf++ = ch;
}

int
vsnprintf(char *buf, int n, const char *fmt, va_list ap)
{
  80f6d2:	55                   	push   %ebp
  80f6d3:	89 e5                	mov    %esp,%ebp
  80f6d5:	83 ec 28             	sub    $0x28,%esp
  80f6d8:	8b 45 08             	mov    0x8(%ebp),%eax
  80f6db:	8b 55 0c             	mov    0xc(%ebp),%edx
	struct sprintbuf b = {buf, buf+n-1, 0};
  80f6de:	89 45 ec             	mov    %eax,-0x14(%ebp)
  80f6e1:	8d 4c 10 ff          	lea    -0x1(%eax,%edx,1),%ecx
  80f6e5:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  80f6e8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	if (buf == NULL || n < 1)
  80f6ef:	85 c0                	test   %eax,%eax
  80f6f1:	74 30                	je     80f723 <vsnprintf+0x51>
  80f6f3:	85 d2                	test   %edx,%edx
  80f6f5:	7e 2c                	jle    80f723 <vsnprintf+0x51>
		return -E_INVAL;

	// print the string to the buffer
	vprintfmt((void*)sprintputch, &b, fmt, ap);
  80f6f7:	8b 45 14             	mov    0x14(%ebp),%eax
  80f6fa:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80f6fe:	8b 45 10             	mov    0x10(%ebp),%eax
  80f701:	89 44 24 08          	mov    %eax,0x8(%esp)
  80f705:	8d 45 ec             	lea    -0x14(%ebp),%eax
  80f708:	89 44 24 04          	mov    %eax,0x4(%esp)
  80f70c:	c7 04 24 b9 f2 80 00 	movl   $0x80f2b9,(%esp)
  80f713:	e8 e6 fb ff ff       	call   80f2fe <vprintfmt>

	// null terminate the buffer
	*b.buf = '\0';
  80f718:	8b 45 ec             	mov    -0x14(%ebp),%eax
  80f71b:	c6 00 00             	movb   $0x0,(%eax)

	return b.cnt;
  80f71e:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80f721:	eb 05                	jmp    80f728 <vsnprintf+0x56>
vsnprintf(char *buf, int n, const char *fmt, va_list ap)
{
	struct sprintbuf b = {buf, buf+n-1, 0};

	if (buf == NULL || n < 1)
		return -E_INVAL;
  80f723:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax

	// null terminate the buffer
	*b.buf = '\0';

	return b.cnt;
}
  80f728:	c9                   	leave  
  80f729:	c3                   	ret    

0080f72a <snprintf>:

int
snprintf(char *buf, int n, const char *fmt, ...)
{
  80f72a:	55                   	push   %ebp
  80f72b:	89 e5                	mov    %esp,%ebp
  80f72d:	83 ec 18             	sub    $0x18,%esp
	va_list ap;
	int rc;

	va_start(ap, fmt);
  80f730:	8d 45 14             	lea    0x14(%ebp),%eax
	rc = vsnprintf(buf, n, fmt, ap);
  80f733:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80f737:	8b 45 10             	mov    0x10(%ebp),%eax
  80f73a:	89 44 24 08          	mov    %eax,0x8(%esp)
  80f73e:	8b 45 0c             	mov    0xc(%ebp),%eax
  80f741:	89 44 24 04          	mov    %eax,0x4(%esp)
  80f745:	8b 45 08             	mov    0x8(%ebp),%eax
  80f748:	89 04 24             	mov    %eax,(%esp)
  80f74b:	e8 82 ff ff ff       	call   80f6d2 <vsnprintf>
	va_end(ap);

	return rc;
}
  80f750:	c9                   	leave  
  80f751:	c3                   	ret    
  80f752:	66 90                	xchg   %ax,%ax
  80f754:	66 90                	xchg   %ax,%ax
  80f756:	66 90                	xchg   %ax,%ax
  80f758:	66 90                	xchg   %ax,%ax
  80f75a:	66 90                	xchg   %ax,%ax
  80f75c:	66 90                	xchg   %ax,%ax
  80f75e:	66 90                	xchg   %ax,%ax

0080f760 <strlen>:
// Primespipe runs 3x faster this way.
#define ASM 1

int
strlen(const char *s)
{
  80f760:	55                   	push   %ebp
  80f761:	89 e5                	mov    %esp,%ebp
  80f763:	8b 55 08             	mov    0x8(%ebp),%edx
	int n;

	for (n = 0; *s != '\0'; s++)
  80f766:	b8 00 00 00 00       	mov    $0x0,%eax
  80f76b:	eb 03                	jmp    80f770 <strlen+0x10>
		n++;
  80f76d:	83 c0 01             	add    $0x1,%eax
int
strlen(const char *s)
{
	int n;

	for (n = 0; *s != '\0'; s++)
  80f770:	80 3c 02 00          	cmpb   $0x0,(%edx,%eax,1)
  80f774:	75 f7                	jne    80f76d <strlen+0xd>
		n++;
	return n;
}
  80f776:	5d                   	pop    %ebp
  80f777:	c3                   	ret    

0080f778 <strnlen>:

int
strnlen(const char *s, size_t size)
{
  80f778:	55                   	push   %ebp
  80f779:	89 e5                	mov    %esp,%ebp
  80f77b:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80f77e:	8b 55 0c             	mov    0xc(%ebp),%edx
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
  80f781:	b8 00 00 00 00       	mov    $0x0,%eax
  80f786:	eb 03                	jmp    80f78b <strnlen+0x13>
		n++;
  80f788:	83 c0 01             	add    $0x1,%eax
int
strnlen(const char *s, size_t size)
{
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
  80f78b:	39 d0                	cmp    %edx,%eax
  80f78d:	74 06                	je     80f795 <strnlen+0x1d>
  80f78f:	80 3c 01 00          	cmpb   $0x0,(%ecx,%eax,1)
  80f793:	75 f3                	jne    80f788 <strnlen+0x10>
		n++;
	return n;
}
  80f795:	5d                   	pop    %ebp
  80f796:	c3                   	ret    

0080f797 <strcpy>:

char *
strcpy(char *dst, const char *src)
{
  80f797:	55                   	push   %ebp
  80f798:	89 e5                	mov    %esp,%ebp
  80f79a:	53                   	push   %ebx
  80f79b:	8b 45 08             	mov    0x8(%ebp),%eax
  80f79e:	8b 4d 0c             	mov    0xc(%ebp),%ecx
	char *ret;

	ret = dst;
	while ((*dst++ = *src++) != '\0')
  80f7a1:	89 c2                	mov    %eax,%edx
  80f7a3:	83 c2 01             	add    $0x1,%edx
  80f7a6:	83 c1 01             	add    $0x1,%ecx
  80f7a9:	0f b6 59 ff          	movzbl -0x1(%ecx),%ebx
  80f7ad:	88 5a ff             	mov    %bl,-0x1(%edx)
  80f7b0:	84 db                	test   %bl,%bl
  80f7b2:	75 ef                	jne    80f7a3 <strcpy+0xc>
		/* do nothing */;
	return ret;
}
  80f7b4:	5b                   	pop    %ebx
  80f7b5:	5d                   	pop    %ebp
  80f7b6:	c3                   	ret    

0080f7b7 <strcat>:

char *
strcat(char *dst, const char *src)
{
  80f7b7:	55                   	push   %ebp
  80f7b8:	89 e5                	mov    %esp,%ebp
  80f7ba:	53                   	push   %ebx
  80f7bb:	83 ec 08             	sub    $0x8,%esp
  80f7be:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int len = strlen(dst);
  80f7c1:	89 1c 24             	mov    %ebx,(%esp)
  80f7c4:	e8 97 ff ff ff       	call   80f760 <strlen>
	strcpy(dst + len, src);
  80f7c9:	8b 55 0c             	mov    0xc(%ebp),%edx
  80f7cc:	89 54 24 04          	mov    %edx,0x4(%esp)
  80f7d0:	01 d8                	add    %ebx,%eax
  80f7d2:	89 04 24             	mov    %eax,(%esp)
  80f7d5:	e8 bd ff ff ff       	call   80f797 <strcpy>
	return dst;
}
  80f7da:	89 d8                	mov    %ebx,%eax
  80f7dc:	83 c4 08             	add    $0x8,%esp
  80f7df:	5b                   	pop    %ebx
  80f7e0:	5d                   	pop    %ebp
  80f7e1:	c3                   	ret    

0080f7e2 <strncpy>:

char *
strncpy(char *dst, const char *src, size_t size) {
  80f7e2:	55                   	push   %ebp
  80f7e3:	89 e5                	mov    %esp,%ebp
  80f7e5:	56                   	push   %esi
  80f7e6:	53                   	push   %ebx
  80f7e7:	8b 75 08             	mov    0x8(%ebp),%esi
  80f7ea:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f7ed:	89 f3                	mov    %esi,%ebx
  80f7ef:	03 5d 10             	add    0x10(%ebp),%ebx
	size_t i;
	char *ret;

	ret = dst;
	for (i = 0; i < size; i++) {
  80f7f2:	89 f2                	mov    %esi,%edx
  80f7f4:	eb 0f                	jmp    80f805 <strncpy+0x23>
		*dst++ = *src;
  80f7f6:	83 c2 01             	add    $0x1,%edx
  80f7f9:	0f b6 01             	movzbl (%ecx),%eax
  80f7fc:	88 42 ff             	mov    %al,-0x1(%edx)
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
			src++;
  80f7ff:	80 39 01             	cmpb   $0x1,(%ecx)
  80f802:	83 d9 ff             	sbb    $0xffffffff,%ecx
strncpy(char *dst, const char *src, size_t size) {
	size_t i;
	char *ret;

	ret = dst;
	for (i = 0; i < size; i++) {
  80f805:	39 da                	cmp    %ebx,%edx
  80f807:	75 ed                	jne    80f7f6 <strncpy+0x14>
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
			src++;
	}
	return ret;
}
  80f809:	89 f0                	mov    %esi,%eax
  80f80b:	5b                   	pop    %ebx
  80f80c:	5e                   	pop    %esi
  80f80d:	5d                   	pop    %ebp
  80f80e:	c3                   	ret    

0080f80f <strlcpy>:

size_t
strlcpy(char *dst, const char *src, size_t size)
{
  80f80f:	55                   	push   %ebp
  80f810:	89 e5                	mov    %esp,%ebp
  80f812:	56                   	push   %esi
  80f813:	53                   	push   %ebx
  80f814:	8b 75 08             	mov    0x8(%ebp),%esi
  80f817:	8b 55 0c             	mov    0xc(%ebp),%edx
  80f81a:	8b 4d 10             	mov    0x10(%ebp),%ecx
  80f81d:	89 f0                	mov    %esi,%eax
  80f81f:	8d 5c 0e ff          	lea    -0x1(%esi,%ecx,1),%ebx
	char *dst_in;

	dst_in = dst;
	if (size > 0) {
  80f823:	85 c9                	test   %ecx,%ecx
  80f825:	75 0b                	jne    80f832 <strlcpy+0x23>
  80f827:	eb 1d                	jmp    80f846 <strlcpy+0x37>
		while (--size > 0 && *src != '\0')
			*dst++ = *src++;
  80f829:	83 c0 01             	add    $0x1,%eax
  80f82c:	83 c2 01             	add    $0x1,%edx
  80f82f:	88 48 ff             	mov    %cl,-0x1(%eax)
{
	char *dst_in;

	dst_in = dst;
	if (size > 0) {
		while (--size > 0 && *src != '\0')
  80f832:	39 d8                	cmp    %ebx,%eax
  80f834:	74 0b                	je     80f841 <strlcpy+0x32>
  80f836:	0f b6 0a             	movzbl (%edx),%ecx
  80f839:	84 c9                	test   %cl,%cl
  80f83b:	75 ec                	jne    80f829 <strlcpy+0x1a>
  80f83d:	89 c2                	mov    %eax,%edx
  80f83f:	eb 02                	jmp    80f843 <strlcpy+0x34>
  80f841:	89 c2                	mov    %eax,%edx
			*dst++ = *src++;
		*dst = '\0';
  80f843:	c6 02 00             	movb   $0x0,(%edx)
	}
	return dst - dst_in;
  80f846:	29 f0                	sub    %esi,%eax
}
  80f848:	5b                   	pop    %ebx
  80f849:	5e                   	pop    %esi
  80f84a:	5d                   	pop    %ebp
  80f84b:	c3                   	ret    

0080f84c <strcmp>:

int
strcmp(const char *p, const char *q)
{
  80f84c:	55                   	push   %ebp
  80f84d:	89 e5                	mov    %esp,%ebp
  80f84f:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80f852:	8b 55 0c             	mov    0xc(%ebp),%edx
	while (*p && *p == *q)
  80f855:	eb 06                	jmp    80f85d <strcmp+0x11>
		p++, q++;
  80f857:	83 c1 01             	add    $0x1,%ecx
  80f85a:	83 c2 01             	add    $0x1,%edx
}

int
strcmp(const char *p, const char *q)
{
	while (*p && *p == *q)
  80f85d:	0f b6 01             	movzbl (%ecx),%eax
  80f860:	84 c0                	test   %al,%al
  80f862:	74 04                	je     80f868 <strcmp+0x1c>
  80f864:	3a 02                	cmp    (%edx),%al
  80f866:	74 ef                	je     80f857 <strcmp+0xb>
		p++, q++;
	return (int) ((unsigned char) *p - (unsigned char) *q);
  80f868:	0f b6 c0             	movzbl %al,%eax
  80f86b:	0f b6 12             	movzbl (%edx),%edx
  80f86e:	29 d0                	sub    %edx,%eax
}
  80f870:	5d                   	pop    %ebp
  80f871:	c3                   	ret    

0080f872 <strncmp>:

int
strncmp(const char *p, const char *q, size_t n)
{
  80f872:	55                   	push   %ebp
  80f873:	89 e5                	mov    %esp,%ebp
  80f875:	53                   	push   %ebx
  80f876:	8b 45 08             	mov    0x8(%ebp),%eax
  80f879:	8b 55 0c             	mov    0xc(%ebp),%edx
  80f87c:	89 c3                	mov    %eax,%ebx
  80f87e:	03 5d 10             	add    0x10(%ebp),%ebx
	while (n > 0 && *p && *p == *q)
  80f881:	eb 06                	jmp    80f889 <strncmp+0x17>
		n--, p++, q++;
  80f883:	83 c0 01             	add    $0x1,%eax
  80f886:	83 c2 01             	add    $0x1,%edx
}

int
strncmp(const char *p, const char *q, size_t n)
{
	while (n > 0 && *p && *p == *q)
  80f889:	39 d8                	cmp    %ebx,%eax
  80f88b:	74 15                	je     80f8a2 <strncmp+0x30>
  80f88d:	0f b6 08             	movzbl (%eax),%ecx
  80f890:	84 c9                	test   %cl,%cl
  80f892:	74 04                	je     80f898 <strncmp+0x26>
  80f894:	3a 0a                	cmp    (%edx),%cl
  80f896:	74 eb                	je     80f883 <strncmp+0x11>
		n--, p++, q++;
	if (n == 0)
		return 0;
	else
		return (int) ((unsigned char) *p - (unsigned char) *q);
  80f898:	0f b6 00             	movzbl (%eax),%eax
  80f89b:	0f b6 12             	movzbl (%edx),%edx
  80f89e:	29 d0                	sub    %edx,%eax
  80f8a0:	eb 05                	jmp    80f8a7 <strncmp+0x35>
strncmp(const char *p, const char *q, size_t n)
{
	while (n > 0 && *p && *p == *q)
		n--, p++, q++;
	if (n == 0)
		return 0;
  80f8a2:	b8 00 00 00 00       	mov    $0x0,%eax
	else
		return (int) ((unsigned char) *p - (unsigned char) *q);
}
  80f8a7:	5b                   	pop    %ebx
  80f8a8:	5d                   	pop    %ebp
  80f8a9:	c3                   	ret    

0080f8aa <strchr>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
  80f8aa:	55                   	push   %ebp
  80f8ab:	89 e5                	mov    %esp,%ebp
  80f8ad:	8b 45 08             	mov    0x8(%ebp),%eax
  80f8b0:	0f b6 4d 0c          	movzbl 0xc(%ebp),%ecx
	for (; *s; s++)
  80f8b4:	eb 07                	jmp    80f8bd <strchr+0x13>
		if (*s == c)
  80f8b6:	38 ca                	cmp    %cl,%dl
  80f8b8:	74 0f                	je     80f8c9 <strchr+0x1f>
// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
	for (; *s; s++)
  80f8ba:	83 c0 01             	add    $0x1,%eax
  80f8bd:	0f b6 10             	movzbl (%eax),%edx
  80f8c0:	84 d2                	test   %dl,%dl
  80f8c2:	75 f2                	jne    80f8b6 <strchr+0xc>
		if (*s == c)
			return (char *) s;
	return 0;
  80f8c4:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80f8c9:	5d                   	pop    %ebp
  80f8ca:	c3                   	ret    

0080f8cb <strfind>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
  80f8cb:	55                   	push   %ebp
  80f8cc:	89 e5                	mov    %esp,%ebp
  80f8ce:	8b 45 08             	mov    0x8(%ebp),%eax
  80f8d1:	0f b6 4d 0c          	movzbl 0xc(%ebp),%ecx
	for (; *s; s++)
  80f8d5:	eb 07                	jmp    80f8de <strfind+0x13>
		if (*s == c)
  80f8d7:	38 ca                	cmp    %cl,%dl
  80f8d9:	74 0a                	je     80f8e5 <strfind+0x1a>
// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
	for (; *s; s++)
  80f8db:	83 c0 01             	add    $0x1,%eax
  80f8de:	0f b6 10             	movzbl (%eax),%edx
  80f8e1:	84 d2                	test   %dl,%dl
  80f8e3:	75 f2                	jne    80f8d7 <strfind+0xc>
		if (*s == c)
			break;
	return (char *) s;
}
  80f8e5:	5d                   	pop    %ebp
  80f8e6:	c3                   	ret    

0080f8e7 <memset>:

#if ASM
void *
memset(void *v, int c, size_t n)
{
  80f8e7:	55                   	push   %ebp
  80f8e8:	89 e5                	mov    %esp,%ebp
  80f8ea:	57                   	push   %edi
  80f8eb:	56                   	push   %esi
  80f8ec:	53                   	push   %ebx
  80f8ed:	8b 7d 08             	mov    0x8(%ebp),%edi
  80f8f0:	8b 4d 10             	mov    0x10(%ebp),%ecx
	char *p;

	if (n == 0)
  80f8f3:	85 c9                	test   %ecx,%ecx
  80f8f5:	74 36                	je     80f92d <memset+0x46>
		return v;
	if ((int)v%4 == 0 && n%4 == 0) {
  80f8f7:	f7 c7 03 00 00 00    	test   $0x3,%edi
  80f8fd:	75 28                	jne    80f927 <memset+0x40>
  80f8ff:	f6 c1 03             	test   $0x3,%cl
  80f902:	75 23                	jne    80f927 <memset+0x40>
		c &= 0xFF;
  80f904:	0f b6 55 0c          	movzbl 0xc(%ebp),%edx
		c = (c<<24)|(c<<16)|(c<<8)|c;
  80f908:	89 d3                	mov    %edx,%ebx
  80f90a:	c1 e3 08             	shl    $0x8,%ebx
  80f90d:	89 d6                	mov    %edx,%esi
  80f90f:	c1 e6 18             	shl    $0x18,%esi
  80f912:	89 d0                	mov    %edx,%eax
  80f914:	c1 e0 10             	shl    $0x10,%eax
  80f917:	09 f0                	or     %esi,%eax
  80f919:	09 c2                	or     %eax,%edx
  80f91b:	89 d0                	mov    %edx,%eax
  80f91d:	09 d8                	or     %ebx,%eax
		asm volatile("cld; rep stosl\n"
			:: "D" (v), "a" (c), "c" (n/4)
  80f91f:	c1 e9 02             	shr    $0x2,%ecx
	if (n == 0)
		return v;
	if ((int)v%4 == 0 && n%4 == 0) {
		c &= 0xFF;
		c = (c<<24)|(c<<16)|(c<<8)|c;
		asm volatile("cld; rep stosl\n"
  80f922:	fc                   	cld    
  80f923:	f3 ab                	rep stos %eax,%es:(%edi)
  80f925:	eb 06                	jmp    80f92d <memset+0x46>
			:: "D" (v), "a" (c), "c" (n/4)
			: "cc", "memory");
	} else
		asm volatile("cld; rep stosb\n"
  80f927:	8b 45 0c             	mov    0xc(%ebp),%eax
  80f92a:	fc                   	cld    
  80f92b:	f3 aa                	rep stos %al,%es:(%edi)
			:: "D" (v), "a" (c), "c" (n)
			: "cc", "memory");
	return v;
}
  80f92d:	89 f8                	mov    %edi,%eax
  80f92f:	5b                   	pop    %ebx
  80f930:	5e                   	pop    %esi
  80f931:	5f                   	pop    %edi
  80f932:	5d                   	pop    %ebp
  80f933:	c3                   	ret    

0080f934 <memmove>:

void *
memmove(void *dst, const void *src, size_t n)
{
  80f934:	55                   	push   %ebp
  80f935:	89 e5                	mov    %esp,%ebp
  80f937:	57                   	push   %edi
  80f938:	56                   	push   %esi
  80f939:	8b 45 08             	mov    0x8(%ebp),%eax
  80f93c:	8b 75 0c             	mov    0xc(%ebp),%esi
  80f93f:	8b 4d 10             	mov    0x10(%ebp),%ecx
	const char *s;
	char *d;

	s = src;
	d = dst;
	if (s < d && s + n > d) {
  80f942:	39 c6                	cmp    %eax,%esi
  80f944:	73 35                	jae    80f97b <memmove+0x47>
  80f946:	8d 14 0e             	lea    (%esi,%ecx,1),%edx
  80f949:	39 d0                	cmp    %edx,%eax
  80f94b:	73 2e                	jae    80f97b <memmove+0x47>
		s += n;
		d += n;
  80f94d:	8d 3c 08             	lea    (%eax,%ecx,1),%edi
  80f950:	89 d6                	mov    %edx,%esi
  80f952:	09 fe                	or     %edi,%esi
		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
  80f954:	f7 c6 03 00 00 00    	test   $0x3,%esi
  80f95a:	75 13                	jne    80f96f <memmove+0x3b>
  80f95c:	f6 c1 03             	test   $0x3,%cl
  80f95f:	75 0e                	jne    80f96f <memmove+0x3b>
			asm volatile("std; rep movsl\n"
				:: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
  80f961:	83 ef 04             	sub    $0x4,%edi
  80f964:	8d 72 fc             	lea    -0x4(%edx),%esi
  80f967:	c1 e9 02             	shr    $0x2,%ecx
	d = dst;
	if (s < d && s + n > d) {
		s += n;
		d += n;
		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
			asm volatile("std; rep movsl\n"
  80f96a:	fd                   	std    
  80f96b:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
  80f96d:	eb 09                	jmp    80f978 <memmove+0x44>
				:: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
		else
			asm volatile("std; rep movsb\n"
				:: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
  80f96f:	83 ef 01             	sub    $0x1,%edi
  80f972:	8d 72 ff             	lea    -0x1(%edx),%esi
		d += n;
		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
			asm volatile("std; rep movsl\n"
				:: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
		else
			asm volatile("std; rep movsb\n"
  80f975:	fd                   	std    
  80f976:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
				:: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
		// Some versions of GCC rely on DF being clear
		asm volatile("cld" ::: "cc");
  80f978:	fc                   	cld    
  80f979:	eb 1d                	jmp    80f998 <memmove+0x64>
  80f97b:	89 f2                	mov    %esi,%edx
  80f97d:	09 c2                	or     %eax,%edx
	} else {
		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
  80f97f:	f6 c2 03             	test   $0x3,%dl
  80f982:	75 0f                	jne    80f993 <memmove+0x5f>
  80f984:	f6 c1 03             	test   $0x3,%cl
  80f987:	75 0a                	jne    80f993 <memmove+0x5f>
			asm volatile("cld; rep movsl\n"
				:: "D" (d), "S" (s), "c" (n/4) : "cc", "memory");
  80f989:	c1 e9 02             	shr    $0x2,%ecx
				:: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
		// Some versions of GCC rely on DF being clear
		asm volatile("cld" ::: "cc");
	} else {
		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
			asm volatile("cld; rep movsl\n"
  80f98c:	89 c7                	mov    %eax,%edi
  80f98e:	fc                   	cld    
  80f98f:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
  80f991:	eb 05                	jmp    80f998 <memmove+0x64>
				:: "D" (d), "S" (s), "c" (n/4) : "cc", "memory");
		else
			asm volatile("cld; rep movsb\n"
  80f993:	89 c7                	mov    %eax,%edi
  80f995:	fc                   	cld    
  80f996:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
				:: "D" (d), "S" (s), "c" (n) : "cc", "memory");
	}
	return dst;
}
  80f998:	5e                   	pop    %esi
  80f999:	5f                   	pop    %edi
  80f99a:	5d                   	pop    %ebp
  80f99b:	c3                   	ret    

0080f99c <memcpy>:
}
#endif

void *
memcpy(void *dst, const void *src, size_t n)
{
  80f99c:	55                   	push   %ebp
  80f99d:	89 e5                	mov    %esp,%ebp
  80f99f:	83 ec 0c             	sub    $0xc,%esp
	return memmove(dst, src, n);
  80f9a2:	8b 45 10             	mov    0x10(%ebp),%eax
  80f9a5:	89 44 24 08          	mov    %eax,0x8(%esp)
  80f9a9:	8b 45 0c             	mov    0xc(%ebp),%eax
  80f9ac:	89 44 24 04          	mov    %eax,0x4(%esp)
  80f9b0:	8b 45 08             	mov    0x8(%ebp),%eax
  80f9b3:	89 04 24             	mov    %eax,(%esp)
  80f9b6:	e8 79 ff ff ff       	call   80f934 <memmove>
}
  80f9bb:	c9                   	leave  
  80f9bc:	c3                   	ret    

0080f9bd <memcmp>:

int
memcmp(const void *v1, const void *v2, size_t n)
{
  80f9bd:	55                   	push   %ebp
  80f9be:	89 e5                	mov    %esp,%ebp
  80f9c0:	56                   	push   %esi
  80f9c1:	53                   	push   %ebx
  80f9c2:	8b 55 08             	mov    0x8(%ebp),%edx
  80f9c5:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f9c8:	89 d6                	mov    %edx,%esi
  80f9ca:	03 75 10             	add    0x10(%ebp),%esi
	const uint8_t *s1 = (const uint8_t *) v1;
	const uint8_t *s2 = (const uint8_t *) v2;

	while (n-- > 0) {
  80f9cd:	eb 1a                	jmp    80f9e9 <memcmp+0x2c>
		if (*s1 != *s2)
  80f9cf:	0f b6 02             	movzbl (%edx),%eax
  80f9d2:	0f b6 19             	movzbl (%ecx),%ebx
  80f9d5:	38 d8                	cmp    %bl,%al
  80f9d7:	74 0a                	je     80f9e3 <memcmp+0x26>
			return (int) *s1 - (int) *s2;
  80f9d9:	0f b6 c0             	movzbl %al,%eax
  80f9dc:	0f b6 db             	movzbl %bl,%ebx
  80f9df:	29 d8                	sub    %ebx,%eax
  80f9e1:	eb 0f                	jmp    80f9f2 <memcmp+0x35>
		s1++, s2++;
  80f9e3:	83 c2 01             	add    $0x1,%edx
  80f9e6:	83 c1 01             	add    $0x1,%ecx
memcmp(const void *v1, const void *v2, size_t n)
{
	const uint8_t *s1 = (const uint8_t *) v1;
	const uint8_t *s2 = (const uint8_t *) v2;

	while (n-- > 0) {
  80f9e9:	39 f2                	cmp    %esi,%edx
  80f9eb:	75 e2                	jne    80f9cf <memcmp+0x12>
		if (*s1 != *s2)
			return (int) *s1 - (int) *s2;
		s1++, s2++;
	}

	return 0;
  80f9ed:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80f9f2:	5b                   	pop    %ebx
  80f9f3:	5e                   	pop    %esi
  80f9f4:	5d                   	pop    %ebp
  80f9f5:	c3                   	ret    

0080f9f6 <memfind>:

void *
memfind(const void *s, int c, size_t n)
{
  80f9f6:	55                   	push   %ebp
  80f9f7:	89 e5                	mov    %esp,%ebp
  80f9f9:	8b 45 08             	mov    0x8(%ebp),%eax
  80f9fc:	8b 4d 0c             	mov    0xc(%ebp),%ecx
	const void *ends = (const char *) s + n;
  80f9ff:	89 c2                	mov    %eax,%edx
  80fa01:	03 55 10             	add    0x10(%ebp),%edx
	for (; s < ends; s++)
  80fa04:	eb 07                	jmp    80fa0d <memfind+0x17>
		if (*(const unsigned char *) s == (unsigned char) c)
  80fa06:	38 08                	cmp    %cl,(%eax)
  80fa08:	74 07                	je     80fa11 <memfind+0x1b>

void *
memfind(const void *s, int c, size_t n)
{
	const void *ends = (const char *) s + n;
	for (; s < ends; s++)
  80fa0a:	83 c0 01             	add    $0x1,%eax
  80fa0d:	39 d0                	cmp    %edx,%eax
  80fa0f:	72 f5                	jb     80fa06 <memfind+0x10>
		if (*(const unsigned char *) s == (unsigned char) c)
			break;
	return (void *) s;
}
  80fa11:	5d                   	pop    %ebp
  80fa12:	c3                   	ret    

0080fa13 <strtol>:

long
strtol(const char *s, char **endptr, int base)
{
  80fa13:	55                   	push   %ebp
  80fa14:	89 e5                	mov    %esp,%ebp
  80fa16:	57                   	push   %edi
  80fa17:	56                   	push   %esi
  80fa18:	53                   	push   %ebx
  80fa19:	8b 55 08             	mov    0x8(%ebp),%edx
  80fa1c:	8b 45 10             	mov    0x10(%ebp),%eax
	int neg = 0;
	long val = 0;

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
  80fa1f:	eb 03                	jmp    80fa24 <strtol+0x11>
		s++;
  80fa21:	83 c2 01             	add    $0x1,%edx
{
	int neg = 0;
	long val = 0;

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
  80fa24:	0f b6 0a             	movzbl (%edx),%ecx
  80fa27:	80 f9 09             	cmp    $0x9,%cl
  80fa2a:	74 f5                	je     80fa21 <strtol+0xe>
  80fa2c:	80 f9 20             	cmp    $0x20,%cl
  80fa2f:	74 f0                	je     80fa21 <strtol+0xe>
		s++;

	// plus/minus sign
	if (*s == '+')
  80fa31:	80 f9 2b             	cmp    $0x2b,%cl
  80fa34:	75 0a                	jne    80fa40 <strtol+0x2d>
		s++;
  80fa36:	83 c2 01             	add    $0x1,%edx
}

long
strtol(const char *s, char **endptr, int base)
{
	int neg = 0;
  80fa39:	bf 00 00 00 00       	mov    $0x0,%edi
  80fa3e:	eb 11                	jmp    80fa51 <strtol+0x3e>
  80fa40:	bf 00 00 00 00       	mov    $0x0,%edi
		s++;

	// plus/minus sign
	if (*s == '+')
		s++;
	else if (*s == '-')
  80fa45:	80 f9 2d             	cmp    $0x2d,%cl
  80fa48:	75 07                	jne    80fa51 <strtol+0x3e>
		s++, neg = 1;
  80fa4a:	8d 52 01             	lea    0x1(%edx),%edx
  80fa4d:	66 bf 01 00          	mov    $0x1,%di

	// hex or octal base prefix
	if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
  80fa51:	a9 ef ff ff ff       	test   $0xffffffef,%eax
  80fa56:	75 15                	jne    80fa6d <strtol+0x5a>
  80fa58:	80 3a 30             	cmpb   $0x30,(%edx)
  80fa5b:	75 10                	jne    80fa6d <strtol+0x5a>
  80fa5d:	80 7a 01 78          	cmpb   $0x78,0x1(%edx)
  80fa61:	75 0a                	jne    80fa6d <strtol+0x5a>
		s += 2, base = 16;
  80fa63:	83 c2 02             	add    $0x2,%edx
  80fa66:	b8 10 00 00 00       	mov    $0x10,%eax
  80fa6b:	eb 10                	jmp    80fa7d <strtol+0x6a>
	else if (base == 0 && s[0] == '0')
  80fa6d:	85 c0                	test   %eax,%eax
  80fa6f:	75 0c                	jne    80fa7d <strtol+0x6a>
		s++, base = 8;
	else if (base == 0)
		base = 10;
  80fa71:	b0 0a                	mov    $0xa,%al
		s++, neg = 1;

	// hex or octal base prefix
	if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
		s += 2, base = 16;
	else if (base == 0 && s[0] == '0')
  80fa73:	80 3a 30             	cmpb   $0x30,(%edx)
  80fa76:	75 05                	jne    80fa7d <strtol+0x6a>
		s++, base = 8;
  80fa78:	83 c2 01             	add    $0x1,%edx
  80fa7b:	b0 08                	mov    $0x8,%al
	else if (base == 0)
		base = 10;
  80fa7d:	bb 00 00 00 00       	mov    $0x0,%ebx
  80fa82:	89 45 10             	mov    %eax,0x10(%ebp)

	// digits
	while (1) {
		int dig;

		if (*s >= '0' && *s <= '9')
  80fa85:	0f b6 0a             	movzbl (%edx),%ecx
  80fa88:	8d 71 d0             	lea    -0x30(%ecx),%esi
  80fa8b:	89 f0                	mov    %esi,%eax
  80fa8d:	3c 09                	cmp    $0x9,%al
  80fa8f:	77 08                	ja     80fa99 <strtol+0x86>
			dig = *s - '0';
  80fa91:	0f be c9             	movsbl %cl,%ecx
  80fa94:	83 e9 30             	sub    $0x30,%ecx
  80fa97:	eb 20                	jmp    80fab9 <strtol+0xa6>
		else if (*s >= 'a' && *s <= 'z')
  80fa99:	8d 71 9f             	lea    -0x61(%ecx),%esi
  80fa9c:	89 f0                	mov    %esi,%eax
  80fa9e:	3c 19                	cmp    $0x19,%al
  80faa0:	77 08                	ja     80faaa <strtol+0x97>
			dig = *s - 'a' + 10;
  80faa2:	0f be c9             	movsbl %cl,%ecx
  80faa5:	83 e9 57             	sub    $0x57,%ecx
  80faa8:	eb 0f                	jmp    80fab9 <strtol+0xa6>
		else if (*s >= 'A' && *s <= 'Z')
  80faaa:	8d 71 bf             	lea    -0x41(%ecx),%esi
  80faad:	89 f0                	mov    %esi,%eax
  80faaf:	3c 19                	cmp    $0x19,%al
  80fab1:	77 16                	ja     80fac9 <strtol+0xb6>
			dig = *s - 'A' + 10;
  80fab3:	0f be c9             	movsbl %cl,%ecx
  80fab6:	83 e9 37             	sub    $0x37,%ecx
		else
			break;
		if (dig >= base)
  80fab9:	3b 4d 10             	cmp    0x10(%ebp),%ecx
  80fabc:	7d 0f                	jge    80facd <strtol+0xba>
			break;
		s++, val = (val * base) + dig;
  80fabe:	83 c2 01             	add    $0x1,%edx
  80fac1:	0f af 5d 10          	imul   0x10(%ebp),%ebx
  80fac5:	01 cb                	add    %ecx,%ebx
		// we don't properly detect overflow!
	}
  80fac7:	eb bc                	jmp    80fa85 <strtol+0x72>
  80fac9:	89 d8                	mov    %ebx,%eax
  80facb:	eb 02                	jmp    80facf <strtol+0xbc>
  80facd:	89 d8                	mov    %ebx,%eax

	if (endptr)
  80facf:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  80fad3:	74 05                	je     80fada <strtol+0xc7>
		*endptr = (char *) s;
  80fad5:	8b 75 0c             	mov    0xc(%ebp),%esi
  80fad8:	89 16                	mov    %edx,(%esi)
	return (neg ? -val : val);
  80fada:	f7 d8                	neg    %eax
  80fadc:	85 ff                	test   %edi,%edi
  80fade:	0f 44 c3             	cmove  %ebx,%eax
}
  80fae1:	5b                   	pop    %ebx
  80fae2:	5e                   	pop    %esi
  80fae3:	5f                   	pop    %edi
  80fae4:	5d                   	pop    %ebp
  80fae5:	c3                   	ret    

0080fae6 <sys_cputs>:
	return ret;
}

void
sys_cputs(const char *s, size_t len)
{
  80fae6:	55                   	push   %ebp
  80fae7:	89 e5                	mov    %esp,%ebp
  80fae9:	57                   	push   %edi
  80faea:	56                   	push   %esi
  80faeb:	53                   	push   %ebx
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80faec:	b8 00 00 00 00       	mov    $0x0,%eax
  80faf1:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80faf4:	8b 55 08             	mov    0x8(%ebp),%edx
  80faf7:	89 c3                	mov    %eax,%ebx
  80faf9:	89 c7                	mov    %eax,%edi
  80fafb:	89 c6                	mov    %eax,%esi
  80fafd:	cd 30                	int    $0x30

void
sys_cputs(const char *s, size_t len)
{
	syscall(SYS_cputs, 0, (uint32_t)s, len, 0, 0, 0);
}
  80faff:	5b                   	pop    %ebx
  80fb00:	5e                   	pop    %esi
  80fb01:	5f                   	pop    %edi
  80fb02:	5d                   	pop    %ebp
  80fb03:	c3                   	ret    

0080fb04 <sys_cgetc>:

int
sys_cgetc(void)
{
  80fb04:	55                   	push   %ebp
  80fb05:	89 e5                	mov    %esp,%ebp
  80fb07:	57                   	push   %edi
  80fb08:	56                   	push   %esi
  80fb09:	53                   	push   %ebx
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80fb0a:	ba 00 00 00 00       	mov    $0x0,%edx
  80fb0f:	b8 01 00 00 00       	mov    $0x1,%eax
  80fb14:	89 d1                	mov    %edx,%ecx
  80fb16:	89 d3                	mov    %edx,%ebx
  80fb18:	89 d7                	mov    %edx,%edi
  80fb1a:	89 d6                	mov    %edx,%esi
  80fb1c:	cd 30                	int    $0x30

int
sys_cgetc(void)
{
	return syscall(SYS_cgetc, 0, 0, 0, 0, 0, 0);
}
  80fb1e:	5b                   	pop    %ebx
  80fb1f:	5e                   	pop    %esi
  80fb20:	5f                   	pop    %edi
  80fb21:	5d                   	pop    %ebp
  80fb22:	c3                   	ret    

0080fb23 <sys_env_destroy>:

int
sys_env_destroy(envid_t envid)
{
  80fb23:	55                   	push   %ebp
  80fb24:	89 e5                	mov    %esp,%ebp
  80fb26:	57                   	push   %edi
  80fb27:	56                   	push   %esi
  80fb28:	53                   	push   %ebx
  80fb29:	83 ec 2c             	sub    $0x2c,%esp
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80fb2c:	b9 00 00 00 00       	mov    $0x0,%ecx
  80fb31:	b8 03 00 00 00       	mov    $0x3,%eax
  80fb36:	8b 55 08             	mov    0x8(%ebp),%edx
  80fb39:	89 cb                	mov    %ecx,%ebx
  80fb3b:	89 cf                	mov    %ecx,%edi
  80fb3d:	89 ce                	mov    %ecx,%esi
  80fb3f:	cd 30                	int    $0x30
		       "b" (a3),
		       "D" (a4),
		       "S" (a5)
		     : "cc", "memory");

	if(check && ret > 0)
  80fb41:	85 c0                	test   %eax,%eax
  80fb43:	7e 28                	jle    80fb6d <sys_env_destroy+0x4a>
		panic("syscall %d returned %d (> 0)", num, ret);
  80fb45:	89 44 24 10          	mov    %eax,0x10(%esp)
  80fb49:	c7 44 24 0c 03 00 00 	movl   $0x3,0xc(%esp)
  80fb50:	00 
  80fb51:	c7 44 24 08 9f 44 81 	movl   $0x81449f,0x8(%esp)
  80fb58:	00 
  80fb59:	c7 44 24 04 23 00 00 	movl   $0x23,0x4(%esp)
  80fb60:	00 
  80fb61:	c7 04 24 bc 44 81 00 	movl   $0x8144bc,(%esp)
  80fb68:	e8 0d f5 ff ff       	call   80f07a <_panic>

int
sys_env_destroy(envid_t envid)
{
	return syscall(SYS_env_destroy, 1, envid, 0, 0, 0, 0);
}
  80fb6d:	83 c4 2c             	add    $0x2c,%esp
  80fb70:	5b                   	pop    %ebx
  80fb71:	5e                   	pop    %esi
  80fb72:	5f                   	pop    %edi
  80fb73:	5d                   	pop    %ebp
  80fb74:	c3                   	ret    

0080fb75 <sys_getenvid>:

envid_t
sys_getenvid(void)
{
  80fb75:	55                   	push   %ebp
  80fb76:	89 e5                	mov    %esp,%ebp
  80fb78:	57                   	push   %edi
  80fb79:	56                   	push   %esi
  80fb7a:	53                   	push   %ebx
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80fb7b:	ba 00 00 00 00       	mov    $0x0,%edx
  80fb80:	b8 02 00 00 00       	mov    $0x2,%eax
  80fb85:	89 d1                	mov    %edx,%ecx
  80fb87:	89 d3                	mov    %edx,%ebx
  80fb89:	89 d7                	mov    %edx,%edi
  80fb8b:	89 d6                	mov    %edx,%esi
  80fb8d:	cd 30                	int    $0x30

envid_t
sys_getenvid(void)
{
	 return syscall(SYS_getenvid, 0, 0, 0, 0, 0, 0);
}
  80fb8f:	5b                   	pop    %ebx
  80fb90:	5e                   	pop    %esi
  80fb91:	5f                   	pop    %edi
  80fb92:	5d                   	pop    %ebp
  80fb93:	c3                   	ret    

0080fb94 <sys_yield>:

void
sys_yield(void)
{
  80fb94:	55                   	push   %ebp
  80fb95:	89 e5                	mov    %esp,%ebp
  80fb97:	57                   	push   %edi
  80fb98:	56                   	push   %esi
  80fb99:	53                   	push   %ebx
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80fb9a:	ba 00 00 00 00       	mov    $0x0,%edx
  80fb9f:	b8 0b 00 00 00       	mov    $0xb,%eax
  80fba4:	89 d1                	mov    %edx,%ecx
  80fba6:	89 d3                	mov    %edx,%ebx
  80fba8:	89 d7                	mov    %edx,%edi
  80fbaa:	89 d6                	mov    %edx,%esi
  80fbac:	cd 30                	int    $0x30

void
sys_yield(void)
{
	syscall(SYS_yield, 0, 0, 0, 0, 0, 0);
}
  80fbae:	5b                   	pop    %ebx
  80fbaf:	5e                   	pop    %esi
  80fbb0:	5f                   	pop    %edi
  80fbb1:	5d                   	pop    %ebp
  80fbb2:	c3                   	ret    

0080fbb3 <sys_page_alloc>:

int
sys_page_alloc(envid_t envid, void *va, int perm)
{
  80fbb3:	55                   	push   %ebp
  80fbb4:	89 e5                	mov    %esp,%ebp
  80fbb6:	57                   	push   %edi
  80fbb7:	56                   	push   %esi
  80fbb8:	53                   	push   %ebx
  80fbb9:	83 ec 2c             	sub    $0x2c,%esp
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80fbbc:	be 00 00 00 00       	mov    $0x0,%esi
  80fbc1:	b8 04 00 00 00       	mov    $0x4,%eax
  80fbc6:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80fbc9:	8b 55 08             	mov    0x8(%ebp),%edx
  80fbcc:	8b 5d 10             	mov    0x10(%ebp),%ebx
  80fbcf:	89 f7                	mov    %esi,%edi
  80fbd1:	cd 30                	int    $0x30
		       "b" (a3),
		       "D" (a4),
		       "S" (a5)
		     : "cc", "memory");

	if(check && ret > 0)
  80fbd3:	85 c0                	test   %eax,%eax
  80fbd5:	7e 28                	jle    80fbff <sys_page_alloc+0x4c>
		panic("syscall %d returned %d (> 0)", num, ret);
  80fbd7:	89 44 24 10          	mov    %eax,0x10(%esp)
  80fbdb:	c7 44 24 0c 04 00 00 	movl   $0x4,0xc(%esp)
  80fbe2:	00 
  80fbe3:	c7 44 24 08 9f 44 81 	movl   $0x81449f,0x8(%esp)
  80fbea:	00 
  80fbeb:	c7 44 24 04 23 00 00 	movl   $0x23,0x4(%esp)
  80fbf2:	00 
  80fbf3:	c7 04 24 bc 44 81 00 	movl   $0x8144bc,(%esp)
  80fbfa:	e8 7b f4 ff ff       	call   80f07a <_panic>

int
sys_page_alloc(envid_t envid, void *va, int perm)
{
	return syscall(SYS_page_alloc, 1, envid, (uint32_t) va, perm, 0, 0);
}
  80fbff:	83 c4 2c             	add    $0x2c,%esp
  80fc02:	5b                   	pop    %ebx
  80fc03:	5e                   	pop    %esi
  80fc04:	5f                   	pop    %edi
  80fc05:	5d                   	pop    %ebp
  80fc06:	c3                   	ret    

0080fc07 <sys_page_map>:

int
sys_page_map(envid_t srcenv, void *srcva, envid_t dstenv, void *dstva, int perm)
{
  80fc07:	55                   	push   %ebp
  80fc08:	89 e5                	mov    %esp,%ebp
  80fc0a:	57                   	push   %edi
  80fc0b:	56                   	push   %esi
  80fc0c:	53                   	push   %ebx
  80fc0d:	83 ec 2c             	sub    $0x2c,%esp
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80fc10:	b8 05 00 00 00       	mov    $0x5,%eax
  80fc15:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80fc18:	8b 55 08             	mov    0x8(%ebp),%edx
  80fc1b:	8b 5d 10             	mov    0x10(%ebp),%ebx
  80fc1e:	8b 7d 14             	mov    0x14(%ebp),%edi
  80fc21:	8b 75 18             	mov    0x18(%ebp),%esi
  80fc24:	cd 30                	int    $0x30
		       "b" (a3),
		       "D" (a4),
		       "S" (a5)
		     : "cc", "memory");

	if(check && ret > 0)
  80fc26:	85 c0                	test   %eax,%eax
  80fc28:	7e 28                	jle    80fc52 <sys_page_map+0x4b>
		panic("syscall %d returned %d (> 0)", num, ret);
  80fc2a:	89 44 24 10          	mov    %eax,0x10(%esp)
  80fc2e:	c7 44 24 0c 05 00 00 	movl   $0x5,0xc(%esp)
  80fc35:	00 
  80fc36:	c7 44 24 08 9f 44 81 	movl   $0x81449f,0x8(%esp)
  80fc3d:	00 
  80fc3e:	c7 44 24 04 23 00 00 	movl   $0x23,0x4(%esp)
  80fc45:	00 
  80fc46:	c7 04 24 bc 44 81 00 	movl   $0x8144bc,(%esp)
  80fc4d:	e8 28 f4 ff ff       	call   80f07a <_panic>

int
sys_page_map(envid_t srcenv, void *srcva, envid_t dstenv, void *dstva, int perm)
{
	return syscall(SYS_page_map, 1, srcenv, (uint32_t) srcva, dstenv, (uint32_t) dstva, perm);
}
  80fc52:	83 c4 2c             	add    $0x2c,%esp
  80fc55:	5b                   	pop    %ebx
  80fc56:	5e                   	pop    %esi
  80fc57:	5f                   	pop    %edi
  80fc58:	5d                   	pop    %ebp
  80fc59:	c3                   	ret    

0080fc5a <sys_page_unmap>:

int
sys_page_unmap(envid_t envid, void *va)
{
  80fc5a:	55                   	push   %ebp
  80fc5b:	89 e5                	mov    %esp,%ebp
  80fc5d:	57                   	push   %edi
  80fc5e:	56                   	push   %esi
  80fc5f:	53                   	push   %ebx
  80fc60:	83 ec 2c             	sub    $0x2c,%esp
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80fc63:	bb 00 00 00 00       	mov    $0x0,%ebx
  80fc68:	b8 06 00 00 00       	mov    $0x6,%eax
  80fc6d:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80fc70:	8b 55 08             	mov    0x8(%ebp),%edx
  80fc73:	89 df                	mov    %ebx,%edi
  80fc75:	89 de                	mov    %ebx,%esi
  80fc77:	cd 30                	int    $0x30
		       "b" (a3),
		       "D" (a4),
		       "S" (a5)
		     : "cc", "memory");

	if(check && ret > 0)
  80fc79:	85 c0                	test   %eax,%eax
  80fc7b:	7e 28                	jle    80fca5 <sys_page_unmap+0x4b>
		panic("syscall %d returned %d (> 0)", num, ret);
  80fc7d:	89 44 24 10          	mov    %eax,0x10(%esp)
  80fc81:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
  80fc88:	00 
  80fc89:	c7 44 24 08 9f 44 81 	movl   $0x81449f,0x8(%esp)
  80fc90:	00 
  80fc91:	c7 44 24 04 23 00 00 	movl   $0x23,0x4(%esp)
  80fc98:	00 
  80fc99:	c7 04 24 bc 44 81 00 	movl   $0x8144bc,(%esp)
  80fca0:	e8 d5 f3 ff ff       	call   80f07a <_panic>

int
sys_page_unmap(envid_t envid, void *va)
{
	return syscall(SYS_page_unmap, 1, envid, (uint32_t) va, 0, 0, 0);
}
  80fca5:	83 c4 2c             	add    $0x2c,%esp
  80fca8:	5b                   	pop    %ebx
  80fca9:	5e                   	pop    %esi
  80fcaa:	5f                   	pop    %edi
  80fcab:	5d                   	pop    %ebp
  80fcac:	c3                   	ret    

0080fcad <sys_env_set_status>:

// sys_exofork is inlined in lib.h

int
sys_env_set_status(envid_t envid, int status)
{
  80fcad:	55                   	push   %ebp
  80fcae:	89 e5                	mov    %esp,%ebp
  80fcb0:	57                   	push   %edi
  80fcb1:	56                   	push   %esi
  80fcb2:	53                   	push   %ebx
  80fcb3:	83 ec 2c             	sub    $0x2c,%esp
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80fcb6:	bb 00 00 00 00       	mov    $0x0,%ebx
  80fcbb:	b8 08 00 00 00       	mov    $0x8,%eax
  80fcc0:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80fcc3:	8b 55 08             	mov    0x8(%ebp),%edx
  80fcc6:	89 df                	mov    %ebx,%edi
  80fcc8:	89 de                	mov    %ebx,%esi
  80fcca:	cd 30                	int    $0x30
		       "b" (a3),
		       "D" (a4),
		       "S" (a5)
		     : "cc", "memory");

	if(check && ret > 0)
  80fccc:	85 c0                	test   %eax,%eax
  80fcce:	7e 28                	jle    80fcf8 <sys_env_set_status+0x4b>
		panic("syscall %d returned %d (> 0)", num, ret);
  80fcd0:	89 44 24 10          	mov    %eax,0x10(%esp)
  80fcd4:	c7 44 24 0c 08 00 00 	movl   $0x8,0xc(%esp)
  80fcdb:	00 
  80fcdc:	c7 44 24 08 9f 44 81 	movl   $0x81449f,0x8(%esp)
  80fce3:	00 
  80fce4:	c7 44 24 04 23 00 00 	movl   $0x23,0x4(%esp)
  80fceb:	00 
  80fcec:	c7 04 24 bc 44 81 00 	movl   $0x8144bc,(%esp)
  80fcf3:	e8 82 f3 ff ff       	call   80f07a <_panic>

int
sys_env_set_status(envid_t envid, int status)
{
	return syscall(SYS_env_set_status, 1, envid, status, 0, 0, 0);
}
  80fcf8:	83 c4 2c             	add    $0x2c,%esp
  80fcfb:	5b                   	pop    %ebx
  80fcfc:	5e                   	pop    %esi
  80fcfd:	5f                   	pop    %edi
  80fcfe:	5d                   	pop    %ebp
  80fcff:	c3                   	ret    

0080fd00 <sys_env_set_trapframe>:

int
sys_env_set_trapframe(envid_t envid, struct Trapframe *tf)
{
  80fd00:	55                   	push   %ebp
  80fd01:	89 e5                	mov    %esp,%ebp
  80fd03:	57                   	push   %edi
  80fd04:	56                   	push   %esi
  80fd05:	53                   	push   %ebx
  80fd06:	83 ec 2c             	sub    $0x2c,%esp
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80fd09:	bb 00 00 00 00       	mov    $0x0,%ebx
  80fd0e:	b8 09 00 00 00       	mov    $0x9,%eax
  80fd13:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80fd16:	8b 55 08             	mov    0x8(%ebp),%edx
  80fd19:	89 df                	mov    %ebx,%edi
  80fd1b:	89 de                	mov    %ebx,%esi
  80fd1d:	cd 30                	int    $0x30
		       "b" (a3),
		       "D" (a4),
		       "S" (a5)
		     : "cc", "memory");

	if(check && ret > 0)
  80fd1f:	85 c0                	test   %eax,%eax
  80fd21:	7e 28                	jle    80fd4b <sys_env_set_trapframe+0x4b>
		panic("syscall %d returned %d (> 0)", num, ret);
  80fd23:	89 44 24 10          	mov    %eax,0x10(%esp)
  80fd27:	c7 44 24 0c 09 00 00 	movl   $0x9,0xc(%esp)
  80fd2e:	00 
  80fd2f:	c7 44 24 08 9f 44 81 	movl   $0x81449f,0x8(%esp)
  80fd36:	00 
  80fd37:	c7 44 24 04 23 00 00 	movl   $0x23,0x4(%esp)
  80fd3e:	00 
  80fd3f:	c7 04 24 bc 44 81 00 	movl   $0x8144bc,(%esp)
  80fd46:	e8 2f f3 ff ff       	call   80f07a <_panic>

int
sys_env_set_trapframe(envid_t envid, struct Trapframe *tf)
{
	return syscall(SYS_env_set_trapframe, 1, envid, (uint32_t) tf, 0, 0, 0);
}
  80fd4b:	83 c4 2c             	add    $0x2c,%esp
  80fd4e:	5b                   	pop    %ebx
  80fd4f:	5e                   	pop    %esi
  80fd50:	5f                   	pop    %edi
  80fd51:	5d                   	pop    %ebp
  80fd52:	c3                   	ret    

0080fd53 <sys_env_set_pgfault_upcall>:

int
sys_env_set_pgfault_upcall(envid_t envid, void *upcall)
{
  80fd53:	55                   	push   %ebp
  80fd54:	89 e5                	mov    %esp,%ebp
  80fd56:	57                   	push   %edi
  80fd57:	56                   	push   %esi
  80fd58:	53                   	push   %ebx
  80fd59:	83 ec 2c             	sub    $0x2c,%esp
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80fd5c:	bb 00 00 00 00       	mov    $0x0,%ebx
  80fd61:	b8 0a 00 00 00       	mov    $0xa,%eax
  80fd66:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80fd69:	8b 55 08             	mov    0x8(%ebp),%edx
  80fd6c:	89 df                	mov    %ebx,%edi
  80fd6e:	89 de                	mov    %ebx,%esi
  80fd70:	cd 30                	int    $0x30
		       "b" (a3),
		       "D" (a4),
		       "S" (a5)
		     : "cc", "memory");

	if(check && ret > 0)
  80fd72:	85 c0                	test   %eax,%eax
  80fd74:	7e 28                	jle    80fd9e <sys_env_set_pgfault_upcall+0x4b>
		panic("syscall %d returned %d (> 0)", num, ret);
  80fd76:	89 44 24 10          	mov    %eax,0x10(%esp)
  80fd7a:	c7 44 24 0c 0a 00 00 	movl   $0xa,0xc(%esp)
  80fd81:	00 
  80fd82:	c7 44 24 08 9f 44 81 	movl   $0x81449f,0x8(%esp)
  80fd89:	00 
  80fd8a:	c7 44 24 04 23 00 00 	movl   $0x23,0x4(%esp)
  80fd91:	00 
  80fd92:	c7 04 24 bc 44 81 00 	movl   $0x8144bc,(%esp)
  80fd99:	e8 dc f2 ff ff       	call   80f07a <_panic>

int
sys_env_set_pgfault_upcall(envid_t envid, void *upcall)
{
	return syscall(SYS_env_set_pgfault_upcall, 1, envid, (uint32_t) upcall, 0, 0, 0);
}
  80fd9e:	83 c4 2c             	add    $0x2c,%esp
  80fda1:	5b                   	pop    %ebx
  80fda2:	5e                   	pop    %esi
  80fda3:	5f                   	pop    %edi
  80fda4:	5d                   	pop    %ebp
  80fda5:	c3                   	ret    

0080fda6 <sys_ipc_try_send>:

int
sys_ipc_try_send(envid_t envid, uint32_t value, void *srcva, int perm)
{
  80fda6:	55                   	push   %ebp
  80fda7:	89 e5                	mov    %esp,%ebp
  80fda9:	57                   	push   %edi
  80fdaa:	56                   	push   %esi
  80fdab:	53                   	push   %ebx
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80fdac:	be 00 00 00 00       	mov    $0x0,%esi
  80fdb1:	b8 0c 00 00 00       	mov    $0xc,%eax
  80fdb6:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80fdb9:	8b 55 08             	mov    0x8(%ebp),%edx
  80fdbc:	8b 5d 10             	mov    0x10(%ebp),%ebx
  80fdbf:	8b 7d 14             	mov    0x14(%ebp),%edi
  80fdc2:	cd 30                	int    $0x30

int
sys_ipc_try_send(envid_t envid, uint32_t value, void *srcva, int perm)
{
	return syscall(SYS_ipc_try_send, 0, envid, value, (uint32_t) srcva, perm, 0);
}
  80fdc4:	5b                   	pop    %ebx
  80fdc5:	5e                   	pop    %esi
  80fdc6:	5f                   	pop    %edi
  80fdc7:	5d                   	pop    %ebp
  80fdc8:	c3                   	ret    

0080fdc9 <sys_ipc_recv>:

int
sys_ipc_recv(void *dstva)
{
  80fdc9:	55                   	push   %ebp
  80fdca:	89 e5                	mov    %esp,%ebp
  80fdcc:	57                   	push   %edi
  80fdcd:	56                   	push   %esi
  80fdce:	53                   	push   %ebx
  80fdcf:	83 ec 2c             	sub    $0x2c,%esp
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80fdd2:	b9 00 00 00 00       	mov    $0x0,%ecx
  80fdd7:	b8 0d 00 00 00       	mov    $0xd,%eax
  80fddc:	8b 55 08             	mov    0x8(%ebp),%edx
  80fddf:	89 cb                	mov    %ecx,%ebx
  80fde1:	89 cf                	mov    %ecx,%edi
  80fde3:	89 ce                	mov    %ecx,%esi
  80fde5:	cd 30                	int    $0x30
		       "b" (a3),
		       "D" (a4),
		       "S" (a5)
		     : "cc", "memory");

	if(check && ret > 0)
  80fde7:	85 c0                	test   %eax,%eax
  80fde9:	7e 28                	jle    80fe13 <sys_ipc_recv+0x4a>
		panic("syscall %d returned %d (> 0)", num, ret);
  80fdeb:	89 44 24 10          	mov    %eax,0x10(%esp)
  80fdef:	c7 44 24 0c 0d 00 00 	movl   $0xd,0xc(%esp)
  80fdf6:	00 
  80fdf7:	c7 44 24 08 9f 44 81 	movl   $0x81449f,0x8(%esp)
  80fdfe:	00 
  80fdff:	c7 44 24 04 23 00 00 	movl   $0x23,0x4(%esp)
  80fe06:	00 
  80fe07:	c7 04 24 bc 44 81 00 	movl   $0x8144bc,(%esp)
  80fe0e:	e8 67 f2 ff ff       	call   80f07a <_panic>

int
sys_ipc_recv(void *dstva)
{
	return syscall(SYS_ipc_recv, 1, (uint32_t)dstva, 0, 0, 0, 0);
}
  80fe13:	83 c4 2c             	add    $0x2c,%esp
  80fe16:	5b                   	pop    %ebx
  80fe17:	5e                   	pop    %esi
  80fe18:	5f                   	pop    %edi
  80fe19:	5d                   	pop    %ebp
  80fe1a:	c3                   	ret    

0080fe1b <sys_time_msec>:

unsigned int
sys_time_msec(void)
{
  80fe1b:	55                   	push   %ebp
  80fe1c:	89 e5                	mov    %esp,%ebp
  80fe1e:	57                   	push   %edi
  80fe1f:	56                   	push   %esi
  80fe20:	53                   	push   %ebx
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80fe21:	ba 00 00 00 00       	mov    $0x0,%edx
  80fe26:	b8 0e 00 00 00       	mov    $0xe,%eax
  80fe2b:	89 d1                	mov    %edx,%ecx
  80fe2d:	89 d3                	mov    %edx,%ebx
  80fe2f:	89 d7                	mov    %edx,%edi
  80fe31:	89 d6                	mov    %edx,%esi
  80fe33:	cd 30                	int    $0x30

unsigned int
sys_time_msec(void)
{
	return (unsigned int) syscall(SYS_time_msec, 0, 0, 0, 0, 0, 0);
}
  80fe35:	5b                   	pop    %ebx
  80fe36:	5e                   	pop    %esi
  80fe37:	5f                   	pop    %edi
  80fe38:	5d                   	pop    %ebp
  80fe39:	c3                   	ret    

0080fe3a <sys_try_send_packet>:

int
sys_try_send_packet(void* packetva, int size)
{
  80fe3a:	55                   	push   %ebp
  80fe3b:	89 e5                	mov    %esp,%ebp
  80fe3d:	57                   	push   %edi
  80fe3e:	56                   	push   %esi
  80fe3f:	53                   	push   %ebx
  80fe40:	83 ec 2c             	sub    $0x2c,%esp
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80fe43:	bb 00 00 00 00       	mov    $0x0,%ebx
  80fe48:	b8 0f 00 00 00       	mov    $0xf,%eax
  80fe4d:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80fe50:	8b 55 08             	mov    0x8(%ebp),%edx
  80fe53:	89 df                	mov    %ebx,%edi
  80fe55:	89 de                	mov    %ebx,%esi
  80fe57:	cd 30                	int    $0x30
		       "b" (a3),
		       "D" (a4),
		       "S" (a5)
		     : "cc", "memory");

	if(check && ret > 0)
  80fe59:	85 c0                	test   %eax,%eax
  80fe5b:	7e 28                	jle    80fe85 <sys_try_send_packet+0x4b>
		panic("syscall %d returned %d (> 0)", num, ret);
  80fe5d:	89 44 24 10          	mov    %eax,0x10(%esp)
  80fe61:	c7 44 24 0c 0f 00 00 	movl   $0xf,0xc(%esp)
  80fe68:	00 
  80fe69:	c7 44 24 08 9f 44 81 	movl   $0x81449f,0x8(%esp)
  80fe70:	00 
  80fe71:	c7 44 24 04 23 00 00 	movl   $0x23,0x4(%esp)
  80fe78:	00 
  80fe79:	c7 04 24 bc 44 81 00 	movl   $0x8144bc,(%esp)
  80fe80:	e8 f5 f1 ff ff       	call   80f07a <_panic>

int
sys_try_send_packet(void* packetva, int size)
{
	return syscall(SYS_try_send_packet, 1, (uint32_t) packetva, size, 0, 0, 0);
}
  80fe85:	83 c4 2c             	add    $0x2c,%esp
  80fe88:	5b                   	pop    %ebx
  80fe89:	5e                   	pop    %esi
  80fe8a:	5f                   	pop    %edi
  80fe8b:	5d                   	pop    %ebp
  80fe8c:	c3                   	ret    

0080fe8d <sys_try_recv_packet>:

int
sys_try_recv_packet(void** packet_dst, int* size_store)
{
  80fe8d:	55                   	push   %ebp
  80fe8e:	89 e5                	mov    %esp,%ebp
  80fe90:	57                   	push   %edi
  80fe91:	56                   	push   %esi
  80fe92:	53                   	push   %ebx
  80fe93:	83 ec 2c             	sub    $0x2c,%esp
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80fe96:	bb 00 00 00 00       	mov    $0x0,%ebx
  80fe9b:	b8 10 00 00 00       	mov    $0x10,%eax
  80fea0:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80fea3:	8b 55 08             	mov    0x8(%ebp),%edx
  80fea6:	89 df                	mov    %ebx,%edi
  80fea8:	89 de                	mov    %ebx,%esi
  80feaa:	cd 30                	int    $0x30
		       "b" (a3),
		       "D" (a4),
		       "S" (a5)
		     : "cc", "memory");

	if(check && ret > 0)
  80feac:	85 c0                	test   %eax,%eax
  80feae:	7e 28                	jle    80fed8 <sys_try_recv_packet+0x4b>
		panic("syscall %d returned %d (> 0)", num, ret);
  80feb0:	89 44 24 10          	mov    %eax,0x10(%esp)
  80feb4:	c7 44 24 0c 10 00 00 	movl   $0x10,0xc(%esp)
  80febb:	00 
  80febc:	c7 44 24 08 9f 44 81 	movl   $0x81449f,0x8(%esp)
  80fec3:	00 
  80fec4:	c7 44 24 04 23 00 00 	movl   $0x23,0x4(%esp)
  80fecb:	00 
  80fecc:	c7 04 24 bc 44 81 00 	movl   $0x8144bc,(%esp)
  80fed3:	e8 a2 f1 ff ff       	call   80f07a <_panic>

int
sys_try_recv_packet(void** packet_dst, int* size_store)
{
	return syscall(SYS_try_recv_packet, 1, (uint32_t) packet_dst, (uint32_t)size_store, 0, 0, 0);
}
  80fed8:	83 c4 2c             	add    $0x2c,%esp
  80fedb:	5b                   	pop    %ebx
  80fedc:	5e                   	pop    %esi
  80fedd:	5f                   	pop    %edi
  80fede:	5d                   	pop    %ebp
  80fedf:	c3                   	ret    

0080fee0 <pgfault>:
// Custom page fault handler - if faulting page is copy-on-write,
// map in our own private writable copy.
//
static void
pgfault(struct UTrapframe *utf)
{
  80fee0:	55                   	push   %ebp
  80fee1:	89 e5                	mov    %esp,%ebp
  80fee3:	56                   	push   %esi
  80fee4:	53                   	push   %ebx
  80fee5:	83 ec 20             	sub    $0x20,%esp
  80fee8:	8b 45 08             	mov    0x8(%ebp),%eax
	void *addr = (void *) utf->utf_fault_va;
  80feeb:	8b 30                	mov    (%eax),%esi
	//   Use the read-only page table mappings at uvpt
	//   (see <inc/memlayout.h>).

	// LAB 4: Your code here.

	if(!(err & FEC_WR)) {
  80feed:	f6 40 04 02          	testb  $0x2,0x4(%eax)
  80fef1:	75 20                	jne    80ff13 <pgfault+0x33>
		panic("0x%x Not a write", addr);
  80fef3:	89 74 24 0c          	mov    %esi,0xc(%esp)
  80fef7:	c7 44 24 08 ca 44 81 	movl   $0x8144ca,0x8(%esp)
  80fefe:	00 
  80feff:	c7 44 24 04 20 00 00 	movl   $0x20,0x4(%esp)
  80ff06:	00 
  80ff07:	c7 04 24 db 44 81 00 	movl   $0x8144db,(%esp)
  80ff0e:	e8 67 f1 ff ff       	call   80f07a <_panic>
	}

	if(!(uvpt[PGNUM(addr)] & PTE_COW)) {
  80ff13:	89 f0                	mov    %esi,%eax
  80ff15:	c1 e8 0c             	shr    $0xc,%eax
  80ff18:	8b 04 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%eax
  80ff1f:	f6 c4 08             	test   $0x8,%ah
  80ff22:	75 1c                	jne    80ff40 <pgfault+0x60>
		panic("Not a COW page");
  80ff24:	c7 44 24 08 e6 44 81 	movl   $0x8144e6,0x8(%esp)
  80ff2b:	00 
  80ff2c:	c7 44 24 04 24 00 00 	movl   $0x24,0x4(%esp)
  80ff33:	00 
  80ff34:	c7 04 24 db 44 81 00 	movl   $0x8144db,(%esp)
  80ff3b:	e8 3a f1 ff ff       	call   80f07a <_panic>

	// Allocate a new page, map it at a temporary location (PFTEMP), // copy the data from the old page to the new page, then move the new
	// page to the old page's address.
	// Hint:
	//   You should make three system calls.
	envid_t envid = sys_getenvid();
  80ff40:	e8 30 fc ff ff       	call   80fb75 <sys_getenvid>
  80ff45:	89 c3                	mov    %eax,%ebx
	r = sys_page_alloc(envid, PFTEMP, PTE_W | PTE_U | PTE_P);
  80ff47:	c7 44 24 08 07 00 00 	movl   $0x7,0x8(%esp)
  80ff4e:	00 
  80ff4f:	c7 44 24 04 00 f0 7f 	movl   $0x7ff000,0x4(%esp)
  80ff56:	00 
  80ff57:	89 04 24             	mov    %eax,(%esp)
  80ff5a:	e8 54 fc ff ff       	call   80fbb3 <sys_page_alloc>
	if(r < 0) {
  80ff5f:	85 c0                	test   %eax,%eax
  80ff61:	79 1c                	jns    80ff7f <pgfault+0x9f>
		panic("couldn't allocate page");
  80ff63:	c7 44 24 08 f5 44 81 	movl   $0x8144f5,0x8(%esp)
  80ff6a:	00 
  80ff6b:	c7 44 24 04 2e 00 00 	movl   $0x2e,0x4(%esp)
  80ff72:	00 
  80ff73:	c7 04 24 db 44 81 00 	movl   $0x8144db,(%esp)
  80ff7a:	e8 fb f0 ff ff       	call   80f07a <_panic>
	}

	memmove(PFTEMP, ROUNDDOWN(addr, PGSIZE), PGSIZE);
  80ff7f:	81 e6 00 f0 ff ff    	and    $0xfffff000,%esi
  80ff85:	c7 44 24 08 00 10 00 	movl   $0x1000,0x8(%esp)
  80ff8c:	00 
  80ff8d:	89 74 24 04          	mov    %esi,0x4(%esp)
  80ff91:	c7 04 24 00 f0 7f 00 	movl   $0x7ff000,(%esp)
  80ff98:	e8 97 f9 ff ff       	call   80f934 <memmove>

	r = sys_page_map(envid, PFTEMP, envid, ROUNDDOWN(addr,PGSIZE), PTE_P | PTE_U | PTE_W);
  80ff9d:	c7 44 24 10 07 00 00 	movl   $0x7,0x10(%esp)
  80ffa4:	00 
  80ffa5:	89 74 24 0c          	mov    %esi,0xc(%esp)
  80ffa9:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  80ffad:	c7 44 24 04 00 f0 7f 	movl   $0x7ff000,0x4(%esp)
  80ffb4:	00 
  80ffb5:	89 1c 24             	mov    %ebx,(%esp)
  80ffb8:	e8 4a fc ff ff       	call   80fc07 <sys_page_map>
	if(r < 0) {
  80ffbd:	85 c0                	test   %eax,%eax
  80ffbf:	79 1c                	jns    80ffdd <pgfault+0xfd>
		panic("couldn't map page");
  80ffc1:	c7 44 24 08 0c 45 81 	movl   $0x81450c,0x8(%esp)
  80ffc8:	00 
  80ffc9:	c7 44 24 04 35 00 00 	movl   $0x35,0x4(%esp)
  80ffd0:	00 
  80ffd1:	c7 04 24 db 44 81 00 	movl   $0x8144db,(%esp)
  80ffd8:	e8 9d f0 ff ff       	call   80f07a <_panic>
	}
}
  80ffdd:	83 c4 20             	add    $0x20,%esp
  80ffe0:	5b                   	pop    %ebx
  80ffe1:	5e                   	pop    %esi
  80ffe2:	5d                   	pop    %ebp
  80ffe3:	c3                   	ret    

0080ffe4 <fork>:
//   Neither user exception stack should ever be marked copy-on-write,
//   so you must allocate a new page for the child's user exception stack.
//
envid_t
fork(void)
{
  80ffe4:	55                   	push   %ebp
  80ffe5:	89 e5                	mov    %esp,%ebp
  80ffe7:	57                   	push   %edi
  80ffe8:	56                   	push   %esi
  80ffe9:	53                   	push   %ebx
  80ffea:	83 ec 3c             	sub    $0x3c,%esp
	envid_t envid;
	uintptr_t addr;
	int r = 0;

	set_pgfault_handler(pgfault);
  80ffed:	c7 04 24 e0 fe 80 00 	movl   $0x80fee0,(%esp)
  80fff4:	e8 6d 18 00 00       	call   811866 <set_pgfault_handler>
// This must be inlined.  Exercise for reader: why?
static inline envid_t __attribute__((always_inline))
sys_exofork(void)
{
	envid_t ret;
	asm volatile("int %2"
  80fff9:	b8 07 00 00 00       	mov    $0x7,%eax
  80fffe:	cd 30                	int    $0x30
  810000:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  810003:	89 45 d8             	mov    %eax,-0x28(%ebp)

	envid = sys_exofork();
	if(envid == 0) {
  810006:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  81000d:	bf 00 00 00 00       	mov    $0x0,%edi
  810012:	85 c0                	test   %eax,%eax
  810014:	75 21                	jne    810037 <fork+0x53>
		thisenv = &envs[ENVX(sys_getenvid())];
  810016:	e8 5a fb ff ff       	call   80fb75 <sys_getenvid>
  81001b:	25 ff 03 00 00       	and    $0x3ff,%eax
  810020:	6b c0 7c             	imul   $0x7c,%eax,%eax
  810023:	05 00 00 c0 ee       	add    $0xeec00000,%eax
  810028:	a3 7c c2 b3 00       	mov    %eax,0xb3c27c
		return 0;
  81002d:	b8 00 00 00 00       	mov    $0x0,%eax
  810032:	e9 8d 01 00 00       	jmp    8101c4 <fork+0x1e0>
	}

	for(addr = 0; addr < UTOP - PGSIZE; addr +=PGSIZE) {
		if(uvpd[PDX(addr)] && PTE_P && uvpt[PGNUM(addr)])  {
  810037:	89 f8                	mov    %edi,%eax
  810039:	c1 e8 16             	shr    $0x16,%eax
  81003c:	8b 04 85 00 d0 7b ef 	mov    -0x10843000(,%eax,4),%eax
  810043:	85 c0                	test   %eax,%eax
  810045:	0f 84 02 01 00 00    	je     81014d <fork+0x169>
  81004b:	89 fa                	mov    %edi,%edx
  81004d:	c1 ea 0c             	shr    $0xc,%edx
  810050:	8b 04 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%eax
  810057:	85 c0                	test   %eax,%eax
  810059:	0f 84 ee 00 00 00    	je     81014d <fork+0x169>
//
static int
duppage(envid_t envid, unsigned pn)
{

	if(!(uvpd[PDX(pn*PGSIZE)] & PTE_P)) return 0;
  81005f:	89 d6                	mov    %edx,%esi
  810061:	c1 e6 0c             	shl    $0xc,%esi
  810064:	89 f0                	mov    %esi,%eax
  810066:	c1 e8 16             	shr    $0x16,%eax
  810069:	8b 0c 85 00 d0 7b ef 	mov    -0x10843000(,%eax,4),%ecx
  810070:	b8 00 00 00 00       	mov    $0x0,%eax
  810075:	f6 c1 01             	test   $0x1,%cl
  810078:	0f 84 cc 00 00 00    	je     81014a <fork+0x166>

	int all_perms = PTE_U | PTE_P | PTE_AVAIL | PTE_W | PTE_COW;
	int orig_perms = uvpt[pn] & all_perms;
  81007e:	8b 1c 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%ebx
  810085:	89 d8                	mov    %ebx,%eax
  810087:	25 07 0e 00 00       	and    $0xe07,%eax
  81008c:	89 45 e0             	mov    %eax,-0x20(%ebp)

	if(!(orig_perms & PTE_P)) return 0;
  81008f:	89 d8                	mov    %ebx,%eax
  810091:	83 e0 01             	and    $0x1,%eax
  810094:	0f 84 b0 00 00 00    	je     81014a <fork+0x166>

	int r = 0;
	envid_t curenvid = sys_getenvid();
  81009a:	e8 d6 fa ff ff       	call   80fb75 <sys_getenvid>
  81009f:	89 45 dc             	mov    %eax,-0x24(%ebp)


	if(orig_perms & PTE_SHARE) {
  8100a2:	f7 45 e0 00 04 00 00 	testl  $0x400,-0x20(%ebp)
  8100a9:	74 28                	je     8100d3 <fork+0xef>
		r += sys_page_map(curenvid, (void *) (pn*PGSIZE), envid, (void *) (pn*PGSIZE), (orig_perms & PTE_SYSCALL));
  8100ab:	8b 45 e0             	mov    -0x20(%ebp),%eax
  8100ae:	25 07 0e 00 00       	and    $0xe07,%eax
  8100b3:	89 44 24 10          	mov    %eax,0x10(%esp)
  8100b7:	89 74 24 0c          	mov    %esi,0xc(%esp)
  8100bb:	8b 45 d8             	mov    -0x28(%ebp),%eax
  8100be:	89 44 24 08          	mov    %eax,0x8(%esp)
  8100c2:	89 74 24 04          	mov    %esi,0x4(%esp)
  8100c6:	8b 45 dc             	mov    -0x24(%ebp),%eax
  8100c9:	89 04 24             	mov    %eax,(%esp)
  8100cc:	e8 36 fb ff ff       	call   80fc07 <sys_page_map>
  8100d1:	eb 77                	jmp    81014a <fork+0x166>

	} else if(((orig_perms) & PTE_COW) || (orig_perms & PTE_W) ) {
  8100d3:	f7 c3 02 08 00 00    	test   $0x802,%ebx
  8100d9:	74 4e                	je     810129 <fork+0x145>
		r += sys_page_map(curenvid, (void *) (pn*PGSIZE), envid, (void *) (pn*PGSIZE), (orig_perms | PTE_COW) & (~PTE_W));
  8100db:	8b 45 e0             	mov    -0x20(%ebp),%eax
  8100de:	25 fd f7 ff ff       	and    $0xfffff7fd,%eax
  8100e3:	80 cc 08             	or     $0x8,%ah
  8100e6:	89 c3                	mov    %eax,%ebx
  8100e8:	89 44 24 10          	mov    %eax,0x10(%esp)
  8100ec:	89 74 24 0c          	mov    %esi,0xc(%esp)
  8100f0:	8b 45 d8             	mov    -0x28(%ebp),%eax
  8100f3:	89 44 24 08          	mov    %eax,0x8(%esp)
  8100f7:	89 74 24 04          	mov    %esi,0x4(%esp)
  8100fb:	8b 45 dc             	mov    -0x24(%ebp),%eax
  8100fe:	89 04 24             	mov    %eax,(%esp)
  810101:	e8 01 fb ff ff       	call   80fc07 <sys_page_map>
  810106:	89 45 e0             	mov    %eax,-0x20(%ebp)

		r += sys_page_map(curenvid, (void *) (pn*PGSIZE), curenvid, (void *) (pn*PGSIZE), (orig_perms | PTE_COW) & (~PTE_W));
  810109:	89 5c 24 10          	mov    %ebx,0x10(%esp)
  81010d:	89 74 24 0c          	mov    %esi,0xc(%esp)
  810111:	8b 4d dc             	mov    -0x24(%ebp),%ecx
  810114:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  810118:	89 74 24 04          	mov    %esi,0x4(%esp)
  81011c:	89 0c 24             	mov    %ecx,(%esp)
  81011f:	e8 e3 fa ff ff       	call   80fc07 <sys_page_map>
  810124:	03 45 e0             	add    -0x20(%ebp),%eax
  810127:	eb 21                	jmp    81014a <fork+0x166>

	} else {
		r = sys_page_map(curenvid, (void *) (pn*PGSIZE), envid, (void *) (pn*PGSIZE), orig_perms);
  810129:	8b 45 e0             	mov    -0x20(%ebp),%eax
  81012c:	89 44 24 10          	mov    %eax,0x10(%esp)
  810130:	89 74 24 0c          	mov    %esi,0xc(%esp)
  810134:	8b 45 d8             	mov    -0x28(%ebp),%eax
  810137:	89 44 24 08          	mov    %eax,0x8(%esp)
  81013b:	89 74 24 04          	mov    %esi,0x4(%esp)
  81013f:	8b 45 dc             	mov    -0x24(%ebp),%eax
  810142:	89 04 24             	mov    %eax,(%esp)
  810145:	e8 bd fa ff ff       	call   80fc07 <sys_page_map>
		return 0;
	}

	for(addr = 0; addr < UTOP - PGSIZE; addr +=PGSIZE) {
		if(uvpd[PDX(addr)] && PTE_P && uvpt[PGNUM(addr)])  {
			r += duppage(envid, PGNUM(addr));
  81014a:	01 45 e4             	add    %eax,-0x1c(%ebp)
	if(envid == 0) {
		thisenv = &envs[ENVX(sys_getenvid())];
		return 0;
	}

	for(addr = 0; addr < UTOP - PGSIZE; addr +=PGSIZE) {
  81014d:	81 c7 00 10 00 00    	add    $0x1000,%edi
  810153:	81 ff 00 f0 bf ee    	cmp    $0xeebff000,%edi
  810159:	0f 85 d8 fe ff ff    	jne    810037 <fork+0x53>
		if(uvpd[PDX(addr)] && PTE_P && uvpt[PGNUM(addr)])  {
			r += duppage(envid, PGNUM(addr));
		}
	}

	r+=sys_page_alloc(envid, (void*)UXSTACKTOP - PGSIZE, PTE_P|PTE_U|PTE_W);
  81015f:	c7 44 24 08 07 00 00 	movl   $0x7,0x8(%esp)
  810166:	00 
  810167:	c7 44 24 04 00 f0 bf 	movl   $0xeebff000,0x4(%esp)
  81016e:	ee 
  81016f:	8b 75 d4             	mov    -0x2c(%ebp),%esi
  810172:	89 34 24             	mov    %esi,(%esp)
  810175:	e8 39 fa ff ff       	call   80fbb3 <sys_page_alloc>
  81017a:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
  81017d:	01 c3                	add    %eax,%ebx
	r+=sys_env_set_pgfault_upcall(envid, _pgfault_upcall);
  81017f:	c7 44 24 04 b3 18 81 	movl   $0x8118b3,0x4(%esp)
  810186:	00 
  810187:	89 34 24             	mov    %esi,(%esp)
  81018a:	e8 c4 fb ff ff       	call   80fd53 <sys_env_set_pgfault_upcall>
  81018f:	01 c3                	add    %eax,%ebx
	r+= sys_env_set_status(envid, ENV_RUNNABLE);
  810191:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
  810198:	00 
  810199:	89 34 24             	mov    %esi,(%esp)
  81019c:	e8 0c fb ff ff       	call   80fcad <sys_env_set_status>

	if(r<0) {
  8101a1:	01 d8                	add    %ebx,%eax
  8101a3:	79 1c                	jns    8101c1 <fork+0x1dd>
	 panic("fork failed!");
  8101a5:	c7 44 24 08 1e 45 81 	movl   $0x81451e,0x8(%esp)
  8101ac:	00 
  8101ad:	c7 44 24 04 8c 00 00 	movl   $0x8c,0x4(%esp)
  8101b4:	00 
  8101b5:	c7 04 24 db 44 81 00 	movl   $0x8144db,(%esp)
  8101bc:	e8 b9 ee ff ff       	call   80f07a <_panic>
	}

	return envid;
  8101c1:	8b 45 d4             	mov    -0x2c(%ebp),%eax
}
  8101c4:	83 c4 3c             	add    $0x3c,%esp
  8101c7:	5b                   	pop    %ebx
  8101c8:	5e                   	pop    %esi
  8101c9:	5f                   	pop    %edi
  8101ca:	5d                   	pop    %ebp
  8101cb:	c3                   	ret    

008101cc <sfork>:

// Challenge!
int
sfork(void)
{
  8101cc:	55                   	push   %ebp
  8101cd:	89 e5                	mov    %esp,%ebp
  8101cf:	83 ec 18             	sub    $0x18,%esp
	panic("sfork not implemented");
  8101d2:	c7 44 24 08 2b 45 81 	movl   $0x81452b,0x8(%esp)
  8101d9:	00 
  8101da:	c7 44 24 04 96 00 00 	movl   $0x96,0x4(%esp)
  8101e1:	00 
  8101e2:	c7 04 24 db 44 81 00 	movl   $0x8144db,(%esp)
  8101e9:	e8 8c ee ff ff       	call   80f07a <_panic>
  8101ee:	66 90                	xchg   %ax,%ax

008101f0 <ipc_recv>:
//   If 'pg' is null, pass sys_ipc_recv a value that it will understand
//   as meaning "no page".  (Zero is not the right value, since that's
//   a perfectly valid place to map a page.)
int32_t
ipc_recv(envid_t *from_env_store, void *pg, int *perm_store)
{
  8101f0:	55                   	push   %ebp
  8101f1:	89 e5                	mov    %esp,%ebp
  8101f3:	56                   	push   %esi
  8101f4:	53                   	push   %ebx
  8101f5:	83 ec 10             	sub    $0x10,%esp
  8101f8:	8b 75 08             	mov    0x8(%ebp),%esi
  8101fb:	8b 45 0c             	mov    0xc(%ebp),%eax
  8101fe:	8b 5d 10             	mov    0x10(%ebp),%ebx
	if(pg == NULL) {
		pg = (void *) UTOP;
  810201:	85 c0                	test   %eax,%eax
  810203:	ba 00 00 c0 ee       	mov    $0xeec00000,%edx
  810208:	0f 44 c2             	cmove  %edx,%eax
	}

	int ret = sys_ipc_recv(pg);
  81020b:	89 04 24             	mov    %eax,(%esp)
  81020e:	e8 b6 fb ff ff       	call   80fdc9 <sys_ipc_recv>

	if(ret < 0) {
  810213:	85 c0                	test   %eax,%eax
  810215:	79 16                	jns    81022d <ipc_recv+0x3d>
		if(from_env_store) *from_env_store = 0;
  810217:	85 f6                	test   %esi,%esi
  810219:	74 06                	je     810221 <ipc_recv+0x31>
  81021b:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
		if(perm_store) *perm_store = 0;
  810221:	85 db                	test   %ebx,%ebx
  810223:	74 3e                	je     810263 <ipc_recv+0x73>
  810225:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
  81022b:	eb 36                	jmp    810263 <ipc_recv+0x73>
		return ret;
	}

	thisenv = &envs[ENVX(sys_getenvid())];
  81022d:	e8 43 f9 ff ff       	call   80fb75 <sys_getenvid>
  810232:	25 ff 03 00 00       	and    $0x3ff,%eax
  810237:	6b c0 7c             	imul   $0x7c,%eax,%eax
  81023a:	05 00 00 c0 ee       	add    $0xeec00000,%eax
  81023f:	a3 7c c2 b3 00       	mov    %eax,0xb3c27c

	if(from_env_store) *from_env_store = thisenv->env_ipc_from;
  810244:	85 f6                	test   %esi,%esi
  810246:	74 05                	je     81024d <ipc_recv+0x5d>
  810248:	8b 40 74             	mov    0x74(%eax),%eax
  81024b:	89 06                	mov    %eax,(%esi)
	if(perm_store) *perm_store = thisenv->env_ipc_perm;
  81024d:	85 db                	test   %ebx,%ebx
  81024f:	74 0a                	je     81025b <ipc_recv+0x6b>
  810251:	a1 7c c2 b3 00       	mov    0xb3c27c,%eax
  810256:	8b 40 78             	mov    0x78(%eax),%eax
  810259:	89 03                	mov    %eax,(%ebx)
	return thisenv->env_ipc_value;
  81025b:	a1 7c c2 b3 00       	mov    0xb3c27c,%eax
  810260:	8b 40 70             	mov    0x70(%eax),%eax
}
  810263:	83 c4 10             	add    $0x10,%esp
  810266:	5b                   	pop    %ebx
  810267:	5e                   	pop    %esi
  810268:	5d                   	pop    %ebp
  810269:	c3                   	ret    

0081026a <ipc_send>:
//   Use sys_yield() to be CPU-friendly.
//   If 'pg' is null, pass sys_ipc_try_send a value that it will understand
//   as meaning "no page".  (Zero is not the right value.)
void
ipc_send(envid_t to_env, uint32_t val, void *pg, int perm)
{
  81026a:	55                   	push   %ebp
  81026b:	89 e5                	mov    %esp,%ebp
  81026d:	57                   	push   %edi
  81026e:	56                   	push   %esi
  81026f:	53                   	push   %ebx
  810270:	83 ec 1c             	sub    $0x1c,%esp
  810273:	8b 7d 08             	mov    0x8(%ebp),%edi
  810276:	8b 75 0c             	mov    0xc(%ebp),%esi
  810279:	8b 5d 10             	mov    0x10(%ebp),%ebx
	if(pg == NULL) {
  81027c:	85 db                	test   %ebx,%ebx
		pg = (void *) UTOP;
  81027e:	b8 00 00 c0 ee       	mov    $0xeec00000,%eax
  810283:	0f 44 d8             	cmove  %eax,%ebx
	}

	while(true) {
		int ret = sys_ipc_try_send(to_env, val, pg, (unsigned) perm);
  810286:	8b 45 14             	mov    0x14(%ebp),%eax
  810289:	89 44 24 0c          	mov    %eax,0xc(%esp)
  81028d:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  810291:	89 74 24 04          	mov    %esi,0x4(%esp)
  810295:	89 3c 24             	mov    %edi,(%esp)
  810298:	e8 09 fb ff ff       	call   80fda6 <sys_ipc_try_send>

		if(ret >= 0) break;
  81029d:	85 c0                	test   %eax,%eax
  81029f:	79 2c                	jns    8102cd <ipc_send+0x63>

		if(ret != -E_IPC_NOT_RECV) {
  8102a1:	83 f8 f9             	cmp    $0xfffffff9,%eax
  8102a4:	74 20                	je     8102c6 <ipc_send+0x5c>
			panic("Invalid error returned by sys_ipc_try_send %e \n", ret);
  8102a6:	89 44 24 0c          	mov    %eax,0xc(%esp)
  8102aa:	c7 44 24 08 44 45 81 	movl   $0x814544,0x8(%esp)
  8102b1:	00 
  8102b2:	c7 44 24 04 41 00 00 	movl   $0x41,0x4(%esp)
  8102b9:	00 
  8102ba:	c7 04 24 74 45 81 00 	movl   $0x814574,(%esp)
  8102c1:	e8 b4 ed ff ff       	call   80f07a <_panic>
		}
		sys_yield();
  8102c6:	e8 c9 f8 ff ff       	call   80fb94 <sys_yield>
	}
  8102cb:	eb b9                	jmp    810286 <ipc_send+0x1c>
}
  8102cd:	83 c4 1c             	add    $0x1c,%esp
  8102d0:	5b                   	pop    %ebx
  8102d1:	5e                   	pop    %esi
  8102d2:	5f                   	pop    %edi
  8102d3:	5d                   	pop    %ebp
  8102d4:	c3                   	ret    

008102d5 <ipc_find_env>:
// Find the first environment of the given type.  We'll use this to
// find special environments.
// Returns 0 if no such environment exists.
envid_t
ipc_find_env(enum EnvType type)
{
  8102d5:	55                   	push   %ebp
  8102d6:	89 e5                	mov    %esp,%ebp
  8102d8:	8b 4d 08             	mov    0x8(%ebp),%ecx
	int i;
	for (i = 0; i < NENV; i++)
  8102db:	b8 00 00 00 00       	mov    $0x0,%eax
		if (envs[i].env_type == type)
  8102e0:	6b d0 7c             	imul   $0x7c,%eax,%edx
  8102e3:	81 c2 00 00 c0 ee    	add    $0xeec00000,%edx
  8102e9:	8b 52 50             	mov    0x50(%edx),%edx
  8102ec:	39 ca                	cmp    %ecx,%edx
  8102ee:	75 0d                	jne    8102fd <ipc_find_env+0x28>
			return envs[i].env_id;
  8102f0:	6b c0 7c             	imul   $0x7c,%eax,%eax
  8102f3:	05 08 00 c0 ee       	add    $0xeec00008,%eax
  8102f8:	8b 40 40             	mov    0x40(%eax),%eax
  8102fb:	eb 0e                	jmp    81030b <ipc_find_env+0x36>
// Returns 0 if no such environment exists.
envid_t
ipc_find_env(enum EnvType type)
{
	int i;
	for (i = 0; i < NENV; i++)
  8102fd:	83 c0 01             	add    $0x1,%eax
  810300:	3d 00 04 00 00       	cmp    $0x400,%eax
  810305:	75 d9                	jne    8102e0 <ipc_find_env+0xb>
		if (envs[i].env_type == type)
			return envs[i].env_id;
	return 0;
  810307:	66 b8 00 00          	mov    $0x0,%ax
}
  81030b:	5d                   	pop    %ebp
  81030c:	c3                   	ret    
  81030d:	66 90                	xchg   %ax,%ax
  81030f:	90                   	nop

00810310 <fd2num>:
// File descriptor manipulators
// --------------------------------------------------------------

int
fd2num(struct Fd *fd)
{
  810310:	55                   	push   %ebp
  810311:	89 e5                	mov    %esp,%ebp
	return ((uintptr_t) fd - FDTABLE) / PGSIZE;
  810313:	8b 45 08             	mov    0x8(%ebp),%eax
  810316:	05 00 00 00 30       	add    $0x30000000,%eax
  81031b:	c1 e8 0c             	shr    $0xc,%eax
}
  81031e:	5d                   	pop    %ebp
  81031f:	c3                   	ret    

00810320 <fd2data>:

char*
fd2data(struct Fd *fd)
{
  810320:	55                   	push   %ebp
  810321:	89 e5                	mov    %esp,%ebp
// --------------------------------------------------------------

int
fd2num(struct Fd *fd)
{
	return ((uintptr_t) fd - FDTABLE) / PGSIZE;
  810323:	8b 45 08             	mov    0x8(%ebp),%eax
  810326:	05 00 00 00 30       	add    $0x30000000,%eax
}

char*
fd2data(struct Fd *fd)
{
	return INDEX2DATA(fd2num(fd));
  81032b:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  810330:	2d 00 00 fe 2f       	sub    $0x2ffe0000,%eax
}
  810335:	5d                   	pop    %ebp
  810336:	c3                   	ret    

00810337 <fd_alloc>:
// Returns 0 on success, < 0 on error.  Errors are:
//	-E_MAX_FD: no more file descriptors
// On error, *fd_store is set to 0.
int
fd_alloc(struct Fd **fd_store)
{
  810337:	55                   	push   %ebp
  810338:	89 e5                	mov    %esp,%ebp
  81033a:	8b 4d 08             	mov    0x8(%ebp),%ecx
  81033d:	b8 00 00 00 d0       	mov    $0xd0000000,%eax
	int i;
	struct Fd *fd;

	for (i = 0; i < MAXFD; i++) {
		fd = INDEX2FD(i);
		if ((uvpd[PDX(fd)] & PTE_P) == 0 || (uvpt[PGNUM(fd)] & PTE_P) == 0) {
  810342:	89 c2                	mov    %eax,%edx
  810344:	c1 ea 16             	shr    $0x16,%edx
  810347:	8b 14 95 00 d0 7b ef 	mov    -0x10843000(,%edx,4),%edx
  81034e:	f6 c2 01             	test   $0x1,%dl
  810351:	74 11                	je     810364 <fd_alloc+0x2d>
  810353:	89 c2                	mov    %eax,%edx
  810355:	c1 ea 0c             	shr    $0xc,%edx
  810358:	8b 14 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%edx
  81035f:	f6 c2 01             	test   $0x1,%dl
  810362:	75 09                	jne    81036d <fd_alloc+0x36>
			*fd_store = fd;
  810364:	89 01                	mov    %eax,(%ecx)
			return 0;
  810366:	b8 00 00 00 00       	mov    $0x0,%eax
  81036b:	eb 17                	jmp    810384 <fd_alloc+0x4d>
  81036d:	05 00 10 00 00       	add    $0x1000,%eax
fd_alloc(struct Fd **fd_store)
{
	int i;
	struct Fd *fd;

	for (i = 0; i < MAXFD; i++) {
  810372:	3d 00 00 02 d0       	cmp    $0xd0020000,%eax
  810377:	75 c9                	jne    810342 <fd_alloc+0xb>
		if ((uvpd[PDX(fd)] & PTE_P) == 0 || (uvpt[PGNUM(fd)] & PTE_P) == 0) {
			*fd_store = fd;
			return 0;
		}
	}
	*fd_store = 0;
  810379:	c7 01 00 00 00 00    	movl   $0x0,(%ecx)
	return -E_MAX_OPEN;
  81037f:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
}
  810384:	5d                   	pop    %ebp
  810385:	c3                   	ret    

00810386 <fd_lookup>:
// Returns 0 on success (the page is in range and mapped), < 0 on error.
// Errors are:
//	-E_INVAL: fdnum was either not in range or not mapped.
int
fd_lookup(int fdnum, struct Fd **fd_store)
{
  810386:	55                   	push   %ebp
  810387:	89 e5                	mov    %esp,%ebp
  810389:	8b 45 08             	mov    0x8(%ebp),%eax
	struct Fd *fd;

	if (fdnum < 0 || fdnum >= MAXFD) {
  81038c:	83 f8 1f             	cmp    $0x1f,%eax
  81038f:	77 36                	ja     8103c7 <fd_lookup+0x41>
		if (debug)
			cprintf("[%08x] bad fd %d\n", thisenv->env_id, fdnum);
		return -E_INVAL;
	}
	fd = INDEX2FD(fdnum);
  810391:	c1 e0 0c             	shl    $0xc,%eax
  810394:	2d 00 00 00 30       	sub    $0x30000000,%eax
	if (!(uvpd[PDX(fd)] & PTE_P) || !(uvpt[PGNUM(fd)] & PTE_P)) {
  810399:	89 c2                	mov    %eax,%edx
  81039b:	c1 ea 16             	shr    $0x16,%edx
  81039e:	8b 14 95 00 d0 7b ef 	mov    -0x10843000(,%edx,4),%edx
  8103a5:	f6 c2 01             	test   $0x1,%dl
  8103a8:	74 24                	je     8103ce <fd_lookup+0x48>
  8103aa:	89 c2                	mov    %eax,%edx
  8103ac:	c1 ea 0c             	shr    $0xc,%edx
  8103af:	8b 14 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%edx
  8103b6:	f6 c2 01             	test   $0x1,%dl
  8103b9:	74 1a                	je     8103d5 <fd_lookup+0x4f>
		if (debug)
			cprintf("[%08x] closed fd %d\n", thisenv->env_id, fdnum);
		return -E_INVAL;
	}
	*fd_store = fd;
  8103bb:	8b 55 0c             	mov    0xc(%ebp),%edx
  8103be:	89 02                	mov    %eax,(%edx)
	return 0;
  8103c0:	b8 00 00 00 00       	mov    $0x0,%eax
  8103c5:	eb 13                	jmp    8103da <fd_lookup+0x54>
	struct Fd *fd;

	if (fdnum < 0 || fdnum >= MAXFD) {
		if (debug)
			cprintf("[%08x] bad fd %d\n", thisenv->env_id, fdnum);
		return -E_INVAL;
  8103c7:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  8103cc:	eb 0c                	jmp    8103da <fd_lookup+0x54>
	}
	fd = INDEX2FD(fdnum);
	if (!(uvpd[PDX(fd)] & PTE_P) || !(uvpt[PGNUM(fd)] & PTE_P)) {
		if (debug)
			cprintf("[%08x] closed fd %d\n", thisenv->env_id, fdnum);
		return -E_INVAL;
  8103ce:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  8103d3:	eb 05                	jmp    8103da <fd_lookup+0x54>
  8103d5:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
	}
	*fd_store = fd;
	return 0;
}
  8103da:	5d                   	pop    %ebp
  8103db:	c3                   	ret    

008103dc <dev_lookup>:
	0
};

int
dev_lookup(int dev_id, struct Dev **dev)
{
  8103dc:	55                   	push   %ebp
  8103dd:	89 e5                	mov    %esp,%ebp
  8103df:	83 ec 18             	sub    $0x18,%esp
  8103e2:	8b 4d 08             	mov    0x8(%ebp),%ecx
	int i;
	for (i = 0; devtab[i]; i++)
  8103e5:	ba 00 00 00 00       	mov    $0x0,%edx
  8103ea:	eb 13                	jmp    8103ff <dev_lookup+0x23>
		if (devtab[i]->dev_id == dev_id) {
  8103ec:	39 08                	cmp    %ecx,(%eax)
  8103ee:	75 0c                	jne    8103fc <dev_lookup+0x20>
			*dev = devtab[i];
  8103f0:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  8103f3:	89 01                	mov    %eax,(%ecx)
			return 0;
  8103f5:	b8 00 00 00 00       	mov    $0x0,%eax
  8103fa:	eb 38                	jmp    810434 <dev_lookup+0x58>

int
dev_lookup(int dev_id, struct Dev **dev)
{
	int i;
	for (i = 0; devtab[i]; i++)
  8103fc:	83 c2 01             	add    $0x1,%edx
  8103ff:	8b 04 95 fc 45 81 00 	mov    0x8145fc(,%edx,4),%eax
  810406:	85 c0                	test   %eax,%eax
  810408:	75 e2                	jne    8103ec <dev_lookup+0x10>
		if (devtab[i]->dev_id == dev_id) {
			*dev = devtab[i];
			return 0;
		}
	cprintf("[%08x] unknown device type %d\n", thisenv->env_id, dev_id);
  81040a:	a1 7c c2 b3 00       	mov    0xb3c27c,%eax
  81040f:	8b 40 48             	mov    0x48(%eax),%eax
  810412:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  810416:	89 44 24 04          	mov    %eax,0x4(%esp)
  81041a:	c7 04 24 80 45 81 00 	movl   $0x814580,(%esp)
  810421:	e8 4d ed ff ff       	call   80f173 <cprintf>
	*dev = 0;
  810426:	8b 45 0c             	mov    0xc(%ebp),%eax
  810429:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	return -E_INVAL;
  81042f:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
}
  810434:	c9                   	leave  
  810435:	c3                   	ret    

00810436 <fd_close>:
// If 'must_exist' is 1, then fd_close returns -E_INVAL when passed a
// closed or nonexistent file descriptor.
// Returns 0 on success, < 0 on error.
int
fd_close(struct Fd *fd, bool must_exist)
{
  810436:	55                   	push   %ebp
  810437:	89 e5                	mov    %esp,%ebp
  810439:	56                   	push   %esi
  81043a:	53                   	push   %ebx
  81043b:	83 ec 20             	sub    $0x20,%esp
  81043e:	8b 75 08             	mov    0x8(%ebp),%esi
  810441:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	struct Fd *fd2;
	struct Dev *dev;
	int r;
	if ((r = fd_lookup(fd2num(fd), &fd2)) < 0
  810444:	8d 45 f4             	lea    -0xc(%ebp),%eax
  810447:	89 44 24 04          	mov    %eax,0x4(%esp)
// --------------------------------------------------------------

int
fd2num(struct Fd *fd)
{
	return ((uintptr_t) fd - FDTABLE) / PGSIZE;
  81044b:	8d 86 00 00 00 30    	lea    0x30000000(%esi),%eax
  810451:	c1 e8 0c             	shr    $0xc,%eax
fd_close(struct Fd *fd, bool must_exist)
{
	struct Fd *fd2;
	struct Dev *dev;
	int r;
	if ((r = fd_lookup(fd2num(fd), &fd2)) < 0
  810454:	89 04 24             	mov    %eax,(%esp)
  810457:	e8 2a ff ff ff       	call   810386 <fd_lookup>
  81045c:	85 c0                	test   %eax,%eax
  81045e:	78 05                	js     810465 <fd_close+0x2f>
	    || fd != fd2)
  810460:	3b 75 f4             	cmp    -0xc(%ebp),%esi
  810463:	74 0c                	je     810471 <fd_close+0x3b>
		return (must_exist ? r : 0);
  810465:	84 db                	test   %bl,%bl
  810467:	ba 00 00 00 00       	mov    $0x0,%edx
  81046c:	0f 44 c2             	cmove  %edx,%eax
  81046f:	eb 3f                	jmp    8104b0 <fd_close+0x7a>
	if ((r = dev_lookup(fd->fd_dev_id, &dev)) >= 0) {
  810471:	8d 45 f0             	lea    -0x10(%ebp),%eax
  810474:	89 44 24 04          	mov    %eax,0x4(%esp)
  810478:	8b 06                	mov    (%esi),%eax
  81047a:	89 04 24             	mov    %eax,(%esp)
  81047d:	e8 5a ff ff ff       	call   8103dc <dev_lookup>
  810482:	89 c3                	mov    %eax,%ebx
  810484:	85 c0                	test   %eax,%eax
  810486:	78 16                	js     81049e <fd_close+0x68>
		if (dev->dev_close)
  810488:	8b 45 f0             	mov    -0x10(%ebp),%eax
  81048b:	8b 40 10             	mov    0x10(%eax),%eax
			r = (*dev->dev_close)(fd);
		else
			r = 0;
  81048e:	bb 00 00 00 00       	mov    $0x0,%ebx
	int r;
	if ((r = fd_lookup(fd2num(fd), &fd2)) < 0
	    || fd != fd2)
		return (must_exist ? r : 0);
	if ((r = dev_lookup(fd->fd_dev_id, &dev)) >= 0) {
		if (dev->dev_close)
  810493:	85 c0                	test   %eax,%eax
  810495:	74 07                	je     81049e <fd_close+0x68>
			r = (*dev->dev_close)(fd);
  810497:	89 34 24             	mov    %esi,(%esp)
  81049a:	ff d0                	call   *%eax
  81049c:	89 c3                	mov    %eax,%ebx
		else
			r = 0;
	}
	// Make sure fd is unmapped.  Might be a no-op if
	// (*dev->dev_close)(fd) already unmapped it.
	(void) sys_page_unmap(0, fd);
  81049e:	89 74 24 04          	mov    %esi,0x4(%esp)
  8104a2:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8104a9:	e8 ac f7 ff ff       	call   80fc5a <sys_page_unmap>
	return r;
  8104ae:	89 d8                	mov    %ebx,%eax
}
  8104b0:	83 c4 20             	add    $0x20,%esp
  8104b3:	5b                   	pop    %ebx
  8104b4:	5e                   	pop    %esi
  8104b5:	5d                   	pop    %ebp
  8104b6:	c3                   	ret    

008104b7 <close>:
	return -E_INVAL;
}

int
close(int fdnum)
{
  8104b7:	55                   	push   %ebp
  8104b8:	89 e5                	mov    %esp,%ebp
  8104ba:	83 ec 28             	sub    $0x28,%esp
	struct Fd *fd;
	int r;

	if ((r = fd_lookup(fdnum, &fd)) < 0)
  8104bd:	8d 45 f4             	lea    -0xc(%ebp),%eax
  8104c0:	89 44 24 04          	mov    %eax,0x4(%esp)
  8104c4:	8b 45 08             	mov    0x8(%ebp),%eax
  8104c7:	89 04 24             	mov    %eax,(%esp)
  8104ca:	e8 b7 fe ff ff       	call   810386 <fd_lookup>
  8104cf:	89 c2                	mov    %eax,%edx
  8104d1:	85 d2                	test   %edx,%edx
  8104d3:	78 13                	js     8104e8 <close+0x31>
		return r;
	else
		return fd_close(fd, 1);
  8104d5:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  8104dc:	00 
  8104dd:	8b 45 f4             	mov    -0xc(%ebp),%eax
  8104e0:	89 04 24             	mov    %eax,(%esp)
  8104e3:	e8 4e ff ff ff       	call   810436 <fd_close>
}
  8104e8:	c9                   	leave  
  8104e9:	c3                   	ret    

008104ea <close_all>:

void
close_all(void)
{
  8104ea:	55                   	push   %ebp
  8104eb:	89 e5                	mov    %esp,%ebp
  8104ed:	53                   	push   %ebx
  8104ee:	83 ec 14             	sub    $0x14,%esp
	int i;
	for (i = 0; i < MAXFD; i++)
  8104f1:	bb 00 00 00 00       	mov    $0x0,%ebx
		close(i);
  8104f6:	89 1c 24             	mov    %ebx,(%esp)
  8104f9:	e8 b9 ff ff ff       	call   8104b7 <close>

void
close_all(void)
{
	int i;
	for (i = 0; i < MAXFD; i++)
  8104fe:	83 c3 01             	add    $0x1,%ebx
  810501:	83 fb 20             	cmp    $0x20,%ebx
  810504:	75 f0                	jne    8104f6 <close_all+0xc>
		close(i);
}
  810506:	83 c4 14             	add    $0x14,%esp
  810509:	5b                   	pop    %ebx
  81050a:	5d                   	pop    %ebp
  81050b:	c3                   	ret    

0081050c <dup>:
// file and the file offset of the other.
// Closes any previously open file descriptor at 'newfdnum'.
// This is implemented using virtual memory tricks (of course!).
int
dup(int oldfdnum, int newfdnum)
{
  81050c:	55                   	push   %ebp
  81050d:	89 e5                	mov    %esp,%ebp
  81050f:	57                   	push   %edi
  810510:	56                   	push   %esi
  810511:	53                   	push   %ebx
  810512:	83 ec 3c             	sub    $0x3c,%esp
	int r;
	char *ova, *nva;
	pte_t pte;
	struct Fd *oldfd, *newfd;

	if ((r = fd_lookup(oldfdnum, &oldfd)) < 0)
  810515:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  810518:	89 44 24 04          	mov    %eax,0x4(%esp)
  81051c:	8b 45 08             	mov    0x8(%ebp),%eax
  81051f:	89 04 24             	mov    %eax,(%esp)
  810522:	e8 5f fe ff ff       	call   810386 <fd_lookup>
  810527:	89 c2                	mov    %eax,%edx
  810529:	85 d2                	test   %edx,%edx
  81052b:	0f 88 e1 00 00 00    	js     810612 <dup+0x106>
		return r;
	close(newfdnum);
  810531:	8b 45 0c             	mov    0xc(%ebp),%eax
  810534:	89 04 24             	mov    %eax,(%esp)
  810537:	e8 7b ff ff ff       	call   8104b7 <close>

	newfd = INDEX2FD(newfdnum);
  81053c:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  81053f:	c1 e3 0c             	shl    $0xc,%ebx
  810542:	81 eb 00 00 00 30    	sub    $0x30000000,%ebx
	ova = fd2data(oldfd);
  810548:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  81054b:	89 04 24             	mov    %eax,(%esp)
  81054e:	e8 cd fd ff ff       	call   810320 <fd2data>
  810553:	89 c6                	mov    %eax,%esi
	nva = fd2data(newfd);
  810555:	89 1c 24             	mov    %ebx,(%esp)
  810558:	e8 c3 fd ff ff       	call   810320 <fd2data>
  81055d:	89 c7                	mov    %eax,%edi

	if ((uvpd[PDX(ova)] & PTE_P) && (uvpt[PGNUM(ova)] & PTE_P))
  81055f:	89 f0                	mov    %esi,%eax
  810561:	c1 e8 16             	shr    $0x16,%eax
  810564:	8b 04 85 00 d0 7b ef 	mov    -0x10843000(,%eax,4),%eax
  81056b:	a8 01                	test   $0x1,%al
  81056d:	74 43                	je     8105b2 <dup+0xa6>
  81056f:	89 f0                	mov    %esi,%eax
  810571:	c1 e8 0c             	shr    $0xc,%eax
  810574:	8b 14 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%edx
  81057b:	f6 c2 01             	test   $0x1,%dl
  81057e:	74 32                	je     8105b2 <dup+0xa6>
		if ((r = sys_page_map(0, ova, 0, nva, uvpt[PGNUM(ova)] & PTE_SYSCALL)) < 0)
  810580:	8b 04 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%eax
  810587:	25 07 0e 00 00       	and    $0xe07,%eax
  81058c:	89 44 24 10          	mov    %eax,0x10(%esp)
  810590:	89 7c 24 0c          	mov    %edi,0xc(%esp)
  810594:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  81059b:	00 
  81059c:	89 74 24 04          	mov    %esi,0x4(%esp)
  8105a0:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8105a7:	e8 5b f6 ff ff       	call   80fc07 <sys_page_map>
  8105ac:	89 c6                	mov    %eax,%esi
  8105ae:	85 c0                	test   %eax,%eax
  8105b0:	78 3e                	js     8105f0 <dup+0xe4>
			goto err;
	if ((r = sys_page_map(0, oldfd, 0, newfd, uvpt[PGNUM(oldfd)] & PTE_SYSCALL)) < 0)
  8105b2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8105b5:	89 c2                	mov    %eax,%edx
  8105b7:	c1 ea 0c             	shr    $0xc,%edx
  8105ba:	8b 14 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%edx
  8105c1:	81 e2 07 0e 00 00    	and    $0xe07,%edx
  8105c7:	89 54 24 10          	mov    %edx,0x10(%esp)
  8105cb:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
  8105cf:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8105d6:	00 
  8105d7:	89 44 24 04          	mov    %eax,0x4(%esp)
  8105db:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8105e2:	e8 20 f6 ff ff       	call   80fc07 <sys_page_map>
  8105e7:	89 c6                	mov    %eax,%esi
		goto err;

	return newfdnum;
  8105e9:	8b 45 0c             	mov    0xc(%ebp),%eax
	nva = fd2data(newfd);

	if ((uvpd[PDX(ova)] & PTE_P) && (uvpt[PGNUM(ova)] & PTE_P))
		if ((r = sys_page_map(0, ova, 0, nva, uvpt[PGNUM(ova)] & PTE_SYSCALL)) < 0)
			goto err;
	if ((r = sys_page_map(0, oldfd, 0, newfd, uvpt[PGNUM(oldfd)] & PTE_SYSCALL)) < 0)
  8105ec:	85 f6                	test   %esi,%esi
  8105ee:	79 22                	jns    810612 <dup+0x106>
		goto err;

	return newfdnum;

err:
	sys_page_unmap(0, newfd);
  8105f0:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8105f4:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8105fb:	e8 5a f6 ff ff       	call   80fc5a <sys_page_unmap>
	sys_page_unmap(0, nva);
  810600:	89 7c 24 04          	mov    %edi,0x4(%esp)
  810604:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  81060b:	e8 4a f6 ff ff       	call   80fc5a <sys_page_unmap>
	return r;
  810610:	89 f0                	mov    %esi,%eax
}
  810612:	83 c4 3c             	add    $0x3c,%esp
  810615:	5b                   	pop    %ebx
  810616:	5e                   	pop    %esi
  810617:	5f                   	pop    %edi
  810618:	5d                   	pop    %ebp
  810619:	c3                   	ret    

0081061a <read>:

ssize_t
read(int fdnum, void *buf, size_t n)
{
  81061a:	55                   	push   %ebp
  81061b:	89 e5                	mov    %esp,%ebp
  81061d:	53                   	push   %ebx
  81061e:	83 ec 24             	sub    $0x24,%esp
  810621:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0
  810624:	8d 45 f0             	lea    -0x10(%ebp),%eax
  810627:	89 44 24 04          	mov    %eax,0x4(%esp)
  81062b:	89 1c 24             	mov    %ebx,(%esp)
  81062e:	e8 53 fd ff ff       	call   810386 <fd_lookup>
  810633:	89 c2                	mov    %eax,%edx
  810635:	85 d2                	test   %edx,%edx
  810637:	78 6d                	js     8106a6 <read+0x8c>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  810639:	8d 45 f4             	lea    -0xc(%ebp),%eax
  81063c:	89 44 24 04          	mov    %eax,0x4(%esp)
  810640:	8b 45 f0             	mov    -0x10(%ebp),%eax
  810643:	8b 00                	mov    (%eax),%eax
  810645:	89 04 24             	mov    %eax,(%esp)
  810648:	e8 8f fd ff ff       	call   8103dc <dev_lookup>
  81064d:	85 c0                	test   %eax,%eax
  81064f:	78 55                	js     8106a6 <read+0x8c>
		return r;
	if ((fd->fd_omode & O_ACCMODE) == O_WRONLY) {
  810651:	8b 45 f0             	mov    -0x10(%ebp),%eax
  810654:	8b 50 08             	mov    0x8(%eax),%edx
  810657:	83 e2 03             	and    $0x3,%edx
  81065a:	83 fa 01             	cmp    $0x1,%edx
  81065d:	75 23                	jne    810682 <read+0x68>
		cprintf("[%08x] read %d -- bad mode\n", thisenv->env_id, fdnum);
  81065f:	a1 7c c2 b3 00       	mov    0xb3c27c,%eax
  810664:	8b 40 48             	mov    0x48(%eax),%eax
  810667:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  81066b:	89 44 24 04          	mov    %eax,0x4(%esp)
  81066f:	c7 04 24 c1 45 81 00 	movl   $0x8145c1,(%esp)
  810676:	e8 f8 ea ff ff       	call   80f173 <cprintf>
		return -E_INVAL;
  81067b:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  810680:	eb 24                	jmp    8106a6 <read+0x8c>
	}
	if (!dev->dev_read)
  810682:	8b 55 f4             	mov    -0xc(%ebp),%edx
  810685:	8b 52 08             	mov    0x8(%edx),%edx
  810688:	85 d2                	test   %edx,%edx
  81068a:	74 15                	je     8106a1 <read+0x87>
		return -E_NOT_SUPP;
	return (*dev->dev_read)(fd, buf, n);
  81068c:	8b 4d 10             	mov    0x10(%ebp),%ecx
  81068f:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  810693:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  810696:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  81069a:	89 04 24             	mov    %eax,(%esp)
  81069d:	ff d2                	call   *%edx
  81069f:	eb 05                	jmp    8106a6 <read+0x8c>
	if ((fd->fd_omode & O_ACCMODE) == O_WRONLY) {
		cprintf("[%08x] read %d -- bad mode\n", thisenv->env_id, fdnum);
		return -E_INVAL;
	}
	if (!dev->dev_read)
		return -E_NOT_SUPP;
  8106a1:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
	return (*dev->dev_read)(fd, buf, n);
}
  8106a6:	83 c4 24             	add    $0x24,%esp
  8106a9:	5b                   	pop    %ebx
  8106aa:	5d                   	pop    %ebp
  8106ab:	c3                   	ret    

008106ac <readn>:

ssize_t
readn(int fdnum, void *buf, size_t n)
{
  8106ac:	55                   	push   %ebp
  8106ad:	89 e5                	mov    %esp,%ebp
  8106af:	57                   	push   %edi
  8106b0:	56                   	push   %esi
  8106b1:	53                   	push   %ebx
  8106b2:	83 ec 1c             	sub    $0x1c,%esp
  8106b5:	8b 7d 08             	mov    0x8(%ebp),%edi
  8106b8:	8b 75 10             	mov    0x10(%ebp),%esi
	int m, tot;

	for (tot = 0; tot < n; tot += m) {
  8106bb:	bb 00 00 00 00       	mov    $0x0,%ebx
  8106c0:	eb 23                	jmp    8106e5 <readn+0x39>
		m = read(fdnum, (char*)buf + tot, n - tot);
  8106c2:	89 f0                	mov    %esi,%eax
  8106c4:	29 d8                	sub    %ebx,%eax
  8106c6:	89 44 24 08          	mov    %eax,0x8(%esp)
  8106ca:	89 d8                	mov    %ebx,%eax
  8106cc:	03 45 0c             	add    0xc(%ebp),%eax
  8106cf:	89 44 24 04          	mov    %eax,0x4(%esp)
  8106d3:	89 3c 24             	mov    %edi,(%esp)
  8106d6:	e8 3f ff ff ff       	call   81061a <read>
		if (m < 0)
  8106db:	85 c0                	test   %eax,%eax
  8106dd:	78 10                	js     8106ef <readn+0x43>
			return m;
		if (m == 0)
  8106df:	85 c0                	test   %eax,%eax
  8106e1:	74 0a                	je     8106ed <readn+0x41>
ssize_t
readn(int fdnum, void *buf, size_t n)
{
	int m, tot;

	for (tot = 0; tot < n; tot += m) {
  8106e3:	01 c3                	add    %eax,%ebx
  8106e5:	39 f3                	cmp    %esi,%ebx
  8106e7:	72 d9                	jb     8106c2 <readn+0x16>
  8106e9:	89 d8                	mov    %ebx,%eax
  8106eb:	eb 02                	jmp    8106ef <readn+0x43>
  8106ed:	89 d8                	mov    %ebx,%eax
			return m;
		if (m == 0)
			break;
	}
	return tot;
}
  8106ef:	83 c4 1c             	add    $0x1c,%esp
  8106f2:	5b                   	pop    %ebx
  8106f3:	5e                   	pop    %esi
  8106f4:	5f                   	pop    %edi
  8106f5:	5d                   	pop    %ebp
  8106f6:	c3                   	ret    

008106f7 <write>:

ssize_t
write(int fdnum, const void *buf, size_t n)
{
  8106f7:	55                   	push   %ebp
  8106f8:	89 e5                	mov    %esp,%ebp
  8106fa:	53                   	push   %ebx
  8106fb:	83 ec 24             	sub    $0x24,%esp
  8106fe:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0
  810701:	8d 45 f0             	lea    -0x10(%ebp),%eax
  810704:	89 44 24 04          	mov    %eax,0x4(%esp)
  810708:	89 1c 24             	mov    %ebx,(%esp)
  81070b:	e8 76 fc ff ff       	call   810386 <fd_lookup>
  810710:	89 c2                	mov    %eax,%edx
  810712:	85 d2                	test   %edx,%edx
  810714:	78 68                	js     81077e <write+0x87>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  810716:	8d 45 f4             	lea    -0xc(%ebp),%eax
  810719:	89 44 24 04          	mov    %eax,0x4(%esp)
  81071d:	8b 45 f0             	mov    -0x10(%ebp),%eax
  810720:	8b 00                	mov    (%eax),%eax
  810722:	89 04 24             	mov    %eax,(%esp)
  810725:	e8 b2 fc ff ff       	call   8103dc <dev_lookup>
  81072a:	85 c0                	test   %eax,%eax
  81072c:	78 50                	js     81077e <write+0x87>
		return r;
	if ((fd->fd_omode & O_ACCMODE) == O_RDONLY) {
  81072e:	8b 45 f0             	mov    -0x10(%ebp),%eax
  810731:	f6 40 08 03          	testb  $0x3,0x8(%eax)
  810735:	75 23                	jne    81075a <write+0x63>
		cprintf("[%08x] write %d -- bad mode\n", thisenv->env_id, fdnum);
  810737:	a1 7c c2 b3 00       	mov    0xb3c27c,%eax
  81073c:	8b 40 48             	mov    0x48(%eax),%eax
  81073f:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  810743:	89 44 24 04          	mov    %eax,0x4(%esp)
  810747:	c7 04 24 dd 45 81 00 	movl   $0x8145dd,(%esp)
  81074e:	e8 20 ea ff ff       	call   80f173 <cprintf>
		return -E_INVAL;
  810753:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  810758:	eb 24                	jmp    81077e <write+0x87>
	}
	if (debug)
		cprintf("write %d %p %d via dev %s\n",
			fdnum, buf, n, dev->dev_name);
	if (!dev->dev_write)
  81075a:	8b 55 f4             	mov    -0xc(%ebp),%edx
  81075d:	8b 52 0c             	mov    0xc(%edx),%edx
  810760:	85 d2                	test   %edx,%edx
  810762:	74 15                	je     810779 <write+0x82>
		return -E_NOT_SUPP;
	return (*dev->dev_write)(fd, buf, n);
  810764:	8b 4d 10             	mov    0x10(%ebp),%ecx
  810767:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  81076b:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  81076e:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  810772:	89 04 24             	mov    %eax,(%esp)
  810775:	ff d2                	call   *%edx
  810777:	eb 05                	jmp    81077e <write+0x87>
	}
	if (debug)
		cprintf("write %d %p %d via dev %s\n",
			fdnum, buf, n, dev->dev_name);
	if (!dev->dev_write)
		return -E_NOT_SUPP;
  810779:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
	return (*dev->dev_write)(fd, buf, n);
}
  81077e:	83 c4 24             	add    $0x24,%esp
  810781:	5b                   	pop    %ebx
  810782:	5d                   	pop    %ebp
  810783:	c3                   	ret    

00810784 <seek>:

int
seek(int fdnum, off_t offset)
{
  810784:	55                   	push   %ebp
  810785:	89 e5                	mov    %esp,%ebp
  810787:	83 ec 18             	sub    $0x18,%esp
	int r;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0)
  81078a:	8d 45 fc             	lea    -0x4(%ebp),%eax
  81078d:	89 44 24 04          	mov    %eax,0x4(%esp)
  810791:	8b 45 08             	mov    0x8(%ebp),%eax
  810794:	89 04 24             	mov    %eax,(%esp)
  810797:	e8 ea fb ff ff       	call   810386 <fd_lookup>
  81079c:	85 c0                	test   %eax,%eax
  81079e:	78 0e                	js     8107ae <seek+0x2a>
		return r;
	fd->fd_offset = offset;
  8107a0:	8b 45 fc             	mov    -0x4(%ebp),%eax
  8107a3:	8b 55 0c             	mov    0xc(%ebp),%edx
  8107a6:	89 50 04             	mov    %edx,0x4(%eax)
	return 0;
  8107a9:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8107ae:	c9                   	leave  
  8107af:	c3                   	ret    

008107b0 <ftruncate>:

int
ftruncate(int fdnum, off_t newsize)
{
  8107b0:	55                   	push   %ebp
  8107b1:	89 e5                	mov    %esp,%ebp
  8107b3:	53                   	push   %ebx
  8107b4:	83 ec 24             	sub    $0x24,%esp
  8107b7:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int r;
	struct Dev *dev;
	struct Fd *fd;
	if ((r = fd_lookup(fdnum, &fd)) < 0
  8107ba:	8d 45 f0             	lea    -0x10(%ebp),%eax
  8107bd:	89 44 24 04          	mov    %eax,0x4(%esp)
  8107c1:	89 1c 24             	mov    %ebx,(%esp)
  8107c4:	e8 bd fb ff ff       	call   810386 <fd_lookup>
  8107c9:	89 c2                	mov    %eax,%edx
  8107cb:	85 d2                	test   %edx,%edx
  8107cd:	78 61                	js     810830 <ftruncate+0x80>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  8107cf:	8d 45 f4             	lea    -0xc(%ebp),%eax
  8107d2:	89 44 24 04          	mov    %eax,0x4(%esp)
  8107d6:	8b 45 f0             	mov    -0x10(%ebp),%eax
  8107d9:	8b 00                	mov    (%eax),%eax
  8107db:	89 04 24             	mov    %eax,(%esp)
  8107de:	e8 f9 fb ff ff       	call   8103dc <dev_lookup>
  8107e3:	85 c0                	test   %eax,%eax
  8107e5:	78 49                	js     810830 <ftruncate+0x80>
		return r;
	if ((fd->fd_omode & O_ACCMODE) == O_RDONLY) {
  8107e7:	8b 45 f0             	mov    -0x10(%ebp),%eax
  8107ea:	f6 40 08 03          	testb  $0x3,0x8(%eax)
  8107ee:	75 23                	jne    810813 <ftruncate+0x63>
		cprintf("[%08x] ftruncate %d -- bad mode\n",
			thisenv->env_id, fdnum);
  8107f0:	a1 7c c2 b3 00       	mov    0xb3c27c,%eax
	struct Fd *fd;
	if ((r = fd_lookup(fdnum, &fd)) < 0
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
		return r;
	if ((fd->fd_omode & O_ACCMODE) == O_RDONLY) {
		cprintf("[%08x] ftruncate %d -- bad mode\n",
  8107f5:	8b 40 48             	mov    0x48(%eax),%eax
  8107f8:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  8107fc:	89 44 24 04          	mov    %eax,0x4(%esp)
  810800:	c7 04 24 a0 45 81 00 	movl   $0x8145a0,(%esp)
  810807:	e8 67 e9 ff ff       	call   80f173 <cprintf>
			thisenv->env_id, fdnum);
		return -E_INVAL;
  81080c:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  810811:	eb 1d                	jmp    810830 <ftruncate+0x80>
	}
	if (!dev->dev_trunc)
  810813:	8b 55 f4             	mov    -0xc(%ebp),%edx
  810816:	8b 52 18             	mov    0x18(%edx),%edx
  810819:	85 d2                	test   %edx,%edx
  81081b:	74 0e                	je     81082b <ftruncate+0x7b>
		return -E_NOT_SUPP;
	return (*dev->dev_trunc)(fd, newsize);
  81081d:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  810820:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  810824:	89 04 24             	mov    %eax,(%esp)
  810827:	ff d2                	call   *%edx
  810829:	eb 05                	jmp    810830 <ftruncate+0x80>
		cprintf("[%08x] ftruncate %d -- bad mode\n",
			thisenv->env_id, fdnum);
		return -E_INVAL;
	}
	if (!dev->dev_trunc)
		return -E_NOT_SUPP;
  81082b:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
	return (*dev->dev_trunc)(fd, newsize);
}
  810830:	83 c4 24             	add    $0x24,%esp
  810833:	5b                   	pop    %ebx
  810834:	5d                   	pop    %ebp
  810835:	c3                   	ret    

00810836 <fstat>:

int
fstat(int fdnum, struct Stat *stat)
{
  810836:	55                   	push   %ebp
  810837:	89 e5                	mov    %esp,%ebp
  810839:	53                   	push   %ebx
  81083a:	83 ec 24             	sub    $0x24,%esp
  81083d:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0
  810840:	8d 45 f0             	lea    -0x10(%ebp),%eax
  810843:	89 44 24 04          	mov    %eax,0x4(%esp)
  810847:	8b 45 08             	mov    0x8(%ebp),%eax
  81084a:	89 04 24             	mov    %eax,(%esp)
  81084d:	e8 34 fb ff ff       	call   810386 <fd_lookup>
  810852:	89 c2                	mov    %eax,%edx
  810854:	85 d2                	test   %edx,%edx
  810856:	78 52                	js     8108aa <fstat+0x74>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  810858:	8d 45 f4             	lea    -0xc(%ebp),%eax
  81085b:	89 44 24 04          	mov    %eax,0x4(%esp)
  81085f:	8b 45 f0             	mov    -0x10(%ebp),%eax
  810862:	8b 00                	mov    (%eax),%eax
  810864:	89 04 24             	mov    %eax,(%esp)
  810867:	e8 70 fb ff ff       	call   8103dc <dev_lookup>
  81086c:	85 c0                	test   %eax,%eax
  81086e:	78 3a                	js     8108aa <fstat+0x74>
		return r;
	if (!dev->dev_stat)
  810870:	8b 45 f4             	mov    -0xc(%ebp),%eax
  810873:	83 78 14 00          	cmpl   $0x0,0x14(%eax)
  810877:	74 2c                	je     8108a5 <fstat+0x6f>
		return -E_NOT_SUPP;
	stat->st_name[0] = 0;
  810879:	c6 03 00             	movb   $0x0,(%ebx)
	stat->st_size = 0;
  81087c:	c7 83 80 00 00 00 00 	movl   $0x0,0x80(%ebx)
  810883:	00 00 00 
	stat->st_isdir = 0;
  810886:	c7 83 84 00 00 00 00 	movl   $0x0,0x84(%ebx)
  81088d:	00 00 00 
	stat->st_dev = dev;
  810890:	89 83 88 00 00 00    	mov    %eax,0x88(%ebx)
	return (*dev->dev_stat)(fd, stat);
  810896:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  81089a:	8b 55 f0             	mov    -0x10(%ebp),%edx
  81089d:	89 14 24             	mov    %edx,(%esp)
  8108a0:	ff 50 14             	call   *0x14(%eax)
  8108a3:	eb 05                	jmp    8108aa <fstat+0x74>

	if ((r = fd_lookup(fdnum, &fd)) < 0
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
		return r;
	if (!dev->dev_stat)
		return -E_NOT_SUPP;
  8108a5:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
	stat->st_name[0] = 0;
	stat->st_size = 0;
	stat->st_isdir = 0;
	stat->st_dev = dev;
	return (*dev->dev_stat)(fd, stat);
}
  8108aa:	83 c4 24             	add    $0x24,%esp
  8108ad:	5b                   	pop    %ebx
  8108ae:	5d                   	pop    %ebp
  8108af:	c3                   	ret    

008108b0 <stat>:

int
stat(const char *path, struct Stat *stat)
{
  8108b0:	55                   	push   %ebp
  8108b1:	89 e5                	mov    %esp,%ebp
  8108b3:	56                   	push   %esi
  8108b4:	53                   	push   %ebx
  8108b5:	83 ec 10             	sub    $0x10,%esp
	int fd, r;

	if ((fd = open(path, O_RDONLY)) < 0)
  8108b8:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8108bf:	00 
  8108c0:	8b 45 08             	mov    0x8(%ebp),%eax
  8108c3:	89 04 24             	mov    %eax,(%esp)
  8108c6:	e8 28 02 00 00       	call   810af3 <open>
  8108cb:	89 c3                	mov    %eax,%ebx
  8108cd:	85 db                	test   %ebx,%ebx
  8108cf:	78 1b                	js     8108ec <stat+0x3c>
		return fd;
	r = fstat(fd, stat);
  8108d1:	8b 45 0c             	mov    0xc(%ebp),%eax
  8108d4:	89 44 24 04          	mov    %eax,0x4(%esp)
  8108d8:	89 1c 24             	mov    %ebx,(%esp)
  8108db:	e8 56 ff ff ff       	call   810836 <fstat>
  8108e0:	89 c6                	mov    %eax,%esi
	close(fd);
  8108e2:	89 1c 24             	mov    %ebx,(%esp)
  8108e5:	e8 cd fb ff ff       	call   8104b7 <close>
	return r;
  8108ea:	89 f0                	mov    %esi,%eax
}
  8108ec:	83 c4 10             	add    $0x10,%esp
  8108ef:	5b                   	pop    %ebx
  8108f0:	5e                   	pop    %esi
  8108f1:	5d                   	pop    %ebp
  8108f2:	c3                   	ret    

008108f3 <fsipc>:
// type: request code, passed as the simple integer IPC value.
// dstva: virtual address at which to receive reply page, 0 if none.
// Returns result from the file server.
static int
fsipc(unsigned type, void *dstva)
{
  8108f3:	55                   	push   %ebp
  8108f4:	89 e5                	mov    %esp,%ebp
  8108f6:	56                   	push   %esi
  8108f7:	53                   	push   %ebx
  8108f8:	83 ec 10             	sub    $0x10,%esp
  8108fb:	89 c6                	mov    %eax,%esi
  8108fd:	89 d3                	mov    %edx,%ebx
	static envid_t fsenv;
	if (fsenv == 0)
  8108ff:	83 3d ec c1 b3 00 00 	cmpl   $0x0,0xb3c1ec
  810906:	75 11                	jne    810919 <fsipc+0x26>
		fsenv = ipc_find_env(ENV_TYPE_FS);
  810908:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  81090f:	e8 c1 f9 ff ff       	call   8102d5 <ipc_find_env>
  810914:	a3 ec c1 b3 00       	mov    %eax,0xb3c1ec
	static_assert(sizeof(fsipcbuf) == PGSIZE);

	if (debug)
		cprintf("[%08x] fsipc %d %08x\n", thisenv->env_id, type, *(uint32_t *)&fsipcbuf);

	ipc_send(fsenv, type, &fsipcbuf, PTE_P | PTE_W | PTE_U);
  810919:	c7 44 24 0c 07 00 00 	movl   $0x7,0xc(%esp)
  810920:	00 
  810921:	c7 44 24 08 00 d0 b3 	movl   $0xb3d000,0x8(%esp)
  810928:	00 
  810929:	89 74 24 04          	mov    %esi,0x4(%esp)
  81092d:	a1 ec c1 b3 00       	mov    0xb3c1ec,%eax
  810932:	89 04 24             	mov    %eax,(%esp)
  810935:	e8 30 f9 ff ff       	call   81026a <ipc_send>
	return ipc_recv(NULL, dstva, NULL);
  81093a:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  810941:	00 
  810942:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  810946:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  81094d:	e8 9e f8 ff ff       	call   8101f0 <ipc_recv>
}
  810952:	83 c4 10             	add    $0x10,%esp
  810955:	5b                   	pop    %ebx
  810956:	5e                   	pop    %esi
  810957:	5d                   	pop    %ebp
  810958:	c3                   	ret    

00810959 <devfile_trunc>:
}

// Truncate or extend an open file to 'size' bytes
static int
devfile_trunc(struct Fd *fd, off_t newsize)
{
  810959:	55                   	push   %ebp
  81095a:	89 e5                	mov    %esp,%ebp
  81095c:	83 ec 08             	sub    $0x8,%esp
	fsipcbuf.set_size.req_fileid = fd->fd_file.id;
  81095f:	8b 45 08             	mov    0x8(%ebp),%eax
  810962:	8b 40 0c             	mov    0xc(%eax),%eax
  810965:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	fsipcbuf.set_size.req_size = newsize;
  81096a:	8b 45 0c             	mov    0xc(%ebp),%eax
  81096d:	a3 04 d0 b3 00       	mov    %eax,0xb3d004
	return fsipc(FSREQ_SET_SIZE, NULL);
  810972:	ba 00 00 00 00       	mov    $0x0,%edx
  810977:	b8 02 00 00 00       	mov    $0x2,%eax
  81097c:	e8 72 ff ff ff       	call   8108f3 <fsipc>
}
  810981:	c9                   	leave  
  810982:	c3                   	ret    

00810983 <devfile_flush>:
// open, unmapping it is enough to free up server-side resources.
// Other than that, we just have to make sure our changes are flushed
// to disk.
static int
devfile_flush(struct Fd *fd)
{
  810983:	55                   	push   %ebp
  810984:	89 e5                	mov    %esp,%ebp
  810986:	83 ec 08             	sub    $0x8,%esp
	fsipcbuf.flush.req_fileid = fd->fd_file.id;
  810989:	8b 45 08             	mov    0x8(%ebp),%eax
  81098c:	8b 40 0c             	mov    0xc(%eax),%eax
  81098f:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	return fsipc(FSREQ_FLUSH, NULL);
  810994:	ba 00 00 00 00       	mov    $0x0,%edx
  810999:	b8 06 00 00 00       	mov    $0x6,%eax
  81099e:	e8 50 ff ff ff       	call   8108f3 <fsipc>
}
  8109a3:	c9                   	leave  
  8109a4:	c3                   	ret    

008109a5 <devfile_stat>:
	return fsipc(FSREQ_WRITE, NULL);
}

static int
devfile_stat(struct Fd *fd, struct Stat *st)
{
  8109a5:	55                   	push   %ebp
  8109a6:	89 e5                	mov    %esp,%ebp
  8109a8:	53                   	push   %ebx
  8109a9:	83 ec 14             	sub    $0x14,%esp
  8109ac:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	int r;

	fsipcbuf.stat.req_fileid = fd->fd_file.id;
  8109af:	8b 45 08             	mov    0x8(%ebp),%eax
  8109b2:	8b 40 0c             	mov    0xc(%eax),%eax
  8109b5:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	if ((r = fsipc(FSREQ_STAT, NULL)) < 0)
  8109ba:	ba 00 00 00 00       	mov    $0x0,%edx
  8109bf:	b8 05 00 00 00       	mov    $0x5,%eax
  8109c4:	e8 2a ff ff ff       	call   8108f3 <fsipc>
  8109c9:	89 c2                	mov    %eax,%edx
  8109cb:	85 d2                	test   %edx,%edx
  8109cd:	78 2b                	js     8109fa <devfile_stat+0x55>
		return r;
	strcpy(st->st_name, fsipcbuf.statRet.ret_name);
  8109cf:	c7 44 24 04 00 d0 b3 	movl   $0xb3d000,0x4(%esp)
  8109d6:	00 
  8109d7:	89 1c 24             	mov    %ebx,(%esp)
  8109da:	e8 b8 ed ff ff       	call   80f797 <strcpy>
	st->st_size = fsipcbuf.statRet.ret_size;
  8109df:	a1 80 d0 b3 00       	mov    0xb3d080,%eax
  8109e4:	89 83 80 00 00 00    	mov    %eax,0x80(%ebx)
	st->st_isdir = fsipcbuf.statRet.ret_isdir;
  8109ea:	a1 84 d0 b3 00       	mov    0xb3d084,%eax
  8109ef:	89 83 84 00 00 00    	mov    %eax,0x84(%ebx)
	return 0;
  8109f5:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8109fa:	83 c4 14             	add    $0x14,%esp
  8109fd:	5b                   	pop    %ebx
  8109fe:	5d                   	pop    %ebp
  8109ff:	c3                   	ret    

00810a00 <devfile_write>:
// Returns:
//	 The number of bytes successfully written.
//	 < 0 on error.
static ssize_t
devfile_write(struct Fd *fd, const void *buf, size_t n)
{
  810a00:	55                   	push   %ebp
  810a01:	89 e5                	mov    %esp,%ebp
  810a03:	83 ec 18             	sub    $0x18,%esp
  810a06:	8b 45 10             	mov    0x10(%ebp),%eax
  810a09:	3d f8 0f 00 00       	cmp    $0xff8,%eax
  810a0e:	ba f8 0f 00 00       	mov    $0xff8,%edx
  810a13:	0f 47 c2             	cmova  %edx,%eax
	int r;
	int buf_size = PGSIZE - (sizeof(int) + sizeof(size_t));

	if(buf_size < n) n = buf_size;

	fsipcbuf.write.req_fileid = fd->fd_file.id;
  810a16:	8b 55 08             	mov    0x8(%ebp),%edx
  810a19:	8b 52 0c             	mov    0xc(%edx),%edx
  810a1c:	89 15 00 d0 b3 00    	mov    %edx,0xb3d000
	fsipcbuf.write.req_n = n;
  810a22:	a3 04 d0 b3 00       	mov    %eax,0xb3d004

	memmove(fsipcbuf.write.req_buf, buf, n);
  810a27:	89 44 24 08          	mov    %eax,0x8(%esp)
  810a2b:	8b 45 0c             	mov    0xc(%ebp),%eax
  810a2e:	89 44 24 04          	mov    %eax,0x4(%esp)
  810a32:	c7 04 24 08 d0 b3 00 	movl   $0xb3d008,(%esp)
  810a39:	e8 f6 ee ff ff       	call   80f934 <memmove>

	return fsipc(FSREQ_WRITE, NULL);
  810a3e:	ba 00 00 00 00       	mov    $0x0,%edx
  810a43:	b8 04 00 00 00       	mov    $0x4,%eax
  810a48:	e8 a6 fe ff ff       	call   8108f3 <fsipc>
}
  810a4d:	c9                   	leave  
  810a4e:	c3                   	ret    

00810a4f <devfile_read>:
// Returns:
// 	The number of bytes successfully read.
// 	< 0 on error.
static ssize_t
devfile_read(struct Fd *fd, void *buf, size_t n)
{
  810a4f:	55                   	push   %ebp
  810a50:	89 e5                	mov    %esp,%ebp
  810a52:	56                   	push   %esi
  810a53:	53                   	push   %ebx
  810a54:	83 ec 10             	sub    $0x10,%esp
  810a57:	8b 75 10             	mov    0x10(%ebp),%esi
	// filling fsipcbuf.read with the request arguments.  The
	// bytes read will be written back to fsipcbuf by the file
	// system server.
	int r;

	fsipcbuf.read.req_fileid = fd->fd_file.id;
  810a5a:	8b 45 08             	mov    0x8(%ebp),%eax
  810a5d:	8b 40 0c             	mov    0xc(%eax),%eax
  810a60:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	fsipcbuf.read.req_n = n;
  810a65:	89 35 04 d0 b3 00    	mov    %esi,0xb3d004
	if ((r = fsipc(FSREQ_READ, NULL)) < 0)
  810a6b:	ba 00 00 00 00       	mov    $0x0,%edx
  810a70:	b8 03 00 00 00       	mov    $0x3,%eax
  810a75:	e8 79 fe ff ff       	call   8108f3 <fsipc>
  810a7a:	89 c3                	mov    %eax,%ebx
  810a7c:	85 c0                	test   %eax,%eax
  810a7e:	78 6a                	js     810aea <devfile_read+0x9b>
		return r;
	assert(r <= n);
  810a80:	39 c6                	cmp    %eax,%esi
  810a82:	73 24                	jae    810aa8 <devfile_read+0x59>
  810a84:	c7 44 24 0c 10 46 81 	movl   $0x814610,0xc(%esp)
  810a8b:	00 
  810a8c:	c7 44 24 08 7f 33 81 	movl   $0x81337f,0x8(%esp)
  810a93:	00 
  810a94:	c7 44 24 04 7c 00 00 	movl   $0x7c,0x4(%esp)
  810a9b:	00 
  810a9c:	c7 04 24 17 46 81 00 	movl   $0x814617,(%esp)
  810aa3:	e8 d2 e5 ff ff       	call   80f07a <_panic>
	assert(r <= PGSIZE);
  810aa8:	3d 00 10 00 00       	cmp    $0x1000,%eax
  810aad:	7e 24                	jle    810ad3 <devfile_read+0x84>
  810aaf:	c7 44 24 0c 22 46 81 	movl   $0x814622,0xc(%esp)
  810ab6:	00 
  810ab7:	c7 44 24 08 7f 33 81 	movl   $0x81337f,0x8(%esp)
  810abe:	00 
  810abf:	c7 44 24 04 7d 00 00 	movl   $0x7d,0x4(%esp)
  810ac6:	00 
  810ac7:	c7 04 24 17 46 81 00 	movl   $0x814617,(%esp)
  810ace:	e8 a7 e5 ff ff       	call   80f07a <_panic>
	memmove(buf, fsipcbuf.readRet.ret_buf, r);
  810ad3:	89 44 24 08          	mov    %eax,0x8(%esp)
  810ad7:	c7 44 24 04 00 d0 b3 	movl   $0xb3d000,0x4(%esp)
  810ade:	00 
  810adf:	8b 45 0c             	mov    0xc(%ebp),%eax
  810ae2:	89 04 24             	mov    %eax,(%esp)
  810ae5:	e8 4a ee ff ff       	call   80f934 <memmove>
	return r;
}
  810aea:	89 d8                	mov    %ebx,%eax
  810aec:	83 c4 10             	add    $0x10,%esp
  810aef:	5b                   	pop    %ebx
  810af0:	5e                   	pop    %esi
  810af1:	5d                   	pop    %ebp
  810af2:	c3                   	ret    

00810af3 <open>:
// 	The file descriptor index on success
// 	-E_BAD_PATH if the path is too long (>= MAXPATHLEN)
// 	< 0 for other errors.
int
open(const char *path, int mode)
{
  810af3:	55                   	push   %ebp
  810af4:	89 e5                	mov    %esp,%ebp
  810af6:	53                   	push   %ebx
  810af7:	83 ec 24             	sub    $0x24,%esp
  810afa:	8b 5d 08             	mov    0x8(%ebp),%ebx
	// file descriptor.

	int r;
	struct Fd *fd;

	if (strlen(path) >= MAXPATHLEN)
  810afd:	89 1c 24             	mov    %ebx,(%esp)
  810b00:	e8 5b ec ff ff       	call   80f760 <strlen>
  810b05:	3d ff 03 00 00       	cmp    $0x3ff,%eax
  810b0a:	7f 60                	jg     810b6c <open+0x79>
		return -E_BAD_PATH;

	if ((r = fd_alloc(&fd)) < 0)
  810b0c:	8d 45 f4             	lea    -0xc(%ebp),%eax
  810b0f:	89 04 24             	mov    %eax,(%esp)
  810b12:	e8 20 f8 ff ff       	call   810337 <fd_alloc>
  810b17:	89 c2                	mov    %eax,%edx
  810b19:	85 d2                	test   %edx,%edx
  810b1b:	78 54                	js     810b71 <open+0x7e>
		return r;

	strcpy(fsipcbuf.open.req_path, path);
  810b1d:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  810b21:	c7 04 24 00 d0 b3 00 	movl   $0xb3d000,(%esp)
  810b28:	e8 6a ec ff ff       	call   80f797 <strcpy>
	fsipcbuf.open.req_omode = mode;
  810b2d:	8b 45 0c             	mov    0xc(%ebp),%eax
  810b30:	a3 00 d4 b3 00       	mov    %eax,0xb3d400

	if ((r = fsipc(FSREQ_OPEN, fd)) < 0) {
  810b35:	8b 55 f4             	mov    -0xc(%ebp),%edx
  810b38:	b8 01 00 00 00       	mov    $0x1,%eax
  810b3d:	e8 b1 fd ff ff       	call   8108f3 <fsipc>
  810b42:	89 c3                	mov    %eax,%ebx
  810b44:	85 c0                	test   %eax,%eax
  810b46:	79 17                	jns    810b5f <open+0x6c>
		fd_close(fd, 0);
  810b48:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  810b4f:	00 
  810b50:	8b 45 f4             	mov    -0xc(%ebp),%eax
  810b53:	89 04 24             	mov    %eax,(%esp)
  810b56:	e8 db f8 ff ff       	call   810436 <fd_close>
		return r;
  810b5b:	89 d8                	mov    %ebx,%eax
  810b5d:	eb 12                	jmp    810b71 <open+0x7e>
	}

	return fd2num(fd);
  810b5f:	8b 45 f4             	mov    -0xc(%ebp),%eax
  810b62:	89 04 24             	mov    %eax,(%esp)
  810b65:	e8 a6 f7 ff ff       	call   810310 <fd2num>
  810b6a:	eb 05                	jmp    810b71 <open+0x7e>

	int r;
	struct Fd *fd;

	if (strlen(path) >= MAXPATHLEN)
		return -E_BAD_PATH;
  810b6c:	b8 f4 ff ff ff       	mov    $0xfffffff4,%eax
		fd_close(fd, 0);
		return r;
	}

	return fd2num(fd);
}
  810b71:	83 c4 24             	add    $0x24,%esp
  810b74:	5b                   	pop    %ebx
  810b75:	5d                   	pop    %ebp
  810b76:	c3                   	ret    

00810b77 <sync>:


// Synchronize disk with buffer cache
int
sync(void)
{
  810b77:	55                   	push   %ebp
  810b78:	89 e5                	mov    %esp,%ebp
  810b7a:	83 ec 08             	sub    $0x8,%esp
	// Ask the file server to update the disk
	// by writing any dirty blocks in the buffer cache.

	return fsipc(FSREQ_SYNC, NULL);
  810b7d:	ba 00 00 00 00       	mov    $0x0,%edx
  810b82:	b8 08 00 00 00       	mov    $0x8,%eax
  810b87:	e8 67 fd ff ff       	call   8108f3 <fsipc>
}
  810b8c:	c9                   	leave  
  810b8d:	c3                   	ret    
  810b8e:	66 90                	xchg   %ax,%ax

00810b90 <devsock_stat>:
	return nsipc_send(fd->fd_sock.sockid, buf, n, 0);
}

static int
devsock_stat(struct Fd *fd, struct Stat *stat)
{
  810b90:	55                   	push   %ebp
  810b91:	89 e5                	mov    %esp,%ebp
  810b93:	83 ec 18             	sub    $0x18,%esp
	strcpy(stat->st_name, "<sock>");
  810b96:	c7 44 24 04 2e 46 81 	movl   $0x81462e,0x4(%esp)
  810b9d:	00 
  810b9e:	8b 45 0c             	mov    0xc(%ebp),%eax
  810ba1:	89 04 24             	mov    %eax,(%esp)
  810ba4:	e8 ee eb ff ff       	call   80f797 <strcpy>
	return 0;
}
  810ba9:	b8 00 00 00 00       	mov    $0x0,%eax
  810bae:	c9                   	leave  
  810baf:	c3                   	ret    

00810bb0 <devsock_close>:
	return nsipc_shutdown(r, how);
}

static int
devsock_close(struct Fd *fd)
{
  810bb0:	55                   	push   %ebp
  810bb1:	89 e5                	mov    %esp,%ebp
  810bb3:	53                   	push   %ebx
  810bb4:	83 ec 14             	sub    $0x14,%esp
  810bb7:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (pageref(fd) == 1)
  810bba:	89 1c 24             	mov    %ebx,(%esp)
  810bbd:	e8 15 0d 00 00       	call   8118d7 <pageref>
		return nsipc_close(fd->fd_sock.sockid);
	else
		return 0;
  810bc2:	ba 00 00 00 00       	mov    $0x0,%edx
}

static int
devsock_close(struct Fd *fd)
{
	if (pageref(fd) == 1)
  810bc7:	83 f8 01             	cmp    $0x1,%eax
  810bca:	75 0d                	jne    810bd9 <devsock_close+0x29>
		return nsipc_close(fd->fd_sock.sockid);
  810bcc:	8b 43 0c             	mov    0xc(%ebx),%eax
  810bcf:	89 04 24             	mov    %eax,(%esp)
  810bd2:	e8 29 03 00 00       	call   810f00 <nsipc_close>
  810bd7:	89 c2                	mov    %eax,%edx
	else
		return 0;
}
  810bd9:	89 d0                	mov    %edx,%eax
  810bdb:	83 c4 14             	add    $0x14,%esp
  810bde:	5b                   	pop    %ebx
  810bdf:	5d                   	pop    %ebp
  810be0:	c3                   	ret    

00810be1 <devsock_write>:
	return nsipc_recv(fd->fd_sock.sockid, buf, n, 0);
}

static ssize_t
devsock_write(struct Fd *fd, const void *buf, size_t n)
{
  810be1:	55                   	push   %ebp
  810be2:	89 e5                	mov    %esp,%ebp
  810be4:	83 ec 18             	sub    $0x18,%esp
	return nsipc_send(fd->fd_sock.sockid, buf, n, 0);
  810be7:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  810bee:	00 
  810bef:	8b 45 10             	mov    0x10(%ebp),%eax
  810bf2:	89 44 24 08          	mov    %eax,0x8(%esp)
  810bf6:	8b 45 0c             	mov    0xc(%ebp),%eax
  810bf9:	89 44 24 04          	mov    %eax,0x4(%esp)
  810bfd:	8b 45 08             	mov    0x8(%ebp),%eax
  810c00:	8b 40 0c             	mov    0xc(%eax),%eax
  810c03:	89 04 24             	mov    %eax,(%esp)
  810c06:	e8 f0 03 00 00       	call   810ffb <nsipc_send>
}
  810c0b:	c9                   	leave  
  810c0c:	c3                   	ret    

00810c0d <devsock_read>:
	return nsipc_listen(r, backlog);
}

static ssize_t
devsock_read(struct Fd *fd, void *buf, size_t n)
{
  810c0d:	55                   	push   %ebp
  810c0e:	89 e5                	mov    %esp,%ebp
  810c10:	83 ec 18             	sub    $0x18,%esp
	return nsipc_recv(fd->fd_sock.sockid, buf, n, 0);
  810c13:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  810c1a:	00 
  810c1b:	8b 45 10             	mov    0x10(%ebp),%eax
  810c1e:	89 44 24 08          	mov    %eax,0x8(%esp)
  810c22:	8b 45 0c             	mov    0xc(%ebp),%eax
  810c25:	89 44 24 04          	mov    %eax,0x4(%esp)
  810c29:	8b 45 08             	mov    0x8(%ebp),%eax
  810c2c:	8b 40 0c             	mov    0xc(%eax),%eax
  810c2f:	89 04 24             	mov    %eax,(%esp)
  810c32:	e8 44 03 00 00       	call   810f7b <nsipc_recv>
}
  810c37:	c9                   	leave  
  810c38:	c3                   	ret    

00810c39 <fd2sockid>:
	.dev_stat =	devsock_stat,
};

static int
fd2sockid(int fd)
{
  810c39:	55                   	push   %ebp
  810c3a:	89 e5                	mov    %esp,%ebp
  810c3c:	83 ec 28             	sub    $0x28,%esp
	struct Fd *sfd;
	int r;

	if ((r = fd_lookup(fd, &sfd)) < 0)
  810c3f:	8d 55 f4             	lea    -0xc(%ebp),%edx
  810c42:	89 54 24 04          	mov    %edx,0x4(%esp)
  810c46:	89 04 24             	mov    %eax,(%esp)
  810c49:	e8 38 f7 ff ff       	call   810386 <fd_lookup>
  810c4e:	85 c0                	test   %eax,%eax
  810c50:	78 17                	js     810c69 <fd2sockid+0x30>
		return r;
	if (sfd->fd_dev_id != devsock.dev_id)
  810c52:	8b 45 f4             	mov    -0xc(%ebp),%eax
  810c55:	8b 0d 08 53 81 00    	mov    0x815308,%ecx
  810c5b:	39 08                	cmp    %ecx,(%eax)
  810c5d:	75 05                	jne    810c64 <fd2sockid+0x2b>
		return -E_NOT_SUPP;
	return sfd->fd_sock.sockid;
  810c5f:	8b 40 0c             	mov    0xc(%eax),%eax
  810c62:	eb 05                	jmp    810c69 <fd2sockid+0x30>
	int r;

	if ((r = fd_lookup(fd, &sfd)) < 0)
		return r;
	if (sfd->fd_dev_id != devsock.dev_id)
		return -E_NOT_SUPP;
  810c64:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
	return sfd->fd_sock.sockid;
}
  810c69:	c9                   	leave  
  810c6a:	c3                   	ret    

00810c6b <alloc_sockfd>:

static int
alloc_sockfd(int sockid)
{
  810c6b:	55                   	push   %ebp
  810c6c:	89 e5                	mov    %esp,%ebp
  810c6e:	56                   	push   %esi
  810c6f:	53                   	push   %ebx
  810c70:	83 ec 20             	sub    $0x20,%esp
  810c73:	89 c6                	mov    %eax,%esi
	struct Fd *sfd;
	int r;

	if ((r = fd_alloc(&sfd)) < 0
  810c75:	8d 45 f4             	lea    -0xc(%ebp),%eax
  810c78:	89 04 24             	mov    %eax,(%esp)
  810c7b:	e8 b7 f6 ff ff       	call   810337 <fd_alloc>
  810c80:	89 c3                	mov    %eax,%ebx
  810c82:	85 c0                	test   %eax,%eax
  810c84:	78 21                	js     810ca7 <alloc_sockfd+0x3c>
	    || (r = sys_page_alloc(0, sfd, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0) {
  810c86:	c7 44 24 08 07 04 00 	movl   $0x407,0x8(%esp)
  810c8d:	00 
  810c8e:	8b 45 f4             	mov    -0xc(%ebp),%eax
  810c91:	89 44 24 04          	mov    %eax,0x4(%esp)
  810c95:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  810c9c:	e8 12 ef ff ff       	call   80fbb3 <sys_page_alloc>
  810ca1:	89 c3                	mov    %eax,%ebx
  810ca3:	85 c0                	test   %eax,%eax
  810ca5:	79 0c                	jns    810cb3 <alloc_sockfd+0x48>
		nsipc_close(sockid);
  810ca7:	89 34 24             	mov    %esi,(%esp)
  810caa:	e8 51 02 00 00       	call   810f00 <nsipc_close>
		return r;
  810caf:	89 d8                	mov    %ebx,%eax
  810cb1:	eb 20                	jmp    810cd3 <alloc_sockfd+0x68>
	}

	sfd->fd_dev_id = devsock.dev_id;
  810cb3:	8b 15 08 53 81 00    	mov    0x815308,%edx
  810cb9:	8b 45 f4             	mov    -0xc(%ebp),%eax
  810cbc:	89 10                	mov    %edx,(%eax)
	sfd->fd_omode = O_RDWR;
  810cbe:	8b 55 f4             	mov    -0xc(%ebp),%edx
  810cc1:	c7 42 08 02 00 00 00 	movl   $0x2,0x8(%edx)
	sfd->fd_sock.sockid = sockid;
  810cc8:	89 72 0c             	mov    %esi,0xc(%edx)
	return fd2num(sfd);
  810ccb:	89 14 24             	mov    %edx,(%esp)
  810cce:	e8 3d f6 ff ff       	call   810310 <fd2num>
}
  810cd3:	83 c4 20             	add    $0x20,%esp
  810cd6:	5b                   	pop    %ebx
  810cd7:	5e                   	pop    %esi
  810cd8:	5d                   	pop    %ebp
  810cd9:	c3                   	ret    

00810cda <accept>:

int
accept(int s, struct sockaddr *addr, socklen_t *addrlen)
{
  810cda:	55                   	push   %ebp
  810cdb:	89 e5                	mov    %esp,%ebp
  810cdd:	83 ec 18             	sub    $0x18,%esp
	int r;
	if ((r = fd2sockid(s)) < 0)
  810ce0:	8b 45 08             	mov    0x8(%ebp),%eax
  810ce3:	e8 51 ff ff ff       	call   810c39 <fd2sockid>
		return r;
  810ce8:	89 c1                	mov    %eax,%ecx

int
accept(int s, struct sockaddr *addr, socklen_t *addrlen)
{
	int r;
	if ((r = fd2sockid(s)) < 0)
  810cea:	85 c0                	test   %eax,%eax
  810cec:	78 23                	js     810d11 <accept+0x37>
		return r;
	if ((r = nsipc_accept(r, addr, addrlen)) < 0)
  810cee:	8b 55 10             	mov    0x10(%ebp),%edx
  810cf1:	89 54 24 08          	mov    %edx,0x8(%esp)
  810cf5:	8b 55 0c             	mov    0xc(%ebp),%edx
  810cf8:	89 54 24 04          	mov    %edx,0x4(%esp)
  810cfc:	89 04 24             	mov    %eax,(%esp)
  810cff:	e8 45 01 00 00       	call   810e49 <nsipc_accept>
		return r;
  810d04:	89 c1                	mov    %eax,%ecx
accept(int s, struct sockaddr *addr, socklen_t *addrlen)
{
	int r;
	if ((r = fd2sockid(s)) < 0)
		return r;
	if ((r = nsipc_accept(r, addr, addrlen)) < 0)
  810d06:	85 c0                	test   %eax,%eax
  810d08:	78 07                	js     810d11 <accept+0x37>
		return r;
	return alloc_sockfd(r);
  810d0a:	e8 5c ff ff ff       	call   810c6b <alloc_sockfd>
  810d0f:	89 c1                	mov    %eax,%ecx
}
  810d11:	89 c8                	mov    %ecx,%eax
  810d13:	c9                   	leave  
  810d14:	c3                   	ret    

00810d15 <bind>:

int
bind(int s, struct sockaddr *name, socklen_t namelen)
{
  810d15:	55                   	push   %ebp
  810d16:	89 e5                	mov    %esp,%ebp
  810d18:	83 ec 18             	sub    $0x18,%esp
	int r;
	if ((r = fd2sockid(s)) < 0)
  810d1b:	8b 45 08             	mov    0x8(%ebp),%eax
  810d1e:	e8 16 ff ff ff       	call   810c39 <fd2sockid>
  810d23:	89 c2                	mov    %eax,%edx
  810d25:	85 d2                	test   %edx,%edx
  810d27:	78 16                	js     810d3f <bind+0x2a>
		return r;
	return nsipc_bind(r, name, namelen);
  810d29:	8b 45 10             	mov    0x10(%ebp),%eax
  810d2c:	89 44 24 08          	mov    %eax,0x8(%esp)
  810d30:	8b 45 0c             	mov    0xc(%ebp),%eax
  810d33:	89 44 24 04          	mov    %eax,0x4(%esp)
  810d37:	89 14 24             	mov    %edx,(%esp)
  810d3a:	e8 60 01 00 00       	call   810e9f <nsipc_bind>
}
  810d3f:	c9                   	leave  
  810d40:	c3                   	ret    

00810d41 <shutdown>:

int
shutdown(int s, int how)
{
  810d41:	55                   	push   %ebp
  810d42:	89 e5                	mov    %esp,%ebp
  810d44:	83 ec 18             	sub    $0x18,%esp
	int r;
	if ((r = fd2sockid(s)) < 0)
  810d47:	8b 45 08             	mov    0x8(%ebp),%eax
  810d4a:	e8 ea fe ff ff       	call   810c39 <fd2sockid>
  810d4f:	89 c2                	mov    %eax,%edx
  810d51:	85 d2                	test   %edx,%edx
  810d53:	78 0f                	js     810d64 <shutdown+0x23>
		return r;
	return nsipc_shutdown(r, how);
  810d55:	8b 45 0c             	mov    0xc(%ebp),%eax
  810d58:	89 44 24 04          	mov    %eax,0x4(%esp)
  810d5c:	89 14 24             	mov    %edx,(%esp)
  810d5f:	e8 7a 01 00 00       	call   810ede <nsipc_shutdown>
}
  810d64:	c9                   	leave  
  810d65:	c3                   	ret    

00810d66 <connect>:
		return 0;
}

int
connect(int s, const struct sockaddr *name, socklen_t namelen)
{
  810d66:	55                   	push   %ebp
  810d67:	89 e5                	mov    %esp,%ebp
  810d69:	83 ec 18             	sub    $0x18,%esp
	int r;
	if ((r = fd2sockid(s)) < 0)
  810d6c:	8b 45 08             	mov    0x8(%ebp),%eax
  810d6f:	e8 c5 fe ff ff       	call   810c39 <fd2sockid>
  810d74:	89 c2                	mov    %eax,%edx
  810d76:	85 d2                	test   %edx,%edx
  810d78:	78 16                	js     810d90 <connect+0x2a>
		return r;
	return nsipc_connect(r, name, namelen);
  810d7a:	8b 45 10             	mov    0x10(%ebp),%eax
  810d7d:	89 44 24 08          	mov    %eax,0x8(%esp)
  810d81:	8b 45 0c             	mov    0xc(%ebp),%eax
  810d84:	89 44 24 04          	mov    %eax,0x4(%esp)
  810d88:	89 14 24             	mov    %edx,(%esp)
  810d8b:	e8 8a 01 00 00       	call   810f1a <nsipc_connect>
}
  810d90:	c9                   	leave  
  810d91:	c3                   	ret    

00810d92 <listen>:

int
listen(int s, int backlog)
{
  810d92:	55                   	push   %ebp
  810d93:	89 e5                	mov    %esp,%ebp
  810d95:	83 ec 18             	sub    $0x18,%esp
	int r;
	if ((r = fd2sockid(s)) < 0)
  810d98:	8b 45 08             	mov    0x8(%ebp),%eax
  810d9b:	e8 99 fe ff ff       	call   810c39 <fd2sockid>
  810da0:	89 c2                	mov    %eax,%edx
  810da2:	85 d2                	test   %edx,%edx
  810da4:	78 0f                	js     810db5 <listen+0x23>
		return r;
	return nsipc_listen(r, backlog);
  810da6:	8b 45 0c             	mov    0xc(%ebp),%eax
  810da9:	89 44 24 04          	mov    %eax,0x4(%esp)
  810dad:	89 14 24             	mov    %edx,(%esp)
  810db0:	e8 a4 01 00 00       	call   810f59 <nsipc_listen>
}
  810db5:	c9                   	leave  
  810db6:	c3                   	ret    

00810db7 <socket>:
	return 0;
}

int
socket(int domain, int type, int protocol)
{
  810db7:	55                   	push   %ebp
  810db8:	89 e5                	mov    %esp,%ebp
  810dba:	83 ec 18             	sub    $0x18,%esp
	int r;
	if ((r = nsipc_socket(domain, type, protocol)) < 0)
  810dbd:	8b 45 10             	mov    0x10(%ebp),%eax
  810dc0:	89 44 24 08          	mov    %eax,0x8(%esp)
  810dc4:	8b 45 0c             	mov    0xc(%ebp),%eax
  810dc7:	89 44 24 04          	mov    %eax,0x4(%esp)
  810dcb:	8b 45 08             	mov    0x8(%ebp),%eax
  810dce:	89 04 24             	mov    %eax,(%esp)
  810dd1:	e8 98 02 00 00       	call   81106e <nsipc_socket>
  810dd6:	89 c2                	mov    %eax,%edx
  810dd8:	85 d2                	test   %edx,%edx
  810dda:	78 05                	js     810de1 <socket+0x2a>
		return r;
	return alloc_sockfd(r);
  810ddc:	e8 8a fe ff ff       	call   810c6b <alloc_sockfd>
}
  810de1:	c9                   	leave  
  810de2:	c3                   	ret    

00810de3 <nsipc>:
// may be written back to nsipcbuf.
// type: request code, passed as the simple integer IPC value.
// Returns 0 if successful, < 0 on failure.
static int
nsipc(unsigned type)
{
  810de3:	55                   	push   %ebp
  810de4:	89 e5                	mov    %esp,%ebp
  810de6:	53                   	push   %ebx
  810de7:	83 ec 14             	sub    $0x14,%esp
  810dea:	89 c3                	mov    %eax,%ebx
	static envid_t nsenv;
	if (nsenv == 0)
  810dec:	83 3d f0 c1 b3 00 00 	cmpl   $0x0,0xb3c1f0
  810df3:	75 11                	jne    810e06 <nsipc+0x23>
		nsenv = ipc_find_env(ENV_TYPE_NS);
  810df5:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  810dfc:	e8 d4 f4 ff ff       	call   8102d5 <ipc_find_env>
  810e01:	a3 f0 c1 b3 00       	mov    %eax,0xb3c1f0
	static_assert(sizeof(nsipcbuf) == PGSIZE);

	if (debug)
		cprintf("[%08x] nsipc %d\n", thisenv->env_id, type);

	ipc_send(nsenv, type, &nsipcbuf, PTE_P|PTE_W|PTE_U);
  810e06:	c7 44 24 0c 07 00 00 	movl   $0x7,0xc(%esp)
  810e0d:	00 
  810e0e:	c7 44 24 08 00 e0 b3 	movl   $0xb3e000,0x8(%esp)
  810e15:	00 
  810e16:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  810e1a:	a1 f0 c1 b3 00       	mov    0xb3c1f0,%eax
  810e1f:	89 04 24             	mov    %eax,(%esp)
  810e22:	e8 43 f4 ff ff       	call   81026a <ipc_send>
	return ipc_recv(NULL, NULL, NULL);
  810e27:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  810e2e:	00 
  810e2f:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  810e36:	00 
  810e37:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  810e3e:	e8 ad f3 ff ff       	call   8101f0 <ipc_recv>
}
  810e43:	83 c4 14             	add    $0x14,%esp
  810e46:	5b                   	pop    %ebx
  810e47:	5d                   	pop    %ebp
  810e48:	c3                   	ret    

00810e49 <nsipc_accept>:

int
nsipc_accept(int s, struct sockaddr *addr, socklen_t *addrlen)
{
  810e49:	55                   	push   %ebp
  810e4a:	89 e5                	mov    %esp,%ebp
  810e4c:	56                   	push   %esi
  810e4d:	53                   	push   %ebx
  810e4e:	83 ec 10             	sub    $0x10,%esp
  810e51:	8b 75 10             	mov    0x10(%ebp),%esi
	int r;

	nsipcbuf.accept.req_s = s;
  810e54:	8b 45 08             	mov    0x8(%ebp),%eax
  810e57:	a3 00 e0 b3 00       	mov    %eax,0xb3e000
	nsipcbuf.accept.req_addrlen = *addrlen;
  810e5c:	8b 06                	mov    (%esi),%eax
  810e5e:	a3 04 e0 b3 00       	mov    %eax,0xb3e004
	if ((r = nsipc(NSREQ_ACCEPT)) >= 0) {
  810e63:	b8 01 00 00 00       	mov    $0x1,%eax
  810e68:	e8 76 ff ff ff       	call   810de3 <nsipc>
  810e6d:	89 c3                	mov    %eax,%ebx
  810e6f:	85 c0                	test   %eax,%eax
  810e71:	78 23                	js     810e96 <nsipc_accept+0x4d>
		struct Nsret_accept *ret = &nsipcbuf.acceptRet;
		memmove(addr, &ret->ret_addr, ret->ret_addrlen);
  810e73:	a1 10 e0 b3 00       	mov    0xb3e010,%eax
  810e78:	89 44 24 08          	mov    %eax,0x8(%esp)
  810e7c:	c7 44 24 04 00 e0 b3 	movl   $0xb3e000,0x4(%esp)
  810e83:	00 
  810e84:	8b 45 0c             	mov    0xc(%ebp),%eax
  810e87:	89 04 24             	mov    %eax,(%esp)
  810e8a:	e8 a5 ea ff ff       	call   80f934 <memmove>
		*addrlen = ret->ret_addrlen;
  810e8f:	a1 10 e0 b3 00       	mov    0xb3e010,%eax
  810e94:	89 06                	mov    %eax,(%esi)
	}
	return r;
}
  810e96:	89 d8                	mov    %ebx,%eax
  810e98:	83 c4 10             	add    $0x10,%esp
  810e9b:	5b                   	pop    %ebx
  810e9c:	5e                   	pop    %esi
  810e9d:	5d                   	pop    %ebp
  810e9e:	c3                   	ret    

00810e9f <nsipc_bind>:

int
nsipc_bind(int s, struct sockaddr *name, socklen_t namelen)
{
  810e9f:	55                   	push   %ebp
  810ea0:	89 e5                	mov    %esp,%ebp
  810ea2:	53                   	push   %ebx
  810ea3:	83 ec 14             	sub    $0x14,%esp
  810ea6:	8b 5d 10             	mov    0x10(%ebp),%ebx
	nsipcbuf.bind.req_s = s;
  810ea9:	8b 45 08             	mov    0x8(%ebp),%eax
  810eac:	a3 00 e0 b3 00       	mov    %eax,0xb3e000
	memmove(&nsipcbuf.bind.req_name, name, namelen);
  810eb1:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  810eb5:	8b 45 0c             	mov    0xc(%ebp),%eax
  810eb8:	89 44 24 04          	mov    %eax,0x4(%esp)
  810ebc:	c7 04 24 04 e0 b3 00 	movl   $0xb3e004,(%esp)
  810ec3:	e8 6c ea ff ff       	call   80f934 <memmove>
	nsipcbuf.bind.req_namelen = namelen;
  810ec8:	89 1d 14 e0 b3 00    	mov    %ebx,0xb3e014
	return nsipc(NSREQ_BIND);
  810ece:	b8 02 00 00 00       	mov    $0x2,%eax
  810ed3:	e8 0b ff ff ff       	call   810de3 <nsipc>
}
  810ed8:	83 c4 14             	add    $0x14,%esp
  810edb:	5b                   	pop    %ebx
  810edc:	5d                   	pop    %ebp
  810edd:	c3                   	ret    

00810ede <nsipc_shutdown>:

int
nsipc_shutdown(int s, int how)
{
  810ede:	55                   	push   %ebp
  810edf:	89 e5                	mov    %esp,%ebp
  810ee1:	83 ec 08             	sub    $0x8,%esp
	nsipcbuf.shutdown.req_s = s;
  810ee4:	8b 45 08             	mov    0x8(%ebp),%eax
  810ee7:	a3 00 e0 b3 00       	mov    %eax,0xb3e000
	nsipcbuf.shutdown.req_how = how;
  810eec:	8b 45 0c             	mov    0xc(%ebp),%eax
  810eef:	a3 04 e0 b3 00       	mov    %eax,0xb3e004
	return nsipc(NSREQ_SHUTDOWN);
  810ef4:	b8 03 00 00 00       	mov    $0x3,%eax
  810ef9:	e8 e5 fe ff ff       	call   810de3 <nsipc>
}
  810efe:	c9                   	leave  
  810eff:	c3                   	ret    

00810f00 <nsipc_close>:

int
nsipc_close(int s)
{
  810f00:	55                   	push   %ebp
  810f01:	89 e5                	mov    %esp,%ebp
  810f03:	83 ec 08             	sub    $0x8,%esp
	nsipcbuf.close.req_s = s;
  810f06:	8b 45 08             	mov    0x8(%ebp),%eax
  810f09:	a3 00 e0 b3 00       	mov    %eax,0xb3e000
	return nsipc(NSREQ_CLOSE);
  810f0e:	b8 04 00 00 00       	mov    $0x4,%eax
  810f13:	e8 cb fe ff ff       	call   810de3 <nsipc>
}
  810f18:	c9                   	leave  
  810f19:	c3                   	ret    

00810f1a <nsipc_connect>:

int
nsipc_connect(int s, const struct sockaddr *name, socklen_t namelen)
{
  810f1a:	55                   	push   %ebp
  810f1b:	89 e5                	mov    %esp,%ebp
  810f1d:	53                   	push   %ebx
  810f1e:	83 ec 14             	sub    $0x14,%esp
  810f21:	8b 5d 10             	mov    0x10(%ebp),%ebx
	nsipcbuf.connect.req_s = s;
  810f24:	8b 45 08             	mov    0x8(%ebp),%eax
  810f27:	a3 00 e0 b3 00       	mov    %eax,0xb3e000
	memmove(&nsipcbuf.connect.req_name, name, namelen);
  810f2c:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  810f30:	8b 45 0c             	mov    0xc(%ebp),%eax
  810f33:	89 44 24 04          	mov    %eax,0x4(%esp)
  810f37:	c7 04 24 04 e0 b3 00 	movl   $0xb3e004,(%esp)
  810f3e:	e8 f1 e9 ff ff       	call   80f934 <memmove>
	nsipcbuf.connect.req_namelen = namelen;
  810f43:	89 1d 14 e0 b3 00    	mov    %ebx,0xb3e014
	return nsipc(NSREQ_CONNECT);
  810f49:	b8 05 00 00 00       	mov    $0x5,%eax
  810f4e:	e8 90 fe ff ff       	call   810de3 <nsipc>
}
  810f53:	83 c4 14             	add    $0x14,%esp
  810f56:	5b                   	pop    %ebx
  810f57:	5d                   	pop    %ebp
  810f58:	c3                   	ret    

00810f59 <nsipc_listen>:

int
nsipc_listen(int s, int backlog)
{
  810f59:	55                   	push   %ebp
  810f5a:	89 e5                	mov    %esp,%ebp
  810f5c:	83 ec 08             	sub    $0x8,%esp
	nsipcbuf.listen.req_s = s;
  810f5f:	8b 45 08             	mov    0x8(%ebp),%eax
  810f62:	a3 00 e0 b3 00       	mov    %eax,0xb3e000
	nsipcbuf.listen.req_backlog = backlog;
  810f67:	8b 45 0c             	mov    0xc(%ebp),%eax
  810f6a:	a3 04 e0 b3 00       	mov    %eax,0xb3e004
	return nsipc(NSREQ_LISTEN);
  810f6f:	b8 06 00 00 00       	mov    $0x6,%eax
  810f74:	e8 6a fe ff ff       	call   810de3 <nsipc>
}
  810f79:	c9                   	leave  
  810f7a:	c3                   	ret    

00810f7b <nsipc_recv>:

int
nsipc_recv(int s, void *mem, int len, unsigned int flags)
{
  810f7b:	55                   	push   %ebp
  810f7c:	89 e5                	mov    %esp,%ebp
  810f7e:	56                   	push   %esi
  810f7f:	53                   	push   %ebx
  810f80:	83 ec 10             	sub    $0x10,%esp
  810f83:	8b 75 10             	mov    0x10(%ebp),%esi
	int r;

	nsipcbuf.recv.req_s = s;
  810f86:	8b 45 08             	mov    0x8(%ebp),%eax
  810f89:	a3 00 e0 b3 00       	mov    %eax,0xb3e000
	nsipcbuf.recv.req_len = len;
  810f8e:	89 35 04 e0 b3 00    	mov    %esi,0xb3e004
	nsipcbuf.recv.req_flags = flags;
  810f94:	8b 45 14             	mov    0x14(%ebp),%eax
  810f97:	a3 08 e0 b3 00       	mov    %eax,0xb3e008

	if ((r = nsipc(NSREQ_RECV)) >= 0) {
  810f9c:	b8 07 00 00 00       	mov    $0x7,%eax
  810fa1:	e8 3d fe ff ff       	call   810de3 <nsipc>
  810fa6:	89 c3                	mov    %eax,%ebx
  810fa8:	85 c0                	test   %eax,%eax
  810faa:	78 46                	js     810ff2 <nsipc_recv+0x77>
		assert(r < 1600 && r <= len);
  810fac:	39 f0                	cmp    %esi,%eax
  810fae:	7f 07                	jg     810fb7 <nsipc_recv+0x3c>
  810fb0:	3d 3f 06 00 00       	cmp    $0x63f,%eax
  810fb5:	7e 24                	jle    810fdb <nsipc_recv+0x60>
  810fb7:	c7 44 24 0c 3a 46 81 	movl   $0x81463a,0xc(%esp)
  810fbe:	00 
  810fbf:	c7 44 24 08 7f 33 81 	movl   $0x81337f,0x8(%esp)
  810fc6:	00 
  810fc7:	c7 44 24 04 62 00 00 	movl   $0x62,0x4(%esp)
  810fce:	00 
  810fcf:	c7 04 24 4f 46 81 00 	movl   $0x81464f,(%esp)
  810fd6:	e8 9f e0 ff ff       	call   80f07a <_panic>
		memmove(mem, nsipcbuf.recvRet.ret_buf, r);
  810fdb:	89 44 24 08          	mov    %eax,0x8(%esp)
  810fdf:	c7 44 24 04 00 e0 b3 	movl   $0xb3e000,0x4(%esp)
  810fe6:	00 
  810fe7:	8b 45 0c             	mov    0xc(%ebp),%eax
  810fea:	89 04 24             	mov    %eax,(%esp)
  810fed:	e8 42 e9 ff ff       	call   80f934 <memmove>
	}

	return r;
}
  810ff2:	89 d8                	mov    %ebx,%eax
  810ff4:	83 c4 10             	add    $0x10,%esp
  810ff7:	5b                   	pop    %ebx
  810ff8:	5e                   	pop    %esi
  810ff9:	5d                   	pop    %ebp
  810ffa:	c3                   	ret    

00810ffb <nsipc_send>:

int
nsipc_send(int s, const void *buf, int size, unsigned int flags)
{
  810ffb:	55                   	push   %ebp
  810ffc:	89 e5                	mov    %esp,%ebp
  810ffe:	53                   	push   %ebx
  810fff:	83 ec 14             	sub    $0x14,%esp
  811002:	8b 5d 10             	mov    0x10(%ebp),%ebx
	nsipcbuf.send.req_s = s;
  811005:	8b 45 08             	mov    0x8(%ebp),%eax
  811008:	a3 00 e0 b3 00       	mov    %eax,0xb3e000
	assert(size < 1600);
  81100d:	81 fb 3f 06 00 00    	cmp    $0x63f,%ebx
  811013:	7e 24                	jle    811039 <nsipc_send+0x3e>
  811015:	c7 44 24 0c 5b 46 81 	movl   $0x81465b,0xc(%esp)
  81101c:	00 
  81101d:	c7 44 24 08 7f 33 81 	movl   $0x81337f,0x8(%esp)
  811024:	00 
  811025:	c7 44 24 04 6d 00 00 	movl   $0x6d,0x4(%esp)
  81102c:	00 
  81102d:	c7 04 24 4f 46 81 00 	movl   $0x81464f,(%esp)
  811034:	e8 41 e0 ff ff       	call   80f07a <_panic>
	memmove(&nsipcbuf.send.req_buf, buf, size);
  811039:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  81103d:	8b 45 0c             	mov    0xc(%ebp),%eax
  811040:	89 44 24 04          	mov    %eax,0x4(%esp)
  811044:	c7 04 24 0c e0 b3 00 	movl   $0xb3e00c,(%esp)
  81104b:	e8 e4 e8 ff ff       	call   80f934 <memmove>
	nsipcbuf.send.req_size = size;
  811050:	89 1d 04 e0 b3 00    	mov    %ebx,0xb3e004
	nsipcbuf.send.req_flags = flags;
  811056:	8b 45 14             	mov    0x14(%ebp),%eax
  811059:	a3 08 e0 b3 00       	mov    %eax,0xb3e008
	return nsipc(NSREQ_SEND);
  81105e:	b8 08 00 00 00       	mov    $0x8,%eax
  811063:	e8 7b fd ff ff       	call   810de3 <nsipc>
}
  811068:	83 c4 14             	add    $0x14,%esp
  81106b:	5b                   	pop    %ebx
  81106c:	5d                   	pop    %ebp
  81106d:	c3                   	ret    

0081106e <nsipc_socket>:

int
nsipc_socket(int domain, int type, int protocol)
{
  81106e:	55                   	push   %ebp
  81106f:	89 e5                	mov    %esp,%ebp
  811071:	83 ec 08             	sub    $0x8,%esp
	nsipcbuf.socket.req_domain = domain;
  811074:	8b 45 08             	mov    0x8(%ebp),%eax
  811077:	a3 00 e0 b3 00       	mov    %eax,0xb3e000
	nsipcbuf.socket.req_type = type;
  81107c:	8b 45 0c             	mov    0xc(%ebp),%eax
  81107f:	a3 04 e0 b3 00       	mov    %eax,0xb3e004
	nsipcbuf.socket.req_protocol = protocol;
  811084:	8b 45 10             	mov    0x10(%ebp),%eax
  811087:	a3 08 e0 b3 00       	mov    %eax,0xb3e008
	return nsipc(NSREQ_SOCKET);
  81108c:	b8 09 00 00 00       	mov    $0x9,%eax
  811091:	e8 4d fd ff ff       	call   810de3 <nsipc>
}
  811096:	c9                   	leave  
  811097:	c3                   	ret    
  811098:	66 90                	xchg   %ax,%ax
  81109a:	66 90                	xchg   %ax,%ax
  81109c:	66 90                	xchg   %ax,%ax
  81109e:	66 90                	xchg   %ax,%ax

008110a0 <free>:
	return v;
}

void
free(void *v)
{
  8110a0:	55                   	push   %ebp
  8110a1:	89 e5                	mov    %esp,%ebp
  8110a3:	53                   	push   %ebx
  8110a4:	83 ec 14             	sub    $0x14,%esp
  8110a7:	8b 5d 08             	mov    0x8(%ebp),%ebx
	uint8_t *c;
	uint32_t *ref;

	if (v == 0)
  8110aa:	85 db                	test   %ebx,%ebx
  8110ac:	0f 84 ba 00 00 00    	je     81116c <free+0xcc>
		return;
	assert(mbegin <= (uint8_t*) v && (uint8_t*) v < mend);
  8110b2:	81 fb ff ff ff 07    	cmp    $0x7ffffff,%ebx
  8110b8:	76 08                	jbe    8110c2 <free+0x22>
  8110ba:	81 fb ff ff ff 0f    	cmp    $0xfffffff,%ebx
  8110c0:	76 24                	jbe    8110e6 <free+0x46>
  8110c2:	c7 44 24 0c 68 46 81 	movl   $0x814668,0xc(%esp)
  8110c9:	00 
  8110ca:	c7 44 24 08 7f 33 81 	movl   $0x81337f,0x8(%esp)
  8110d1:	00 
  8110d2:	c7 44 24 04 7a 00 00 	movl   $0x7a,0x4(%esp)
  8110d9:	00 
  8110da:	c7 04 24 98 46 81 00 	movl   $0x814698,(%esp)
  8110e1:	e8 94 df ff ff       	call   80f07a <_panic>

	c = ROUNDDOWN(v, PGSIZE);
  8110e6:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx

	while (uvpt[PGNUM(c)] & PTE_CONTINUED) {
  8110ec:	eb 4a                	jmp    811138 <free+0x98>
		sys_page_unmap(0, c);
  8110ee:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8110f2:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8110f9:	e8 5c eb ff ff       	call   80fc5a <sys_page_unmap>
		c += PGSIZE;
  8110fe:	81 c3 00 10 00 00    	add    $0x1000,%ebx
		assert(mbegin <= c && c < mend);
  811104:	81 fb ff ff ff 07    	cmp    $0x7ffffff,%ebx
  81110a:	76 08                	jbe    811114 <free+0x74>
  81110c:	81 fb ff ff ff 0f    	cmp    $0xfffffff,%ebx
  811112:	76 24                	jbe    811138 <free+0x98>
  811114:	c7 44 24 0c a5 46 81 	movl   $0x8146a5,0xc(%esp)
  81111b:	00 
  81111c:	c7 44 24 08 7f 33 81 	movl   $0x81337f,0x8(%esp)
  811123:	00 
  811124:	c7 44 24 04 81 00 00 	movl   $0x81,0x4(%esp)
  81112b:	00 
  81112c:	c7 04 24 98 46 81 00 	movl   $0x814698,(%esp)
  811133:	e8 42 df ff ff       	call   80f07a <_panic>
		return;
	assert(mbegin <= (uint8_t*) v && (uint8_t*) v < mend);

	c = ROUNDDOWN(v, PGSIZE);

	while (uvpt[PGNUM(c)] & PTE_CONTINUED) {
  811138:	89 d8                	mov    %ebx,%eax
  81113a:	c1 e8 0c             	shr    $0xc,%eax
  81113d:	8b 04 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%eax
  811144:	f6 c4 02             	test   $0x2,%ah
  811147:	75 a5                	jne    8110ee <free+0x4e>
	/*
	 * c is just a piece of this page, so dec the ref count
	 * and maybe free the page.
	 */
	ref = (uint32_t*) (c + PGSIZE - 4);
	if (--(*ref) == 0)
  811149:	8b 83 fc 0f 00 00    	mov    0xffc(%ebx),%eax
  81114f:	83 e8 01             	sub    $0x1,%eax
  811152:	89 83 fc 0f 00 00    	mov    %eax,0xffc(%ebx)
  811158:	85 c0                	test   %eax,%eax
  81115a:	75 10                	jne    81116c <free+0xcc>
		sys_page_unmap(0, c);
  81115c:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  811160:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  811167:	e8 ee ea ff ff       	call   80fc5a <sys_page_unmap>
}
  81116c:	83 c4 14             	add    $0x14,%esp
  81116f:	5b                   	pop    %ebx
  811170:	5d                   	pop    %ebp
  811171:	c3                   	ret    

00811172 <malloc>:
	return 1;
}

void*
malloc(size_t n)
{
  811172:	55                   	push   %ebp
  811173:	89 e5                	mov    %esp,%ebp
  811175:	57                   	push   %edi
  811176:	56                   	push   %esi
  811177:	53                   	push   %ebx
  811178:	83 ec 2c             	sub    $0x2c,%esp
	int i, cont;
	int nwrap;
	uint32_t *ref;
	void *v;

	if (mptr == 0)
  81117b:	83 3d f4 c1 b3 00 00 	cmpl   $0x0,0xb3c1f4
  811182:	75 0a                	jne    81118e <malloc+0x1c>
		mptr = mbegin;
  811184:	c7 05 f4 c1 b3 00 00 	movl   $0x8000000,0xb3c1f4
  81118b:	00 00 08 

	n = ROUNDUP(n, 4);
  81118e:	8b 45 08             	mov    0x8(%ebp),%eax
  811191:	83 c0 03             	add    $0x3,%eax
  811194:	83 e0 fc             	and    $0xfffffffc,%eax
  811197:	89 45 e0             	mov    %eax,-0x20(%ebp)

	if (n >= MAXMALLOC)
  81119a:	3d ff ff 0f 00       	cmp    $0xfffff,%eax
  81119f:	0f 87 64 01 00 00    	ja     811309 <malloc+0x197>
		return 0;

	if ((uintptr_t) mptr % PGSIZE){
  8111a5:	a1 f4 c1 b3 00       	mov    0xb3c1f4,%eax
  8111aa:	a9 ff 0f 00 00       	test   $0xfff,%eax
  8111af:	75 15                	jne    8111c6 <malloc+0x54>
  8111b1:	8b 35 f4 c1 b3 00    	mov    0xb3c1f4,%esi
	return 1;
}

void*
malloc(size_t n)
{
  8111b7:	c7 45 dc 02 00 00 00 	movl   $0x2,-0x24(%ebp)
	 * runs of more than a page can't have ref counts so we
	 * flag the PTE entries instead.
	 */
	nwrap = 0;
	while (1) {
		if (isfree(mptr, n + 4))
  8111be:	8b 45 e0             	mov    -0x20(%ebp),%eax
  8111c1:	8d 78 04             	lea    0x4(%eax),%edi
  8111c4:	eb 50                	jmp    811216 <malloc+0xa4>
		 * we're in the middle of a partially
		 * allocated page - can we add this chunk?
		 * the +4 below is for the ref count.
		 */
		ref = (uint32_t*) (ROUNDUP(mptr, PGSIZE) - 4);
		if ((uintptr_t) mptr / PGSIZE == (uintptr_t) (mptr + n - 1 + 4) / PGSIZE) {
  8111c6:	89 c1                	mov    %eax,%ecx
  8111c8:	c1 e9 0c             	shr    $0xc,%ecx
  8111cb:	8b 5d e0             	mov    -0x20(%ebp),%ebx
  8111ce:	8d 54 18 03          	lea    0x3(%eax,%ebx,1),%edx
  8111d2:	c1 ea 0c             	shr    $0xc,%edx
  8111d5:	39 d1                	cmp    %edx,%ecx
  8111d7:	75 1f                	jne    8111f8 <malloc+0x86>
		/*
		 * we're in the middle of a partially
		 * allocated page - can we add this chunk?
		 * the +4 below is for the ref count.
		 */
		ref = (uint32_t*) (ROUNDUP(mptr, PGSIZE) - 4);
  8111d9:	8d 90 ff 0f 00 00    	lea    0xfff(%eax),%edx
  8111df:	81 e2 00 f0 ff ff    	and    $0xfffff000,%edx
		if ((uintptr_t) mptr / PGSIZE == (uintptr_t) (mptr + n - 1 + 4) / PGSIZE) {
			(*ref)++;
  8111e5:	83 42 fc 01          	addl   $0x1,-0x4(%edx)
			v = mptr;
			mptr += n;
  8111e9:	89 da                	mov    %ebx,%edx
  8111eb:	01 c2                	add    %eax,%edx
  8111ed:	89 15 f4 c1 b3 00    	mov    %edx,0xb3c1f4
			return v;
  8111f3:	e9 2f 01 00 00       	jmp    811327 <malloc+0x1b5>
		}
		/*
		 * stop working on this page and move on.
		 */
		free(mptr);	/* drop reference to this page */
  8111f8:	89 04 24             	mov    %eax,(%esp)
  8111fb:	e8 a0 fe ff ff       	call   8110a0 <free>
		mptr = ROUNDDOWN(mptr + PGSIZE, PGSIZE);
  811200:	a1 f4 c1 b3 00       	mov    0xb3c1f4,%eax
  811205:	05 00 10 00 00       	add    $0x1000,%eax
  81120a:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  81120f:	a3 f4 c1 b3 00       	mov    %eax,0xb3c1f4
  811214:	eb 9b                	jmp    8111b1 <malloc+0x3f>
  811216:	89 75 e4             	mov    %esi,-0x1c(%ebp)
	 * runs of more than a page can't have ref counts so we
	 * flag the PTE entries instead.
	 */
	nwrap = 0;
	while (1) {
		if (isfree(mptr, n + 4))
  811219:	89 fb                	mov    %edi,%ebx
  81121b:	8d 0c 37             	lea    (%edi,%esi,1),%ecx
static int
isfree(void *v, size_t n)
{
	uintptr_t va, end_va = (uintptr_t) v + n;

	for (va = (uintptr_t) v; va < end_va; va += PGSIZE)
  81121e:	89 f0                	mov    %esi,%eax
  811220:	eb 36                	jmp    811258 <malloc+0xe6>
		if (va >= (uintptr_t) mend
  811222:	3d ff ff ff 0f       	cmp    $0xfffffff,%eax
  811227:	0f 87 e3 00 00 00    	ja     811310 <malloc+0x19e>
		    || ((uvpd[PDX(va)] & PTE_P) && (uvpt[PGNUM(va)] & PTE_P)))
  81122d:	89 c2                	mov    %eax,%edx
  81122f:	c1 ea 16             	shr    $0x16,%edx
  811232:	8b 14 95 00 d0 7b ef 	mov    -0x10843000(,%edx,4),%edx
  811239:	f6 c2 01             	test   $0x1,%dl
  81123c:	74 15                	je     811253 <malloc+0xe1>
  81123e:	89 c2                	mov    %eax,%edx
  811240:	c1 ea 0c             	shr    $0xc,%edx
  811243:	8b 14 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%edx
  81124a:	f6 c2 01             	test   $0x1,%dl
  81124d:	0f 85 bd 00 00 00    	jne    811310 <malloc+0x19e>
static int
isfree(void *v, size_t n)
{
	uintptr_t va, end_va = (uintptr_t) v + n;

	for (va = (uintptr_t) v; va < end_va; va += PGSIZE)
  811253:	05 00 10 00 00       	add    $0x1000,%eax
  811258:	39 c1                	cmp    %eax,%ecx
  81125a:	77 c6                	ja     811222 <malloc+0xb0>
  81125c:	eb 7e                	jmp    8112dc <malloc+0x16a>
		if (isfree(mptr, n + 4))
			break;
		mptr += PGSIZE;
		if (mptr == mend) {
			mptr = mbegin;
			if (++nwrap == 2)
  81125e:	83 6d dc 01          	subl   $0x1,-0x24(%ebp)
  811262:	74 07                	je     81126b <malloc+0xf9>
	while (1) {
		if (isfree(mptr, n + 4))
			break;
		mptr += PGSIZE;
		if (mptr == mend) {
			mptr = mbegin;
  811264:	be 00 00 00 08       	mov    $0x8000000,%esi
  811269:	eb ab                	jmp    811216 <malloc+0xa4>
  81126b:	c7 05 f4 c1 b3 00 00 	movl   $0x8000000,0xb3c1f4
  811272:	00 00 08 
			if (++nwrap == 2)
				return 0;	/* out of address space */
  811275:	b8 00 00 00 00       	mov    $0x0,%eax
  81127a:	e9 a8 00 00 00       	jmp    811327 <malloc+0x1b5>

	/*
	 * allocate at mptr - the +4 makes sure we allocate a ref count.
	 */
	for (i = 0; i < n + 4; i += PGSIZE){
		cont = (i + PGSIZE < n + 4) ? PTE_CONTINUED : 0;
  81127f:	8d be 00 10 00 00    	lea    0x1000(%esi),%edi
  811285:	39 df                	cmp    %ebx,%edi
  811287:	19 c0                	sbb    %eax,%eax
  811289:	25 00 02 00 00       	and    $0x200,%eax
		if (sys_page_alloc(0, mptr + i, PTE_P|PTE_U|PTE_W|cont) < 0){
  81128e:	83 c8 07             	or     $0x7,%eax
  811291:	89 44 24 08          	mov    %eax,0x8(%esp)
  811295:	03 15 f4 c1 b3 00    	add    0xb3c1f4,%edx
  81129b:	89 54 24 04          	mov    %edx,0x4(%esp)
  81129f:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8112a6:	e8 08 e9 ff ff       	call   80fbb3 <sys_page_alloc>
  8112ab:	85 c0                	test   %eax,%eax
  8112ad:	78 22                	js     8112d1 <malloc+0x15f>
	}

	/*
	 * allocate at mptr - the +4 makes sure we allocate a ref count.
	 */
	for (i = 0; i < n + 4; i += PGSIZE){
  8112af:	89 fe                	mov    %edi,%esi
  8112b1:	eb 36                	jmp    8112e9 <malloc+0x177>
		cont = (i + PGSIZE < n + 4) ? PTE_CONTINUED : 0;
		if (sys_page_alloc(0, mptr + i, PTE_P|PTE_U|PTE_W|cont) < 0){
			for (; i >= 0; i -= PGSIZE)
				sys_page_unmap(0, mptr + i);
  8112b3:	89 f0                	mov    %esi,%eax
  8112b5:	03 05 f4 c1 b3 00    	add    0xb3c1f4,%eax
  8112bb:	89 44 24 04          	mov    %eax,0x4(%esp)
  8112bf:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8112c6:	e8 8f e9 ff ff       	call   80fc5a <sys_page_unmap>
	 * allocate at mptr - the +4 makes sure we allocate a ref count.
	 */
	for (i = 0; i < n + 4; i += PGSIZE){
		cont = (i + PGSIZE < n + 4) ? PTE_CONTINUED : 0;
		if (sys_page_alloc(0, mptr + i, PTE_P|PTE_U|PTE_W|cont) < 0){
			for (; i >= 0; i -= PGSIZE)
  8112cb:	81 ee 00 10 00 00    	sub    $0x1000,%esi
  8112d1:	85 f6                	test   %esi,%esi
  8112d3:	79 de                	jns    8112b3 <malloc+0x141>
				sys_page_unmap(0, mptr + i);
			return 0;	/* out of physical memory */
  8112d5:	b8 00 00 00 00       	mov    $0x0,%eax
  8112da:	eb 4b                	jmp    811327 <malloc+0x1b5>
  8112dc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8112df:	a3 f4 c1 b3 00       	mov    %eax,0xb3c1f4
static int
isfree(void *v, size_t n)
{
	uintptr_t va, end_va = (uintptr_t) v + n;

	for (va = (uintptr_t) v; va < end_va; va += PGSIZE)
  8112e4:	be 00 00 00 00       	mov    $0x0,%esi
	}

	/*
	 * allocate at mptr - the +4 makes sure we allocate a ref count.
	 */
	for (i = 0; i < n + 4; i += PGSIZE){
  8112e9:	89 f2                	mov    %esi,%edx
  8112eb:	39 de                	cmp    %ebx,%esi
  8112ed:	72 90                	jb     81127f <malloc+0x10d>
				sys_page_unmap(0, mptr + i);
			return 0;	/* out of physical memory */
		}
	}

	ref = (uint32_t*) (mptr + i - 4);
  8112ef:	a1 f4 c1 b3 00       	mov    0xb3c1f4,%eax
	*ref = 2;	/* reference for mptr, reference for returned block */
  8112f4:	c7 44 30 fc 02 00 00 	movl   $0x2,-0x4(%eax,%esi,1)
  8112fb:	00 
	v = mptr;
	mptr += n;
  8112fc:	8b 55 e0             	mov    -0x20(%ebp),%edx
  8112ff:	01 c2                	add    %eax,%edx
  811301:	89 15 f4 c1 b3 00    	mov    %edx,0xb3c1f4
	return v;
  811307:	eb 1e                	jmp    811327 <malloc+0x1b5>
		mptr = mbegin;

	n = ROUNDUP(n, 4);

	if (n >= MAXMALLOC)
		return 0;
  811309:	b8 00 00 00 00       	mov    $0x0,%eax
  81130e:	eb 17                	jmp    811327 <malloc+0x1b5>
  811310:	81 c6 00 10 00 00    	add    $0x1000,%esi
	nwrap = 0;
	while (1) {
		if (isfree(mptr, n + 4))
			break;
		mptr += PGSIZE;
		if (mptr == mend) {
  811316:	81 fe 00 00 00 10    	cmp    $0x10000000,%esi
  81131c:	0f 84 3c ff ff ff    	je     81125e <malloc+0xec>
  811322:	e9 ef fe ff ff       	jmp    811216 <malloc+0xa4>
	ref = (uint32_t*) (mptr + i - 4);
	*ref = 2;	/* reference for mptr, reference for returned block */
	v = mptr;
	mptr += n;
	return v;
}
  811327:	83 c4 2c             	add    $0x2c,%esp
  81132a:	5b                   	pop    %ebx
  81132b:	5e                   	pop    %esi
  81132c:	5f                   	pop    %edi
  81132d:	5d                   	pop    %ebp
  81132e:	c3                   	ret    

0081132f <devpipe_stat>:
	return i;
}

static int
devpipe_stat(struct Fd *fd, struct Stat *stat)
{
  81132f:	55                   	push   %ebp
  811330:	89 e5                	mov    %esp,%ebp
  811332:	56                   	push   %esi
  811333:	53                   	push   %ebx
  811334:	83 ec 10             	sub    $0x10,%esp
  811337:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	struct Pipe *p = (struct Pipe*) fd2data(fd);
  81133a:	8b 45 08             	mov    0x8(%ebp),%eax
  81133d:	89 04 24             	mov    %eax,(%esp)
  811340:	e8 db ef ff ff       	call   810320 <fd2data>
  811345:	89 c6                	mov    %eax,%esi
	strcpy(stat->st_name, "<pipe>");
  811347:	c7 44 24 04 bd 46 81 	movl   $0x8146bd,0x4(%esp)
  81134e:	00 
  81134f:	89 1c 24             	mov    %ebx,(%esp)
  811352:	e8 40 e4 ff ff       	call   80f797 <strcpy>
	stat->st_size = p->p_wpos - p->p_rpos;
  811357:	8b 46 04             	mov    0x4(%esi),%eax
  81135a:	2b 06                	sub    (%esi),%eax
  81135c:	89 83 80 00 00 00    	mov    %eax,0x80(%ebx)
	stat->st_isdir = 0;
  811362:	c7 83 84 00 00 00 00 	movl   $0x0,0x84(%ebx)
  811369:	00 00 00 
	stat->st_dev = &devpipe;
  81136c:	c7 83 88 00 00 00 24 	movl   $0x815324,0x88(%ebx)
  811373:	53 81 00 
	return 0;
}
  811376:	b8 00 00 00 00       	mov    $0x0,%eax
  81137b:	83 c4 10             	add    $0x10,%esp
  81137e:	5b                   	pop    %ebx
  81137f:	5e                   	pop    %esi
  811380:	5d                   	pop    %ebp
  811381:	c3                   	ret    

00811382 <devpipe_close>:

static int
devpipe_close(struct Fd *fd)
{
  811382:	55                   	push   %ebp
  811383:	89 e5                	mov    %esp,%ebp
  811385:	53                   	push   %ebx
  811386:	83 ec 14             	sub    $0x14,%esp
  811389:	8b 5d 08             	mov    0x8(%ebp),%ebx
	(void) sys_page_unmap(0, fd);
  81138c:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  811390:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  811397:	e8 be e8 ff ff       	call   80fc5a <sys_page_unmap>
	return sys_page_unmap(0, fd2data(fd));
  81139c:	89 1c 24             	mov    %ebx,(%esp)
  81139f:	e8 7c ef ff ff       	call   810320 <fd2data>
  8113a4:	89 44 24 04          	mov    %eax,0x4(%esp)
  8113a8:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8113af:	e8 a6 e8 ff ff       	call   80fc5a <sys_page_unmap>
}
  8113b4:	83 c4 14             	add    $0x14,%esp
  8113b7:	5b                   	pop    %ebx
  8113b8:	5d                   	pop    %ebp
  8113b9:	c3                   	ret    

008113ba <_pipeisclosed>:
	return r;
}

static int
_pipeisclosed(struct Fd *fd, struct Pipe *p)
{
  8113ba:	55                   	push   %ebp
  8113bb:	89 e5                	mov    %esp,%ebp
  8113bd:	57                   	push   %edi
  8113be:	56                   	push   %esi
  8113bf:	53                   	push   %ebx
  8113c0:	83 ec 2c             	sub    $0x2c,%esp
  8113c3:	89 c6                	mov    %eax,%esi
  8113c5:	89 55 e4             	mov    %edx,-0x1c(%ebp)
	int n, nn, ret;

	while (1) {
		n = thisenv->env_runs;
  8113c8:	a1 7c c2 b3 00       	mov    0xb3c27c,%eax
  8113cd:	8b 58 58             	mov    0x58(%eax),%ebx
		ret = pageref(fd) == pageref(p);
  8113d0:	89 34 24             	mov    %esi,(%esp)
  8113d3:	e8 ff 04 00 00       	call   8118d7 <pageref>
  8113d8:	89 c7                	mov    %eax,%edi
  8113da:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8113dd:	89 04 24             	mov    %eax,(%esp)
  8113e0:	e8 f2 04 00 00       	call   8118d7 <pageref>
  8113e5:	39 c7                	cmp    %eax,%edi
  8113e7:	0f 94 c2             	sete   %dl
  8113ea:	0f b6 c2             	movzbl %dl,%eax
		nn = thisenv->env_runs;
  8113ed:	8b 0d 7c c2 b3 00    	mov    0xb3c27c,%ecx
  8113f3:	8b 79 58             	mov    0x58(%ecx),%edi
		if (n == nn)
  8113f6:	39 fb                	cmp    %edi,%ebx
  8113f8:	74 21                	je     81141b <_pipeisclosed+0x61>
			return ret;
		if (n != nn && ret == 1)
  8113fa:	84 d2                	test   %dl,%dl
  8113fc:	74 ca                	je     8113c8 <_pipeisclosed+0xe>
			cprintf("pipe race avoided\n", n, thisenv->env_runs, ret);
  8113fe:	8b 51 58             	mov    0x58(%ecx),%edx
  811401:	89 44 24 0c          	mov    %eax,0xc(%esp)
  811405:	89 54 24 08          	mov    %edx,0x8(%esp)
  811409:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  81140d:	c7 04 24 c4 46 81 00 	movl   $0x8146c4,(%esp)
  811414:	e8 5a dd ff ff       	call   80f173 <cprintf>
  811419:	eb ad                	jmp    8113c8 <_pipeisclosed+0xe>
	}
}
  81141b:	83 c4 2c             	add    $0x2c,%esp
  81141e:	5b                   	pop    %ebx
  81141f:	5e                   	pop    %esi
  811420:	5f                   	pop    %edi
  811421:	5d                   	pop    %ebp
  811422:	c3                   	ret    

00811423 <devpipe_write>:
	return i;
}

static ssize_t
devpipe_write(struct Fd *fd, const void *vbuf, size_t n)
{
  811423:	55                   	push   %ebp
  811424:	89 e5                	mov    %esp,%ebp
  811426:	57                   	push   %edi
  811427:	56                   	push   %esi
  811428:	53                   	push   %ebx
  811429:	83 ec 1c             	sub    $0x1c,%esp
  81142c:	8b 75 08             	mov    0x8(%ebp),%esi
	const uint8_t *buf;
	size_t i;
	struct Pipe *p;

	p = (struct Pipe*) fd2data(fd);
  81142f:	89 34 24             	mov    %esi,(%esp)
  811432:	e8 e9 ee ff ff       	call   810320 <fd2data>
  811437:	89 c3                	mov    %eax,%ebx
	if (debug)
		cprintf("[%08x] devpipe_write %08x %d rpos %d wpos %d\n",
			thisenv->env_id, uvpt[PGNUM(p)], n, p->p_rpos, p->p_wpos);

	buf = vbuf;
	for (i = 0; i < n; i++) {
  811439:	bf 00 00 00 00       	mov    $0x0,%edi
  81143e:	eb 45                	jmp    811485 <devpipe_write+0x62>
		while (p->p_wpos >= p->p_rpos + sizeof(p->p_buf)) {
			// pipe is full
			// if all the readers are gone
			// (it's only writers like us now),
			// note eof
			if (_pipeisclosed(fd, p))
  811440:	89 da                	mov    %ebx,%edx
  811442:	89 f0                	mov    %esi,%eax
  811444:	e8 71 ff ff ff       	call   8113ba <_pipeisclosed>
  811449:	85 c0                	test   %eax,%eax
  81144b:	75 41                	jne    81148e <devpipe_write+0x6b>
				return 0;
			// yield and see what happens
			if (debug)
				cprintf("devpipe_write yield\n");
			sys_yield();
  81144d:	e8 42 e7 ff ff       	call   80fb94 <sys_yield>
		cprintf("[%08x] devpipe_write %08x %d rpos %d wpos %d\n",
			thisenv->env_id, uvpt[PGNUM(p)], n, p->p_rpos, p->p_wpos);

	buf = vbuf;
	for (i = 0; i < n; i++) {
		while (p->p_wpos >= p->p_rpos + sizeof(p->p_buf)) {
  811452:	8b 43 04             	mov    0x4(%ebx),%eax
  811455:	8b 0b                	mov    (%ebx),%ecx
  811457:	8d 51 20             	lea    0x20(%ecx),%edx
  81145a:	39 d0                	cmp    %edx,%eax
  81145c:	73 e2                	jae    811440 <devpipe_write+0x1d>
				cprintf("devpipe_write yield\n");
			sys_yield();
		}
		// there's room for a byte.  store it.
		// wait to increment wpos until the byte is stored!
		p->p_buf[p->p_wpos % PIPEBUFSIZ] = buf[i];
  81145e:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  811461:	0f b6 0c 39          	movzbl (%ecx,%edi,1),%ecx
  811465:	88 4d e7             	mov    %cl,-0x19(%ebp)
  811468:	99                   	cltd   
  811469:	c1 ea 1b             	shr    $0x1b,%edx
  81146c:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
  81146f:	83 e1 1f             	and    $0x1f,%ecx
  811472:	29 d1                	sub    %edx,%ecx
  811474:	0f b6 55 e7          	movzbl -0x19(%ebp),%edx
  811478:	88 54 0b 08          	mov    %dl,0x8(%ebx,%ecx,1)
		p->p_wpos++;
  81147c:	83 c0 01             	add    $0x1,%eax
  81147f:	89 43 04             	mov    %eax,0x4(%ebx)
	if (debug)
		cprintf("[%08x] devpipe_write %08x %d rpos %d wpos %d\n",
			thisenv->env_id, uvpt[PGNUM(p)], n, p->p_rpos, p->p_wpos);

	buf = vbuf;
	for (i = 0; i < n; i++) {
  811482:	83 c7 01             	add    $0x1,%edi
  811485:	3b 7d 10             	cmp    0x10(%ebp),%edi
  811488:	75 c8                	jne    811452 <devpipe_write+0x2f>
		// wait to increment wpos until the byte is stored!
		p->p_buf[p->p_wpos % PIPEBUFSIZ] = buf[i];
		p->p_wpos++;
	}

	return i;
  81148a:	89 f8                	mov    %edi,%eax
  81148c:	eb 05                	jmp    811493 <devpipe_write+0x70>
			// pipe is full
			// if all the readers are gone
			// (it's only writers like us now),
			// note eof
			if (_pipeisclosed(fd, p))
				return 0;
  81148e:	b8 00 00 00 00       	mov    $0x0,%eax
		p->p_buf[p->p_wpos % PIPEBUFSIZ] = buf[i];
		p->p_wpos++;
	}

	return i;
}
  811493:	83 c4 1c             	add    $0x1c,%esp
  811496:	5b                   	pop    %ebx
  811497:	5e                   	pop    %esi
  811498:	5f                   	pop    %edi
  811499:	5d                   	pop    %ebp
  81149a:	c3                   	ret    

0081149b <devpipe_read>:
	return _pipeisclosed(fd, p);
}

static ssize_t
devpipe_read(struct Fd *fd, void *vbuf, size_t n)
{
  81149b:	55                   	push   %ebp
  81149c:	89 e5                	mov    %esp,%ebp
  81149e:	57                   	push   %edi
  81149f:	56                   	push   %esi
  8114a0:	53                   	push   %ebx
  8114a1:	83 ec 1c             	sub    $0x1c,%esp
  8114a4:	8b 7d 08             	mov    0x8(%ebp),%edi
	uint8_t *buf;
	size_t i;
	struct Pipe *p;

	p = (struct Pipe*)fd2data(fd);
  8114a7:	89 3c 24             	mov    %edi,(%esp)
  8114aa:	e8 71 ee ff ff       	call   810320 <fd2data>
  8114af:	89 c3                	mov    %eax,%ebx
	if (debug)
		cprintf("[%08x] devpipe_read %08x %d rpos %d wpos %d\n",
			thisenv->env_id, uvpt[PGNUM(p)], n, p->p_rpos, p->p_wpos);

	buf = vbuf;
	for (i = 0; i < n; i++) {
  8114b1:	be 00 00 00 00       	mov    $0x0,%esi
  8114b6:	eb 3d                	jmp    8114f5 <devpipe_read+0x5a>
		while (p->p_rpos == p->p_wpos) {
			// pipe is empty
			// if we got any data, return it
			if (i > 0)
  8114b8:	85 f6                	test   %esi,%esi
  8114ba:	74 04                	je     8114c0 <devpipe_read+0x25>
				return i;
  8114bc:	89 f0                	mov    %esi,%eax
  8114be:	eb 43                	jmp    811503 <devpipe_read+0x68>
			// if all the writers are gone, note eof
			if (_pipeisclosed(fd, p))
  8114c0:	89 da                	mov    %ebx,%edx
  8114c2:	89 f8                	mov    %edi,%eax
  8114c4:	e8 f1 fe ff ff       	call   8113ba <_pipeisclosed>
  8114c9:	85 c0                	test   %eax,%eax
  8114cb:	75 31                	jne    8114fe <devpipe_read+0x63>
				return 0;
			// yield and see what happens
			if (debug)
				cprintf("devpipe_read yield\n");
			sys_yield();
  8114cd:	e8 c2 e6 ff ff       	call   80fb94 <sys_yield>
		cprintf("[%08x] devpipe_read %08x %d rpos %d wpos %d\n",
			thisenv->env_id, uvpt[PGNUM(p)], n, p->p_rpos, p->p_wpos);

	buf = vbuf;
	for (i = 0; i < n; i++) {
		while (p->p_rpos == p->p_wpos) {
  8114d2:	8b 03                	mov    (%ebx),%eax
  8114d4:	3b 43 04             	cmp    0x4(%ebx),%eax
  8114d7:	74 df                	je     8114b8 <devpipe_read+0x1d>
				cprintf("devpipe_read yield\n");
			sys_yield();
		}
		// there's a byte.  take it.
		// wait to increment rpos until the byte is taken!
		buf[i] = p->p_buf[p->p_rpos % PIPEBUFSIZ];
  8114d9:	99                   	cltd   
  8114da:	c1 ea 1b             	shr    $0x1b,%edx
  8114dd:	01 d0                	add    %edx,%eax
  8114df:	83 e0 1f             	and    $0x1f,%eax
  8114e2:	29 d0                	sub    %edx,%eax
  8114e4:	0f b6 44 03 08       	movzbl 0x8(%ebx,%eax,1),%eax
  8114e9:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  8114ec:	88 04 31             	mov    %al,(%ecx,%esi,1)
		p->p_rpos++;
  8114ef:	83 03 01             	addl   $0x1,(%ebx)
	if (debug)
		cprintf("[%08x] devpipe_read %08x %d rpos %d wpos %d\n",
			thisenv->env_id, uvpt[PGNUM(p)], n, p->p_rpos, p->p_wpos);

	buf = vbuf;
	for (i = 0; i < n; i++) {
  8114f2:	83 c6 01             	add    $0x1,%esi
  8114f5:	3b 75 10             	cmp    0x10(%ebp),%esi
  8114f8:	75 d8                	jne    8114d2 <devpipe_read+0x37>
		// there's a byte.  take it.
		// wait to increment rpos until the byte is taken!
		buf[i] = p->p_buf[p->p_rpos % PIPEBUFSIZ];
		p->p_rpos++;
	}
	return i;
  8114fa:	89 f0                	mov    %esi,%eax
  8114fc:	eb 05                	jmp    811503 <devpipe_read+0x68>
			// if we got any data, return it
			if (i > 0)
				return i;
			// if all the writers are gone, note eof
			if (_pipeisclosed(fd, p))
				return 0;
  8114fe:	b8 00 00 00 00       	mov    $0x0,%eax
		// wait to increment rpos until the byte is taken!
		buf[i] = p->p_buf[p->p_rpos % PIPEBUFSIZ];
		p->p_rpos++;
	}
	return i;
}
  811503:	83 c4 1c             	add    $0x1c,%esp
  811506:	5b                   	pop    %ebx
  811507:	5e                   	pop    %esi
  811508:	5f                   	pop    %edi
  811509:	5d                   	pop    %ebp
  81150a:	c3                   	ret    

0081150b <pipe>:
	uint8_t p_buf[PIPEBUFSIZ];	// data buffer
};

int
pipe(int pfd[2])
{
  81150b:	55                   	push   %ebp
  81150c:	89 e5                	mov    %esp,%ebp
  81150e:	56                   	push   %esi
  81150f:	53                   	push   %ebx
  811510:	83 ec 30             	sub    $0x30,%esp
	int r;
	struct Fd *fd0, *fd1;
	void *va;

	// allocate the file descriptor table entries
	if ((r = fd_alloc(&fd0)) < 0
  811513:	8d 45 f4             	lea    -0xc(%ebp),%eax
  811516:	89 04 24             	mov    %eax,(%esp)
  811519:	e8 19 ee ff ff       	call   810337 <fd_alloc>
  81151e:	89 c2                	mov    %eax,%edx
  811520:	85 d2                	test   %edx,%edx
  811522:	0f 88 4d 01 00 00    	js     811675 <pipe+0x16a>
	    || (r = sys_page_alloc(0, fd0, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
  811528:	c7 44 24 08 07 04 00 	movl   $0x407,0x8(%esp)
  81152f:	00 
  811530:	8b 45 f4             	mov    -0xc(%ebp),%eax
  811533:	89 44 24 04          	mov    %eax,0x4(%esp)
  811537:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  81153e:	e8 70 e6 ff ff       	call   80fbb3 <sys_page_alloc>
  811543:	89 c2                	mov    %eax,%edx
  811545:	85 d2                	test   %edx,%edx
  811547:	0f 88 28 01 00 00    	js     811675 <pipe+0x16a>
		goto err;

	if ((r = fd_alloc(&fd1)) < 0
  81154d:	8d 45 f0             	lea    -0x10(%ebp),%eax
  811550:	89 04 24             	mov    %eax,(%esp)
  811553:	e8 df ed ff ff       	call   810337 <fd_alloc>
  811558:	89 c3                	mov    %eax,%ebx
  81155a:	85 c0                	test   %eax,%eax
  81155c:	0f 88 fe 00 00 00    	js     811660 <pipe+0x155>
	    || (r = sys_page_alloc(0, fd1, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
  811562:	c7 44 24 08 07 04 00 	movl   $0x407,0x8(%esp)
  811569:	00 
  81156a:	8b 45 f0             	mov    -0x10(%ebp),%eax
  81156d:	89 44 24 04          	mov    %eax,0x4(%esp)
  811571:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  811578:	e8 36 e6 ff ff       	call   80fbb3 <sys_page_alloc>
  81157d:	89 c3                	mov    %eax,%ebx
  81157f:	85 c0                	test   %eax,%eax
  811581:	0f 88 d9 00 00 00    	js     811660 <pipe+0x155>
		goto err1;

	// allocate the pipe structure as first data page in both
	va = fd2data(fd0);
  811587:	8b 45 f4             	mov    -0xc(%ebp),%eax
  81158a:	89 04 24             	mov    %eax,(%esp)
  81158d:	e8 8e ed ff ff       	call   810320 <fd2data>
  811592:	89 c6                	mov    %eax,%esi
	if ((r = sys_page_alloc(0, va, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
  811594:	c7 44 24 08 07 04 00 	movl   $0x407,0x8(%esp)
  81159b:	00 
  81159c:	89 44 24 04          	mov    %eax,0x4(%esp)
  8115a0:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8115a7:	e8 07 e6 ff ff       	call   80fbb3 <sys_page_alloc>
  8115ac:	89 c3                	mov    %eax,%ebx
  8115ae:	85 c0                	test   %eax,%eax
  8115b0:	0f 88 97 00 00 00    	js     81164d <pipe+0x142>
		goto err2;
	if ((r = sys_page_map(0, va, 0, fd2data(fd1), PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
  8115b6:	8b 45 f0             	mov    -0x10(%ebp),%eax
  8115b9:	89 04 24             	mov    %eax,(%esp)
  8115bc:	e8 5f ed ff ff       	call   810320 <fd2data>
  8115c1:	c7 44 24 10 07 04 00 	movl   $0x407,0x10(%esp)
  8115c8:	00 
  8115c9:	89 44 24 0c          	mov    %eax,0xc(%esp)
  8115cd:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8115d4:	00 
  8115d5:	89 74 24 04          	mov    %esi,0x4(%esp)
  8115d9:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8115e0:	e8 22 e6 ff ff       	call   80fc07 <sys_page_map>
  8115e5:	89 c3                	mov    %eax,%ebx
  8115e7:	85 c0                	test   %eax,%eax
  8115e9:	78 52                	js     81163d <pipe+0x132>
		goto err3;

	// set up fd structures
	fd0->fd_dev_id = devpipe.dev_id;
  8115eb:	8b 15 24 53 81 00    	mov    0x815324,%edx
  8115f1:	8b 45 f4             	mov    -0xc(%ebp),%eax
  8115f4:	89 10                	mov    %edx,(%eax)
	fd0->fd_omode = O_RDONLY;
  8115f6:	8b 45 f4             	mov    -0xc(%ebp),%eax
  8115f9:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)

	fd1->fd_dev_id = devpipe.dev_id;
  811600:	8b 15 24 53 81 00    	mov    0x815324,%edx
  811606:	8b 45 f0             	mov    -0x10(%ebp),%eax
  811609:	89 10                	mov    %edx,(%eax)
	fd1->fd_omode = O_WRONLY;
  81160b:	8b 45 f0             	mov    -0x10(%ebp),%eax
  81160e:	c7 40 08 01 00 00 00 	movl   $0x1,0x8(%eax)

	if (debug)
		cprintf("[%08x] pipecreate %08x\n", thisenv->env_id, uvpt[PGNUM(va)]);

	pfd[0] = fd2num(fd0);
  811615:	8b 45 f4             	mov    -0xc(%ebp),%eax
  811618:	89 04 24             	mov    %eax,(%esp)
  81161b:	e8 f0 ec ff ff       	call   810310 <fd2num>
  811620:	8b 4d 08             	mov    0x8(%ebp),%ecx
  811623:	89 01                	mov    %eax,(%ecx)
	pfd[1] = fd2num(fd1);
  811625:	8b 45 f0             	mov    -0x10(%ebp),%eax
  811628:	89 04 24             	mov    %eax,(%esp)
  81162b:	e8 e0 ec ff ff       	call   810310 <fd2num>
  811630:	8b 4d 08             	mov    0x8(%ebp),%ecx
  811633:	89 41 04             	mov    %eax,0x4(%ecx)
	return 0;
  811636:	b8 00 00 00 00       	mov    $0x0,%eax
  81163b:	eb 38                	jmp    811675 <pipe+0x16a>

    err3:
	sys_page_unmap(0, va);
  81163d:	89 74 24 04          	mov    %esi,0x4(%esp)
  811641:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  811648:	e8 0d e6 ff ff       	call   80fc5a <sys_page_unmap>
    err2:
	sys_page_unmap(0, fd1);
  81164d:	8b 45 f0             	mov    -0x10(%ebp),%eax
  811650:	89 44 24 04          	mov    %eax,0x4(%esp)
  811654:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  81165b:	e8 fa e5 ff ff       	call   80fc5a <sys_page_unmap>
    err1:
	sys_page_unmap(0, fd0);
  811660:	8b 45 f4             	mov    -0xc(%ebp),%eax
  811663:	89 44 24 04          	mov    %eax,0x4(%esp)
  811667:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  81166e:	e8 e7 e5 ff ff       	call   80fc5a <sys_page_unmap>
  811673:	89 d8                	mov    %ebx,%eax
    err:
	return r;
}
  811675:	83 c4 30             	add    $0x30,%esp
  811678:	5b                   	pop    %ebx
  811679:	5e                   	pop    %esi
  81167a:	5d                   	pop    %ebp
  81167b:	c3                   	ret    

0081167c <pipeisclosed>:
	}
}

int
pipeisclosed(int fdnum)
{
  81167c:	55                   	push   %ebp
  81167d:	89 e5                	mov    %esp,%ebp
  81167f:	83 ec 28             	sub    $0x28,%esp
	struct Fd *fd;
	struct Pipe *p;
	int r;

	if ((r = fd_lookup(fdnum, &fd)) < 0)
  811682:	8d 45 f4             	lea    -0xc(%ebp),%eax
  811685:	89 44 24 04          	mov    %eax,0x4(%esp)
  811689:	8b 45 08             	mov    0x8(%ebp),%eax
  81168c:	89 04 24             	mov    %eax,(%esp)
  81168f:	e8 f2 ec ff ff       	call   810386 <fd_lookup>
  811694:	89 c2                	mov    %eax,%edx
  811696:	85 d2                	test   %edx,%edx
  811698:	78 15                	js     8116af <pipeisclosed+0x33>
		return r;
	p = (struct Pipe*) fd2data(fd);
  81169a:	8b 45 f4             	mov    -0xc(%ebp),%eax
  81169d:	89 04 24             	mov    %eax,(%esp)
  8116a0:	e8 7b ec ff ff       	call   810320 <fd2data>
	return _pipeisclosed(fd, p);
  8116a5:	89 c2                	mov    %eax,%edx
  8116a7:	8b 45 f4             	mov    -0xc(%ebp),%eax
  8116aa:	e8 0b fd ff ff       	call   8113ba <_pipeisclosed>
}
  8116af:	c9                   	leave  
  8116b0:	c3                   	ret    
  8116b1:	66 90                	xchg   %ax,%ax
  8116b3:	66 90                	xchg   %ax,%ax
  8116b5:	66 90                	xchg   %ax,%ax
  8116b7:	66 90                	xchg   %ax,%ax
  8116b9:	66 90                	xchg   %ax,%ax
  8116bb:	66 90                	xchg   %ax,%ax
  8116bd:	66 90                	xchg   %ax,%ax
  8116bf:	90                   	nop

008116c0 <devcons_close>:
	return tot;
}

static int
devcons_close(struct Fd *fd)
{
  8116c0:	55                   	push   %ebp
  8116c1:	89 e5                	mov    %esp,%ebp
	USED(fd);

	return 0;
}
  8116c3:	b8 00 00 00 00       	mov    $0x0,%eax
  8116c8:	5d                   	pop    %ebp
  8116c9:	c3                   	ret    

008116ca <devcons_stat>:

static int
devcons_stat(struct Fd *fd, struct Stat *stat)
{
  8116ca:	55                   	push   %ebp
  8116cb:	89 e5                	mov    %esp,%ebp
  8116cd:	83 ec 18             	sub    $0x18,%esp
	strcpy(stat->st_name, "<cons>");
  8116d0:	c7 44 24 04 dc 46 81 	movl   $0x8146dc,0x4(%esp)
  8116d7:	00 
  8116d8:	8b 45 0c             	mov    0xc(%ebp),%eax
  8116db:	89 04 24             	mov    %eax,(%esp)
  8116de:	e8 b4 e0 ff ff       	call   80f797 <strcpy>
	return 0;
}
  8116e3:	b8 00 00 00 00       	mov    $0x0,%eax
  8116e8:	c9                   	leave  
  8116e9:	c3                   	ret    

008116ea <devcons_write>:
	return 1;
}

static ssize_t
devcons_write(struct Fd *fd, const void *vbuf, size_t n)
{
  8116ea:	55                   	push   %ebp
  8116eb:	89 e5                	mov    %esp,%ebp
  8116ed:	57                   	push   %edi
  8116ee:	56                   	push   %esi
  8116ef:	53                   	push   %ebx
  8116f0:	81 ec 9c 00 00 00    	sub    $0x9c,%esp
	int tot, m;
	char buf[128];

	// mistake: have to nul-terminate arg to sys_cputs,
	// so we have to copy vbuf into buf in chunks and nul-terminate.
	for (tot = 0; tot < n; tot += m) {
  8116f6:	bb 00 00 00 00       	mov    $0x0,%ebx
		m = n - tot;
		if (m > sizeof(buf) - 1)
			m = sizeof(buf) - 1;
		memmove(buf, (char*)vbuf + tot, m);
  8116fb:	8d bd 68 ff ff ff    	lea    -0x98(%ebp),%edi
	int tot, m;
	char buf[128];

	// mistake: have to nul-terminate arg to sys_cputs,
	// so we have to copy vbuf into buf in chunks and nul-terminate.
	for (tot = 0; tot < n; tot += m) {
  811701:	eb 31                	jmp    811734 <devcons_write+0x4a>
		m = n - tot;
  811703:	8b 75 10             	mov    0x10(%ebp),%esi
  811706:	29 de                	sub    %ebx,%esi
		if (m > sizeof(buf) - 1)
  811708:	83 fe 7f             	cmp    $0x7f,%esi
	char buf[128];

	// mistake: have to nul-terminate arg to sys_cputs,
	// so we have to copy vbuf into buf in chunks and nul-terminate.
	for (tot = 0; tot < n; tot += m) {
		m = n - tot;
  81170b:	ba 7f 00 00 00       	mov    $0x7f,%edx
  811710:	0f 47 f2             	cmova  %edx,%esi
		if (m > sizeof(buf) - 1)
			m = sizeof(buf) - 1;
		memmove(buf, (char*)vbuf + tot, m);
  811713:	89 74 24 08          	mov    %esi,0x8(%esp)
  811717:	03 45 0c             	add    0xc(%ebp),%eax
  81171a:	89 44 24 04          	mov    %eax,0x4(%esp)
  81171e:	89 3c 24             	mov    %edi,(%esp)
  811721:	e8 0e e2 ff ff       	call   80f934 <memmove>
		sys_cputs(buf, m);
  811726:	89 74 24 04          	mov    %esi,0x4(%esp)
  81172a:	89 3c 24             	mov    %edi,(%esp)
  81172d:	e8 b4 e3 ff ff       	call   80fae6 <sys_cputs>
	int tot, m;
	char buf[128];

	// mistake: have to nul-terminate arg to sys_cputs,
	// so we have to copy vbuf into buf in chunks and nul-terminate.
	for (tot = 0; tot < n; tot += m) {
  811732:	01 f3                	add    %esi,%ebx
  811734:	89 d8                	mov    %ebx,%eax
  811736:	3b 5d 10             	cmp    0x10(%ebp),%ebx
  811739:	72 c8                	jb     811703 <devcons_write+0x19>
			m = sizeof(buf) - 1;
		memmove(buf, (char*)vbuf + tot, m);
		sys_cputs(buf, m);
	}
	return tot;
}
  81173b:	81 c4 9c 00 00 00    	add    $0x9c,%esp
  811741:	5b                   	pop    %ebx
  811742:	5e                   	pop    %esi
  811743:	5f                   	pop    %edi
  811744:	5d                   	pop    %ebp
  811745:	c3                   	ret    

00811746 <devcons_read>:
	return fd2num(fd);
}

static ssize_t
devcons_read(struct Fd *fd, void *vbuf, size_t n)
{
  811746:	55                   	push   %ebp
  811747:	89 e5                	mov    %esp,%ebp
  811749:	83 ec 08             	sub    $0x8,%esp
	int c;

	if (n == 0)
		return 0;
  81174c:	b8 00 00 00 00       	mov    $0x0,%eax
static ssize_t
devcons_read(struct Fd *fd, void *vbuf, size_t n)
{
	int c;

	if (n == 0)
  811751:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  811755:	75 07                	jne    81175e <devcons_read+0x18>
  811757:	eb 2a                	jmp    811783 <devcons_read+0x3d>
		return 0;

	while ((c = sys_cgetc()) == 0)
		sys_yield();
  811759:	e8 36 e4 ff ff       	call   80fb94 <sys_yield>
	int c;

	if (n == 0)
		return 0;

	while ((c = sys_cgetc()) == 0)
  81175e:	66 90                	xchg   %ax,%ax
  811760:	e8 9f e3 ff ff       	call   80fb04 <sys_cgetc>
  811765:	85 c0                	test   %eax,%eax
  811767:	74 f0                	je     811759 <devcons_read+0x13>
		sys_yield();
	if (c < 0)
  811769:	85 c0                	test   %eax,%eax
  81176b:	78 16                	js     811783 <devcons_read+0x3d>
		return c;
	if (c == 0x04)	// ctl-d is eof
  81176d:	83 f8 04             	cmp    $0x4,%eax
  811770:	74 0c                	je     81177e <devcons_read+0x38>
		return 0;
	*(char*)vbuf = c;
  811772:	8b 55 0c             	mov    0xc(%ebp),%edx
  811775:	88 02                	mov    %al,(%edx)
	return 1;
  811777:	b8 01 00 00 00       	mov    $0x1,%eax
  81177c:	eb 05                	jmp    811783 <devcons_read+0x3d>
	while ((c = sys_cgetc()) == 0)
		sys_yield();
	if (c < 0)
		return c;
	if (c == 0x04)	// ctl-d is eof
		return 0;
  81177e:	b8 00 00 00 00       	mov    $0x0,%eax
	*(char*)vbuf = c;
	return 1;
}
  811783:	c9                   	leave  
  811784:	c3                   	ret    

00811785 <cputchar>:
#include <inc/string.h>
#include <inc/lib.h>

void
cputchar(int ch)
{
  811785:	55                   	push   %ebp
  811786:	89 e5                	mov    %esp,%ebp
  811788:	83 ec 28             	sub    $0x28,%esp
	char c = ch;
  81178b:	8b 45 08             	mov    0x8(%ebp),%eax
  81178e:	88 45 f7             	mov    %al,-0x9(%ebp)

	// Unlike standard Unix's putchar,
	// the cputchar function _always_ outputs to the system console.
	sys_cputs(&c, 1);
  811791:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  811798:	00 
  811799:	8d 45 f7             	lea    -0x9(%ebp),%eax
  81179c:	89 04 24             	mov    %eax,(%esp)
  81179f:	e8 42 e3 ff ff       	call   80fae6 <sys_cputs>
}
  8117a4:	c9                   	leave  
  8117a5:	c3                   	ret    

008117a6 <getchar>:

int
getchar(void)
{
  8117a6:	55                   	push   %ebp
  8117a7:	89 e5                	mov    %esp,%ebp
  8117a9:	83 ec 28             	sub    $0x28,%esp
	int r;

	// JOS does, however, support standard _input_ redirection,
	// allowing the user to redirect script files to the shell and such.
	// getchar() reads a character from file descriptor 0.
	r = read(0, &c, 1);
  8117ac:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  8117b3:	00 
  8117b4:	8d 45 f7             	lea    -0x9(%ebp),%eax
  8117b7:	89 44 24 04          	mov    %eax,0x4(%esp)
  8117bb:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8117c2:	e8 53 ee ff ff       	call   81061a <read>
	if (r < 0)
  8117c7:	85 c0                	test   %eax,%eax
  8117c9:	78 0f                	js     8117da <getchar+0x34>
		return r;
	if (r < 1)
  8117cb:	85 c0                	test   %eax,%eax
  8117cd:	7e 06                	jle    8117d5 <getchar+0x2f>
		return -E_EOF;
	return c;
  8117cf:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
  8117d3:	eb 05                	jmp    8117da <getchar+0x34>
	// getchar() reads a character from file descriptor 0.
	r = read(0, &c, 1);
	if (r < 0)
		return r;
	if (r < 1)
		return -E_EOF;
  8117d5:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
	return c;
}
  8117da:	c9                   	leave  
  8117db:	c3                   	ret    

008117dc <iscons>:
	.dev_stat =	devcons_stat
};

int
iscons(int fdnum)
{
  8117dc:	55                   	push   %ebp
  8117dd:	89 e5                	mov    %esp,%ebp
  8117df:	83 ec 28             	sub    $0x28,%esp
	int r;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0)
  8117e2:	8d 45 f4             	lea    -0xc(%ebp),%eax
  8117e5:	89 44 24 04          	mov    %eax,0x4(%esp)
  8117e9:	8b 45 08             	mov    0x8(%ebp),%eax
  8117ec:	89 04 24             	mov    %eax,(%esp)
  8117ef:	e8 92 eb ff ff       	call   810386 <fd_lookup>
  8117f4:	85 c0                	test   %eax,%eax
  8117f6:	78 11                	js     811809 <iscons+0x2d>
		return r;
	return fd->fd_dev_id == devcons.dev_id;
  8117f8:	8b 45 f4             	mov    -0xc(%ebp),%eax
  8117fb:	8b 15 40 53 81 00    	mov    0x815340,%edx
  811801:	39 10                	cmp    %edx,(%eax)
  811803:	0f 94 c0             	sete   %al
  811806:	0f b6 c0             	movzbl %al,%eax
}
  811809:	c9                   	leave  
  81180a:	c3                   	ret    

0081180b <opencons>:

int
opencons(void)
{
  81180b:	55                   	push   %ebp
  81180c:	89 e5                	mov    %esp,%ebp
  81180e:	83 ec 28             	sub    $0x28,%esp
	int r;
	struct Fd* fd;

	if ((r = fd_alloc(&fd)) < 0)
  811811:	8d 45 f4             	lea    -0xc(%ebp),%eax
  811814:	89 04 24             	mov    %eax,(%esp)
  811817:	e8 1b eb ff ff       	call   810337 <fd_alloc>
		return r;
  81181c:	89 c2                	mov    %eax,%edx
opencons(void)
{
	int r;
	struct Fd* fd;

	if ((r = fd_alloc(&fd)) < 0)
  81181e:	85 c0                	test   %eax,%eax
  811820:	78 40                	js     811862 <opencons+0x57>
		return r;
	if ((r = sys_page_alloc(0, fd, PTE_P|PTE_U|PTE_W|PTE_SHARE)) < 0)
  811822:	c7 44 24 08 07 04 00 	movl   $0x407,0x8(%esp)
  811829:	00 
  81182a:	8b 45 f4             	mov    -0xc(%ebp),%eax
  81182d:	89 44 24 04          	mov    %eax,0x4(%esp)
  811831:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  811838:	e8 76 e3 ff ff       	call   80fbb3 <sys_page_alloc>
		return r;
  81183d:	89 c2                	mov    %eax,%edx
	int r;
	struct Fd* fd;

	if ((r = fd_alloc(&fd)) < 0)
		return r;
	if ((r = sys_page_alloc(0, fd, PTE_P|PTE_U|PTE_W|PTE_SHARE)) < 0)
  81183f:	85 c0                	test   %eax,%eax
  811841:	78 1f                	js     811862 <opencons+0x57>
		return r;
	fd->fd_dev_id = devcons.dev_id;
  811843:	8b 15 40 53 81 00    	mov    0x815340,%edx
  811849:	8b 45 f4             	mov    -0xc(%ebp),%eax
  81184c:	89 10                	mov    %edx,(%eax)
	fd->fd_omode = O_RDWR;
  81184e:	8b 45 f4             	mov    -0xc(%ebp),%eax
  811851:	c7 40 08 02 00 00 00 	movl   $0x2,0x8(%eax)
	return fd2num(fd);
  811858:	89 04 24             	mov    %eax,(%esp)
  81185b:	e8 b0 ea ff ff       	call   810310 <fd2num>
  811860:	89 c2                	mov    %eax,%edx
}
  811862:	89 d0                	mov    %edx,%eax
  811864:	c9                   	leave  
  811865:	c3                   	ret    

00811866 <set_pgfault_handler>:
// at UXSTACKTOP), and tell the kernel to call the assembly-language
// _pgfault_upcall routine when a page fault occurs.
//
void
set_pgfault_handler(void (*handler)(struct UTrapframe *utf))
{
  811866:	55                   	push   %ebp
  811867:	89 e5                	mov    %esp,%ebp
  811869:	53                   	push   %ebx
  81186a:	83 ec 14             	sub    $0x14,%esp
	int r;

	if (_pgfault_handler == 0) {
  81186d:	83 3d 00 f0 b3 00 00 	cmpl   $0x0,0xb3f000
  811874:	75 2f                	jne    8118a5 <set_pgfault_handler+0x3f>
		// First time through!
		// LAB 4: Your code here.
		envid_t envid = sys_getenvid();
  811876:	e8 fa e2 ff ff       	call   80fb75 <sys_getenvid>
  81187b:	89 c3                	mov    %eax,%ebx
		sys_page_alloc(envid, (void *)(UXSTACKTOP - PGSIZE), PTE_U|PTE_W|PTE_P);
  81187d:	c7 44 24 08 07 00 00 	movl   $0x7,0x8(%esp)
  811884:	00 
  811885:	c7 44 24 04 00 f0 bf 	movl   $0xeebff000,0x4(%esp)
  81188c:	ee 
  81188d:	89 04 24             	mov    %eax,(%esp)
  811890:	e8 1e e3 ff ff       	call   80fbb3 <sys_page_alloc>
		sys_env_set_pgfault_upcall(envid, (void *)_pgfault_upcall);
  811895:	c7 44 24 04 b3 18 81 	movl   $0x8118b3,0x4(%esp)
  81189c:	00 
  81189d:	89 1c 24             	mov    %ebx,(%esp)
  8118a0:	e8 ae e4 ff ff       	call   80fd53 <sys_env_set_pgfault_upcall>
	}

	// Save handler pointer for assembly to call.
	_pgfault_handler = handler;
  8118a5:	8b 45 08             	mov    0x8(%ebp),%eax
  8118a8:	a3 00 f0 b3 00       	mov    %eax,0xb3f000
}
  8118ad:	83 c4 14             	add    $0x14,%esp
  8118b0:	5b                   	pop    %ebx
  8118b1:	5d                   	pop    %ebp
  8118b2:	c3                   	ret    

008118b3 <_pgfault_upcall>:

.text
.globl _pgfault_upcall
_pgfault_upcall:
	// Call the C page fault handler.
	pushl %esp			// function argument: pointer to UTF
  8118b3:	54                   	push   %esp
	movl _pgfault_handler, %eax
  8118b4:	a1 00 f0 b3 00       	mov    0xb3f000,%eax
	call *%eax
  8118b9:	ff d0                	call   *%eax
	addl $4, %esp			// pop function argument
  8118bb:	83 c4 04             	add    $0x4,%esp
	//
	// LAB 4: Your code here.

	// 0x30(%esp) points to trap-time stack pointer
	// 0x28(%esp) points to trap-time eip
	subl $4, 0x30(%esp)
  8118be:	83 6c 24 30 04       	subl   $0x4,0x30(%esp)
	movl 0x30(%esp), %eax 
  8118c3:	8b 44 24 30          	mov    0x30(%esp),%eax
	movl 0x28(%esp), %ebp
  8118c7:	8b 6c 24 28          	mov    0x28(%esp),%ebp
	movl %ebp, (%eax)
  8118cb:	89 28                	mov    %ebp,(%eax)

	// Restore the trap-time registers.  After you do this, you
	// can no longer modify any general-purpose registers.
	// LAB 4: Your code here.
	addl $8, %esp
  8118cd:	83 c4 08             	add    $0x8,%esp
	popal
  8118d0:	61                   	popa   

	// Restore eflags from the stack.  After you do this, you can
	// no longer use arithmetic operations or anything else that
	// modifies eflags.
	// LAB 4: Your code here.
	addl $4, %esp //pop eip - we already stored it
  8118d1:	83 c4 04             	add    $0x4,%esp
	popfl
  8118d4:	9d                   	popf   

	// Switch back to the adjusted trap-time stack.
	// LAB 4: Your code here.
	popl %esp
  8118d5:	5c                   	pop    %esp

	// Return to re-execute the instruction that faulted.
	// LAB 4: Your code here.
	ret
  8118d6:	c3                   	ret    

008118d7 <pageref>:
#include <inc/lib.h>

int
pageref(void *v)
{
  8118d7:	55                   	push   %ebp
  8118d8:	89 e5                	mov    %esp,%ebp
  8118da:	8b 55 08             	mov    0x8(%ebp),%edx
	pte_t pte;

	if (!(uvpd[PDX(v)] & PTE_P))
  8118dd:	89 d0                	mov    %edx,%eax
  8118df:	c1 e8 16             	shr    $0x16,%eax
  8118e2:	8b 0c 85 00 d0 7b ef 	mov    -0x10843000(,%eax,4),%ecx
		return 0;
  8118e9:	b8 00 00 00 00       	mov    $0x0,%eax
int
pageref(void *v)
{
	pte_t pte;

	if (!(uvpd[PDX(v)] & PTE_P))
  8118ee:	f6 c1 01             	test   $0x1,%cl
  8118f1:	74 1d                	je     811910 <pageref+0x39>
		return 0;
	pte = uvpt[PGNUM(v)];
  8118f3:	c1 ea 0c             	shr    $0xc,%edx
  8118f6:	8b 14 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%edx
	if (!(pte & PTE_P))
  8118fd:	f6 c2 01             	test   $0x1,%dl
  811900:	74 0e                	je     811910 <pageref+0x39>
		return 0;
	return pages[PGNUM(pte)].pp_ref;
  811902:	c1 ea 0c             	shr    $0xc,%edx
  811905:	0f b7 04 d5 04 00 00 	movzwl -0x10fffffc(,%edx,8),%eax
  81190c:	ef 
  81190d:	0f b7 c0             	movzwl %ax,%eax
}
  811910:	5d                   	pop    %ebp
  811911:	c3                   	ret    
  811912:	66 90                	xchg   %ax,%ax
  811914:	66 90                	xchg   %ax,%ax
  811916:	66 90                	xchg   %ax,%ax
  811918:	66 90                	xchg   %ax,%ax
  81191a:	66 90                	xchg   %ax,%ax
  81191c:	66 90                	xchg   %ax,%ax
  81191e:	66 90                	xchg   %ax,%ax

00811920 <__udivdi3>:
  811920:	55                   	push   %ebp
  811921:	57                   	push   %edi
  811922:	56                   	push   %esi
  811923:	83 ec 0c             	sub    $0xc,%esp
  811926:	8b 44 24 28          	mov    0x28(%esp),%eax
  81192a:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
  81192e:	8b 6c 24 20          	mov    0x20(%esp),%ebp
  811932:	8b 4c 24 24          	mov    0x24(%esp),%ecx
  811936:	85 c0                	test   %eax,%eax
  811938:	89 7c 24 04          	mov    %edi,0x4(%esp)
  81193c:	89 ea                	mov    %ebp,%edx
  81193e:	89 0c 24             	mov    %ecx,(%esp)
  811941:	75 2d                	jne    811970 <__udivdi3+0x50>
  811943:	39 e9                	cmp    %ebp,%ecx
  811945:	77 61                	ja     8119a8 <__udivdi3+0x88>
  811947:	85 c9                	test   %ecx,%ecx
  811949:	89 ce                	mov    %ecx,%esi
  81194b:	75 0b                	jne    811958 <__udivdi3+0x38>
  81194d:	b8 01 00 00 00       	mov    $0x1,%eax
  811952:	31 d2                	xor    %edx,%edx
  811954:	f7 f1                	div    %ecx
  811956:	89 c6                	mov    %eax,%esi
  811958:	31 d2                	xor    %edx,%edx
  81195a:	89 e8                	mov    %ebp,%eax
  81195c:	f7 f6                	div    %esi
  81195e:	89 c5                	mov    %eax,%ebp
  811960:	89 f8                	mov    %edi,%eax
  811962:	f7 f6                	div    %esi
  811964:	89 ea                	mov    %ebp,%edx
  811966:	83 c4 0c             	add    $0xc,%esp
  811969:	5e                   	pop    %esi
  81196a:	5f                   	pop    %edi
  81196b:	5d                   	pop    %ebp
  81196c:	c3                   	ret    
  81196d:	8d 76 00             	lea    0x0(%esi),%esi
  811970:	39 e8                	cmp    %ebp,%eax
  811972:	77 24                	ja     811998 <__udivdi3+0x78>
  811974:	0f bd e8             	bsr    %eax,%ebp
  811977:	83 f5 1f             	xor    $0x1f,%ebp
  81197a:	75 3c                	jne    8119b8 <__udivdi3+0x98>
  81197c:	8b 74 24 04          	mov    0x4(%esp),%esi
  811980:	39 34 24             	cmp    %esi,(%esp)
  811983:	0f 86 9f 00 00 00    	jbe    811a28 <__udivdi3+0x108>
  811989:	39 d0                	cmp    %edx,%eax
  81198b:	0f 82 97 00 00 00    	jb     811a28 <__udivdi3+0x108>
  811991:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  811998:	31 d2                	xor    %edx,%edx
  81199a:	31 c0                	xor    %eax,%eax
  81199c:	83 c4 0c             	add    $0xc,%esp
  81199f:	5e                   	pop    %esi
  8119a0:	5f                   	pop    %edi
  8119a1:	5d                   	pop    %ebp
  8119a2:	c3                   	ret    
  8119a3:	90                   	nop
  8119a4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  8119a8:	89 f8                	mov    %edi,%eax
  8119aa:	f7 f1                	div    %ecx
  8119ac:	31 d2                	xor    %edx,%edx
  8119ae:	83 c4 0c             	add    $0xc,%esp
  8119b1:	5e                   	pop    %esi
  8119b2:	5f                   	pop    %edi
  8119b3:	5d                   	pop    %ebp
  8119b4:	c3                   	ret    
  8119b5:	8d 76 00             	lea    0x0(%esi),%esi
  8119b8:	89 e9                	mov    %ebp,%ecx
  8119ba:	8b 3c 24             	mov    (%esp),%edi
  8119bd:	d3 e0                	shl    %cl,%eax
  8119bf:	89 c6                	mov    %eax,%esi
  8119c1:	b8 20 00 00 00       	mov    $0x20,%eax
  8119c6:	29 e8                	sub    %ebp,%eax
  8119c8:	89 c1                	mov    %eax,%ecx
  8119ca:	d3 ef                	shr    %cl,%edi
  8119cc:	89 e9                	mov    %ebp,%ecx
  8119ce:	89 7c 24 08          	mov    %edi,0x8(%esp)
  8119d2:	8b 3c 24             	mov    (%esp),%edi
  8119d5:	09 74 24 08          	or     %esi,0x8(%esp)
  8119d9:	89 d6                	mov    %edx,%esi
  8119db:	d3 e7                	shl    %cl,%edi
  8119dd:	89 c1                	mov    %eax,%ecx
  8119df:	89 3c 24             	mov    %edi,(%esp)
  8119e2:	8b 7c 24 04          	mov    0x4(%esp),%edi
  8119e6:	d3 ee                	shr    %cl,%esi
  8119e8:	89 e9                	mov    %ebp,%ecx
  8119ea:	d3 e2                	shl    %cl,%edx
  8119ec:	89 c1                	mov    %eax,%ecx
  8119ee:	d3 ef                	shr    %cl,%edi
  8119f0:	09 d7                	or     %edx,%edi
  8119f2:	89 f2                	mov    %esi,%edx
  8119f4:	89 f8                	mov    %edi,%eax
  8119f6:	f7 74 24 08          	divl   0x8(%esp)
  8119fa:	89 d6                	mov    %edx,%esi
  8119fc:	89 c7                	mov    %eax,%edi
  8119fe:	f7 24 24             	mull   (%esp)
  811a01:	39 d6                	cmp    %edx,%esi
  811a03:	89 14 24             	mov    %edx,(%esp)
  811a06:	72 30                	jb     811a38 <__udivdi3+0x118>
  811a08:	8b 54 24 04          	mov    0x4(%esp),%edx
  811a0c:	89 e9                	mov    %ebp,%ecx
  811a0e:	d3 e2                	shl    %cl,%edx
  811a10:	39 c2                	cmp    %eax,%edx
  811a12:	73 05                	jae    811a19 <__udivdi3+0xf9>
  811a14:	3b 34 24             	cmp    (%esp),%esi
  811a17:	74 1f                	je     811a38 <__udivdi3+0x118>
  811a19:	89 f8                	mov    %edi,%eax
  811a1b:	31 d2                	xor    %edx,%edx
  811a1d:	e9 7a ff ff ff       	jmp    81199c <__udivdi3+0x7c>
  811a22:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  811a28:	31 d2                	xor    %edx,%edx
  811a2a:	b8 01 00 00 00       	mov    $0x1,%eax
  811a2f:	e9 68 ff ff ff       	jmp    81199c <__udivdi3+0x7c>
  811a34:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  811a38:	8d 47 ff             	lea    -0x1(%edi),%eax
  811a3b:	31 d2                	xor    %edx,%edx
  811a3d:	83 c4 0c             	add    $0xc,%esp
  811a40:	5e                   	pop    %esi
  811a41:	5f                   	pop    %edi
  811a42:	5d                   	pop    %ebp
  811a43:	c3                   	ret    
  811a44:	66 90                	xchg   %ax,%ax
  811a46:	66 90                	xchg   %ax,%ax
  811a48:	66 90                	xchg   %ax,%ax
  811a4a:	66 90                	xchg   %ax,%ax
  811a4c:	66 90                	xchg   %ax,%ax
  811a4e:	66 90                	xchg   %ax,%ax

00811a50 <__umoddi3>:
  811a50:	55                   	push   %ebp
  811a51:	57                   	push   %edi
  811a52:	56                   	push   %esi
  811a53:	83 ec 14             	sub    $0x14,%esp
  811a56:	8b 44 24 28          	mov    0x28(%esp),%eax
  811a5a:	8b 4c 24 24          	mov    0x24(%esp),%ecx
  811a5e:	8b 74 24 2c          	mov    0x2c(%esp),%esi
  811a62:	89 c7                	mov    %eax,%edi
  811a64:	89 44 24 04          	mov    %eax,0x4(%esp)
  811a68:	8b 44 24 30          	mov    0x30(%esp),%eax
  811a6c:	89 4c 24 10          	mov    %ecx,0x10(%esp)
  811a70:	89 34 24             	mov    %esi,(%esp)
  811a73:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  811a77:	85 c0                	test   %eax,%eax
  811a79:	89 c2                	mov    %eax,%edx
  811a7b:	89 7c 24 0c          	mov    %edi,0xc(%esp)
  811a7f:	75 17                	jne    811a98 <__umoddi3+0x48>
  811a81:	39 fe                	cmp    %edi,%esi
  811a83:	76 4b                	jbe    811ad0 <__umoddi3+0x80>
  811a85:	89 c8                	mov    %ecx,%eax
  811a87:	89 fa                	mov    %edi,%edx
  811a89:	f7 f6                	div    %esi
  811a8b:	89 d0                	mov    %edx,%eax
  811a8d:	31 d2                	xor    %edx,%edx
  811a8f:	83 c4 14             	add    $0x14,%esp
  811a92:	5e                   	pop    %esi
  811a93:	5f                   	pop    %edi
  811a94:	5d                   	pop    %ebp
  811a95:	c3                   	ret    
  811a96:	66 90                	xchg   %ax,%ax
  811a98:	39 f8                	cmp    %edi,%eax
  811a9a:	77 54                	ja     811af0 <__umoddi3+0xa0>
  811a9c:	0f bd e8             	bsr    %eax,%ebp
  811a9f:	83 f5 1f             	xor    $0x1f,%ebp
  811aa2:	75 5c                	jne    811b00 <__umoddi3+0xb0>
  811aa4:	8b 7c 24 08          	mov    0x8(%esp),%edi
  811aa8:	39 3c 24             	cmp    %edi,(%esp)
  811aab:	0f 87 e7 00 00 00    	ja     811b98 <__umoddi3+0x148>
  811ab1:	8b 7c 24 04          	mov    0x4(%esp),%edi
  811ab5:	29 f1                	sub    %esi,%ecx
  811ab7:	19 c7                	sbb    %eax,%edi
  811ab9:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  811abd:	89 7c 24 0c          	mov    %edi,0xc(%esp)
  811ac1:	8b 44 24 08          	mov    0x8(%esp),%eax
  811ac5:	8b 54 24 0c          	mov    0xc(%esp),%edx
  811ac9:	83 c4 14             	add    $0x14,%esp
  811acc:	5e                   	pop    %esi
  811acd:	5f                   	pop    %edi
  811ace:	5d                   	pop    %ebp
  811acf:	c3                   	ret    
  811ad0:	85 f6                	test   %esi,%esi
  811ad2:	89 f5                	mov    %esi,%ebp
  811ad4:	75 0b                	jne    811ae1 <__umoddi3+0x91>
  811ad6:	b8 01 00 00 00       	mov    $0x1,%eax
  811adb:	31 d2                	xor    %edx,%edx
  811add:	f7 f6                	div    %esi
  811adf:	89 c5                	mov    %eax,%ebp
  811ae1:	8b 44 24 04          	mov    0x4(%esp),%eax
  811ae5:	31 d2                	xor    %edx,%edx
  811ae7:	f7 f5                	div    %ebp
  811ae9:	89 c8                	mov    %ecx,%eax
  811aeb:	f7 f5                	div    %ebp
  811aed:	eb 9c                	jmp    811a8b <__umoddi3+0x3b>
  811aef:	90                   	nop
  811af0:	89 c8                	mov    %ecx,%eax
  811af2:	89 fa                	mov    %edi,%edx
  811af4:	83 c4 14             	add    $0x14,%esp
  811af7:	5e                   	pop    %esi
  811af8:	5f                   	pop    %edi
  811af9:	5d                   	pop    %ebp
  811afa:	c3                   	ret    
  811afb:	90                   	nop
  811afc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  811b00:	8b 04 24             	mov    (%esp),%eax
  811b03:	be 20 00 00 00       	mov    $0x20,%esi
  811b08:	89 e9                	mov    %ebp,%ecx
  811b0a:	29 ee                	sub    %ebp,%esi
  811b0c:	d3 e2                	shl    %cl,%edx
  811b0e:	89 f1                	mov    %esi,%ecx
  811b10:	d3 e8                	shr    %cl,%eax
  811b12:	89 e9                	mov    %ebp,%ecx
  811b14:	89 44 24 04          	mov    %eax,0x4(%esp)
  811b18:	8b 04 24             	mov    (%esp),%eax
  811b1b:	09 54 24 04          	or     %edx,0x4(%esp)
  811b1f:	89 fa                	mov    %edi,%edx
  811b21:	d3 e0                	shl    %cl,%eax
  811b23:	89 f1                	mov    %esi,%ecx
  811b25:	89 44 24 08          	mov    %eax,0x8(%esp)
  811b29:	8b 44 24 10          	mov    0x10(%esp),%eax
  811b2d:	d3 ea                	shr    %cl,%edx
  811b2f:	89 e9                	mov    %ebp,%ecx
  811b31:	d3 e7                	shl    %cl,%edi
  811b33:	89 f1                	mov    %esi,%ecx
  811b35:	d3 e8                	shr    %cl,%eax
  811b37:	89 e9                	mov    %ebp,%ecx
  811b39:	09 f8                	or     %edi,%eax
  811b3b:	8b 7c 24 10          	mov    0x10(%esp),%edi
  811b3f:	f7 74 24 04          	divl   0x4(%esp)
  811b43:	d3 e7                	shl    %cl,%edi
  811b45:	89 7c 24 0c          	mov    %edi,0xc(%esp)
  811b49:	89 d7                	mov    %edx,%edi
  811b4b:	f7 64 24 08          	mull   0x8(%esp)
  811b4f:	39 d7                	cmp    %edx,%edi
  811b51:	89 c1                	mov    %eax,%ecx
  811b53:	89 14 24             	mov    %edx,(%esp)
  811b56:	72 2c                	jb     811b84 <__umoddi3+0x134>
  811b58:	39 44 24 0c          	cmp    %eax,0xc(%esp)
  811b5c:	72 22                	jb     811b80 <__umoddi3+0x130>
  811b5e:	8b 44 24 0c          	mov    0xc(%esp),%eax
  811b62:	29 c8                	sub    %ecx,%eax
  811b64:	19 d7                	sbb    %edx,%edi
  811b66:	89 e9                	mov    %ebp,%ecx
  811b68:	89 fa                	mov    %edi,%edx
  811b6a:	d3 e8                	shr    %cl,%eax
  811b6c:	89 f1                	mov    %esi,%ecx
  811b6e:	d3 e2                	shl    %cl,%edx
  811b70:	89 e9                	mov    %ebp,%ecx
  811b72:	d3 ef                	shr    %cl,%edi
  811b74:	09 d0                	or     %edx,%eax
  811b76:	89 fa                	mov    %edi,%edx
  811b78:	83 c4 14             	add    $0x14,%esp
  811b7b:	5e                   	pop    %esi
  811b7c:	5f                   	pop    %edi
  811b7d:	5d                   	pop    %ebp
  811b7e:	c3                   	ret    
  811b7f:	90                   	nop
  811b80:	39 d7                	cmp    %edx,%edi
  811b82:	75 da                	jne    811b5e <__umoddi3+0x10e>
  811b84:	8b 14 24             	mov    (%esp),%edx
  811b87:	89 c1                	mov    %eax,%ecx
  811b89:	2b 4c 24 08          	sub    0x8(%esp),%ecx
  811b8d:	1b 54 24 04          	sbb    0x4(%esp),%edx
  811b91:	eb cb                	jmp    811b5e <__umoddi3+0x10e>
  811b93:	90                   	nop
  811b94:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  811b98:	3b 44 24 0c          	cmp    0xc(%esp),%eax
  811b9c:	0f 82 0f ff ff ff    	jb     811ab1 <__umoddi3+0x61>
  811ba2:	e9 1a ff ff ff       	jmp    811ac1 <__umoddi3+0x71>
